import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/core-js/modules/_global.js
var require_global = __commonJS({
  "node_modules/core-js/modules/_global.js"(exports, module2) {
    var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
    if (typeof __g == "number") __g = global2;
  }
});

// node_modules/core-js/modules/_has.js
var require_has = __commonJS({
  "node_modules/core-js/modules/_has.js"(exports, module2) {
    var hasOwnProperty2 = {}.hasOwnProperty;
    module2.exports = function(it, key) {
      return hasOwnProperty2.call(it, key);
    };
  }
});

// node_modules/core-js/modules/_fails.js
var require_fails = __commonJS({
  "node_modules/core-js/modules/_fails.js"(exports, module2) {
    module2.exports = function(exec) {
      try {
        return !!exec();
      } catch (e) {
        return true;
      }
    };
  }
});

// node_modules/core-js/modules/_descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/modules/_descriptors.js"(exports, module2) {
    module2.exports = !require_fails()(function() {
      return Object.defineProperty({}, "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/modules/_core.js
var require_core = __commonJS({
  "node_modules/core-js/modules/_core.js"(exports, module2) {
    var core = module2.exports = { version: "2.6.12" };
    if (typeof __e == "number") __e = core;
  }
});

// node_modules/core-js/modules/_is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/modules/_is-object.js"(exports, module2) {
    module2.exports = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
  }
});

// node_modules/core-js/modules/_an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/modules/_an-object.js"(exports, module2) {
    var isObject4 = require_is_object();
    module2.exports = function(it) {
      if (!isObject4(it)) throw TypeError(it + " is not an object!");
      return it;
    };
  }
});

// node_modules/core-js/modules/_dom-create.js
var require_dom_create = __commonJS({
  "node_modules/core-js/modules/_dom-create.js"(exports, module2) {
    var isObject4 = require_is_object();
    var document2 = require_global().document;
    var is = isObject4(document2) && isObject4(document2.createElement);
    module2.exports = function(it) {
      return is ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/modules/_ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/modules/_ie8-dom-define.js"(exports, module2) {
    module2.exports = !require_descriptors() && !require_fails()(function() {
      return Object.defineProperty(require_dom_create()("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/modules/_to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/modules/_to-primitive.js"(exports, module2) {
    var isObject4 = require_is_object();
    module2.exports = function(it, S) {
      if (!isObject4(it)) return it;
      var fn, val;
      if (S && typeof (fn = it.toString) == "function" && !isObject4(val = fn.call(it))) return val;
      if (typeof (fn = it.valueOf) == "function" && !isObject4(val = fn.call(it))) return val;
      if (!S && typeof (fn = it.toString) == "function" && !isObject4(val = fn.call(it))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/modules/_object-dp.js
var require_object_dp = __commonJS({
  "node_modules/core-js/modules/_object-dp.js"(exports) {
    var anObject = require_an_object();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var toPrimitive = require_to_primitive();
    var dP = Object.defineProperty;
    exports.f = require_descriptors() ? Object.defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return dP(O, P, Attributes);
      } catch (e) {
      }
      if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
  }
});

// node_modules/core-js/modules/_property-desc.js
var require_property_desc = __commonJS({
  "node_modules/core-js/modules/_property-desc.js"(exports, module2) {
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/modules/_hide.js
var require_hide = __commonJS({
  "node_modules/core-js/modules/_hide.js"(exports, module2) {
    var dP = require_object_dp();
    var createDesc = require_property_desc();
    module2.exports = require_descriptors() ? function(object, key, value) {
      return dP.f(object, key, createDesc(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/modules/_uid.js
var require_uid = __commonJS({
  "node_modules/core-js/modules/_uid.js"(exports, module2) {
    var id = 0;
    var px = Math.random();
    module2.exports = function(key) {
      return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
    };
  }
});

// node_modules/core-js/modules/_library.js
var require_library = __commonJS({
  "node_modules/core-js/modules/_library.js"(exports, module2) {
    module2.exports = false;
  }
});

// node_modules/core-js/modules/_shared.js
var require_shared = __commonJS({
  "node_modules/core-js/modules/_shared.js"(exports, module2) {
    var core = require_core();
    var global2 = require_global();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || (global2[SHARED] = {});
    (module2.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: core.version,
      mode: require_library() ? "pure" : "global",
      copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
    });
  }
});

// node_modules/core-js/modules/_function-to-string.js
var require_function_to_string = __commonJS({
  "node_modules/core-js/modules/_function-to-string.js"(exports, module2) {
    module2.exports = require_shared()("native-function-to-string", Function.toString);
  }
});

// node_modules/core-js/modules/_redefine.js
var require_redefine = __commonJS({
  "node_modules/core-js/modules/_redefine.js"(exports, module2) {
    var global2 = require_global();
    var hide = require_hide();
    var has = require_has();
    var SRC = require_uid()("src");
    var $toString = require_function_to_string();
    var TO_STRING = "toString";
    var TPL = ("" + $toString).split(TO_STRING);
    require_core().inspectSource = function(it) {
      return $toString.call(it);
    };
    (module2.exports = function(O, key, val, safe) {
      var isFunction4 = typeof val == "function";
      if (isFunction4) has(val, "name") || hide(val, "name", key);
      if (O[key] === val) return;
      if (isFunction4) has(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
      if (O === global2) {
        O[key] = val;
      } else if (!safe) {
        delete O[key];
        hide(O, key, val);
      } else if (O[key]) {
        O[key] = val;
      } else {
        hide(O, key, val);
      }
    })(Function.prototype, TO_STRING, function toString3() {
      return typeof this == "function" && this[SRC] || $toString.call(this);
    });
  }
});

// node_modules/core-js/modules/_a-function.js
var require_a_function = __commonJS({
  "node_modules/core-js/modules/_a-function.js"(exports, module2) {
    module2.exports = function(it) {
      if (typeof it != "function") throw TypeError(it + " is not a function!");
      return it;
    };
  }
});

// node_modules/core-js/modules/_ctx.js
var require_ctx = __commonJS({
  "node_modules/core-js/modules/_ctx.js"(exports, module2) {
    var aFunction = require_a_function();
    module2.exports = function(fn, that, length) {
      aFunction(fn);
      if (that === void 0) return fn;
      switch (length) {
        case 1:
          return function(a) {
            return fn.call(that, a);
          };
        case 2:
          return function(a, b) {
            return fn.call(that, a, b);
          };
        case 3:
          return function(a, b, c) {
            return fn.call(that, a, b, c);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/modules/_export.js
var require_export = __commonJS({
  "node_modules/core-js/modules/_export.js"(exports, module2) {
    var global2 = require_global();
    var core = require_core();
    var hide = require_hide();
    var redefine = require_redefine();
    var ctx = require_ctx();
    var PROTOTYPE = "prototype";
    var $export = function(type, name, source) {
      var IS_FORCED = type & $export.F;
      var IS_GLOBAL = type & $export.G;
      var IS_STATIC = type & $export.S;
      var IS_PROTO = type & $export.P;
      var IS_BIND = type & $export.B;
      var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] || (global2[name] = {}) : (global2[name] || {})[PROTOTYPE];
      var exports2 = IS_GLOBAL ? core : core[name] || (core[name] = {});
      var expProto = exports2[PROTOTYPE] || (exports2[PROTOTYPE] = {});
      var key, own, out, exp;
      if (IS_GLOBAL) source = name;
      for (key in source) {
        own = !IS_FORCED && target && target[key] !== void 0;
        out = (own ? target : source)[key];
        exp = IS_BIND && own ? ctx(out, global2) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
        if (target) redefine(target, key, out, type & $export.U);
        if (exports2[key] != out) hide(exports2, key, exp);
        if (IS_PROTO && expProto[key] != out) expProto[key] = out;
      }
    };
    global2.core = core;
    $export.F = 1;
    $export.G = 2;
    $export.S = 4;
    $export.P = 8;
    $export.B = 16;
    $export.W = 32;
    $export.U = 64;
    $export.R = 128;
    module2.exports = $export;
  }
});

// node_modules/core-js/modules/_meta.js
var require_meta = __commonJS({
  "node_modules/core-js/modules/_meta.js"(exports, module2) {
    var META = require_uid()("meta");
    var isObject4 = require_is_object();
    var has = require_has();
    var setDesc = require_object_dp().f;
    var id = 0;
    var isExtensible = Object.isExtensible || function() {
      return true;
    };
    var FREEZE = !require_fails()(function() {
      return isExtensible(Object.preventExtensions({}));
    });
    var setMeta = function(it) {
      setDesc(it, META, { value: {
        i: "O" + ++id,
        // object ID
        w: {}
        // weak collections IDs
      } });
    };
    var fastKey = function(it, create) {
      if (!isObject4(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!has(it, META)) {
        if (!isExtensible(it)) return "F";
        if (!create) return "E";
        setMeta(it);
      }
      return it[META].i;
    };
    var getWeak = function(it, create) {
      if (!has(it, META)) {
        if (!isExtensible(it)) return true;
        if (!create) return false;
        setMeta(it);
      }
      return it[META].w;
    };
    var onFreeze = function(it) {
      if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
      return it;
    };
    var meta = module2.exports = {
      KEY: META,
      NEED: false,
      fastKey,
      getWeak,
      onFreeze
    };
  }
});

// node_modules/core-js/modules/_wks.js
var require_wks = __commonJS({
  "node_modules/core-js/modules/_wks.js"(exports, module2) {
    var store = require_shared()("wks");
    var uid = require_uid();
    var Symbol2 = require_global().Symbol;
    var USE_SYMBOL = typeof Symbol2 == "function";
    var $exports = module2.exports = function(name) {
      return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
    };
    $exports.store = store;
  }
});

// node_modules/core-js/modules/_set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/modules/_set-to-string-tag.js"(exports, module2) {
    var def = require_object_dp().f;
    var has = require_has();
    var TAG = require_wks()("toStringTag");
    module2.exports = function(it, tag, stat) {
      if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
    };
  }
});

// node_modules/core-js/modules/_wks-ext.js
var require_wks_ext = __commonJS({
  "node_modules/core-js/modules/_wks-ext.js"(exports) {
    exports.f = require_wks();
  }
});

// node_modules/core-js/modules/_wks-define.js
var require_wks_define = __commonJS({
  "node_modules/core-js/modules/_wks-define.js"(exports, module2) {
    var global2 = require_global();
    var core = require_core();
    var LIBRARY = require_library();
    var wksExt = require_wks_ext();
    var defineProperty = require_object_dp().f;
    module2.exports = function(name) {
      var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global2.Symbol || {});
      if (name.charAt(0) != "_" && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
    };
  }
});

// node_modules/core-js/modules/_cof.js
var require_cof = __commonJS({
  "node_modules/core-js/modules/_cof.js"(exports, module2) {
    var toString3 = {}.toString;
    module2.exports = function(it) {
      return toString3.call(it).slice(8, -1);
    };
  }
});

// node_modules/core-js/modules/_iobject.js
var require_iobject = __commonJS({
  "node_modules/core-js/modules/_iobject.js"(exports, module2) {
    var cof = require_cof();
    module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
      return cof(it) == "String" ? it.split("") : Object(it);
    };
  }
});

// node_modules/core-js/modules/_defined.js
var require_defined = __commonJS({
  "node_modules/core-js/modules/_defined.js"(exports, module2) {
    module2.exports = function(it) {
      if (it == void 0) throw TypeError("Can't call method on  " + it);
      return it;
    };
  }
});

// node_modules/core-js/modules/_to-iobject.js
var require_to_iobject = __commonJS({
  "node_modules/core-js/modules/_to-iobject.js"(exports, module2) {
    var IObject = require_iobject();
    var defined = require_defined();
    module2.exports = function(it) {
      return IObject(defined(it));
    };
  }
});

// node_modules/core-js/modules/_to-integer.js
var require_to_integer = __commonJS({
  "node_modules/core-js/modules/_to-integer.js"(exports, module2) {
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = function(it) {
      return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
    };
  }
});

// node_modules/core-js/modules/_to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/modules/_to-length.js"(exports, module2) {
    var toInteger = require_to_integer();
    var min3 = Math.min;
    module2.exports = function(it) {
      return it > 0 ? min3(toInteger(it), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/modules/_to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/modules/_to-absolute-index.js"(exports, module2) {
    var toInteger = require_to_integer();
    var max3 = Math.max;
    var min3 = Math.min;
    module2.exports = function(index2, length) {
      index2 = toInteger(index2);
      return index2 < 0 ? max3(index2 + length, 0) : min3(index2, length);
    };
  }
});

// node_modules/core-js/modules/_array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/modules/_array-includes.js"(exports, module2) {
    var toIObject = require_to_iobject();
    var toLength = require_to_length();
    var toAbsoluteIndex = require_to_absolute_index();
    module2.exports = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIObject($this);
        var length = toLength(O.length);
        var index2 = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el) while (length > index2) {
          value = O[index2++];
          if (value != value) return true;
        }
        else for (; length > index2; index2++) if (IS_INCLUDES || index2 in O) {
          if (O[index2] === el) return IS_INCLUDES || index2 || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
  }
});

// node_modules/core-js/modules/_shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/modules/_shared-key.js"(exports, module2) {
    var shared = require_shared()("keys");
    var uid = require_uid();
    module2.exports = function(key) {
      return shared[key] || (shared[key] = uid(key));
    };
  }
});

// node_modules/core-js/modules/_object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/modules/_object-keys-internal.js"(exports, module2) {
    var has = require_has();
    var toIObject = require_to_iobject();
    var arrayIndexOf = require_array_includes()(false);
    var IE_PROTO = require_shared_key()("IE_PROTO");
    module2.exports = function(object, names) {
      var O = toIObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
      while (names.length > i) if (has(O, key = names[i++])) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
      return result;
    };
  }
});

// node_modules/core-js/modules/_enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/modules/_enum-bug-keys.js"(exports, module2) {
    module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }
});

// node_modules/core-js/modules/_object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/modules/_object-keys.js"(exports, module2) {
    var $keys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module2.exports = Object.keys || function keys3(O) {
      return $keys(O, enumBugKeys);
    };
  }
});

// node_modules/core-js/modules/_object-gops.js
var require_object_gops = __commonJS({
  "node_modules/core-js/modules/_object-gops.js"(exports) {
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/modules/_object-pie.js
var require_object_pie = __commonJS({
  "node_modules/core-js/modules/_object-pie.js"(exports) {
    exports.f = {}.propertyIsEnumerable;
  }
});

// node_modules/core-js/modules/_enum-keys.js
var require_enum_keys = __commonJS({
  "node_modules/core-js/modules/_enum-keys.js"(exports, module2) {
    var getKeys = require_object_keys();
    var gOPS = require_object_gops();
    var pIE = require_object_pie();
    module2.exports = function(it) {
      var result = getKeys(it);
      var getSymbols = gOPS.f;
      if (getSymbols) {
        var symbols = getSymbols(it);
        var isEnum = pIE.f;
        var i = 0;
        var key;
        while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
      }
      return result;
    };
  }
});

// node_modules/core-js/modules/_is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/modules/_is-array.js"(exports, module2) {
    var cof = require_cof();
    module2.exports = Array.isArray || function isArray3(arg) {
      return cof(arg) == "Array";
    };
  }
});

// node_modules/core-js/modules/_to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/modules/_to-object.js"(exports, module2) {
    var defined = require_defined();
    module2.exports = function(it) {
      return Object(defined(it));
    };
  }
});

// node_modules/core-js/modules/_object-dps.js
var require_object_dps = __commonJS({
  "node_modules/core-js/modules/_object-dps.js"(exports, module2) {
    var dP = require_object_dp();
    var anObject = require_an_object();
    var getKeys = require_object_keys();
    module2.exports = require_descriptors() ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var keys3 = getKeys(Properties);
      var length = keys3.length;
      var i = 0;
      var P;
      while (length > i) dP.f(O, P = keys3[i++], Properties[P]);
      return O;
    };
  }
});

// node_modules/core-js/modules/_html.js
var require_html = __commonJS({
  "node_modules/core-js/modules/_html.js"(exports, module2) {
    var document2 = require_global().document;
    module2.exports = document2 && document2.documentElement;
  }
});

// node_modules/core-js/modules/_object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/modules/_object-create.js"(exports, module2) {
    var anObject = require_an_object();
    var dPs = require_object_dps();
    var enumBugKeys = require_enum_bug_keys();
    var IE_PROTO = require_shared_key()("IE_PROTO");
    var Empty = function() {
    };
    var PROTOTYPE = "prototype";
    var createDict = function() {
      var iframe = require_dom_create()("iframe");
      var i = enumBugKeys.length;
      var lt = "<";
      var gt = ">";
      var iframeDocument;
      iframe.style.display = "none";
      require_html().appendChild(iframe);
      iframe.src = "javascript:";
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
      iframeDocument.close();
      createDict = iframeDocument.F;
      while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
      return createDict();
    };
    module2.exports = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        Empty[PROTOTYPE] = anObject(O);
        result = new Empty();
        Empty[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else result = createDict();
      return Properties === void 0 ? result : dPs(result, Properties);
    };
  }
});

// node_modules/core-js/modules/_object-gopn.js
var require_object_gopn = __commonJS({
  "node_modules/core-js/modules/_object-gopn.js"(exports) {
    var $keys = require_object_keys_internal();
    var hiddenKeys = require_enum_bug_keys().concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return $keys(O, hiddenKeys);
    };
  }
});

// node_modules/core-js/modules/_object-gopn-ext.js
var require_object_gopn_ext = __commonJS({
  "node_modules/core-js/modules/_object-gopn-ext.js"(exports, module2) {
    var toIObject = require_to_iobject();
    var gOPN = require_object_gopn().f;
    var toString3 = {}.toString;
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function(it) {
      try {
        return gOPN(it);
      } catch (e) {
        return windowNames.slice();
      }
    };
    module2.exports.f = function getOwnPropertyNames(it) {
      return windowNames && toString3.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it));
    };
  }
});

// node_modules/core-js/modules/_object-gopd.js
var require_object_gopd = __commonJS({
  "node_modules/core-js/modules/_object-gopd.js"(exports) {
    var pIE = require_object_pie();
    var createDesc = require_property_desc();
    var toIObject = require_to_iobject();
    var toPrimitive = require_to_primitive();
    var has = require_has();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var gOPD = Object.getOwnPropertyDescriptor;
    exports.f = require_descriptors() ? gOPD : function getOwnPropertyDescriptor(O, P) {
      O = toIObject(O);
      P = toPrimitive(P, true);
      if (IE8_DOM_DEFINE) try {
        return gOPD(O, P);
      } catch (e) {
      }
      if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
    };
  }
});

// node_modules/core-js/modules/es6.symbol.js
var require_es6_symbol = __commonJS({
  "node_modules/core-js/modules/es6.symbol.js"() {
    "use strict";
    var global2 = require_global();
    var has = require_has();
    var DESCRIPTORS = require_descriptors();
    var $export = require_export();
    var redefine = require_redefine();
    var META = require_meta().KEY;
    var $fails = require_fails();
    var shared = require_shared();
    var setToStringTag = require_set_to_string_tag();
    var uid = require_uid();
    var wks = require_wks();
    var wksExt = require_wks_ext();
    var wksDefine = require_wks_define();
    var enumKeys = require_enum_keys();
    var isArray3 = require_is_array();
    var anObject = require_an_object();
    var isObject4 = require_is_object();
    var toObject3 = require_to_object();
    var toIObject = require_to_iobject();
    var toPrimitive = require_to_primitive();
    var createDesc = require_property_desc();
    var _create = require_object_create();
    var gOPNExt = require_object_gopn_ext();
    var $GOPD = require_object_gopd();
    var $GOPS = require_object_gops();
    var $DP = require_object_dp();
    var $keys = require_object_keys();
    var gOPD = $GOPD.f;
    var dP = $DP.f;
    var gOPN = gOPNExt.f;
    var $Symbol = global2.Symbol;
    var $JSON = global2.JSON;
    var _stringify = $JSON && $JSON.stringify;
    var PROTOTYPE = "prototype";
    var HIDDEN = wks("_hidden");
    var TO_PRIMITIVE = wks("toPrimitive");
    var isEnum = {}.propertyIsEnumerable;
    var SymbolRegistry = shared("symbol-registry");
    var AllSymbols = shared("symbols");
    var OPSymbols = shared("op-symbols");
    var ObjectProto = Object[PROTOTYPE];
    var USE_NATIVE = typeof $Symbol == "function" && !!$GOPS.f;
    var QObject = global2.QObject;
    var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
    var setSymbolDesc = DESCRIPTORS && $fails(function() {
      return _create(dP({}, "a", {
        get: function() {
          return dP(this, "a", { value: 7 }).a;
        }
      })).a != 7;
    }) ? function(it, key, D) {
      var protoDesc = gOPD(ObjectProto, key);
      if (protoDesc) delete ObjectProto[key];
      dP(it, key, D);
      if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
    } : dP;
    var wrap2 = function(tag) {
      var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
      sym._k = tag;
      return sym;
    };
    var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      return it instanceof $Symbol;
    };
    var $defineProperty = function defineProperty(it, key, D) {
      if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
      anObject(it);
      key = toPrimitive(key, true);
      anObject(D);
      if (has(AllSymbols, key)) {
        if (!D.enumerable) {
          if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
          it[HIDDEN][key] = true;
        } else {
          if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
          D = _create(D, { enumerable: createDesc(0, false) });
        }
        return setSymbolDesc(it, key, D);
      }
      return dP(it, key, D);
    };
    var $defineProperties = function defineProperties(it, P) {
      anObject(it);
      var keys3 = enumKeys(P = toIObject(P));
      var i = 0;
      var l = keys3.length;
      var key;
      while (l > i) $defineProperty(it, key = keys3[i++], P[key]);
      return it;
    };
    var $create = function create(it, P) {
      return P === void 0 ? _create(it) : $defineProperties(_create(it), P);
    };
    var $propertyIsEnumerable = function propertyIsEnumerable(key) {
      var E = isEnum.call(this, key = toPrimitive(key, true));
      if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
      return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
    };
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
      it = toIObject(it);
      key = toPrimitive(key, true);
      if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
      var D = gOPD(it, key);
      if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
      return D;
    };
    var $getOwnPropertyNames = function getOwnPropertyNames(it) {
      var names = gOPN(toIObject(it));
      var result = [];
      var i = 0;
      var key;
      while (names.length > i) {
        if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
      }
      return result;
    };
    var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
      var IS_OP = it === ObjectProto;
      var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
      var result = [];
      var i = 0;
      var key;
      while (names.length > i) {
        if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
      }
      return result;
    };
    if (!USE_NATIVE) {
      $Symbol = function Symbol2() {
        if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
        var tag = uid(arguments.length > 0 ? arguments[0] : void 0);
        var $set = function(value) {
          if (this === ObjectProto) $set.call(OPSymbols, value);
          if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
          setSymbolDesc(this, tag, createDesc(1, value));
        };
        if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
        return wrap2(tag);
      };
      redefine($Symbol[PROTOTYPE], "toString", function toString3() {
        return this._k;
      });
      $GOPD.f = $getOwnPropertyDescriptor;
      $DP.f = $defineProperty;
      require_object_gopn().f = gOPNExt.f = $getOwnPropertyNames;
      require_object_pie().f = $propertyIsEnumerable;
      $GOPS.f = $getOwnPropertySymbols;
      if (DESCRIPTORS && !require_library()) {
        redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
      }
      wksExt.f = function(name) {
        return wrap2(wks(name));
      };
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
    for (es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
    "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; ) wks(es6Symbols[j++]);
    var es6Symbols;
    var j;
    for (wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k; ) wksDefine(wellKnownSymbols[k++]);
    var wellKnownSymbols;
    var k;
    $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
      // 19.4.2.1 Symbol.for(key)
      "for": function(key) {
        return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
      },
      // 19.4.2.5 Symbol.keyFor(sym)
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
        for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
      },
      useSetter: function() {
        setter = true;
      },
      useSimple: function() {
        setter = false;
      }
    });
    $export($export.S + $export.F * !USE_NATIVE, "Object", {
      // 19.1.2.2 Object.create(O [, Properties])
      create: $create,
      // 19.1.2.4 Object.defineProperty(O, P, Attributes)
      defineProperty: $defineProperty,
      // 19.1.2.3 Object.defineProperties(O, Properties)
      defineProperties: $defineProperties,
      // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
      // 19.1.2.7 Object.getOwnPropertyNames(O)
      getOwnPropertyNames: $getOwnPropertyNames,
      // 19.1.2.8 Object.getOwnPropertySymbols(O)
      getOwnPropertySymbols: $getOwnPropertySymbols
    });
    var FAILS_ON_PRIMITIVES = $fails(function() {
      $GOPS.f(1);
    });
    $export($export.S + $export.F * FAILS_ON_PRIMITIVES, "Object", {
      getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        return $GOPS.f(toObject3(it));
      }
    });
    $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
      var S = $Symbol();
      return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
    })), "JSON", {
      stringify: function stringify2(it) {
        var args = [it];
        var i = 1;
        var replacer, $replacer;
        while (arguments.length > i) args.push(arguments[i++]);
        $replacer = replacer = args[1];
        if (!isObject4(replacer) && it === void 0 || isSymbol(it)) return;
        if (!isArray3(replacer)) replacer = function(key, value) {
          if (typeof $replacer == "function") value = $replacer.call(this, key, value);
          if (!isSymbol(value)) return value;
        };
        args[1] = replacer;
        return _stringify.apply($JSON, args);
      }
    });
    $Symbol[PROTOTYPE][TO_PRIMITIVE] || require_hide()($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
    setToStringTag($Symbol, "Symbol");
    setToStringTag(Math, "Math", true);
    setToStringTag(global2.JSON, "JSON", true);
  }
});

// node_modules/core-js/modules/es6.object.create.js
var require_es6_object_create = __commonJS({
  "node_modules/core-js/modules/es6.object.create.js"() {
    var $export = require_export();
    $export($export.S, "Object", { create: require_object_create() });
  }
});

// node_modules/core-js/modules/es6.object.define-property.js
var require_es6_object_define_property = __commonJS({
  "node_modules/core-js/modules/es6.object.define-property.js"() {
    var $export = require_export();
    $export($export.S + $export.F * !require_descriptors(), "Object", { defineProperty: require_object_dp().f });
  }
});

// node_modules/core-js/modules/es6.object.define-properties.js
var require_es6_object_define_properties = __commonJS({
  "node_modules/core-js/modules/es6.object.define-properties.js"() {
    var $export = require_export();
    $export($export.S + $export.F * !require_descriptors(), "Object", { defineProperties: require_object_dps() });
  }
});

// node_modules/core-js/modules/_object-sap.js
var require_object_sap = __commonJS({
  "node_modules/core-js/modules/_object-sap.js"(exports, module2) {
    var $export = require_export();
    var core = require_core();
    var fails = require_fails();
    module2.exports = function(KEY13, exec) {
      var fn = (core.Object || {})[KEY13] || Object[KEY13];
      var exp = {};
      exp[KEY13] = exec(fn);
      $export($export.S + $export.F * fails(function() {
        fn(1);
      }), "Object", exp);
    };
  }
});

// node_modules/core-js/modules/es6.object.get-own-property-descriptor.js
var require_es6_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/modules/es6.object.get-own-property-descriptor.js"() {
    var toIObject = require_to_iobject();
    var $getOwnPropertyDescriptor = require_object_gopd().f;
    require_object_sap()("getOwnPropertyDescriptor", function() {
      return function getOwnPropertyDescriptor(it, key) {
        return $getOwnPropertyDescriptor(toIObject(it), key);
      };
    });
  }
});

// node_modules/core-js/modules/_object-gpo.js
var require_object_gpo = __commonJS({
  "node_modules/core-js/modules/_object-gpo.js"(exports, module2) {
    var has = require_has();
    var toObject3 = require_to_object();
    var IE_PROTO = require_shared_key()("IE_PROTO");
    var ObjectProto = Object.prototype;
    module2.exports = Object.getPrototypeOf || function(O) {
      O = toObject3(O);
      if (has(O, IE_PROTO)) return O[IE_PROTO];
      if (typeof O.constructor == "function" && O instanceof O.constructor) {
        return O.constructor.prototype;
      }
      return O instanceof Object ? ObjectProto : null;
    };
  }
});

// node_modules/core-js/modules/es6.object.get-prototype-of.js
var require_es6_object_get_prototype_of = __commonJS({
  "node_modules/core-js/modules/es6.object.get-prototype-of.js"() {
    var toObject3 = require_to_object();
    var $getPrototypeOf = require_object_gpo();
    require_object_sap()("getPrototypeOf", function() {
      return function getPrototypeOf(it) {
        return $getPrototypeOf(toObject3(it));
      };
    });
  }
});

// node_modules/core-js/modules/es6.object.keys.js
var require_es6_object_keys = __commonJS({
  "node_modules/core-js/modules/es6.object.keys.js"() {
    var toObject3 = require_to_object();
    var $keys = require_object_keys();
    require_object_sap()("keys", function() {
      return function keys3(it) {
        return $keys(toObject3(it));
      };
    });
  }
});

// node_modules/core-js/modules/es6.object.get-own-property-names.js
var require_es6_object_get_own_property_names = __commonJS({
  "node_modules/core-js/modules/es6.object.get-own-property-names.js"() {
    require_object_sap()("getOwnPropertyNames", function() {
      return require_object_gopn_ext().f;
    });
  }
});

// node_modules/core-js/modules/es6.object.freeze.js
var require_es6_object_freeze = __commonJS({
  "node_modules/core-js/modules/es6.object.freeze.js"() {
    var isObject4 = require_is_object();
    var meta = require_meta().onFreeze;
    require_object_sap()("freeze", function($freeze) {
      return function freeze(it) {
        return $freeze && isObject4(it) ? $freeze(meta(it)) : it;
      };
    });
  }
});

// node_modules/core-js/modules/es6.object.seal.js
var require_es6_object_seal = __commonJS({
  "node_modules/core-js/modules/es6.object.seal.js"() {
    var isObject4 = require_is_object();
    var meta = require_meta().onFreeze;
    require_object_sap()("seal", function($seal) {
      return function seal(it) {
        return $seal && isObject4(it) ? $seal(meta(it)) : it;
      };
    });
  }
});

// node_modules/core-js/modules/es6.object.prevent-extensions.js
var require_es6_object_prevent_extensions = __commonJS({
  "node_modules/core-js/modules/es6.object.prevent-extensions.js"() {
    var isObject4 = require_is_object();
    var meta = require_meta().onFreeze;
    require_object_sap()("preventExtensions", function($preventExtensions) {
      return function preventExtensions(it) {
        return $preventExtensions && isObject4(it) ? $preventExtensions(meta(it)) : it;
      };
    });
  }
});

// node_modules/core-js/modules/es6.object.is-frozen.js
var require_es6_object_is_frozen = __commonJS({
  "node_modules/core-js/modules/es6.object.is-frozen.js"() {
    var isObject4 = require_is_object();
    require_object_sap()("isFrozen", function($isFrozen) {
      return function isFrozen(it) {
        return isObject4(it) ? $isFrozen ? $isFrozen(it) : false : true;
      };
    });
  }
});

// node_modules/core-js/modules/es6.object.is-sealed.js
var require_es6_object_is_sealed = __commonJS({
  "node_modules/core-js/modules/es6.object.is-sealed.js"() {
    var isObject4 = require_is_object();
    require_object_sap()("isSealed", function($isSealed) {
      return function isSealed(it) {
        return isObject4(it) ? $isSealed ? $isSealed(it) : false : true;
      };
    });
  }
});

// node_modules/core-js/modules/es6.object.is-extensible.js
var require_es6_object_is_extensible = __commonJS({
  "node_modules/core-js/modules/es6.object.is-extensible.js"() {
    var isObject4 = require_is_object();
    require_object_sap()("isExtensible", function($isExtensible) {
      return function isExtensible(it) {
        return isObject4(it) ? $isExtensible ? $isExtensible(it) : true : false;
      };
    });
  }
});

// node_modules/core-js/modules/_object-assign.js
var require_object_assign = __commonJS({
  "node_modules/core-js/modules/_object-assign.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var getKeys = require_object_keys();
    var gOPS = require_object_gops();
    var pIE = require_object_pie();
    var toObject3 = require_to_object();
    var IObject = require_iobject();
    var $assign = Object.assign;
    module2.exports = !$assign || require_fails()(function() {
      var A = {};
      var B = {};
      var S = Symbol();
      var K = "abcdefghijklmnopqrst";
      A[S] = 7;
      K.split("").forEach(function(k) {
        B[k] = k;
      });
      return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
    }) ? function assign(target, source) {
      var T = toObject3(target);
      var aLen = arguments.length;
      var index2 = 1;
      var getSymbols = gOPS.f;
      var isEnum = pIE.f;
      while (aLen > index2) {
        var S = IObject(arguments[index2++]);
        var keys3 = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
        var length = keys3.length;
        var j = 0;
        var key;
        while (length > j) {
          key = keys3[j++];
          if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
        }
      }
      return T;
    } : $assign;
  }
});

// node_modules/core-js/modules/es6.object.assign.js
var require_es6_object_assign = __commonJS({
  "node_modules/core-js/modules/es6.object.assign.js"() {
    var $export = require_export();
    $export($export.S + $export.F, "Object", { assign: require_object_assign() });
  }
});

// node_modules/core-js/modules/_same-value.js
var require_same_value = __commonJS({
  "node_modules/core-js/modules/_same-value.js"(exports, module2) {
    module2.exports = Object.is || function is(x, y) {
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    };
  }
});

// node_modules/core-js/modules/es6.object.is.js
var require_es6_object_is = __commonJS({
  "node_modules/core-js/modules/es6.object.is.js"() {
    var $export = require_export();
    $export($export.S, "Object", { is: require_same_value() });
  }
});

// node_modules/core-js/modules/_set-proto.js
var require_set_proto = __commonJS({
  "node_modules/core-js/modules/_set-proto.js"(exports, module2) {
    var isObject4 = require_is_object();
    var anObject = require_an_object();
    var check = function(O, proto5) {
      anObject(O);
      if (!isObject4(proto5) && proto5 !== null) throw TypeError(proto5 + ": can't set as prototype!");
    };
    module2.exports = {
      set: Object.setPrototypeOf || ("__proto__" in {} ? (
        // eslint-disable-line
        function(test, buggy, set5) {
          try {
            set5 = require_ctx()(Function.call, require_object_gopd().f(Object.prototype, "__proto__").set, 2);
            set5(test, []);
            buggy = !(test instanceof Array);
          } catch (e) {
            buggy = true;
          }
          return function setPrototypeOf(O, proto5) {
            check(O, proto5);
            if (buggy) O.__proto__ = proto5;
            else set5(O, proto5);
            return O;
          };
        }({}, false)
      ) : void 0),
      check
    };
  }
});

// node_modules/core-js/modules/es6.object.set-prototype-of.js
var require_es6_object_set_prototype_of = __commonJS({
  "node_modules/core-js/modules/es6.object.set-prototype-of.js"() {
    var $export = require_export();
    $export($export.S, "Object", { setPrototypeOf: require_set_proto().set });
  }
});

// node_modules/core-js/modules/_classof.js
var require_classof = __commonJS({
  "node_modules/core-js/modules/_classof.js"(exports, module2) {
    var cof = require_cof();
    var TAG = require_wks()("toStringTag");
    var ARG = cof(/* @__PURE__ */ function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (e) {
      }
    };
    module2.exports = function(it) {
      var O, T, B;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
    };
  }
});

// node_modules/core-js/modules/es6.object.to-string.js
var require_es6_object_to_string = __commonJS({
  "node_modules/core-js/modules/es6.object.to-string.js"() {
    "use strict";
    var classof = require_classof();
    var test = {};
    test[require_wks()("toStringTag")] = "z";
    if (test + "" != "[object z]") {
      require_redefine()(Object.prototype, "toString", function toString3() {
        return "[object " + classof(this) + "]";
      }, true);
    }
  }
});

// node_modules/core-js/modules/_invoke.js
var require_invoke = __commonJS({
  "node_modules/core-js/modules/_invoke.js"(exports, module2) {
    module2.exports = function(fn, args, that) {
      var un = that === void 0;
      switch (args.length) {
        case 0:
          return un ? fn() : fn.call(that);
        case 1:
          return un ? fn(args[0]) : fn.call(that, args[0]);
        case 2:
          return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
        case 3:
          return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
        case 4:
          return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
      }
      return fn.apply(that, args);
    };
  }
});

// node_modules/core-js/modules/_bind.js
var require_bind = __commonJS({
  "node_modules/core-js/modules/_bind.js"(exports, module2) {
    "use strict";
    var aFunction = require_a_function();
    var isObject4 = require_is_object();
    var invoke = require_invoke();
    var arraySlice = [].slice;
    var factories = {};
    var construct = function(F, len, args) {
      if (!(len in factories)) {
        for (var n = [], i = 0; i < len; i++) n[i] = "a[" + i + "]";
        factories[len] = Function("F,a", "return new F(" + n.join(",") + ")");
      }
      return factories[len](F, args);
    };
    module2.exports = Function.bind || function bind(that) {
      var fn = aFunction(this);
      var partArgs = arraySlice.call(arguments, 1);
      var bound = function() {
        var args = partArgs.concat(arraySlice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
      };
      if (isObject4(fn.prototype)) bound.prototype = fn.prototype;
      return bound;
    };
  }
});

// node_modules/core-js/modules/es6.function.bind.js
var require_es6_function_bind = __commonJS({
  "node_modules/core-js/modules/es6.function.bind.js"() {
    var $export = require_export();
    $export($export.P, "Function", { bind: require_bind() });
  }
});

// node_modules/core-js/modules/es6.function.name.js
var require_es6_function_name = __commonJS({
  "node_modules/core-js/modules/es6.function.name.js"() {
    var dP = require_object_dp().f;
    var FProto = Function.prototype;
    var nameRE = /^\s*function ([^ (]*)/;
    var NAME = "name";
    NAME in FProto || require_descriptors() && dP(FProto, NAME, {
      configurable: true,
      get: function() {
        try {
          return ("" + this).match(nameRE)[1];
        } catch (e) {
          return "";
        }
      }
    });
  }
});

// node_modules/core-js/modules/es6.function.has-instance.js
var require_es6_function_has_instance = __commonJS({
  "node_modules/core-js/modules/es6.function.has-instance.js"() {
    "use strict";
    var isObject4 = require_is_object();
    var getPrototypeOf = require_object_gpo();
    var HAS_INSTANCE = require_wks()("hasInstance");
    var FunctionProto = Function.prototype;
    if (!(HAS_INSTANCE in FunctionProto)) require_object_dp().f(FunctionProto, HAS_INSTANCE, { value: function(O) {
      if (typeof this != "function" || !isObject4(O)) return false;
      if (!isObject4(this.prototype)) return O instanceof this;
      while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
      return false;
    } });
  }
});

// node_modules/core-js/modules/_string-ws.js
var require_string_ws = __commonJS({
  "node_modules/core-js/modules/_string-ws.js"(exports, module2) {
    module2.exports = "	\n\v\f\r   ᠎             　\u2028\u2029\uFEFF";
  }
});

// node_modules/core-js/modules/_string-trim.js
var require_string_trim = __commonJS({
  "node_modules/core-js/modules/_string-trim.js"(exports, module2) {
    var $export = require_export();
    var defined = require_defined();
    var fails = require_fails();
    var spaces = require_string_ws();
    var space = "[" + spaces + "]";
    var non = "​";
    var ltrim = RegExp("^" + space + space + "*");
    var rtrim = RegExp(space + space + "*$");
    var exporter = function(KEY13, exec, ALIAS) {
      var exp = {};
      var FORCE = fails(function() {
        return !!spaces[KEY13]() || non[KEY13]() != non;
      });
      var fn = exp[KEY13] = FORCE ? exec(trim) : spaces[KEY13];
      if (ALIAS) exp[ALIAS] = fn;
      $export($export.P + $export.F * FORCE, "String", exp);
    };
    var trim = exporter.trim = function(string, TYPE) {
      string = String(defined(string));
      if (TYPE & 1) string = string.replace(ltrim, "");
      if (TYPE & 2) string = string.replace(rtrim, "");
      return string;
    };
    module2.exports = exporter;
  }
});

// node_modules/core-js/modules/_parse-int.js
var require_parse_int = __commonJS({
  "node_modules/core-js/modules/_parse-int.js"(exports, module2) {
    var $parseInt = require_global().parseInt;
    var $trim = require_string_trim().trim;
    var ws = require_string_ws();
    var hex = /^[-+]?0[xX]/;
    module2.exports = $parseInt(ws + "08") !== 8 || $parseInt(ws + "0x16") !== 22 ? function parseInt2(str, radix) {
      var string = $trim(String(str), 3);
      return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
    } : $parseInt;
  }
});

// node_modules/core-js/modules/es6.parse-int.js
var require_es6_parse_int = __commonJS({
  "node_modules/core-js/modules/es6.parse-int.js"() {
    var $export = require_export();
    var $parseInt = require_parse_int();
    $export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });
  }
});

// node_modules/core-js/modules/_parse-float.js
var require_parse_float = __commonJS({
  "node_modules/core-js/modules/_parse-float.js"(exports, module2) {
    var $parseFloat = require_global().parseFloat;
    var $trim = require_string_trim().trim;
    module2.exports = 1 / $parseFloat(require_string_ws() + "-0") !== -Infinity ? function parseFloat2(str) {
      var string = $trim(String(str), 3);
      var result = $parseFloat(string);
      return result === 0 && string.charAt(0) == "-" ? -0 : result;
    } : $parseFloat;
  }
});

// node_modules/core-js/modules/es6.parse-float.js
var require_es6_parse_float = __commonJS({
  "node_modules/core-js/modules/es6.parse-float.js"() {
    var $export = require_export();
    var $parseFloat = require_parse_float();
    $export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });
  }
});

// node_modules/core-js/modules/_inherit-if-required.js
var require_inherit_if_required = __commonJS({
  "node_modules/core-js/modules/_inherit-if-required.js"(exports, module2) {
    var isObject4 = require_is_object();
    var setPrototypeOf = require_set_proto().set;
    module2.exports = function(that, target, C) {
      var S = target.constructor;
      var P;
      if (S !== C && typeof S == "function" && (P = S.prototype) !== C.prototype && isObject4(P) && setPrototypeOf) {
        setPrototypeOf(that, P);
      }
      return that;
    };
  }
});

// node_modules/core-js/modules/es6.number.constructor.js
var require_es6_number_constructor = __commonJS({
  "node_modules/core-js/modules/es6.number.constructor.js"() {
    "use strict";
    var global2 = require_global();
    var has = require_has();
    var cof = require_cof();
    var inheritIfRequired = require_inherit_if_required();
    var toPrimitive = require_to_primitive();
    var fails = require_fails();
    var gOPN = require_object_gopn().f;
    var gOPD = require_object_gopd().f;
    var dP = require_object_dp().f;
    var $trim = require_string_trim().trim;
    var NUMBER = "Number";
    var $Number = global2[NUMBER];
    var Base = $Number;
    var proto5 = $Number.prototype;
    var BROKEN_COF = cof(require_object_create()(proto5)) == NUMBER;
    var TRIM = "trim" in String.prototype;
    var toNumber = function(argument) {
      var it = toPrimitive(argument, false);
      if (typeof it == "string" && it.length > 2) {
        it = TRIM ? it.trim() : $trim(it, 3);
        var first = it.charCodeAt(0);
        var third, radix, maxCode;
        if (first === 43 || first === 45) {
          third = it.charCodeAt(2);
          if (third === 88 || third === 120) return NaN;
        } else if (first === 48) {
          switch (it.charCodeAt(1)) {
            case 66:
            case 98:
              radix = 2;
              maxCode = 49;
              break;
            case 79:
            case 111:
              radix = 8;
              maxCode = 55;
              break;
            default:
              return +it;
          }
          for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
            code = digits.charCodeAt(i);
            if (code < 48 || code > maxCode) return NaN;
          }
          return parseInt(digits, radix);
        }
      }
      return +it;
    };
    if (!$Number(" 0o1") || !$Number("0b1") || $Number("+0x1")) {
      $Number = function Number2(value) {
        var it = arguments.length < 1 ? 0 : value;
        var that = this;
        return that instanceof $Number && (BROKEN_COF ? fails(function() {
          proto5.valueOf.call(that);
        }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
      };
      for (keys3 = require_descriptors() ? gOPN(Base) : (
        // ES3:
        "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(",")
      ), j = 0; keys3.length > j; j++) {
        if (has(Base, key = keys3[j]) && !has($Number, key)) {
          dP($Number, key, gOPD(Base, key));
        }
      }
      $Number.prototype = proto5;
      proto5.constructor = $Number;
      require_redefine()(global2, NUMBER, $Number);
    }
    var keys3;
    var j;
    var key;
  }
});

// node_modules/core-js/modules/_a-number-value.js
var require_a_number_value = __commonJS({
  "node_modules/core-js/modules/_a-number-value.js"(exports, module2) {
    var cof = require_cof();
    module2.exports = function(it, msg) {
      if (typeof it != "number" && cof(it) != "Number") throw TypeError(msg);
      return +it;
    };
  }
});

// node_modules/core-js/modules/_string-repeat.js
var require_string_repeat = __commonJS({
  "node_modules/core-js/modules/_string-repeat.js"(exports, module2) {
    "use strict";
    var toInteger = require_to_integer();
    var defined = require_defined();
    module2.exports = function repeat(count) {
      var str = String(defined(this));
      var res = "";
      var n = toInteger(count);
      if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
      for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
      return res;
    };
  }
});

// node_modules/core-js/modules/es6.number.to-fixed.js
var require_es6_number_to_fixed = __commonJS({
  "node_modules/core-js/modules/es6.number.to-fixed.js"() {
    "use strict";
    var $export = require_export();
    var toInteger = require_to_integer();
    var aNumberValue = require_a_number_value();
    var repeat = require_string_repeat();
    var $toFixed = 1 .toFixed;
    var floor = Math.floor;
    var data = [0, 0, 0, 0, 0, 0];
    var ERROR = "Number.toFixed: incorrect invocation!";
    var ZERO = "0";
    var multiply2 = function(n, c) {
      var i = -1;
      var c2 = c;
      while (++i < 6) {
        c2 += n * data[i];
        data[i] = c2 % 1e7;
        c2 = floor(c2 / 1e7);
      }
    };
    var divide2 = function(n) {
      var i = 6;
      var c = 0;
      while (--i >= 0) {
        c += data[i];
        data[i] = floor(c / n);
        c = c % n * 1e7;
      }
    };
    var numToString = function() {
      var i = 6;
      var s = "";
      while (--i >= 0) {
        if (s !== "" || i === 0 || data[i] !== 0) {
          var t = String(data[i]);
          s = s === "" ? t : s + repeat.call(ZERO, 7 - t.length) + t;
        }
      }
      return s;
    };
    var pow = function(x, n, acc) {
      return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
    };
    var log = function(x) {
      var n = 0;
      var x2 = x;
      while (x2 >= 4096) {
        n += 12;
        x2 /= 4096;
      }
      while (x2 >= 2) {
        n += 1;
        x2 /= 2;
      }
      return n;
    };
    $export($export.P + $export.F * (!!$toFixed && (8e-5.toFixed(3) !== "0.000" || 0.9.toFixed(0) !== "1" || 1.255.toFixed(2) !== "1.25" || 1000000000000000100 .toFixed(0) !== "1000000000000000128") || !require_fails()(function() {
      $toFixed.call({});
    })), "Number", {
      toFixed: function toFixed2(fractionDigits) {
        var x = aNumberValue(this, ERROR);
        var f = toInteger(fractionDigits);
        var s = "";
        var m = ZERO;
        var e, z, j, k;
        if (f < 0 || f > 20) throw RangeError(ERROR);
        if (x != x) return "NaN";
        if (x <= -1e21 || x >= 1e21) return String(x);
        if (x < 0) {
          s = "-";
          x = -x;
        }
        if (x > 1e-21) {
          e = log(x * pow(2, 69, 1)) - 69;
          z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
          z *= 4503599627370496;
          e = 52 - e;
          if (e > 0) {
            multiply2(0, z);
            j = f;
            while (j >= 7) {
              multiply2(1e7, 0);
              j -= 7;
            }
            multiply2(pow(10, j, 1), 0);
            j = e - 1;
            while (j >= 23) {
              divide2(1 << 23);
              j -= 23;
            }
            divide2(1 << j);
            multiply2(1, 1);
            divide2(2);
            m = numToString();
          } else {
            multiply2(0, z);
            multiply2(1 << -e, 0);
            m = numToString() + repeat.call(ZERO, f);
          }
        }
        if (f > 0) {
          k = m.length;
          m = s + (k <= f ? "0." + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + "." + m.slice(k - f));
        } else {
          m = s + m;
        }
        return m;
      }
    });
  }
});

// node_modules/core-js/modules/es6.number.to-precision.js
var require_es6_number_to_precision = __commonJS({
  "node_modules/core-js/modules/es6.number.to-precision.js"() {
    "use strict";
    var $export = require_export();
    var $fails = require_fails();
    var aNumberValue = require_a_number_value();
    var $toPrecision = 1 .toPrecision;
    $export($export.P + $export.F * ($fails(function() {
      return $toPrecision.call(1, void 0) !== "1";
    }) || !$fails(function() {
      $toPrecision.call({});
    })), "Number", {
      toPrecision: function toPrecision(precision) {
        var that = aNumberValue(this, "Number#toPrecision: incorrect invocation!");
        return precision === void 0 ? $toPrecision.call(that) : $toPrecision.call(that, precision);
      }
    });
  }
});

// node_modules/core-js/modules/es6.number.epsilon.js
var require_es6_number_epsilon = __commonJS({
  "node_modules/core-js/modules/es6.number.epsilon.js"() {
    var $export = require_export();
    $export($export.S, "Number", { EPSILON: Math.pow(2, -52) });
  }
});

// node_modules/core-js/modules/es6.number.is-finite.js
var require_es6_number_is_finite = __commonJS({
  "node_modules/core-js/modules/es6.number.is-finite.js"() {
    var $export = require_export();
    var _isFinite = require_global().isFinite;
    $export($export.S, "Number", {
      isFinite: function isFinite2(it) {
        return typeof it == "number" && _isFinite(it);
      }
    });
  }
});

// node_modules/core-js/modules/_is-integer.js
var require_is_integer = __commonJS({
  "node_modules/core-js/modules/_is-integer.js"(exports, module2) {
    var isObject4 = require_is_object();
    var floor = Math.floor;
    module2.exports = function isInteger(it) {
      return !isObject4(it) && isFinite(it) && floor(it) === it;
    };
  }
});

// node_modules/core-js/modules/es6.number.is-integer.js
var require_es6_number_is_integer = __commonJS({
  "node_modules/core-js/modules/es6.number.is-integer.js"() {
    var $export = require_export();
    $export($export.S, "Number", { isInteger: require_is_integer() });
  }
});

// node_modules/core-js/modules/es6.number.is-nan.js
var require_es6_number_is_nan = __commonJS({
  "node_modules/core-js/modules/es6.number.is-nan.js"() {
    var $export = require_export();
    $export($export.S, "Number", {
      isNaN: function isNaN2(number) {
        return number != number;
      }
    });
  }
});

// node_modules/core-js/modules/es6.number.is-safe-integer.js
var require_es6_number_is_safe_integer = __commonJS({
  "node_modules/core-js/modules/es6.number.is-safe-integer.js"() {
    var $export = require_export();
    var isInteger = require_is_integer();
    var abs4 = Math.abs;
    $export($export.S, "Number", {
      isSafeInteger: function isSafeInteger(number) {
        return isInteger(number) && abs4(number) <= 9007199254740991;
      }
    });
  }
});

// node_modules/core-js/modules/es6.number.max-safe-integer.js
var require_es6_number_max_safe_integer = __commonJS({
  "node_modules/core-js/modules/es6.number.max-safe-integer.js"() {
    var $export = require_export();
    $export($export.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 });
  }
});

// node_modules/core-js/modules/es6.number.min-safe-integer.js
var require_es6_number_min_safe_integer = __commonJS({
  "node_modules/core-js/modules/es6.number.min-safe-integer.js"() {
    var $export = require_export();
    $export($export.S, "Number", { MIN_SAFE_INTEGER: -9007199254740991 });
  }
});

// node_modules/core-js/modules/es6.number.parse-float.js
var require_es6_number_parse_float = __commonJS({
  "node_modules/core-js/modules/es6.number.parse-float.js"() {
    var $export = require_export();
    var $parseFloat = require_parse_float();
    $export($export.S + $export.F * (Number.parseFloat != $parseFloat), "Number", { parseFloat: $parseFloat });
  }
});

// node_modules/core-js/modules/es6.number.parse-int.js
var require_es6_number_parse_int = __commonJS({
  "node_modules/core-js/modules/es6.number.parse-int.js"() {
    var $export = require_export();
    var $parseInt = require_parse_int();
    $export($export.S + $export.F * (Number.parseInt != $parseInt), "Number", { parseInt: $parseInt });
  }
});

// node_modules/core-js/modules/_math-log1p.js
var require_math_log1p = __commonJS({
  "node_modules/core-js/modules/_math-log1p.js"(exports, module2) {
    module2.exports = Math.log1p || function log1p(x) {
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
    };
  }
});

// node_modules/core-js/modules/es6.math.acosh.js
var require_es6_math_acosh = __commonJS({
  "node_modules/core-js/modules/es6.math.acosh.js"() {
    var $export = require_export();
    var log1p = require_math_log1p();
    var sqrt = Math.sqrt;
    var $acosh = Math.acosh;
    $export($export.S + $export.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710 && $acosh(Infinity) == Infinity), "Math", {
      acosh: function acosh(x) {
        return (x = +x) < 1 ? NaN : x > 9490626562425156e-8 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
      }
    });
  }
});

// node_modules/core-js/modules/es6.math.asinh.js
var require_es6_math_asinh = __commonJS({
  "node_modules/core-js/modules/es6.math.asinh.js"() {
    var $export = require_export();
    var $asinh = Math.asinh;
    function asinh(x) {
      return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
    }
    $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), "Math", { asinh });
  }
});

// node_modules/core-js/modules/es6.math.atanh.js
var require_es6_math_atanh = __commonJS({
  "node_modules/core-js/modules/es6.math.atanh.js"() {
    var $export = require_export();
    var $atanh = Math.atanh;
    $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), "Math", {
      atanh: function atanh(x) {
        return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
      }
    });
  }
});

// node_modules/core-js/modules/_math-sign.js
var require_math_sign = __commonJS({
  "node_modules/core-js/modules/_math-sign.js"(exports, module2) {
    module2.exports = Math.sign || function sign3(x) {
      return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
    };
  }
});

// node_modules/core-js/modules/es6.math.cbrt.js
var require_es6_math_cbrt = __commonJS({
  "node_modules/core-js/modules/es6.math.cbrt.js"() {
    var $export = require_export();
    var sign3 = require_math_sign();
    $export($export.S, "Math", {
      cbrt: function cbrt(x) {
        return sign3(x = +x) * Math.pow(Math.abs(x), 1 / 3);
      }
    });
  }
});

// node_modules/core-js/modules/es6.math.clz32.js
var require_es6_math_clz32 = __commonJS({
  "node_modules/core-js/modules/es6.math.clz32.js"() {
    var $export = require_export();
    $export($export.S, "Math", {
      clz32: function clz32(x) {
        return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
      }
    });
  }
});

// node_modules/core-js/modules/es6.math.cosh.js
var require_es6_math_cosh = __commonJS({
  "node_modules/core-js/modules/es6.math.cosh.js"() {
    var $export = require_export();
    var exp = Math.exp;
    $export($export.S, "Math", {
      cosh: function cosh(x) {
        return (exp(x = +x) + exp(-x)) / 2;
      }
    });
  }
});

// node_modules/core-js/modules/_math-expm1.js
var require_math_expm1 = __commonJS({
  "node_modules/core-js/modules/_math-expm1.js"(exports, module2) {
    var $expm1 = Math.expm1;
    module2.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-2e-17) != -2e-17 ? function expm1(x) {
      return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
    } : $expm1;
  }
});

// node_modules/core-js/modules/es6.math.expm1.js
var require_es6_math_expm1 = __commonJS({
  "node_modules/core-js/modules/es6.math.expm1.js"() {
    var $export = require_export();
    var $expm1 = require_math_expm1();
    $export($export.S + $export.F * ($expm1 != Math.expm1), "Math", { expm1: $expm1 });
  }
});

// node_modules/core-js/modules/_math-fround.js
var require_math_fround = __commonJS({
  "node_modules/core-js/modules/_math-fround.js"(exports, module2) {
    var sign3 = require_math_sign();
    var pow = Math.pow;
    var EPSILON = pow(2, -52);
    var EPSILON32 = pow(2, -23);
    var MAX32 = pow(2, 127) * (2 - EPSILON32);
    var MIN32 = pow(2, -126);
    var roundTiesToEven = function(n) {
      return n + 1 / EPSILON - 1 / EPSILON;
    };
    module2.exports = Math.fround || function fround(x) {
      var $abs = Math.abs(x);
      var $sign = sign3(x);
      var a, result;
      if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
      a = (1 + EPSILON32 / EPSILON) * $abs;
      result = a - (a - $abs);
      if (result > MAX32 || result != result) return $sign * Infinity;
      return $sign * result;
    };
  }
});

// node_modules/core-js/modules/es6.math.fround.js
var require_es6_math_fround = __commonJS({
  "node_modules/core-js/modules/es6.math.fround.js"() {
    var $export = require_export();
    $export($export.S, "Math", { fround: require_math_fround() });
  }
});

// node_modules/core-js/modules/es6.math.hypot.js
var require_es6_math_hypot = __commonJS({
  "node_modules/core-js/modules/es6.math.hypot.js"() {
    var $export = require_export();
    var abs4 = Math.abs;
    $export($export.S, "Math", {
      hypot: function hypot(value1, value2) {
        var sum = 0;
        var i = 0;
        var aLen = arguments.length;
        var larg = 0;
        var arg, div;
        while (i < aLen) {
          arg = abs4(arguments[i++]);
          if (larg < arg) {
            div = larg / arg;
            sum = sum * div * div + 1;
            larg = arg;
          } else if (arg > 0) {
            div = arg / larg;
            sum += div * div;
          } else sum += arg;
        }
        return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
      }
    });
  }
});

// node_modules/core-js/modules/es6.math.imul.js
var require_es6_math_imul = __commonJS({
  "node_modules/core-js/modules/es6.math.imul.js"() {
    var $export = require_export();
    var $imul = Math.imul;
    $export($export.S + $export.F * require_fails()(function() {
      return $imul(4294967295, 5) != -5 || $imul.length != 2;
    }), "Math", {
      imul: function imul(x, y) {
        var UINT16 = 65535;
        var xn = +x;
        var yn = +y;
        var xl = UINT16 & xn;
        var yl = UINT16 & yn;
        return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
      }
    });
  }
});

// node_modules/core-js/modules/es6.math.log10.js
var require_es6_math_log10 = __commonJS({
  "node_modules/core-js/modules/es6.math.log10.js"() {
    var $export = require_export();
    $export($export.S, "Math", {
      log10: function log10(x) {
        return Math.log(x) * Math.LOG10E;
      }
    });
  }
});

// node_modules/core-js/modules/es6.math.log1p.js
var require_es6_math_log1p = __commonJS({
  "node_modules/core-js/modules/es6.math.log1p.js"() {
    var $export = require_export();
    $export($export.S, "Math", { log1p: require_math_log1p() });
  }
});

// node_modules/core-js/modules/es6.math.log2.js
var require_es6_math_log2 = __commonJS({
  "node_modules/core-js/modules/es6.math.log2.js"() {
    var $export = require_export();
    $export($export.S, "Math", {
      log2: function log2(x) {
        return Math.log(x) / Math.LN2;
      }
    });
  }
});

// node_modules/core-js/modules/es6.math.sign.js
var require_es6_math_sign = __commonJS({
  "node_modules/core-js/modules/es6.math.sign.js"() {
    var $export = require_export();
    $export($export.S, "Math", { sign: require_math_sign() });
  }
});

// node_modules/core-js/modules/es6.math.sinh.js
var require_es6_math_sinh = __commonJS({
  "node_modules/core-js/modules/es6.math.sinh.js"() {
    var $export = require_export();
    var expm1 = require_math_expm1();
    var exp = Math.exp;
    $export($export.S + $export.F * require_fails()(function() {
      return !Math.sinh(-2e-17) != -2e-17;
    }), "Math", {
      sinh: function sinh(x) {
        return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
      }
    });
  }
});

// node_modules/core-js/modules/es6.math.tanh.js
var require_es6_math_tanh = __commonJS({
  "node_modules/core-js/modules/es6.math.tanh.js"() {
    var $export = require_export();
    var expm1 = require_math_expm1();
    var exp = Math.exp;
    $export($export.S, "Math", {
      tanh: function tanh(x) {
        var a = expm1(x = +x);
        var b = expm1(-x);
        return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
      }
    });
  }
});

// node_modules/core-js/modules/es6.math.trunc.js
var require_es6_math_trunc = __commonJS({
  "node_modules/core-js/modules/es6.math.trunc.js"() {
    var $export = require_export();
    $export($export.S, "Math", {
      trunc: function trunc(it) {
        return (it > 0 ? Math.floor : Math.ceil)(it);
      }
    });
  }
});

// node_modules/core-js/modules/es6.string.from-code-point.js
var require_es6_string_from_code_point = __commonJS({
  "node_modules/core-js/modules/es6.string.from-code-point.js"() {
    var $export = require_export();
    var toAbsoluteIndex = require_to_absolute_index();
    var fromCharCode = String.fromCharCode;
    var $fromCodePoint = String.fromCodePoint;
    $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), "String", {
      // 21.1.2.2 String.fromCodePoint(...codePoints)
      fromCodePoint: function fromCodePoint(x) {
        var res = [];
        var aLen = arguments.length;
        var i = 0;
        var code;
        while (aLen > i) {
          code = +arguments[i++];
          if (toAbsoluteIndex(code, 1114111) !== code) throw RangeError(code + " is not a valid code point");
          res.push(
            code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320)
          );
        }
        return res.join("");
      }
    });
  }
});

// node_modules/core-js/modules/es6.string.raw.js
var require_es6_string_raw = __commonJS({
  "node_modules/core-js/modules/es6.string.raw.js"() {
    var $export = require_export();
    var toIObject = require_to_iobject();
    var toLength = require_to_length();
    $export($export.S, "String", {
      // 21.1.2.4 String.raw(callSite, ...substitutions)
      raw: function raw(callSite) {
        var tpl = toIObject(callSite.raw);
        var len = toLength(tpl.length);
        var aLen = arguments.length;
        var res = [];
        var i = 0;
        while (len > i) {
          res.push(String(tpl[i++]));
          if (i < aLen) res.push(String(arguments[i]));
        }
        return res.join("");
      }
    });
  }
});

// node_modules/core-js/modules/es6.string.trim.js
var require_es6_string_trim = __commonJS({
  "node_modules/core-js/modules/es6.string.trim.js"() {
    "use strict";
    require_string_trim()("trim", function($trim) {
      return function trim() {
        return $trim(this, 3);
      };
    });
  }
});

// node_modules/core-js/modules/_string-at.js
var require_string_at = __commonJS({
  "node_modules/core-js/modules/_string-at.js"(exports, module2) {
    var toInteger = require_to_integer();
    var defined = require_defined();
    module2.exports = function(TO_STRING) {
      return function(that, pos) {
        var s = String(defined(that));
        var i = toInteger(pos);
        var l = s.length;
        var a, b;
        if (i < 0 || i >= l) return TO_STRING ? "" : void 0;
        a = s.charCodeAt(i);
        return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
      };
    };
  }
});

// node_modules/core-js/modules/_iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/modules/_iterators.js"(exports, module2) {
    module2.exports = {};
  }
});

// node_modules/core-js/modules/_iter-create.js
var require_iter_create = __commonJS({
  "node_modules/core-js/modules/_iter-create.js"(exports, module2) {
    "use strict";
    var create = require_object_create();
    var descriptor = require_property_desc();
    var setToStringTag = require_set_to_string_tag();
    var IteratorPrototype = {};
    require_hide()(IteratorPrototype, require_wks()("iterator"), function() {
      return this;
    });
    module2.exports = function(Constructor, NAME, next) {
      Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
      setToStringTag(Constructor, NAME + " Iterator");
    };
  }
});

// node_modules/core-js/modules/_iter-define.js
var require_iter_define = __commonJS({
  "node_modules/core-js/modules/_iter-define.js"(exports, module2) {
    "use strict";
    var LIBRARY = require_library();
    var $export = require_export();
    var redefine = require_redefine();
    var hide = require_hide();
    var Iterators = require_iterators();
    var $iterCreate = require_iter_create();
    var setToStringTag = require_set_to_string_tag();
    var getPrototypeOf = require_object_gpo();
    var ITERATOR = require_wks()("iterator");
    var BUGGY = !([].keys && "next" in [].keys());
    var FF_ITERATOR = "@@iterator";
    var KEYS = "keys";
    var VALUES = "values";
    var returnThis = function() {
      return this;
    };
    module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
      $iterCreate(Constructor, NAME, next);
      var getMethod = function(kind) {
        if (!BUGGY && kind in proto5) return proto5[kind];
        switch (kind) {
          case KEYS:
            return function keys3() {
              return new Constructor(this, kind);
            };
          case VALUES:
            return function values() {
              return new Constructor(this, kind);
            };
        }
        return function entries() {
          return new Constructor(this, kind);
        };
      };
      var TAG = NAME + " Iterator";
      var DEF_VALUES = DEFAULT == VALUES;
      var VALUES_BUG = false;
      var proto5 = Base.prototype;
      var $native = proto5[ITERATOR] || proto5[FF_ITERATOR] || DEFAULT && proto5[DEFAULT];
      var $default = $native || getMethod(DEFAULT);
      var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
      var $anyNative = NAME == "Array" ? proto5.entries || $native : $native;
      var methods, key, IteratorPrototype;
      if ($anyNative) {
        IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
        if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
          setToStringTag(IteratorPrototype, TAG, true);
          if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function") hide(IteratorPrototype, ITERATOR, returnThis);
        }
      }
      if (DEF_VALUES && $native && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
      if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto5[ITERATOR])) {
        hide(proto5, ITERATOR, $default);
      }
      Iterators[NAME] = $default;
      Iterators[TAG] = returnThis;
      if (DEFAULT) {
        methods = {
          values: DEF_VALUES ? $default : getMethod(VALUES),
          keys: IS_SET ? $default : getMethod(KEYS),
          entries: $entries
        };
        if (FORCED) for (key in methods) {
          if (!(key in proto5)) redefine(proto5, key, methods[key]);
        }
        else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
      }
      return methods;
    };
  }
});

// node_modules/core-js/modules/es6.string.iterator.js
var require_es6_string_iterator = __commonJS({
  "node_modules/core-js/modules/es6.string.iterator.js"() {
    "use strict";
    var $at = require_string_at()(true);
    require_iter_define()(String, "String", function(iterated) {
      this._t = String(iterated);
      this._i = 0;
    }, function() {
      var O = this._t;
      var index2 = this._i;
      var point;
      if (index2 >= O.length) return { value: void 0, done: true };
      point = $at(O, index2);
      this._i += point.length;
      return { value: point, done: false };
    });
  }
});

// node_modules/core-js/modules/es6.string.code-point-at.js
var require_es6_string_code_point_at = __commonJS({
  "node_modules/core-js/modules/es6.string.code-point-at.js"() {
    "use strict";
    var $export = require_export();
    var $at = require_string_at()(false);
    $export($export.P, "String", {
      // 21.1.3.3 String.prototype.codePointAt(pos)
      codePointAt: function codePointAt(pos) {
        return $at(this, pos);
      }
    });
  }
});

// node_modules/core-js/modules/_is-regexp.js
var require_is_regexp = __commonJS({
  "node_modules/core-js/modules/_is-regexp.js"(exports, module2) {
    var isObject4 = require_is_object();
    var cof = require_cof();
    var MATCH = require_wks()("match");
    module2.exports = function(it) {
      var isRegExp2;
      return isObject4(it) && ((isRegExp2 = it[MATCH]) !== void 0 ? !!isRegExp2 : cof(it) == "RegExp");
    };
  }
});

// node_modules/core-js/modules/_string-context.js
var require_string_context = __commonJS({
  "node_modules/core-js/modules/_string-context.js"(exports, module2) {
    var isRegExp2 = require_is_regexp();
    var defined = require_defined();
    module2.exports = function(that, searchString, NAME) {
      if (isRegExp2(searchString)) throw TypeError("String#" + NAME + " doesn't accept regex!");
      return String(defined(that));
    };
  }
});

// node_modules/core-js/modules/_fails-is-regexp.js
var require_fails_is_regexp = __commonJS({
  "node_modules/core-js/modules/_fails-is-regexp.js"(exports, module2) {
    var MATCH = require_wks()("match");
    module2.exports = function(KEY13) {
      var re = /./;
      try {
        "/./"[KEY13](re);
      } catch (e) {
        try {
          re[MATCH] = false;
          return !"/./"[KEY13](re);
        } catch (f) {
        }
      }
      return true;
    };
  }
});

// node_modules/core-js/modules/es6.string.ends-with.js
var require_es6_string_ends_with = __commonJS({
  "node_modules/core-js/modules/es6.string.ends-with.js"() {
    "use strict";
    var $export = require_export();
    var toLength = require_to_length();
    var context = require_string_context();
    var ENDS_WITH = "endsWith";
    var $endsWith = ""[ENDS_WITH];
    $export($export.P + $export.F * require_fails_is_regexp()(ENDS_WITH), "String", {
      endsWith: function endsWith(searchString) {
        var that = context(this, searchString, ENDS_WITH);
        var endPosition = arguments.length > 1 ? arguments[1] : void 0;
        var len = toLength(that.length);
        var end = endPosition === void 0 ? len : Math.min(toLength(endPosition), len);
        var search = String(searchString);
        return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
      }
    });
  }
});

// node_modules/core-js/modules/es6.string.includes.js
var require_es6_string_includes = __commonJS({
  "node_modules/core-js/modules/es6.string.includes.js"() {
    "use strict";
    var $export = require_export();
    var context = require_string_context();
    var INCLUDES = "includes";
    $export($export.P + $export.F * require_fails_is_regexp()(INCLUDES), "String", {
      includes: function includes(searchString) {
        return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es6.string.repeat.js
var require_es6_string_repeat = __commonJS({
  "node_modules/core-js/modules/es6.string.repeat.js"() {
    var $export = require_export();
    $export($export.P, "String", {
      // 21.1.3.13 String.prototype.repeat(count)
      repeat: require_string_repeat()
    });
  }
});

// node_modules/core-js/modules/es6.string.starts-with.js
var require_es6_string_starts_with = __commonJS({
  "node_modules/core-js/modules/es6.string.starts-with.js"() {
    "use strict";
    var $export = require_export();
    var toLength = require_to_length();
    var context = require_string_context();
    var STARTS_WITH = "startsWith";
    var $startsWith = ""[STARTS_WITH];
    $export($export.P + $export.F * require_fails_is_regexp()(STARTS_WITH), "String", {
      startsWith: function startsWith(searchString) {
        var that = context(this, searchString, STARTS_WITH);
        var index2 = toLength(Math.min(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = String(searchString);
        return $startsWith ? $startsWith.call(that, search, index2) : that.slice(index2, index2 + search.length) === search;
      }
    });
  }
});

// node_modules/core-js/modules/_string-html.js
var require_string_html = __commonJS({
  "node_modules/core-js/modules/_string-html.js"(exports, module2) {
    var $export = require_export();
    var fails = require_fails();
    var defined = require_defined();
    var quot = /"/g;
    var createHTML = function(string, tag, attribute, value) {
      var S = String(defined(string));
      var p1 = "<" + tag;
      if (attribute !== "") p1 += " " + attribute + '="' + String(value).replace(quot, "&quot;") + '"';
      return p1 + ">" + S + "</" + tag + ">";
    };
    module2.exports = function(NAME, exec) {
      var O = {};
      O[NAME] = exec(createHTML);
      $export($export.P + $export.F * fails(function() {
        var test = ""[NAME]('"');
        return test !== test.toLowerCase() || test.split('"').length > 3;
      }), "String", O);
    };
  }
});

// node_modules/core-js/modules/es6.string.anchor.js
var require_es6_string_anchor = __commonJS({
  "node_modules/core-js/modules/es6.string.anchor.js"() {
    "use strict";
    require_string_html()("anchor", function(createHTML) {
      return function anchor(name) {
        return createHTML(this, "a", "name", name);
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.big.js
var require_es6_string_big = __commonJS({
  "node_modules/core-js/modules/es6.string.big.js"() {
    "use strict";
    require_string_html()("big", function(createHTML) {
      return function big() {
        return createHTML(this, "big", "", "");
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.blink.js
var require_es6_string_blink = __commonJS({
  "node_modules/core-js/modules/es6.string.blink.js"() {
    "use strict";
    require_string_html()("blink", function(createHTML) {
      return function blink() {
        return createHTML(this, "blink", "", "");
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.bold.js
var require_es6_string_bold = __commonJS({
  "node_modules/core-js/modules/es6.string.bold.js"() {
    "use strict";
    require_string_html()("bold", function(createHTML) {
      return function bold() {
        return createHTML(this, "b", "", "");
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.fixed.js
var require_es6_string_fixed = __commonJS({
  "node_modules/core-js/modules/es6.string.fixed.js"() {
    "use strict";
    require_string_html()("fixed", function(createHTML) {
      return function fixed() {
        return createHTML(this, "tt", "", "");
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.fontcolor.js
var require_es6_string_fontcolor = __commonJS({
  "node_modules/core-js/modules/es6.string.fontcolor.js"() {
    "use strict";
    require_string_html()("fontcolor", function(createHTML) {
      return function fontcolor(color) {
        return createHTML(this, "font", "color", color);
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.fontsize.js
var require_es6_string_fontsize = __commonJS({
  "node_modules/core-js/modules/es6.string.fontsize.js"() {
    "use strict";
    require_string_html()("fontsize", function(createHTML) {
      return function fontsize(size) {
        return createHTML(this, "font", "size", size);
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.italics.js
var require_es6_string_italics = __commonJS({
  "node_modules/core-js/modules/es6.string.italics.js"() {
    "use strict";
    require_string_html()("italics", function(createHTML) {
      return function italics() {
        return createHTML(this, "i", "", "");
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.link.js
var require_es6_string_link = __commonJS({
  "node_modules/core-js/modules/es6.string.link.js"() {
    "use strict";
    require_string_html()("link", function(createHTML) {
      return function link(url) {
        return createHTML(this, "a", "href", url);
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.small.js
var require_es6_string_small = __commonJS({
  "node_modules/core-js/modules/es6.string.small.js"() {
    "use strict";
    require_string_html()("small", function(createHTML) {
      return function small() {
        return createHTML(this, "small", "", "");
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.strike.js
var require_es6_string_strike = __commonJS({
  "node_modules/core-js/modules/es6.string.strike.js"() {
    "use strict";
    require_string_html()("strike", function(createHTML) {
      return function strike() {
        return createHTML(this, "strike", "", "");
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.sub.js
var require_es6_string_sub = __commonJS({
  "node_modules/core-js/modules/es6.string.sub.js"() {
    "use strict";
    require_string_html()("sub", function(createHTML) {
      return function sub() {
        return createHTML(this, "sub", "", "");
      };
    });
  }
});

// node_modules/core-js/modules/es6.string.sup.js
var require_es6_string_sup = __commonJS({
  "node_modules/core-js/modules/es6.string.sup.js"() {
    "use strict";
    require_string_html()("sup", function(createHTML) {
      return function sup() {
        return createHTML(this, "sup", "", "");
      };
    });
  }
});

// node_modules/core-js/modules/es6.date.now.js
var require_es6_date_now = __commonJS({
  "node_modules/core-js/modules/es6.date.now.js"() {
    var $export = require_export();
    $export($export.S, "Date", { now: function() {
      return (/* @__PURE__ */ new Date()).getTime();
    } });
  }
});

// node_modules/core-js/modules/es6.date.to-json.js
var require_es6_date_to_json = __commonJS({
  "node_modules/core-js/modules/es6.date.to-json.js"() {
    "use strict";
    var $export = require_export();
    var toObject3 = require_to_object();
    var toPrimitive = require_to_primitive();
    $export($export.P + $export.F * require_fails()(function() {
      return (/* @__PURE__ */ new Date(NaN)).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function() {
        return 1;
      } }) !== 1;
    }), "Date", {
      // eslint-disable-next-line no-unused-vars
      toJSON: function toJSON3(key) {
        var O = toObject3(this);
        var pv = toPrimitive(O);
        return typeof pv == "number" && !isFinite(pv) ? null : O.toISOString();
      }
    });
  }
});

// node_modules/core-js/modules/_date-to-iso-string.js
var require_date_to_iso_string = __commonJS({
  "node_modules/core-js/modules/_date-to-iso-string.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var getTime = Date.prototype.getTime;
    var $toISOString = Date.prototype.toISOString;
    var lz = function(num) {
      return num > 9 ? num : "0" + num;
    };
    module2.exports = fails(function() {
      return $toISOString.call(new Date(-5e13 - 1)) != "0385-07-25T07:06:39.999Z";
    }) || !fails(function() {
      $toISOString.call(/* @__PURE__ */ new Date(NaN));
    }) ? function toISOString4() {
      if (!isFinite(getTime.call(this))) throw RangeError("Invalid time value");
      var d = this;
      var y = d.getUTCFullYear();
      var m = d.getUTCMilliseconds();
      var s = y < 0 ? "-" : y > 9999 ? "+" : "";
      return s + ("00000" + Math.abs(y)).slice(s ? -6 : -4) + "-" + lz(d.getUTCMonth() + 1) + "-" + lz(d.getUTCDate()) + "T" + lz(d.getUTCHours()) + ":" + lz(d.getUTCMinutes()) + ":" + lz(d.getUTCSeconds()) + "." + (m > 99 ? m : "0" + lz(m)) + "Z";
    } : $toISOString;
  }
});

// node_modules/core-js/modules/es6.date.to-iso-string.js
var require_es6_date_to_iso_string = __commonJS({
  "node_modules/core-js/modules/es6.date.to-iso-string.js"() {
    var $export = require_export();
    var toISOString4 = require_date_to_iso_string();
    $export($export.P + $export.F * (Date.prototype.toISOString !== toISOString4), "Date", {
      toISOString: toISOString4
    });
  }
});

// node_modules/core-js/modules/es6.date.to-string.js
var require_es6_date_to_string = __commonJS({
  "node_modules/core-js/modules/es6.date.to-string.js"() {
    var DateProto = Date.prototype;
    var INVALID_DATE = "Invalid Date";
    var TO_STRING = "toString";
    var $toString = DateProto[TO_STRING];
    var getTime = DateProto.getTime;
    if (/* @__PURE__ */ new Date(NaN) + "" != INVALID_DATE) {
      require_redefine()(DateProto, TO_STRING, function toString3() {
        var value = getTime.call(this);
        return value === value ? $toString.call(this) : INVALID_DATE;
      });
    }
  }
});

// node_modules/core-js/modules/_date-to-primitive.js
var require_date_to_primitive = __commonJS({
  "node_modules/core-js/modules/_date-to-primitive.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    var toPrimitive = require_to_primitive();
    var NUMBER = "number";
    module2.exports = function(hint) {
      if (hint !== "string" && hint !== NUMBER && hint !== "default") throw TypeError("Incorrect hint");
      return toPrimitive(anObject(this), hint != NUMBER);
    };
  }
});

// node_modules/core-js/modules/es6.date.to-primitive.js
var require_es6_date_to_primitive = __commonJS({
  "node_modules/core-js/modules/es6.date.to-primitive.js"() {
    var TO_PRIMITIVE = require_wks()("toPrimitive");
    var proto5 = Date.prototype;
    if (!(TO_PRIMITIVE in proto5)) require_hide()(proto5, TO_PRIMITIVE, require_date_to_primitive());
  }
});

// node_modules/core-js/modules/es6.array.is-array.js
var require_es6_array_is_array = __commonJS({
  "node_modules/core-js/modules/es6.array.is-array.js"() {
    var $export = require_export();
    $export($export.S, "Array", { isArray: require_is_array() });
  }
});

// node_modules/core-js/modules/_iter-call.js
var require_iter_call = __commonJS({
  "node_modules/core-js/modules/_iter-call.js"(exports, module2) {
    var anObject = require_an_object();
    module2.exports = function(iterator, fn, value, entries) {
      try {
        return entries ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (e) {
        var ret = iterator["return"];
        if (ret !== void 0) anObject(ret.call(iterator));
        throw e;
      }
    };
  }
});

// node_modules/core-js/modules/_is-array-iter.js
var require_is_array_iter = __commonJS({
  "node_modules/core-js/modules/_is-array-iter.js"(exports, module2) {
    var Iterators = require_iterators();
    var ITERATOR = require_wks()("iterator");
    var ArrayProto = Array.prototype;
    module2.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
    };
  }
});

// node_modules/core-js/modules/_create-property.js
var require_create_property = __commonJS({
  "node_modules/core-js/modules/_create-property.js"(exports, module2) {
    "use strict";
    var $defineProperty = require_object_dp();
    var createDesc = require_property_desc();
    module2.exports = function(object, index2, value) {
      if (index2 in object) $defineProperty.f(object, index2, createDesc(0, value));
      else object[index2] = value;
    };
  }
});

// node_modules/core-js/modules/core.get-iterator-method.js
var require_core_get_iterator_method = __commonJS({
  "node_modules/core-js/modules/core.get-iterator-method.js"(exports, module2) {
    var classof = require_classof();
    var ITERATOR = require_wks()("iterator");
    var Iterators = require_iterators();
    module2.exports = require_core().getIteratorMethod = function(it) {
      if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js/modules/_iter-detect.js
var require_iter_detect = __commonJS({
  "node_modules/core-js/modules/_iter-detect.js"(exports, module2) {
    var ITERATOR = require_wks()("iterator");
    var SAFE_CLOSING = false;
    try {
      riter = [7][ITERATOR]();
      riter["return"] = function() {
        SAFE_CLOSING = true;
      };
      Array.from(riter, function() {
        throw 2;
      });
    } catch (e) {
    }
    var riter;
    module2.exports = function(exec, skipClosing) {
      if (!skipClosing && !SAFE_CLOSING) return false;
      var safe = false;
      try {
        var arr = [7];
        var iter = arr[ITERATOR]();
        iter.next = function() {
          return { done: safe = true };
        };
        arr[ITERATOR] = function() {
          return iter;
        };
        exec(arr);
      } catch (e) {
      }
      return safe;
    };
  }
});

// node_modules/core-js/modules/es6.array.from.js
var require_es6_array_from = __commonJS({
  "node_modules/core-js/modules/es6.array.from.js"() {
    "use strict";
    var ctx = require_ctx();
    var $export = require_export();
    var toObject3 = require_to_object();
    var call = require_iter_call();
    var isArrayIter = require_is_array_iter();
    var toLength = require_to_length();
    var createProperty = require_create_property();
    var getIterFn = require_core_get_iterator_method();
    $export($export.S + $export.F * !require_iter_detect()(function(iter) {
      Array.from(iter);
    }), "Array", {
      // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
      from: function from3(arrayLike) {
        var O = toObject3(arrayLike);
        var C = typeof this == "function" ? this : Array;
        var aLen = arguments.length;
        var mapfn = aLen > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        var index2 = 0;
        var iterFn = getIterFn(O);
        var length, result, step, iterator;
        if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : void 0, 2);
        if (iterFn != void 0 && !(C == Array && isArrayIter(iterFn))) {
          for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index2++) {
            createProperty(result, index2, mapping ? call(iterator, mapfn, [step.value, index2], true) : step.value);
          }
        } else {
          length = toLength(O.length);
          for (result = new C(length); length > index2; index2++) {
            createProperty(result, index2, mapping ? mapfn(O[index2], index2) : O[index2]);
          }
        }
        result.length = index2;
        return result;
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.of.js
var require_es6_array_of = __commonJS({
  "node_modules/core-js/modules/es6.array.of.js"() {
    "use strict";
    var $export = require_export();
    var createProperty = require_create_property();
    $export($export.S + $export.F * require_fails()(function() {
      function F() {
      }
      return !(Array.of.call(F) instanceof F);
    }), "Array", {
      // 22.1.2.3 Array.of( ...items)
      of: function of() {
        var index2 = 0;
        var aLen = arguments.length;
        var result = new (typeof this == "function" ? this : Array)(aLen);
        while (aLen > index2) createProperty(result, index2, arguments[index2++]);
        result.length = aLen;
        return result;
      }
    });
  }
});

// node_modules/core-js/modules/_strict-method.js
var require_strict_method = __commonJS({
  "node_modules/core-js/modules/_strict-method.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = function(method, arg) {
      return !!method && fails(function() {
        arg ? method.call(null, function() {
        }, 1) : method.call(null);
      });
    };
  }
});

// node_modules/core-js/modules/es6.array.join.js
var require_es6_array_join = __commonJS({
  "node_modules/core-js/modules/es6.array.join.js"() {
    "use strict";
    var $export = require_export();
    var toIObject = require_to_iobject();
    var arrayJoin = [].join;
    $export($export.P + $export.F * (require_iobject() != Object || !require_strict_method()(arrayJoin)), "Array", {
      join: function join(separator) {
        return arrayJoin.call(toIObject(this), separator === void 0 ? "," : separator);
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.slice.js
var require_es6_array_slice = __commonJS({
  "node_modules/core-js/modules/es6.array.slice.js"() {
    "use strict";
    var $export = require_export();
    var html = require_html();
    var cof = require_cof();
    var toAbsoluteIndex = require_to_absolute_index();
    var toLength = require_to_length();
    var arraySlice = [].slice;
    $export($export.P + $export.F * require_fails()(function() {
      if (html) arraySlice.call(html);
    }), "Array", {
      slice: function slice(begin, end) {
        var len = toLength(this.length);
        var klass = cof(this);
        end = end === void 0 ? len : end;
        if (klass == "Array") return arraySlice.call(this, begin, end);
        var start = toAbsoluteIndex(begin, len);
        var upTo = toAbsoluteIndex(end, len);
        var size = toLength(upTo - start);
        var cloned = new Array(size);
        var i = 0;
        for (; i < size; i++) cloned[i] = klass == "String" ? this.charAt(start + i) : this[start + i];
        return cloned;
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.sort.js
var require_es6_array_sort = __commonJS({
  "node_modules/core-js/modules/es6.array.sort.js"() {
    "use strict";
    var $export = require_export();
    var aFunction = require_a_function();
    var toObject3 = require_to_object();
    var fails = require_fails();
    var $sort = [].sort;
    var test = [1, 2, 3];
    $export($export.P + $export.F * (fails(function() {
      test.sort(void 0);
    }) || !fails(function() {
      test.sort(null);
    }) || !require_strict_method()($sort)), "Array", {
      // 22.1.3.25 Array.prototype.sort(comparefn)
      sort: function sort2(comparefn) {
        return comparefn === void 0 ? $sort.call(toObject3(this)) : $sort.call(toObject3(this), aFunction(comparefn));
      }
    });
  }
});

// node_modules/core-js/modules/_array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js/modules/_array-species-constructor.js"(exports, module2) {
    var isObject4 = require_is_object();
    var isArray3 = require_is_array();
    var SPECIES = require_wks()("species");
    module2.exports = function(original) {
      var C;
      if (isArray3(original)) {
        C = original.constructor;
        if (typeof C == "function" && (C === Array || isArray3(C.prototype))) C = void 0;
        if (isObject4(C)) {
          C = C[SPECIES];
          if (C === null) C = void 0;
        }
      }
      return C === void 0 ? Array : C;
    };
  }
});

// node_modules/core-js/modules/_array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js/modules/_array-species-create.js"(exports, module2) {
    var speciesConstructor = require_array_species_constructor();
    module2.exports = function(original, length) {
      return new (speciesConstructor(original))(length);
    };
  }
});

// node_modules/core-js/modules/_array-methods.js
var require_array_methods = __commonJS({
  "node_modules/core-js/modules/_array-methods.js"(exports, module2) {
    var ctx = require_ctx();
    var IObject = require_iobject();
    var toObject3 = require_to_object();
    var toLength = require_to_length();
    var asc = require_array_species_create();
    module2.exports = function(TYPE, $create) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      var create = $create || asc;
      return function($this, callbackfn, that) {
        var O = toObject3($this);
        var self2 = IObject(O);
        var f = ctx(callbackfn, that, 3);
        var length = toLength(self2.length);
        var index2 = 0;
        var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
        var val, res;
        for (; length > index2; index2++) if (NO_HOLES || index2 in self2) {
          val = self2[index2];
          res = f(val, index2, O);
          if (TYPE) {
            if (IS_MAP) result[index2] = res;
            else if (res) switch (TYPE) {
              case 3:
                return true;
              case 5:
                return val;
              case 6:
                return index2;
              case 2:
                result.push(val);
            }
            else if (IS_EVERY) return false;
          }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
      };
    };
  }
});

// node_modules/core-js/modules/es6.array.for-each.js
var require_es6_array_for_each = __commonJS({
  "node_modules/core-js/modules/es6.array.for-each.js"() {
    "use strict";
    var $export = require_export();
    var $forEach = require_array_methods()(0);
    var STRICT = require_strict_method()([].forEach, true);
    $export($export.P + $export.F * !STRICT, "Array", {
      // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
      forEach: function forEach(callbackfn) {
        return $forEach(this, callbackfn, arguments[1]);
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.map.js
var require_es6_array_map = __commonJS({
  "node_modules/core-js/modules/es6.array.map.js"() {
    "use strict";
    var $export = require_export();
    var $map = require_array_methods()(1);
    $export($export.P + $export.F * !require_strict_method()([].map, true), "Array", {
      // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
      map: function map3(callbackfn) {
        return $map(this, callbackfn, arguments[1]);
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.filter.js
var require_es6_array_filter = __commonJS({
  "node_modules/core-js/modules/es6.array.filter.js"() {
    "use strict";
    var $export = require_export();
    var $filter = require_array_methods()(2);
    $export($export.P + $export.F * !require_strict_method()([].filter, true), "Array", {
      // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
      filter: function filter(callbackfn) {
        return $filter(this, callbackfn, arguments[1]);
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.some.js
var require_es6_array_some = __commonJS({
  "node_modules/core-js/modules/es6.array.some.js"() {
    "use strict";
    var $export = require_export();
    var $some = require_array_methods()(3);
    $export($export.P + $export.F * !require_strict_method()([].some, true), "Array", {
      // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
      some: function some3(callbackfn) {
        return $some(this, callbackfn, arguments[1]);
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.every.js
var require_es6_array_every = __commonJS({
  "node_modules/core-js/modules/es6.array.every.js"() {
    "use strict";
    var $export = require_export();
    var $every = require_array_methods()(4);
    $export($export.P + $export.F * !require_strict_method()([].every, true), "Array", {
      // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
      every: function every(callbackfn) {
        return $every(this, callbackfn, arguments[1]);
      }
    });
  }
});

// node_modules/core-js/modules/_array-reduce.js
var require_array_reduce = __commonJS({
  "node_modules/core-js/modules/_array-reduce.js"(exports, module2) {
    var aFunction = require_a_function();
    var toObject3 = require_to_object();
    var IObject = require_iobject();
    var toLength = require_to_length();
    module2.exports = function(that, callbackfn, aLen, memo, isRight) {
      aFunction(callbackfn);
      var O = toObject3(that);
      var self2 = IObject(O);
      var length = toLength(O.length);
      var index2 = isRight ? length - 1 : 0;
      var i = isRight ? -1 : 1;
      if (aLen < 2) for (; ; ) {
        if (index2 in self2) {
          memo = self2[index2];
          index2 += i;
          break;
        }
        index2 += i;
        if (isRight ? index2 < 0 : length <= index2) {
          throw TypeError("Reduce of empty array with no initial value");
        }
      }
      for (; isRight ? index2 >= 0 : length > index2; index2 += i) if (index2 in self2) {
        memo = callbackfn(memo, self2[index2], index2, O);
      }
      return memo;
    };
  }
});

// node_modules/core-js/modules/es6.array.reduce.js
var require_es6_array_reduce = __commonJS({
  "node_modules/core-js/modules/es6.array.reduce.js"() {
    "use strict";
    var $export = require_export();
    var $reduce = require_array_reduce();
    $export($export.P + $export.F * !require_strict_method()([].reduce, true), "Array", {
      // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
      reduce: function reduce(callbackfn) {
        return $reduce(this, callbackfn, arguments.length, arguments[1], false);
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.reduce-right.js
var require_es6_array_reduce_right = __commonJS({
  "node_modules/core-js/modules/es6.array.reduce-right.js"() {
    "use strict";
    var $export = require_export();
    var $reduce = require_array_reduce();
    $export($export.P + $export.F * !require_strict_method()([].reduceRight, true), "Array", {
      // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
      reduceRight: function reduceRight(callbackfn) {
        return $reduce(this, callbackfn, arguments.length, arguments[1], true);
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.index-of.js
var require_es6_array_index_of = __commonJS({
  "node_modules/core-js/modules/es6.array.index-of.js"() {
    "use strict";
    var $export = require_export();
    var $indexOf = require_array_includes()(false);
    var $native = [].indexOf;
    var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
    $export($export.P + $export.F * (NEGATIVE_ZERO || !require_strict_method()($native)), "Array", {
      // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
      indexOf: function indexOf3(searchElement) {
        return NEGATIVE_ZERO ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
      }
    });
  }
});

// node_modules/core-js/modules/es6.array.last-index-of.js
var require_es6_array_last_index_of = __commonJS({
  "node_modules/core-js/modules/es6.array.last-index-of.js"() {
    "use strict";
    var $export = require_export();
    var toIObject = require_to_iobject();
    var toInteger = require_to_integer();
    var toLength = require_to_length();
    var $native = [].lastIndexOf;
    var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
    $export($export.P + $export.F * (NEGATIVE_ZERO || !require_strict_method()($native)), "Array", {
      // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
      lastIndexOf: function lastIndexOf(searchElement) {
        if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
        var O = toIObject(this);
        var length = toLength(O.length);
        var index2 = length - 1;
        if (arguments.length > 1) index2 = Math.min(index2, toInteger(arguments[1]));
        if (index2 < 0) index2 = length + index2;
        for (; index2 >= 0; index2--) if (index2 in O) {
          if (O[index2] === searchElement) return index2 || 0;
        }
        return -1;
      }
    });
  }
});

// node_modules/core-js/modules/_array-copy-within.js
var require_array_copy_within = __commonJS({
  "node_modules/core-js/modules/_array-copy-within.js"(exports, module2) {
    "use strict";
    var toObject3 = require_to_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var toLength = require_to_length();
    module2.exports = [].copyWithin || function copyWithin(target, start) {
      var O = toObject3(this);
      var len = toLength(O.length);
      var to3 = toAbsoluteIndex(target, len);
      var from3 = toAbsoluteIndex(start, len);
      var end = arguments.length > 2 ? arguments[2] : void 0;
      var count = Math.min((end === void 0 ? len : toAbsoluteIndex(end, len)) - from3, len - to3);
      var inc = 1;
      if (from3 < to3 && to3 < from3 + count) {
        inc = -1;
        from3 += count - 1;
        to3 += count - 1;
      }
      while (count-- > 0) {
        if (from3 in O) O[to3] = O[from3];
        else delete O[to3];
        to3 += inc;
        from3 += inc;
      }
      return O;
    };
  }
});

// node_modules/core-js/modules/_add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/modules/_add-to-unscopables.js"(exports, module2) {
    var UNSCOPABLES = require_wks()("unscopables");
    var ArrayProto = Array.prototype;
    if (ArrayProto[UNSCOPABLES] == void 0) require_hide()(ArrayProto, UNSCOPABLES, {});
    module2.exports = function(key) {
      ArrayProto[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/core-js/modules/es6.array.copy-within.js
var require_es6_array_copy_within = __commonJS({
  "node_modules/core-js/modules/es6.array.copy-within.js"() {
    var $export = require_export();
    $export($export.P, "Array", { copyWithin: require_array_copy_within() });
    require_add_to_unscopables()("copyWithin");
  }
});

// node_modules/core-js/modules/_array-fill.js
var require_array_fill = __commonJS({
  "node_modules/core-js/modules/_array-fill.js"(exports, module2) {
    "use strict";
    var toObject3 = require_to_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var toLength = require_to_length();
    module2.exports = function fill(value) {
      var O = toObject3(this);
      var length = toLength(O.length);
      var aLen = arguments.length;
      var index2 = toAbsoluteIndex(aLen > 1 ? arguments[1] : void 0, length);
      var end = aLen > 2 ? arguments[2] : void 0;
      var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
      while (endPos > index2) O[index2++] = value;
      return O;
    };
  }
});

// node_modules/core-js/modules/es6.array.fill.js
var require_es6_array_fill = __commonJS({
  "node_modules/core-js/modules/es6.array.fill.js"() {
    var $export = require_export();
    $export($export.P, "Array", { fill: require_array_fill() });
    require_add_to_unscopables()("fill");
  }
});

// node_modules/core-js/modules/es6.array.find.js
var require_es6_array_find = __commonJS({
  "node_modules/core-js/modules/es6.array.find.js"() {
    "use strict";
    var $export = require_export();
    var $find = require_array_methods()(5);
    var KEY13 = "find";
    var forced = true;
    if (KEY13 in []) Array(1)[KEY13](function() {
      forced = false;
    });
    $export($export.P + $export.F * forced, "Array", {
      find: function find(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    require_add_to_unscopables()(KEY13);
  }
});

// node_modules/core-js/modules/es6.array.find-index.js
var require_es6_array_find_index = __commonJS({
  "node_modules/core-js/modules/es6.array.find-index.js"() {
    "use strict";
    var $export = require_export();
    var $find = require_array_methods()(6);
    var KEY13 = "findIndex";
    var forced = true;
    if (KEY13 in []) Array(1)[KEY13](function() {
      forced = false;
    });
    $export($export.P + $export.F * forced, "Array", {
      findIndex: function findIndex(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    require_add_to_unscopables()(KEY13);
  }
});

// node_modules/core-js/modules/_set-species.js
var require_set_species = __commonJS({
  "node_modules/core-js/modules/_set-species.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var dP = require_object_dp();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = require_wks()("species");
    module2.exports = function(KEY13) {
      var C = global2[KEY13];
      if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
    };
  }
});

// node_modules/core-js/modules/es6.array.species.js
var require_es6_array_species = __commonJS({
  "node_modules/core-js/modules/es6.array.species.js"() {
    require_set_species()("Array");
  }
});

// node_modules/core-js/modules/_iter-step.js
var require_iter_step = __commonJS({
  "node_modules/core-js/modules/_iter-step.js"(exports, module2) {
    module2.exports = function(done, value) {
      return { value, done: !!done };
    };
  }
});

// node_modules/core-js/modules/es6.array.iterator.js
var require_es6_array_iterator = __commonJS({
  "node_modules/core-js/modules/es6.array.iterator.js"(exports, module2) {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    var step = require_iter_step();
    var Iterators = require_iterators();
    var toIObject = require_to_iobject();
    module2.exports = require_iter_define()(Array, "Array", function(iterated, kind) {
      this._t = toIObject(iterated);
      this._i = 0;
      this._k = kind;
    }, function() {
      var O = this._t;
      var kind = this._k;
      var index2 = this._i++;
      if (!O || index2 >= O.length) {
        this._t = void 0;
        return step(1);
      }
      if (kind == "keys") return step(0, index2);
      if (kind == "values") return step(0, O[index2]);
      return step(0, [index2, O[index2]]);
    }, "values");
    Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
  }
});

// node_modules/core-js/modules/_flags.js
var require_flags = __commonJS({
  "node_modules/core-js/modules/_flags.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    module2.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.global) result += "g";
      if (that.ignoreCase) result += "i";
      if (that.multiline) result += "m";
      if (that.unicode) result += "u";
      if (that.sticky) result += "y";
      return result;
    };
  }
});

// node_modules/core-js/modules/es6.regexp.constructor.js
var require_es6_regexp_constructor = __commonJS({
  "node_modules/core-js/modules/es6.regexp.constructor.js"() {
    var global2 = require_global();
    var inheritIfRequired = require_inherit_if_required();
    var dP = require_object_dp().f;
    var gOPN = require_object_gopn().f;
    var isRegExp2 = require_is_regexp();
    var $flags = require_flags();
    var $RegExp = global2.RegExp;
    var Base = $RegExp;
    var proto5 = $RegExp.prototype;
    var re1 = /a/g;
    var re2 = /a/g;
    var CORRECT_NEW = new $RegExp(re1) !== re1;
    if (require_descriptors() && (!CORRECT_NEW || require_fails()(function() {
      re2[require_wks()("match")] = false;
      return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, "i") != "/a/i";
    }))) {
      $RegExp = function RegExp2(p, f) {
        var tiRE = this instanceof $RegExp;
        var piRE = isRegExp2(p);
        var fiU = f === void 0;
        return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(
          CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f),
          tiRE ? this : proto5,
          $RegExp
        );
      };
      proxy = function(key) {
        key in $RegExp || dP($RegExp, key, {
          configurable: true,
          get: function() {
            return Base[key];
          },
          set: function(it) {
            Base[key] = it;
          }
        });
      };
      for (keys3 = gOPN(Base), i = 0; keys3.length > i; ) proxy(keys3[i++]);
      proto5.constructor = $RegExp;
      $RegExp.prototype = proto5;
      require_redefine()(global2, "RegExp", $RegExp);
    }
    var proxy;
    var keys3;
    var i;
    require_set_species()("RegExp");
  }
});

// node_modules/core-js/modules/_regexp-exec.js
var require_regexp_exec = __commonJS({
  "node_modules/core-js/modules/_regexp-exec.js"(exports, module2) {
    "use strict";
    var regexpFlags = require_flags();
    var nativeExec = RegExp.prototype.exec;
    var nativeReplace = String.prototype.replace;
    var patchedExec = nativeExec;
    var LAST_INDEX = "lastIndex";
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/, re2 = /b*/g;
      nativeExec.call(re1, "a");
      nativeExec.call(re2, "a");
      return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
    }();
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;
    if (PATCH) {
      patchedExec = function exec(str) {
        var re = this;
        var lastIndex, reCopy, match, i;
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + re.source + "$(?!\\s)", regexpFlags.call(re));
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
        match = nativeExec.call(re, str);
        if (UPDATES_LAST_INDEX_WRONG && match) {
          re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          nativeReplace.call(match[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === void 0) match[i] = void 0;
            }
          });
        }
        return match;
      };
    }
    module2.exports = patchedExec;
  }
});

// node_modules/core-js/modules/es6.regexp.exec.js
var require_es6_regexp_exec = __commonJS({
  "node_modules/core-js/modules/es6.regexp.exec.js"() {
    "use strict";
    var regexpExec = require_regexp_exec();
    require_export()({
      target: "RegExp",
      proto: true,
      forced: regexpExec !== /./.exec
    }, {
      exec: regexpExec
    });
  }
});

// node_modules/core-js/modules/es6.regexp.flags.js
var require_es6_regexp_flags = __commonJS({
  "node_modules/core-js/modules/es6.regexp.flags.js"() {
    if (require_descriptors() && /./g.flags != "g") require_object_dp().f(RegExp.prototype, "flags", {
      configurable: true,
      get: require_flags()
    });
  }
});

// node_modules/core-js/modules/es6.regexp.to-string.js
var require_es6_regexp_to_string = __commonJS({
  "node_modules/core-js/modules/es6.regexp.to-string.js"() {
    "use strict";
    require_es6_regexp_flags();
    var anObject = require_an_object();
    var $flags = require_flags();
    var DESCRIPTORS = require_descriptors();
    var TO_STRING = "toString";
    var $toString = /./[TO_STRING];
    var define2 = function(fn) {
      require_redefine()(RegExp.prototype, TO_STRING, fn, true);
    };
    if (require_fails()(function() {
      return $toString.call({ source: "a", flags: "b" }) != "/a/b";
    })) {
      define2(function toString3() {
        var R = anObject(this);
        return "/".concat(
          R.source,
          "/",
          "flags" in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : void 0
        );
      });
    } else if ($toString.name != TO_STRING) {
      define2(function toString3() {
        return $toString.call(this);
      });
    }
  }
});

// node_modules/core-js/modules/_advance-string-index.js
var require_advance_string_index = __commonJS({
  "node_modules/core-js/modules/_advance-string-index.js"(exports, module2) {
    "use strict";
    var at = require_string_at()(true);
    module2.exports = function(S, index2, unicode) {
      return index2 + (unicode ? at(S, index2).length : 1);
    };
  }
});

// node_modules/core-js/modules/_regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "node_modules/core-js/modules/_regexp-exec-abstract.js"(exports, module2) {
    "use strict";
    var classof = require_classof();
    var builtinExec = RegExp.prototype.exec;
    module2.exports = function(R, S) {
      var exec = R.exec;
      if (typeof exec === "function") {
        var result = exec.call(R, S);
        if (typeof result !== "object") {
          throw new TypeError("RegExp exec method returned something other than an Object or null");
        }
        return result;
      }
      if (classof(R) !== "RegExp") {
        throw new TypeError("RegExp#exec called on incompatible receiver");
      }
      return builtinExec.call(R, S);
    };
  }
});

// node_modules/core-js/modules/_fix-re-wks.js
var require_fix_re_wks = __commonJS({
  "node_modules/core-js/modules/_fix-re-wks.js"(exports, module2) {
    "use strict";
    require_es6_regexp_exec();
    var redefine = require_redefine();
    var hide = require_hide();
    var fails = require_fails();
    var defined = require_defined();
    var wks = require_wks();
    var regexpExec = require_regexp_exec();
    var SPECIES = wks("species");
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length === 2 && result[0] === "a" && result[1] === "b";
    }();
    module2.exports = function(KEY13, length, exec) {
      var SYMBOL = wks(KEY13);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY13](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function() {
        var execCalled = false;
        var re = /a/;
        re.exec = function() {
          execCalled = true;
          return null;
        };
        if (KEY13 === "split") {
          re.constructor = {};
          re.constructor[SPECIES] = function() {
            return re;
          };
        }
        re[SYMBOL]("");
        return !execCalled;
      }) : void 0;
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY13 === "replace" && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY13 === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
        var nativeRegExpMethod = /./[SYMBOL];
        var fns = exec(
          defined,
          SYMBOL,
          ""[KEY13],
          function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
            if (regexp.exec === regexpExec) {
              if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
              }
              return { done: true, value: nativeMethod.call(str, regexp, arg2) };
            }
            return { done: false };
          }
        );
        var strfn = fns[0];
        var rxfn = fns[1];
        redefine(String.prototype, KEY13, strfn);
        hide(
          RegExp.prototype,
          SYMBOL,
          length == 2 ? function(string, arg) {
            return rxfn.call(string, this, arg);
          } : function(string) {
            return rxfn.call(string, this);
          }
        );
      }
    };
  }
});

// node_modules/core-js/modules/es6.regexp.match.js
var require_es6_regexp_match = __commonJS({
  "node_modules/core-js/modules/es6.regexp.match.js"() {
    "use strict";
    var anObject = require_an_object();
    var toLength = require_to_length();
    var advanceStringIndex = require_advance_string_index();
    var regExpExec = require_regexp_exec_abstract();
    require_fix_re_wks()("match", 1, function(defined, MATCH, $match, maybeCallNative) {
      return [
        // `String.prototype.match` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.match
        function match(regexp) {
          var O = defined(this);
          var fn = regexp == void 0 ? void 0 : regexp[MATCH];
          return fn !== void 0 ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
        function(regexp) {
          var res = maybeCallNative($match, regexp, this);
          if (res.done) return res.value;
          var rx = anObject(regexp);
          var S = String(this);
          if (!rx.global) return regExpExec(rx, S);
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
          var A = [];
          var n = 0;
          var result;
          while ((result = regExpExec(rx, S)) !== null) {
            var matchStr = String(result[0]);
            A[n] = matchStr;
            if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            n++;
          }
          return n === 0 ? null : A;
        }
      ];
    });
  }
});

// node_modules/core-js/modules/es6.regexp.replace.js
var require_es6_regexp_replace = __commonJS({
  "node_modules/core-js/modules/es6.regexp.replace.js"() {
    "use strict";
    var anObject = require_an_object();
    var toObject3 = require_to_object();
    var toLength = require_to_length();
    var toInteger = require_to_integer();
    var advanceStringIndex = require_advance_string_index();
    var regExpExec = require_regexp_exec_abstract();
    var max3 = Math.max;
    var min3 = Math.min;
    var floor = Math.floor;
    var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;
    var maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    require_fix_re_wks()("replace", 2, function(defined, REPLACE, $replace, maybeCallNative) {
      return [
        // `String.prototype.replace` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
          var O = defined(this);
          var fn = searchValue == void 0 ? void 0 : searchValue[REPLACE];
          return fn !== void 0 ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
        function(regexp, replaceValue) {
          var res = maybeCallNative($replace, regexp, this, replaceValue);
          if (res.done) return res.value;
          var rx = anObject(regexp);
          var S = String(this);
          var functionalReplace = typeof replaceValue === "function";
          if (!functionalReplace) replaceValue = String(replaceValue);
          var global2 = rx.global;
          if (global2) {
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
          }
          var results = [];
          while (true) {
            var result = regExpExec(rx, S);
            if (result === null) break;
            results.push(result);
            if (!global2) break;
            var matchStr = String(result[0]);
            if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i = 0; i < results.length; i++) {
            result = results[i];
            var matched = String(result[0]);
            var position = max3(min3(toInteger(result.index), S.length), 0);
            var captures = [];
            for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = [matched].concat(captures, position, S);
              if (namedCaptures !== void 0) replacerArgs.push(namedCaptures);
              var replacement = String(replaceValue.apply(void 0, replacerArgs));
            } else {
              replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + S.slice(nextSourcePosition);
        }
      ];
      function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
        var tailPos = position + matched.length;
        var m = captures.length;
        var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
        if (namedCaptures !== void 0) {
          namedCaptures = toObject3(namedCaptures);
          symbols = SUBSTITUTION_SYMBOLS;
        }
        return $replace.call(replacement, symbols, function(match, ch) {
          var capture;
          switch (ch.charAt(0)) {
            case "$":
              return "$";
            case "&":
              return matched;
            case "`":
              return str.slice(0, position);
            case "'":
              return str.slice(tailPos);
            case "<":
              capture = namedCaptures[ch.slice(1, -1)];
              break;
            default:
              var n = +ch;
              if (n === 0) return match;
              if (n > m) {
                var f = floor(n / 10);
                if (f === 0) return match;
                if (f <= m) return captures[f - 1] === void 0 ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                return match;
              }
              capture = captures[n - 1];
          }
          return capture === void 0 ? "" : capture;
        });
      }
    });
  }
});

// node_modules/core-js/modules/es6.regexp.search.js
var require_es6_regexp_search = __commonJS({
  "node_modules/core-js/modules/es6.regexp.search.js"() {
    "use strict";
    var anObject = require_an_object();
    var sameValue = require_same_value();
    var regExpExec = require_regexp_exec_abstract();
    require_fix_re_wks()("search", 1, function(defined, SEARCH, $search, maybeCallNative) {
      return [
        // `String.prototype.search` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.search
        function search(regexp) {
          var O = defined(this);
          var fn = regexp == void 0 ? void 0 : regexp[SEARCH];
          return fn !== void 0 ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
        },
        // `RegExp.prototype[@@search]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
        function(regexp) {
          var res = maybeCallNative($search, regexp, this);
          if (res.done) return res.value;
          var rx = anObject(regexp);
          var S = String(this);
          var previousLastIndex = rx.lastIndex;
          if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
          var result = regExpExec(rx, S);
          if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
          return result === null ? -1 : result.index;
        }
      ];
    });
  }
});

// node_modules/core-js/modules/_species-constructor.js
var require_species_constructor = __commonJS({
  "node_modules/core-js/modules/_species-constructor.js"(exports, module2) {
    var anObject = require_an_object();
    var aFunction = require_a_function();
    var SPECIES = require_wks()("species");
    module2.exports = function(O, D) {
      var C = anObject(O).constructor;
      var S;
      return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? D : aFunction(S);
    };
  }
});

// node_modules/core-js/modules/es6.regexp.split.js
var require_es6_regexp_split = __commonJS({
  "node_modules/core-js/modules/es6.regexp.split.js"() {
    "use strict";
    var isRegExp2 = require_is_regexp();
    var anObject = require_an_object();
    var speciesConstructor = require_species_constructor();
    var advanceStringIndex = require_advance_string_index();
    var toLength = require_to_length();
    var callRegExpExec = require_regexp_exec_abstract();
    var regexpExec = require_regexp_exec();
    var fails = require_fails();
    var $min = Math.min;
    var $push = [].push;
    var $SPLIT = "split";
    var LENGTH = "length";
    var LAST_INDEX = "lastIndex";
    var MAX_UINT32 = 4294967295;
    var SUPPORTS_Y = !fails(function() {
      RegExp(MAX_UINT32, "y");
    });
    require_fix_re_wks()("split", 2, function(defined, SPLIT, $split, maybeCallNative) {
      var internalSplit;
      if ("abbc"[$SPLIT](/(b)*/)[1] == "c" || "test"[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || "ab"[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || "."[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || "."[$SPLIT](/()()/)[LENGTH] > 1 || ""[$SPLIT](/.?/)[LENGTH]) {
        internalSplit = function(separator, limit) {
          var string = String(this);
          if (separator === void 0 && limit === 0) return [];
          if (!isRegExp2(separator)) return $split.call(string, separator, limit);
          var output = [];
          var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
          var lastLastIndex = 0;
          var splitLimit = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          var separatorCopy = new RegExp(separator.source, flags + "g");
          var match, lastIndex, lastLength;
          while (match = regexpExec.call(separatorCopy, string)) {
            lastIndex = separatorCopy[LAST_INDEX];
            if (lastIndex > lastLastIndex) {
              output.push(string.slice(lastLastIndex, match.index));
              if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
              lastLength = match[0][LENGTH];
              lastLastIndex = lastIndex;
              if (output[LENGTH] >= splitLimit) break;
            }
            if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++;
          }
          if (lastLastIndex === string[LENGTH]) {
            if (lastLength || !separatorCopy.test("")) output.push("");
          } else output.push(string.slice(lastLastIndex));
          return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
        };
      } else if ("0"[$SPLIT](void 0, 0)[LENGTH]) {
        internalSplit = function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : $split.call(this, separator, limit);
        };
      } else {
        internalSplit = $split;
      }
      return [
        // `String.prototype.split` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.split
        function split(separator, limit) {
          var O = defined(this);
          var splitter = separator == void 0 ? void 0 : separator[SPLIT];
          return splitter !== void 0 ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(regexp, limit) {
          var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
          if (res.done) return res.value;
          var rx = anObject(regexp);
          var S = String(this);
          var C = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (SUPPORTS_Y ? "y" : "g");
          var splitter = new C(SUPPORTS_Y ? rx : "^(?:" + rx.source + ")", flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0) return [];
          if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
          var p = 0;
          var q = 0;
          var A = [];
          while (q < S.length) {
            splitter.lastIndex = SUPPORTS_Y ? q : 0;
            var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
            var e;
            if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
              q = advanceStringIndex(S, q, unicodeMatching);
            } else {
              A.push(S.slice(p, q));
              if (A.length === lim) return A;
              for (var i = 1; i <= z.length - 1; i++) {
                A.push(z[i]);
                if (A.length === lim) return A;
              }
              q = p = e;
            }
          }
          A.push(S.slice(p));
          return A;
        }
      ];
    });
  }
});

// node_modules/core-js/modules/_an-instance.js
var require_an_instance = __commonJS({
  "node_modules/core-js/modules/_an-instance.js"(exports, module2) {
    module2.exports = function(it, Constructor, name, forbiddenField) {
      if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
        throw TypeError(name + ": incorrect invocation!");
      }
      return it;
    };
  }
});

// node_modules/core-js/modules/_for-of.js
var require_for_of = __commonJS({
  "node_modules/core-js/modules/_for-of.js"(exports, module2) {
    var ctx = require_ctx();
    var call = require_iter_call();
    var isArrayIter = require_is_array_iter();
    var anObject = require_an_object();
    var toLength = require_to_length();
    var getIterFn = require_core_get_iterator_method();
    var BREAK = {};
    var RETURN = {};
    var exports = module2.exports = function(iterable, entries, fn, that, ITERATOR) {
      var iterFn = ITERATOR ? function() {
        return iterable;
      } : getIterFn(iterable);
      var f = ctx(fn, that, entries ? 2 : 1);
      var index2 = 0;
      var length, step, iterator, result;
      if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
      if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index2; index2++) {
        result = entries ? f(anObject(step = iterable[index2])[0], step[1]) : f(iterable[index2]);
        if (result === BREAK || result === RETURN) return result;
      }
      else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        result = call(iterator, f, step.value, entries);
        if (result === BREAK || result === RETURN) return result;
      }
    };
    exports.BREAK = BREAK;
    exports.RETURN = RETURN;
  }
});

// node_modules/core-js/modules/_task.js
var require_task = __commonJS({
  "node_modules/core-js/modules/_task.js"(exports, module2) {
    var ctx = require_ctx();
    var invoke = require_invoke();
    var html = require_html();
    var cel = require_dom_create();
    var global2 = require_global();
    var process2 = global2.process;
    var setTask = global2.setImmediate;
    var clearTask = global2.clearImmediate;
    var MessageChannel = global2.MessageChannel;
    var Dispatch = global2.Dispatch;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var defer;
    var channel;
    var port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listener = function(event2) {
      run.call(event2.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate2(fn) {
        var args = [];
        var i = 1;
        while (arguments.length > i) args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == "function" ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate2(id) {
        delete queue[id];
      };
      if (require_cof()(process2) == "process") {
        defer = function(id) {
          process2.nextTick(ctx(run, id, 1));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = ctx(port.postMessage, port, 1);
      } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts) {
        defer = function(id) {
          global2.postMessage(id + "", "*");
        };
        global2.addEventListener("message", listener, false);
      } else if (ONREADYSTATECHANGE in cel("script")) {
        defer = function(id) {
          html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module2.exports = {
      set: setTask,
      clear: clearTask
    };
  }
});

// node_modules/core-js/modules/_microtask.js
var require_microtask = __commonJS({
  "node_modules/core-js/modules/_microtask.js"(exports, module2) {
    var global2 = require_global();
    var macrotask = require_task().set;
    var Observer = global2.MutationObserver || global2.WebKitMutationObserver;
    var process2 = global2.process;
    var Promise2 = global2.Promise;
    var isNode = require_cof()(process2) == "process";
    module2.exports = function() {
      var head, last, notify;
      var flush = function() {
        var parent, fn;
        if (isNode && (parent = process2.domain)) parent.exit();
        while (head) {
          fn = head.fn;
          head = head.next;
          try {
            fn();
          } catch (e) {
            if (head) notify();
            else last = void 0;
            throw e;
          }
        }
        last = void 0;
        if (parent) parent.enter();
      };
      if (isNode) {
        notify = function() {
          process2.nextTick(flush);
        };
      } else if (Observer && !(global2.navigator && global2.navigator.standalone)) {
        var toggle = true;
        var node = document.createTextNode("");
        new Observer(flush).observe(node, { characterData: true });
        notify = function() {
          node.data = toggle = !toggle;
        };
      } else if (Promise2 && Promise2.resolve) {
        var promise = Promise2.resolve(void 0);
        notify = function() {
          promise.then(flush);
        };
      } else {
        notify = function() {
          macrotask.call(global2, flush);
        };
      }
      return function(fn) {
        var task = { fn, next: void 0 };
        if (last) last.next = task;
        if (!head) {
          head = task;
          notify();
        }
        last = task;
      };
    };
  }
});

// node_modules/core-js/modules/_new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "node_modules/core-js/modules/_new-promise-capability.js"(exports, module2) {
    "use strict";
    var aFunction = require_a_function();
    function PromiseCapability(C) {
      var resolve, reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve);
      this.reject = aFunction(reject);
    }
    module2.exports.f = function(C) {
      return new PromiseCapability(C);
    };
  }
});

// node_modules/core-js/modules/_perform.js
var require_perform = __commonJS({
  "node_modules/core-js/modules/_perform.js"(exports, module2) {
    module2.exports = function(exec) {
      try {
        return { e: false, v: exec() };
      } catch (e) {
        return { e: true, v: e };
      }
    };
  }
});

// node_modules/core-js/modules/_user-agent.js
var require_user_agent = __commonJS({
  "node_modules/core-js/modules/_user-agent.js"(exports, module2) {
    var global2 = require_global();
    var navigator2 = global2.navigator;
    module2.exports = navigator2 && navigator2.userAgent || "";
  }
});

// node_modules/core-js/modules/_promise-resolve.js
var require_promise_resolve = __commonJS({
  "node_modules/core-js/modules/_promise-resolve.js"(exports, module2) {
    var anObject = require_an_object();
    var isObject4 = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module2.exports = function(C, x) {
      anObject(C);
      if (isObject4(x) && x.constructor === C) return x;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };
  }
});

// node_modules/core-js/modules/_redefine-all.js
var require_redefine_all = __commonJS({
  "node_modules/core-js/modules/_redefine-all.js"(exports, module2) {
    var redefine = require_redefine();
    module2.exports = function(target, src, safe) {
      for (var key in src) redefine(target, key, src[key], safe);
      return target;
    };
  }
});

// node_modules/core-js/modules/es6.promise.js
var require_es6_promise = __commonJS({
  "node_modules/core-js/modules/es6.promise.js"() {
    "use strict";
    var LIBRARY = require_library();
    var global2 = require_global();
    var ctx = require_ctx();
    var classof = require_classof();
    var $export = require_export();
    var isObject4 = require_is_object();
    var aFunction = require_a_function();
    var anInstance = require_an_instance();
    var forOf = require_for_of();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask()();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var userAgent = require_user_agent();
    var promiseResolve = require_promise_resolve();
    var PROMISE = "Promise";
    var TypeError2 = global2.TypeError;
    var process2 = global2.process;
    var versions = process2 && process2.versions;
    var v8 = versions && versions.v8 || "";
    var $Promise = global2[PROMISE];
    var isNode = classof(process2) == "process";
    var empty2 = function() {
    };
    var Internal;
    var newGenericPromiseCapability;
    var OwnPromiseCapability;
    var Wrapper;
    var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
    var USE_NATIVE = !!function() {
      try {
        var promise = $Promise.resolve(1);
        var FakePromise = (promise.constructor = {})[require_wks()("species")] = function(exec) {
          exec(empty2, empty2);
        };
        return (isNode || typeof PromiseRejectionEvent == "function") && promise.then(empty2) instanceof FakePromise && v8.indexOf("6.6") !== 0 && userAgent.indexOf("Chrome/66") === -1;
      } catch (e) {
      }
    }();
    var isThenable = function(it) {
      var then;
      return isObject4(it) && typeof (then = it.then) == "function" ? then : false;
    };
    var notify = function(promise, isReject) {
      if (promise._n) return;
      promise._n = true;
      var chain = promise._c;
      microtask(function() {
        var value = promise._v;
        var ok = promise._s == 1;
        var i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail;
          var resolve = reaction.resolve;
          var reject = reaction.reject;
          var domain = reaction.domain;
          var result, then, exited;
          try {
            if (handler) {
              if (!ok) {
                if (promise._h == 2) onHandleUnhandled(promise);
                promise._h = 1;
              }
              if (handler === true) result = value;
              else {
                if (domain) domain.enter();
                result = handler(value);
                if (domain) {
                  domain.exit();
                  exited = true;
                }
              }
              if (result === reaction.promise) {
                reject(TypeError2("Promise-chain cycle"));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else resolve(result);
            } else reject(value);
          } catch (e) {
            if (domain && !exited) domain.exit();
            reject(e);
          }
        };
        while (chain.length > i) run(chain[i++]);
        promise._c = [];
        promise._n = false;
        if (isReject && !promise._h) onUnhandled(promise);
      });
    };
    var onUnhandled = function(promise) {
      task.call(global2, function() {
        var value = promise._v;
        var unhandled = isUnhandled(promise);
        var result, handler, console2;
        if (unhandled) {
          result = perform(function() {
            if (isNode) {
              process2.emit("unhandledRejection", value, promise);
            } else if (handler = global2.onunhandledrejection) {
              handler({ promise, reason: value });
            } else if ((console2 = global2.console) && console2.error) {
              console2.error("Unhandled promise rejection", value);
            }
          });
          promise._h = isNode || isUnhandled(promise) ? 2 : 1;
        }
        promise._a = void 0;
        if (unhandled && result.e) throw result.v;
      });
    };
    var isUnhandled = function(promise) {
      return promise._h !== 1 && (promise._a || promise._c).length === 0;
    };
    var onHandleUnhandled = function(promise) {
      task.call(global2, function() {
        var handler;
        if (isNode) {
          process2.emit("rejectionHandled", promise);
        } else if (handler = global2.onrejectionhandled) {
          handler({ promise, reason: promise._v });
        }
      });
    };
    var $reject = function(value) {
      var promise = this;
      if (promise._d) return;
      promise._d = true;
      promise = promise._w || promise;
      promise._v = value;
      promise._s = 2;
      if (!promise._a) promise._a = promise._c.slice();
      notify(promise, true);
    };
    var $resolve = function(value) {
      var promise = this;
      var then;
      if (promise._d) return;
      promise._d = true;
      promise = promise._w || promise;
      try {
        if (promise === value) throw TypeError2("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          microtask(function() {
            var wrapper = { _w: promise, _d: false };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          promise._v = value;
          promise._s = 1;
          notify(promise, false);
        }
      } catch (e) {
        $reject.call({ _w: promise, _d: false }, e);
      }
    };
    if (!USE_NATIVE) {
      $Promise = function Promise2(executor) {
        anInstance(this, $Promise, PROMISE, "_h");
        aFunction(executor);
        Internal.call(this);
        try {
          executor(ctx($resolve, this, 1), ctx($reject, this, 1));
        } catch (err) {
          $reject.call(this, err);
        }
      };
      Internal = function Promise2(executor) {
        this._c = [];
        this._a = void 0;
        this._s = 0;
        this._d = false;
        this._v = void 0;
        this._h = 0;
        this._n = false;
      };
      Internal.prototype = require_redefine_all()($Promise.prototype, {
        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function then(onFulfilled, onRejected) {
          var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
          reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
          reaction.fail = typeof onRejected == "function" && onRejected;
          reaction.domain = isNode ? process2.domain : void 0;
          this._c.push(reaction);
          if (this._a) this._a.push(reaction);
          if (this._s) notify(this, false);
          return reaction.promise;
        },
        // 25.4.5.1 Promise.prototype.catch(onRejected)
        "catch": function(onRejected) {
          return this.then(void 0, onRejected);
        }
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        this.promise = promise;
        this.resolve = ctx($resolve, promise, 1);
        this.reject = ctx($reject, promise, 1);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
    require_set_to_string_tag()($Promise, PROMISE);
    require_set_species()(PROMISE);
    Wrapper = require_core()[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
      // 25.4.4.5 Promise.reject(r)
      reject: function reject(r) {
        var capability = newPromiseCapability(this);
        var $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }
    });
    $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
      // 25.4.4.6 Promise.resolve(x)
      resolve: function resolve(x) {
        return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
      }
    });
    $export($export.S + $export.F * !(USE_NATIVE && require_iter_detect()(function(iter) {
      $Promise.all(iter)["catch"](empty2);
    })), PROMISE, {
      // 25.4.4.1 Promise.all(iterable)
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var values = [];
          var index2 = 0;
          var remaining = 1;
          forOf(iterable, false, function(promise) {
            var $index = index2++;
            var alreadyCalled = false;
            values.push(void 0);
            remaining++;
            C.resolve(promise).then(function(value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[$index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.e) reject(result.v);
        return capability.promise;
      },
      // 25.4.4.4 Promise.race(iterable)
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject = capability.reject;
        var result = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (result.e) reject(result.v);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/_validate-collection.js
var require_validate_collection = __commonJS({
  "node_modules/core-js/modules/_validate-collection.js"(exports, module2) {
    var isObject4 = require_is_object();
    module2.exports = function(it, TYPE) {
      if (!isObject4(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
      return it;
    };
  }
});

// node_modules/core-js/modules/_collection-strong.js
var require_collection_strong = __commonJS({
  "node_modules/core-js/modules/_collection-strong.js"(exports, module2) {
    "use strict";
    var dP = require_object_dp().f;
    var create = require_object_create();
    var redefineAll = require_redefine_all();
    var ctx = require_ctx();
    var anInstance = require_an_instance();
    var forOf = require_for_of();
    var $iterDefine = require_iter_define();
    var step = require_iter_step();
    var setSpecies = require_set_species();
    var DESCRIPTORS = require_descriptors();
    var fastKey = require_meta().fastKey;
    var validate = require_validate_collection();
    var SIZE = DESCRIPTORS ? "_s" : "size";
    var getEntry = function(that, key) {
      var index2 = fastKey(key);
      var entry;
      if (index2 !== "F") return that._i[index2];
      for (entry = that._f; entry; entry = entry.n) {
        if (entry.k == key) return entry;
      }
    };
    module2.exports = {
      getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
          anInstance(that, C, NAME, "_i");
          that._t = NAME;
          that._i = create(null);
          that._f = void 0;
          that._l = void 0;
          that[SIZE] = 0;
          if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
        });
        redefineAll(C.prototype, {
          // 23.1.3.1 Map.prototype.clear()
          // 23.2.3.2 Set.prototype.clear()
          clear: function clear() {
            for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
              entry.r = true;
              if (entry.p) entry.p = entry.p.n = void 0;
              delete data[entry.i];
            }
            that._f = that._l = void 0;
            that[SIZE] = 0;
          },
          // 23.1.3.3 Map.prototype.delete(key)
          // 23.2.3.4 Set.prototype.delete(value)
          "delete": function(key) {
            var that = validate(this, NAME);
            var entry = getEntry(that, key);
            if (entry) {
              var next = entry.n;
              var prev = entry.p;
              delete that._i[entry.i];
              entry.r = true;
              if (prev) prev.n = next;
              if (next) next.p = prev;
              if (that._f == entry) that._f = next;
              if (that._l == entry) that._l = prev;
              that[SIZE]--;
            }
            return !!entry;
          },
          // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
          // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
          forEach: function forEach(callbackfn) {
            validate(this, NAME);
            var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
            var entry;
            while (entry = entry ? entry.n : this._f) {
              f(entry.v, entry.k, this);
              while (entry && entry.r) entry = entry.p;
            }
          },
          // 23.1.3.7 Map.prototype.has(key)
          // 23.2.3.7 Set.prototype.has(value)
          has: function has(key) {
            return !!getEntry(validate(this, NAME), key);
          }
        });
        if (DESCRIPTORS) dP(C.prototype, "size", {
          get: function() {
            return validate(this, NAME)[SIZE];
          }
        });
        return C;
      },
      def: function(that, key, value) {
        var entry = getEntry(that, key);
        var prev, index2;
        if (entry) {
          entry.v = value;
        } else {
          that._l = entry = {
            i: index2 = fastKey(key, true),
            // <- index
            k: key,
            // <- key
            v: value,
            // <- value
            p: prev = that._l,
            // <- previous entry
            n: void 0,
            // <- next entry
            r: false
            // <- removed
          };
          if (!that._f) that._f = entry;
          if (prev) prev.n = entry;
          that[SIZE]++;
          if (index2 !== "F") that._i[index2] = entry;
        }
        return that;
      },
      getEntry,
      setStrong: function(C, NAME, IS_MAP) {
        $iterDefine(C, NAME, function(iterated, kind) {
          this._t = validate(iterated, NAME);
          this._k = kind;
          this._l = void 0;
        }, function() {
          var that = this;
          var kind = that._k;
          var entry = that._l;
          while (entry && entry.r) entry = entry.p;
          if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
            that._t = void 0;
            return step(1);
          }
          if (kind == "keys") return step(0, entry.k);
          if (kind == "values") return step(0, entry.v);
          return step(0, [entry.k, entry.v]);
        }, IS_MAP ? "entries" : "values", !IS_MAP, true);
        setSpecies(NAME);
      }
    };
  }
});

// node_modules/core-js/modules/_collection.js
var require_collection = __commonJS({
  "node_modules/core-js/modules/_collection.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var $export = require_export();
    var redefine = require_redefine();
    var redefineAll = require_redefine_all();
    var meta = require_meta();
    var forOf = require_for_of();
    var anInstance = require_an_instance();
    var isObject4 = require_is_object();
    var fails = require_fails();
    var $iterDetect = require_iter_detect();
    var setToStringTag = require_set_to_string_tag();
    var inheritIfRequired = require_inherit_if_required();
    module2.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
      var Base = global2[NAME];
      var C = Base;
      var ADDER = IS_MAP ? "set" : "add";
      var proto5 = C && C.prototype;
      var O = {};
      var fixMethod = function(KEY13) {
        var fn = proto5[KEY13];
        redefine(
          proto5,
          KEY13,
          KEY13 == "delete" ? function(a) {
            return IS_WEAK && !isObject4(a) ? false : fn.call(this, a === 0 ? 0 : a);
          } : KEY13 == "has" ? function has(a) {
            return IS_WEAK && !isObject4(a) ? false : fn.call(this, a === 0 ? 0 : a);
          } : KEY13 == "get" ? function get5(a) {
            return IS_WEAK && !isObject4(a) ? void 0 : fn.call(this, a === 0 ? 0 : a);
          } : KEY13 == "add" ? function add5(a) {
            fn.call(this, a === 0 ? 0 : a);
            return this;
          } : function set5(a, b) {
            fn.call(this, a === 0 ? 0 : a, b);
            return this;
          }
        );
      };
      if (typeof C != "function" || !(IS_WEAK || proto5.forEach && !fails(function() {
        new C().entries().next();
      }))) {
        C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
        redefineAll(C.prototype, methods);
        meta.NEED = true;
      } else {
        var instance = new C();
        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
        var THROWS_ON_PRIMITIVES = fails(function() {
          instance.has(1);
        });
        var ACCEPT_ITERABLES = $iterDetect(function(iter) {
          new C(iter);
        });
        var BUGGY_ZERO = !IS_WEAK && fails(function() {
          var $instance = new C();
          var index2 = 5;
          while (index2--) $instance[ADDER](index2, index2);
          return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
          C = wrapper(function(target, iterable) {
            anInstance(target, C, NAME);
            var that = inheritIfRequired(new Base(), target, C);
            if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
            return that;
          });
          C.prototype = proto5;
          proto5.constructor = C;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
          fixMethod("delete");
          fixMethod("has");
          IS_MAP && fixMethod("get");
        }
        if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
        if (IS_WEAK && proto5.clear) delete proto5.clear;
      }
      setToStringTag(C, NAME);
      O[NAME] = C;
      $export($export.G + $export.W + $export.F * (C != Base), O);
      if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
      return C;
    };
  }
});

// node_modules/core-js/modules/es6.map.js
var require_es6_map = __commonJS({
  "node_modules/core-js/modules/es6.map.js"(exports, module2) {
    "use strict";
    var strong = require_collection_strong();
    var validate = require_validate_collection();
    var MAP = "Map";
    module2.exports = require_collection()(MAP, function(get5) {
      return function Map2() {
        return get5(this, arguments.length > 0 ? arguments[0] : void 0);
      };
    }, {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get5(key) {
        var entry = strong.getEntry(validate(this, MAP), key);
        return entry && entry.v;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set5(key, value) {
        return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
      }
    }, strong, true);
  }
});

// node_modules/core-js/modules/es6.set.js
var require_es6_set = __commonJS({
  "node_modules/core-js/modules/es6.set.js"(exports, module2) {
    "use strict";
    var strong = require_collection_strong();
    var validate = require_validate_collection();
    var SET = "Set";
    module2.exports = require_collection()(SET, function(get5) {
      return function Set2() {
        return get5(this, arguments.length > 0 ? arguments[0] : void 0);
      };
    }, {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add5(value) {
        return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
      }
    }, strong);
  }
});

// node_modules/core-js/modules/_collection-weak.js
var require_collection_weak = __commonJS({
  "node_modules/core-js/modules/_collection-weak.js"(exports, module2) {
    "use strict";
    var redefineAll = require_redefine_all();
    var getWeak = require_meta().getWeak;
    var anObject = require_an_object();
    var isObject4 = require_is_object();
    var anInstance = require_an_instance();
    var forOf = require_for_of();
    var createArrayMethod = require_array_methods();
    var $has = require_has();
    var validate = require_validate_collection();
    var arrayFind = createArrayMethod(5);
    var arrayFindIndex = createArrayMethod(6);
    var id = 0;
    var uncaughtFrozenStore = function(that) {
      return that._l || (that._l = new UncaughtFrozenStore());
    };
    var UncaughtFrozenStore = function() {
      this.a = [];
    };
    var findUncaughtFrozen = function(store, key) {
      return arrayFind(store.a, function(it) {
        return it[0] === key;
      });
    };
    UncaughtFrozenStore.prototype = {
      get: function(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) return entry[1];
      },
      has: function(key) {
        return !!findUncaughtFrozen(this, key);
      },
      set: function(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) entry[1] = value;
        else this.a.push([key, value]);
      },
      "delete": function(key) {
        var index2 = arrayFindIndex(this.a, function(it) {
          return it[0] === key;
        });
        if (~index2) this.a.splice(index2, 1);
        return !!~index2;
      }
    };
    module2.exports = {
      getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
          anInstance(that, C, NAME, "_i");
          that._t = NAME;
          that._i = id++;
          that._l = void 0;
          if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
        });
        redefineAll(C.prototype, {
          // 23.3.3.2 WeakMap.prototype.delete(key)
          // 23.4.3.3 WeakSet.prototype.delete(value)
          "delete": function(key) {
            if (!isObject4(key)) return false;
            var data = getWeak(key);
            if (data === true) return uncaughtFrozenStore(validate(this, NAME))["delete"](key);
            return data && $has(data, this._i) && delete data[this._i];
          },
          // 23.3.3.4 WeakMap.prototype.has(key)
          // 23.4.3.4 WeakSet.prototype.has(value)
          has: function has(key) {
            if (!isObject4(key)) return false;
            var data = getWeak(key);
            if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
            return data && $has(data, this._i);
          }
        });
        return C;
      },
      def: function(that, key, value) {
        var data = getWeak(anObject(key), true);
        if (data === true) uncaughtFrozenStore(that).set(key, value);
        else data[that._i] = value;
        return that;
      },
      ufstore: uncaughtFrozenStore
    };
  }
});

// node_modules/core-js/modules/es6.weak-map.js
var require_es6_weak_map = __commonJS({
  "node_modules/core-js/modules/es6.weak-map.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var each = require_array_methods()(0);
    var redefine = require_redefine();
    var meta = require_meta();
    var assign = require_object_assign();
    var weak = require_collection_weak();
    var isObject4 = require_is_object();
    var validate = require_validate_collection();
    var NATIVE_WEAK_MAP = require_validate_collection();
    var IS_IE11 = !global2.ActiveXObject && "ActiveXObject" in global2;
    var WEAK_MAP = "WeakMap";
    var getWeak = meta.getWeak;
    var isExtensible = Object.isExtensible;
    var uncaughtFrozenStore = weak.ufstore;
    var InternalMap;
    var wrapper = function(get5) {
      return function WeakMap2() {
        return get5(this, arguments.length > 0 ? arguments[0] : void 0);
      };
    };
    var methods = {
      // 23.3.3.3 WeakMap.prototype.get(key)
      get: function get5(key) {
        if (isObject4(key)) {
          var data = getWeak(key);
          if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
          return data ? data[this._i] : void 0;
        }
      },
      // 23.3.3.5 WeakMap.prototype.set(key, value)
      set: function set5(key, value) {
        return weak.def(validate(this, WEAK_MAP), key, value);
      }
    };
    var $WeakMap = module2.exports = require_collection()(WEAK_MAP, wrapper, methods, weak, true, true);
    if (NATIVE_WEAK_MAP && IS_IE11) {
      InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
      assign(InternalMap.prototype, methods);
      meta.NEED = true;
      each(["delete", "has", "get", "set"], function(key) {
        var proto5 = $WeakMap.prototype;
        var method = proto5[key];
        redefine(proto5, key, function(a, b) {
          if (isObject4(a) && !isExtensible(a)) {
            if (!this._f) this._f = new InternalMap();
            var result = this._f[key](a, b);
            return key == "set" ? this : result;
          }
          return method.call(this, a, b);
        });
      });
    }
  }
});

// node_modules/core-js/modules/es6.weak-set.js
var require_es6_weak_set = __commonJS({
  "node_modules/core-js/modules/es6.weak-set.js"() {
    "use strict";
    var weak = require_collection_weak();
    var validate = require_validate_collection();
    var WEAK_SET = "WeakSet";
    require_collection()(WEAK_SET, function(get5) {
      return function WeakSet2() {
        return get5(this, arguments.length > 0 ? arguments[0] : void 0);
      };
    }, {
      // 23.4.3.1 WeakSet.prototype.add(value)
      add: function add5(value) {
        return weak.def(validate(this, WEAK_SET), value, true);
      }
    }, weak, false, true);
  }
});

// node_modules/core-js/modules/_typed.js
var require_typed = __commonJS({
  "node_modules/core-js/modules/_typed.js"(exports, module2) {
    var global2 = require_global();
    var hide = require_hide();
    var uid = require_uid();
    var TYPED = uid("typed_array");
    var VIEW = uid("view");
    var ABV = !!(global2.ArrayBuffer && global2.DataView);
    var CONSTR = ABV;
    var i = 0;
    var l = 9;
    var Typed;
    var TypedArrayConstructors = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");
    while (i < l) {
      if (Typed = global2[TypedArrayConstructors[i++]]) {
        hide(Typed.prototype, TYPED, true);
        hide(Typed.prototype, VIEW, true);
      } else CONSTR = false;
    }
    module2.exports = {
      ABV,
      CONSTR,
      TYPED,
      VIEW
    };
  }
});

// node_modules/core-js/modules/_to-index.js
var require_to_index = __commonJS({
  "node_modules/core-js/modules/_to-index.js"(exports, module2) {
    var toInteger = require_to_integer();
    var toLength = require_to_length();
    module2.exports = function(it) {
      if (it === void 0) return 0;
      var number = toInteger(it);
      var length = toLength(number);
      if (number !== length) throw RangeError("Wrong length!");
      return length;
    };
  }
});

// node_modules/core-js/modules/_typed-buffer.js
var require_typed_buffer = __commonJS({
  "node_modules/core-js/modules/_typed-buffer.js"(exports) {
    "use strict";
    var global2 = require_global();
    var DESCRIPTORS = require_descriptors();
    var LIBRARY = require_library();
    var $typed = require_typed();
    var hide = require_hide();
    var redefineAll = require_redefine_all();
    var fails = require_fails();
    var anInstance = require_an_instance();
    var toInteger = require_to_integer();
    var toLength = require_to_length();
    var toIndex = require_to_index();
    var gOPN = require_object_gopn().f;
    var dP = require_object_dp().f;
    var arrayFill = require_array_fill();
    var setToStringTag = require_set_to_string_tag();
    var ARRAY_BUFFER = "ArrayBuffer";
    var DATA_VIEW = "DataView";
    var PROTOTYPE = "prototype";
    var WRONG_LENGTH = "Wrong length!";
    var WRONG_INDEX = "Wrong index!";
    var $ArrayBuffer = global2[ARRAY_BUFFER];
    var $DataView = global2[DATA_VIEW];
    var Math2 = global2.Math;
    var RangeError2 = global2.RangeError;
    var Infinity2 = global2.Infinity;
    var BaseBuffer = $ArrayBuffer;
    var abs4 = Math2.abs;
    var pow = Math2.pow;
    var floor = Math2.floor;
    var log = Math2.log;
    var LN2 = Math2.LN2;
    var BUFFER = "buffer";
    var BYTE_LENGTH = "byteLength";
    var BYTE_OFFSET = "byteOffset";
    var $BUFFER = DESCRIPTORS ? "_b" : BUFFER;
    var $LENGTH = DESCRIPTORS ? "_l" : BYTE_LENGTH;
    var $OFFSET = DESCRIPTORS ? "_o" : BYTE_OFFSET;
    function packIEEE754(value, mLen, nBytes) {
      var buffer = new Array(nBytes);
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
      var i = 0;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      var e, m, c;
      value = abs4(value);
      if (value != value || value === Infinity2) {
        m = value != value ? 1 : 0;
        e = eMax;
      } else {
        e = floor(log(value) / LN2);
        if (value * (c = pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * pow(2, eBias - 1) * pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) ;
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) ;
      buffer[--i] |= s * 128;
      return buffer;
    }
    function unpackIEEE754(buffer, mLen, nBytes) {
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = eLen - 7;
      var i = nBytes - 1;
      var s = buffer[i--];
      var e = s & 127;
      var m;
      s >>= 7;
      for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) ;
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) ;
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : s ? -Infinity2 : Infinity2;
      } else {
        m = m + pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * pow(2, e - mLen);
    }
    function unpackI32(bytes2) {
      return bytes2[3] << 24 | bytes2[2] << 16 | bytes2[1] << 8 | bytes2[0];
    }
    function packI8(it) {
      return [it & 255];
    }
    function packI16(it) {
      return [it & 255, it >> 8 & 255];
    }
    function packI32(it) {
      return [it & 255, it >> 8 & 255, it >> 16 & 255, it >> 24 & 255];
    }
    function packF64(it) {
      return packIEEE754(it, 52, 8);
    }
    function packF32(it) {
      return packIEEE754(it, 23, 4);
    }
    function addGetter(C, key2, internal) {
      dP(C[PROTOTYPE], key2, { get: function() {
        return this[internal];
      } });
    }
    function get5(view2, bytes2, index2, isLittleEndian) {
      var numIndex = +index2;
      var intIndex = toIndex(numIndex);
      if (intIndex + bytes2 > view2[$LENGTH]) throw RangeError2(WRONG_INDEX);
      var store = view2[$BUFFER]._b;
      var start = intIndex + view2[$OFFSET];
      var pack = store.slice(start, start + bytes2);
      return isLittleEndian ? pack : pack.reverse();
    }
    function set5(view2, bytes2, index2, conversion, value, isLittleEndian) {
      var numIndex = +index2;
      var intIndex = toIndex(numIndex);
      if (intIndex + bytes2 > view2[$LENGTH]) throw RangeError2(WRONG_INDEX);
      var store = view2[$BUFFER]._b;
      var start = intIndex + view2[$OFFSET];
      var pack = conversion(+value);
      for (var i = 0; i < bytes2; i++) store[start + i] = pack[isLittleEndian ? i : bytes2 - i - 1];
    }
    if (!$typed.ABV) {
      $ArrayBuffer = function ArrayBuffer(length) {
        anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
        var byteLength = toIndex(length);
        this._b = arrayFill.call(new Array(byteLength), 0);
        this[$LENGTH] = byteLength;
      };
      $DataView = function DataView(buffer, byteOffset, byteLength) {
        anInstance(this, $DataView, DATA_VIEW);
        anInstance(buffer, $ArrayBuffer, DATA_VIEW);
        var bufferLength = buffer[$LENGTH];
        var offset4 = toInteger(byteOffset);
        if (offset4 < 0 || offset4 > bufferLength) throw RangeError2("Wrong offset!");
        byteLength = byteLength === void 0 ? bufferLength - offset4 : toLength(byteLength);
        if (offset4 + byteLength > bufferLength) throw RangeError2(WRONG_LENGTH);
        this[$BUFFER] = buffer;
        this[$OFFSET] = offset4;
        this[$LENGTH] = byteLength;
      };
      if (DESCRIPTORS) {
        addGetter($ArrayBuffer, BYTE_LENGTH, "_l");
        addGetter($DataView, BUFFER, "_b");
        addGetter($DataView, BYTE_LENGTH, "_l");
        addGetter($DataView, BYTE_OFFSET, "_o");
      }
      redefineAll($DataView[PROTOTYPE], {
        getInt8: function getInt8(byteOffset) {
          return get5(this, 1, byteOffset)[0] << 24 >> 24;
        },
        getUint8: function getUint8(byteOffset) {
          return get5(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset) {
          var bytes2 = get5(this, 2, byteOffset, arguments[1]);
          return (bytes2[1] << 8 | bytes2[0]) << 16 >> 16;
        },
        getUint16: function getUint16(byteOffset) {
          var bytes2 = get5(this, 2, byteOffset, arguments[1]);
          return bytes2[1] << 8 | bytes2[0];
        },
        getInt32: function getInt32(byteOffset) {
          return unpackI32(get5(this, 4, byteOffset, arguments[1]));
        },
        getUint32: function getUint32(byteOffset) {
          return unpackI32(get5(this, 4, byteOffset, arguments[1])) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset) {
          return unpackIEEE754(get5(this, 4, byteOffset, arguments[1]), 23, 4);
        },
        getFloat64: function getFloat64(byteOffset) {
          return unpackIEEE754(get5(this, 8, byteOffset, arguments[1]), 52, 8);
        },
        setInt8: function setInt8(byteOffset, value) {
          set5(this, 1, byteOffset, packI8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
          set5(this, 1, byteOffset, packI8, value);
        },
        setInt16: function setInt16(byteOffset, value) {
          set5(this, 2, byteOffset, packI16, value, arguments[2]);
        },
        setUint16: function setUint16(byteOffset, value) {
          set5(this, 2, byteOffset, packI16, value, arguments[2]);
        },
        setInt32: function setInt32(byteOffset, value) {
          set5(this, 4, byteOffset, packI32, value, arguments[2]);
        },
        setUint32: function setUint32(byteOffset, value) {
          set5(this, 4, byteOffset, packI32, value, arguments[2]);
        },
        setFloat32: function setFloat32(byteOffset, value) {
          set5(this, 4, byteOffset, packF32, value, arguments[2]);
        },
        setFloat64: function setFloat64(byteOffset, value) {
          set5(this, 8, byteOffset, packF64, value, arguments[2]);
        }
      });
    } else {
      if (!fails(function() {
        $ArrayBuffer(1);
      }) || !fails(function() {
        new $ArrayBuffer(-1);
      }) || fails(function() {
        new $ArrayBuffer();
        new $ArrayBuffer(1.5);
        new $ArrayBuffer(NaN);
        return $ArrayBuffer.name != ARRAY_BUFFER;
      })) {
        $ArrayBuffer = function ArrayBuffer(length) {
          anInstance(this, $ArrayBuffer);
          return new BaseBuffer(toIndex(length));
        };
        ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
        for (keys3 = gOPN(BaseBuffer), j = 0; keys3.length > j; ) {
          if (!((key = keys3[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
        }
        if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
      }
      view = new $DataView(new $ArrayBuffer(2));
      $setInt8 = $DataView[PROTOTYPE].setInt8;
      view.setInt8(0, 2147483648);
      view.setInt8(1, 2147483649);
      if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
        setInt8: function setInt8(byteOffset, value) {
          $setInt8.call(this, byteOffset, value << 24 >> 24);
        },
        setUint8: function setUint8(byteOffset, value) {
          $setInt8.call(this, byteOffset, value << 24 >> 24);
        }
      }, true);
    }
    var ArrayBufferProto;
    var keys3;
    var j;
    var key;
    var view;
    var $setInt8;
    setToStringTag($ArrayBuffer, ARRAY_BUFFER);
    setToStringTag($DataView, DATA_VIEW);
    hide($DataView[PROTOTYPE], $typed.VIEW, true);
    exports[ARRAY_BUFFER] = $ArrayBuffer;
    exports[DATA_VIEW] = $DataView;
  }
});

// node_modules/core-js/modules/es6.typed.array-buffer.js
var require_es6_typed_array_buffer = __commonJS({
  "node_modules/core-js/modules/es6.typed.array-buffer.js"() {
    "use strict";
    var $export = require_export();
    var $typed = require_typed();
    var buffer = require_typed_buffer();
    var anObject = require_an_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var toLength = require_to_length();
    var isObject4 = require_is_object();
    var ArrayBuffer = require_global().ArrayBuffer;
    var speciesConstructor = require_species_constructor();
    var $ArrayBuffer = buffer.ArrayBuffer;
    var $DataView = buffer.DataView;
    var $isView = $typed.ABV && ArrayBuffer.isView;
    var $slice = $ArrayBuffer.prototype.slice;
    var VIEW = $typed.VIEW;
    var ARRAY_BUFFER = "ArrayBuffer";
    $export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });
    $export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
      // 24.1.3.1 ArrayBuffer.isView(arg)
      isView: function isView(it) {
        return $isView && $isView(it) || isObject4(it) && VIEW in it;
      }
    });
    $export($export.P + $export.U + $export.F * require_fails()(function() {
      return !new $ArrayBuffer(2).slice(1, void 0).byteLength;
    }), ARRAY_BUFFER, {
      // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
      slice: function slice(start, end) {
        if ($slice !== void 0 && end === void 0) return $slice.call(anObject(this), start);
        var len = anObject(this).byteLength;
        var first = toAbsoluteIndex(start, len);
        var fin = toAbsoluteIndex(end === void 0 ? len : end, len);
        var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
        var viewS = new $DataView(this);
        var viewT = new $DataView(result);
        var index2 = 0;
        while (first < fin) {
          viewT.setUint8(index2++, viewS.getUint8(first++));
        }
        return result;
      }
    });
    require_set_species()(ARRAY_BUFFER);
  }
});

// node_modules/core-js/modules/es6.typed.data-view.js
var require_es6_typed_data_view = __commonJS({
  "node_modules/core-js/modules/es6.typed.data-view.js"() {
    var $export = require_export();
    $export($export.G + $export.W + $export.F * !require_typed().ABV, {
      DataView: require_typed_buffer().DataView
    });
  }
});

// node_modules/core-js/modules/_typed-array.js
var require_typed_array = __commonJS({
  "node_modules/core-js/modules/_typed-array.js"(exports, module2) {
    "use strict";
    if (require_descriptors()) {
      LIBRARY = require_library();
      global2 = require_global();
      fails = require_fails();
      $export = require_export();
      $typed = require_typed();
      $buffer = require_typed_buffer();
      ctx = require_ctx();
      anInstance = require_an_instance();
      propertyDesc = require_property_desc();
      hide = require_hide();
      redefineAll = require_redefine_all();
      toInteger = require_to_integer();
      toLength = require_to_length();
      toIndex = require_to_index();
      toAbsoluteIndex = require_to_absolute_index();
      toPrimitive = require_to_primitive();
      has = require_has();
      classof = require_classof();
      isObject4 = require_is_object();
      toObject3 = require_to_object();
      isArrayIter = require_is_array_iter();
      create = require_object_create();
      getPrototypeOf = require_object_gpo();
      gOPN = require_object_gopn().f;
      getIterFn = require_core_get_iterator_method();
      uid = require_uid();
      wks = require_wks();
      createArrayMethod = require_array_methods();
      createArrayIncludes = require_array_includes();
      speciesConstructor = require_species_constructor();
      ArrayIterators = require_es6_array_iterator();
      Iterators = require_iterators();
      $iterDetect = require_iter_detect();
      setSpecies = require_set_species();
      arrayFill = require_array_fill();
      arrayCopyWithin = require_array_copy_within();
      $DP = require_object_dp();
      $GOPD = require_object_gopd();
      dP = $DP.f;
      gOPD = $GOPD.f;
      RangeError2 = global2.RangeError;
      TypeError2 = global2.TypeError;
      Uint8Array = global2.Uint8Array;
      ARRAY_BUFFER = "ArrayBuffer";
      SHARED_BUFFER = "Shared" + ARRAY_BUFFER;
      BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
      PROTOTYPE = "prototype";
      ArrayProto = Array[PROTOTYPE];
      $ArrayBuffer = $buffer.ArrayBuffer;
      $DataView = $buffer.DataView;
      arrayForEach = createArrayMethod(0);
      arrayFilter2 = createArrayMethod(2);
      arraySome = createArrayMethod(3);
      arrayEvery = createArrayMethod(4);
      arrayFind = createArrayMethod(5);
      arrayFindIndex = createArrayMethod(6);
      arrayIncludes = createArrayIncludes(true);
      arrayIndexOf = createArrayIncludes(false);
      arrayValues = ArrayIterators.values;
      arrayKeys = ArrayIterators.keys;
      arrayEntries = ArrayIterators.entries;
      arrayLastIndexOf = ArrayProto.lastIndexOf;
      arrayReduce2 = ArrayProto.reduce;
      arrayReduceRight = ArrayProto.reduceRight;
      arrayJoin = ArrayProto.join;
      arraySort = ArrayProto.sort;
      arraySlice = ArrayProto.slice;
      arrayToString = ArrayProto.toString;
      arrayToLocaleString = ArrayProto.toLocaleString;
      ITERATOR = wks("iterator");
      TAG = wks("toStringTag");
      TYPED_CONSTRUCTOR = uid("typed_constructor");
      DEF_CONSTRUCTOR = uid("def_constructor");
      ALL_CONSTRUCTORS = $typed.CONSTR;
      TYPED_ARRAY = $typed.TYPED;
      VIEW = $typed.VIEW;
      WRONG_LENGTH = "Wrong length!";
      $map = createArrayMethod(1, function(O, length) {
        return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
      });
      LITTLE_ENDIAN = fails(function() {
        return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
      });
      FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function() {
        new Uint8Array(1).set({});
      });
      toOffset = function(it, BYTES) {
        var offset4 = toInteger(it);
        if (offset4 < 0 || offset4 % BYTES) throw RangeError2("Wrong offset!");
        return offset4;
      };
      validate = function(it) {
        if (isObject4(it) && TYPED_ARRAY in it) return it;
        throw TypeError2(it + " is not a typed array!");
      };
      allocate = function(C, length) {
        if (!(isObject4(C) && TYPED_CONSTRUCTOR in C)) {
          throw TypeError2("It is not a typed array constructor!");
        }
        return new C(length);
      };
      speciesFromList = function(O, list) {
        return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
      };
      fromList = function(C, list) {
        var index2 = 0;
        var length = list.length;
        var result = allocate(C, length);
        while (length > index2) result[index2] = list[index2++];
        return result;
      };
      addGetter = function(it, key, internal) {
        dP(it, key, { get: function() {
          return this._d[internal];
        } });
      };
      $from = function from3(source) {
        var O = toObject3(source);
        var aLen = arguments.length;
        var mapfn = aLen > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        var iterFn = getIterFn(O);
        var i, length, values, result, step, iterator;
        if (iterFn != void 0 && !isArrayIter(iterFn)) {
          for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
            values.push(step.value);
          }
          O = values;
        }
        if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
        for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
          result[i] = mapping ? mapfn(O[i], i) : O[i];
        }
        return result;
      };
      $of = function of() {
        var index2 = 0;
        var length = arguments.length;
        var result = allocate(this, length);
        while (length > index2) result[index2] = arguments[index2++];
        return result;
      };
      TO_LOCALE_BUG = !!Uint8Array && fails(function() {
        arrayToLocaleString.call(new Uint8Array(1));
      });
      $toLocaleString = function toLocaleString() {
        return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
      };
      proto5 = {
        copyWithin: function copyWithin(target, start) {
          return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
        },
        every: function every(callbackfn) {
          return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        },
        fill: function fill(value) {
          return arrayFill.apply(validate(this), arguments);
        },
        filter: function filter(callbackfn) {
          return speciesFromList(this, arrayFilter2(
            validate(this),
            callbackfn,
            arguments.length > 1 ? arguments[1] : void 0
          ));
        },
        find: function find(predicate) {
          return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
        },
        findIndex: function findIndex(predicate) {
          return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
        },
        forEach: function forEach(callbackfn) {
          arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        },
        indexOf: function indexOf3(searchElement) {
          return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
        },
        includes: function includes(searchElement) {
          return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
        },
        join: function join(separator) {
          return arrayJoin.apply(validate(this), arguments);
        },
        lastIndexOf: function lastIndexOf(searchElement) {
          return arrayLastIndexOf.apply(validate(this), arguments);
        },
        map: function map3(mapfn) {
          return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : void 0);
        },
        reduce: function reduce(callbackfn) {
          return arrayReduce2.apply(validate(this), arguments);
        },
        reduceRight: function reduceRight(callbackfn) {
          return arrayReduceRight.apply(validate(this), arguments);
        },
        reverse: function reverse() {
          var that = this;
          var length = validate(that).length;
          var middle = Math.floor(length / 2);
          var index2 = 0;
          var value;
          while (index2 < middle) {
            value = that[index2];
            that[index2++] = that[--length];
            that[length] = value;
          }
          return that;
        },
        some: function some3(callbackfn) {
          return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        },
        sort: function sort2(comparefn) {
          return arraySort.call(validate(this), comparefn);
        },
        subarray: function subarray(begin, end) {
          var O = validate(this);
          var length = O.length;
          var $begin = toAbsoluteIndex(begin, length);
          return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
            O.buffer,
            O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
            toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - $begin)
          );
        }
      };
      $slice = function slice(start, end) {
        return speciesFromList(this, arraySlice.call(validate(this), start, end));
      };
      $set = function set5(arrayLike) {
        validate(this);
        var offset4 = toOffset(arguments[1], 1);
        var length = this.length;
        var src = toObject3(arrayLike);
        var len = toLength(src.length);
        var index2 = 0;
        if (len + offset4 > length) throw RangeError2(WRONG_LENGTH);
        while (index2 < len) this[offset4 + index2] = src[index2++];
      };
      $iterators = {
        entries: function entries() {
          return arrayEntries.call(validate(this));
        },
        keys: function keys3() {
          return arrayKeys.call(validate(this));
        },
        values: function values() {
          return arrayValues.call(validate(this));
        }
      };
      isTAIndex = function(target, key) {
        return isObject4(target) && target[TYPED_ARRAY] && typeof key != "symbol" && key in target && String(+key) == String(key);
      };
      $getDesc = function getOwnPropertyDescriptor(target, key) {
        return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
      };
      $setDesc = function defineProperty(target, key, desc) {
        if (isTAIndex(target, key = toPrimitive(key, true)) && isObject4(desc) && has(desc, "value") && !has(desc, "get") && !has(desc, "set") && !desc.configurable && (!has(desc, "writable") || desc.writable) && (!has(desc, "enumerable") || desc.enumerable)) {
          target[key] = desc.value;
          return target;
        }
        return dP(target, key, desc);
      };
      if (!ALL_CONSTRUCTORS) {
        $GOPD.f = $getDesc;
        $DP.f = $setDesc;
      }
      $export($export.S + $export.F * !ALL_CONSTRUCTORS, "Object", {
        getOwnPropertyDescriptor: $getDesc,
        defineProperty: $setDesc
      });
      if (fails(function() {
        arrayToString.call({});
      })) {
        arrayToString = arrayToLocaleString = function toString3() {
          return arrayJoin.call(this);
        };
      }
      $TypedArrayPrototype$ = redefineAll({}, proto5);
      redefineAll($TypedArrayPrototype$, $iterators);
      hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
      redefineAll($TypedArrayPrototype$, {
        slice: $slice,
        set: $set,
        constructor: function() {
        },
        toString: arrayToString,
        toLocaleString: $toLocaleString
      });
      addGetter($TypedArrayPrototype$, "buffer", "b");
      addGetter($TypedArrayPrototype$, "byteOffset", "o");
      addGetter($TypedArrayPrototype$, "byteLength", "l");
      addGetter($TypedArrayPrototype$, "length", "e");
      dP($TypedArrayPrototype$, TAG, {
        get: function() {
          return this[TYPED_ARRAY];
        }
      });
      module2.exports = function(KEY13, BYTES, wrapper, CLAMPED) {
        CLAMPED = !!CLAMPED;
        var NAME = KEY13 + (CLAMPED ? "Clamped" : "") + "Array";
        var GETTER = "get" + KEY13;
        var SETTER = "set" + KEY13;
        var TypedArray = global2[NAME];
        var Base = TypedArray || {};
        var TAC = TypedArray && getPrototypeOf(TypedArray);
        var FORCED = !TypedArray || !$typed.ABV;
        var O = {};
        var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
        var getter = function(that, index2) {
          var data = that._d;
          return data.v[GETTER](index2 * BYTES + data.o, LITTLE_ENDIAN);
        };
        var setter = function(that, index2, value) {
          var data = that._d;
          if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
          data.v[SETTER](index2 * BYTES + data.o, value, LITTLE_ENDIAN);
        };
        var addElement = function(that, index2) {
          dP(that, index2, {
            get: function() {
              return getter(this, index2);
            },
            set: function(value) {
              return setter(this, index2, value);
            },
            enumerable: true
          });
        };
        if (FORCED) {
          TypedArray = wrapper(function(that, data, $offset, $length) {
            anInstance(that, TypedArray, NAME, "_d");
            var index2 = 0;
            var offset4 = 0;
            var buffer, byteLength, length, klass;
            if (!isObject4(data)) {
              length = toIndex(data);
              byteLength = length * BYTES;
              buffer = new $ArrayBuffer(byteLength);
            } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
              buffer = data;
              offset4 = toOffset($offset, BYTES);
              var $len = data.byteLength;
              if ($length === void 0) {
                if ($len % BYTES) throw RangeError2(WRONG_LENGTH);
                byteLength = $len - offset4;
                if (byteLength < 0) throw RangeError2(WRONG_LENGTH);
              } else {
                byteLength = toLength($length) * BYTES;
                if (byteLength + offset4 > $len) throw RangeError2(WRONG_LENGTH);
              }
              length = byteLength / BYTES;
            } else if (TYPED_ARRAY in data) {
              return fromList(TypedArray, data);
            } else {
              return $from.call(TypedArray, data);
            }
            hide(that, "_d", {
              b: buffer,
              o: offset4,
              l: byteLength,
              e: length,
              v: new $DataView(buffer)
            });
            while (index2 < length) addElement(that, index2++);
          });
          TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
          hide(TypedArrayPrototype, "constructor", TypedArray);
        } else if (!fails(function() {
          TypedArray(1);
        }) || !fails(function() {
          new TypedArray(-1);
        }) || !$iterDetect(function(iter) {
          new TypedArray();
          new TypedArray(null);
          new TypedArray(1.5);
          new TypedArray(iter);
        }, true)) {
          TypedArray = wrapper(function(that, data, $offset, $length) {
            anInstance(that, TypedArray, NAME);
            var klass;
            if (!isObject4(data)) return new Base(toIndex(data));
            if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
              return $length !== void 0 ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== void 0 ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
            }
            if (TYPED_ARRAY in data) return fromList(TypedArray, data);
            return $from.call(TypedArray, data);
          });
          arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key) {
            if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
          });
          TypedArray[PROTOTYPE] = TypedArrayPrototype;
          if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
        }
        var $nativeIterator = TypedArrayPrototype[ITERATOR];
        var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == "values" || $nativeIterator.name == void 0);
        var $iterator = $iterators.values;
        hide(TypedArray, TYPED_CONSTRUCTOR, true);
        hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
        hide(TypedArrayPrototype, VIEW, true);
        hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
        if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
          dP(TypedArrayPrototype, TAG, {
            get: function() {
              return NAME;
            }
          });
        }
        O[NAME] = TypedArray;
        $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
        $export($export.S, NAME, {
          BYTES_PER_ELEMENT: BYTES
        });
        $export($export.S + $export.F * fails(function() {
          Base.of.call(TypedArray, 1);
        }), NAME, {
          from: $from,
          of: $of
        });
        if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
        $export($export.P, NAME, proto5);
        setSpecies(NAME);
        $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });
        $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
        if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
        $export($export.P + $export.F * fails(function() {
          new TypedArray(1).slice();
        }), NAME, { slice: $slice });
        $export($export.P + $export.F * (fails(function() {
          return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
        }) || !fails(function() {
          TypedArrayPrototype.toLocaleString.call([1, 2]);
        })), NAME, { toLocaleString: $toLocaleString });
        Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
        if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
      };
    } else module2.exports = function() {
    };
    var LIBRARY;
    var global2;
    var fails;
    var $export;
    var $typed;
    var $buffer;
    var ctx;
    var anInstance;
    var propertyDesc;
    var hide;
    var redefineAll;
    var toInteger;
    var toLength;
    var toIndex;
    var toAbsoluteIndex;
    var toPrimitive;
    var has;
    var classof;
    var isObject4;
    var toObject3;
    var isArrayIter;
    var create;
    var getPrototypeOf;
    var gOPN;
    var getIterFn;
    var uid;
    var wks;
    var createArrayMethod;
    var createArrayIncludes;
    var speciesConstructor;
    var ArrayIterators;
    var Iterators;
    var $iterDetect;
    var setSpecies;
    var arrayFill;
    var arrayCopyWithin;
    var $DP;
    var $GOPD;
    var dP;
    var gOPD;
    var RangeError2;
    var TypeError2;
    var Uint8Array;
    var ARRAY_BUFFER;
    var SHARED_BUFFER;
    var BYTES_PER_ELEMENT;
    var PROTOTYPE;
    var ArrayProto;
    var $ArrayBuffer;
    var $DataView;
    var arrayForEach;
    var arrayFilter2;
    var arraySome;
    var arrayEvery;
    var arrayFind;
    var arrayFindIndex;
    var arrayIncludes;
    var arrayIndexOf;
    var arrayValues;
    var arrayKeys;
    var arrayEntries;
    var arrayLastIndexOf;
    var arrayReduce2;
    var arrayReduceRight;
    var arrayJoin;
    var arraySort;
    var arraySlice;
    var arrayToString;
    var arrayToLocaleString;
    var ITERATOR;
    var TAG;
    var TYPED_CONSTRUCTOR;
    var DEF_CONSTRUCTOR;
    var ALL_CONSTRUCTORS;
    var TYPED_ARRAY;
    var VIEW;
    var WRONG_LENGTH;
    var $map;
    var LITTLE_ENDIAN;
    var FORCED_SET;
    var toOffset;
    var validate;
    var allocate;
    var speciesFromList;
    var fromList;
    var addGetter;
    var $from;
    var $of;
    var TO_LOCALE_BUG;
    var $toLocaleString;
    var proto5;
    var $slice;
    var $set;
    var $iterators;
    var isTAIndex;
    var $getDesc;
    var $setDesc;
    var $TypedArrayPrototype$;
  }
});

// node_modules/core-js/modules/es6.typed.int8-array.js
var require_es6_typed_int8_array = __commonJS({
  "node_modules/core-js/modules/es6.typed.int8-array.js"() {
    require_typed_array()("Int8", 1, function(init2) {
      return function Int8Array(data, byteOffset, length) {
        return init2(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es6.typed.uint8-array.js
var require_es6_typed_uint8_array = __commonJS({
  "node_modules/core-js/modules/es6.typed.uint8-array.js"() {
    require_typed_array()("Uint8", 1, function(init2) {
      return function Uint8Array(data, byteOffset, length) {
        return init2(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es6.typed.uint8-clamped-array.js
var require_es6_typed_uint8_clamped_array = __commonJS({
  "node_modules/core-js/modules/es6.typed.uint8-clamped-array.js"() {
    require_typed_array()("Uint8", 1, function(init2) {
      return function Uint8ClampedArray(data, byteOffset, length) {
        return init2(this, data, byteOffset, length);
      };
    }, true);
  }
});

// node_modules/core-js/modules/es6.typed.int16-array.js
var require_es6_typed_int16_array = __commonJS({
  "node_modules/core-js/modules/es6.typed.int16-array.js"() {
    require_typed_array()("Int16", 2, function(init2) {
      return function Int16Array(data, byteOffset, length) {
        return init2(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es6.typed.uint16-array.js
var require_es6_typed_uint16_array = __commonJS({
  "node_modules/core-js/modules/es6.typed.uint16-array.js"() {
    require_typed_array()("Uint16", 2, function(init2) {
      return function Uint16Array2(data, byteOffset, length) {
        return init2(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es6.typed.int32-array.js
var require_es6_typed_int32_array = __commonJS({
  "node_modules/core-js/modules/es6.typed.int32-array.js"() {
    require_typed_array()("Int32", 4, function(init2) {
      return function Int32Array(data, byteOffset, length) {
        return init2(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es6.typed.uint32-array.js
var require_es6_typed_uint32_array = __commonJS({
  "node_modules/core-js/modules/es6.typed.uint32-array.js"() {
    require_typed_array()("Uint32", 4, function(init2) {
      return function Uint32Array2(data, byteOffset, length) {
        return init2(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es6.typed.float32-array.js
var require_es6_typed_float32_array = __commonJS({
  "node_modules/core-js/modules/es6.typed.float32-array.js"() {
    require_typed_array()("Float32", 4, function(init2) {
      return function Float32Array(data, byteOffset, length) {
        return init2(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es6.typed.float64-array.js
var require_es6_typed_float64_array = __commonJS({
  "node_modules/core-js/modules/es6.typed.float64-array.js"() {
    require_typed_array()("Float64", 8, function(init2) {
      return function Float64Array(data, byteOffset, length) {
        return init2(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es6.reflect.apply.js
var require_es6_reflect_apply = __commonJS({
  "node_modules/core-js/modules/es6.reflect.apply.js"() {
    var $export = require_export();
    var aFunction = require_a_function();
    var anObject = require_an_object();
    var rApply = (require_global().Reflect || {}).apply;
    var fApply = Function.apply;
    $export($export.S + $export.F * !require_fails()(function() {
      rApply(function() {
      });
    }), "Reflect", {
      apply: function apply(target, thisArgument, argumentsList) {
        var T = aFunction(target);
        var L = anObject(argumentsList);
        return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
      }
    });
  }
});

// node_modules/core-js/modules/es6.reflect.construct.js
var require_es6_reflect_construct = __commonJS({
  "node_modules/core-js/modules/es6.reflect.construct.js"() {
    var $export = require_export();
    var create = require_object_create();
    var aFunction = require_a_function();
    var anObject = require_an_object();
    var isObject4 = require_is_object();
    var fails = require_fails();
    var bind = require_bind();
    var rConstruct = (require_global().Reflect || {}).construct;
    var NEW_TARGET_BUG = fails(function() {
      function F() {
      }
      return !(rConstruct(function() {
      }, [], F) instanceof F);
    });
    var ARGS_BUG = !fails(function() {
      rConstruct(function() {
      });
    });
    $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), "Reflect", {
      construct: function construct(Target, args) {
        aFunction(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
        if (Target == newTarget) {
          switch (args.length) {
            case 0:
              return new Target();
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
          var $args = [null];
          $args.push.apply($args, args);
          return new (bind.apply(Target, $args))();
        }
        var proto5 = newTarget.prototype;
        var instance = create(isObject4(proto5) ? proto5 : Object.prototype);
        var result = Function.apply.call(Target, instance, args);
        return isObject4(result) ? result : instance;
      }
    });
  }
});

// node_modules/core-js/modules/es6.reflect.define-property.js
var require_es6_reflect_define_property = __commonJS({
  "node_modules/core-js/modules/es6.reflect.define-property.js"() {
    var dP = require_object_dp();
    var $export = require_export();
    var anObject = require_an_object();
    var toPrimitive = require_to_primitive();
    $export($export.S + $export.F * require_fails()(function() {
      Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
    }), "Reflect", {
      defineProperty: function defineProperty(target, propertyKey, attributes) {
        anObject(target);
        propertyKey = toPrimitive(propertyKey, true);
        anObject(attributes);
        try {
          dP.f(target, propertyKey, attributes);
          return true;
        } catch (e) {
          return false;
        }
      }
    });
  }
});

// node_modules/core-js/modules/es6.reflect.delete-property.js
var require_es6_reflect_delete_property = __commonJS({
  "node_modules/core-js/modules/es6.reflect.delete-property.js"() {
    var $export = require_export();
    var gOPD = require_object_gopd().f;
    var anObject = require_an_object();
    $export($export.S, "Reflect", {
      deleteProperty: function deleteProperty(target, propertyKey) {
        var desc = gOPD(anObject(target), propertyKey);
        return desc && !desc.configurable ? false : delete target[propertyKey];
      }
    });
  }
});

// node_modules/core-js/modules/es6.reflect.enumerate.js
var require_es6_reflect_enumerate = __commonJS({
  "node_modules/core-js/modules/es6.reflect.enumerate.js"() {
    "use strict";
    var $export = require_export();
    var anObject = require_an_object();
    var Enumerate = function(iterated) {
      this._t = anObject(iterated);
      this._i = 0;
      var keys3 = this._k = [];
      var key;
      for (key in iterated) keys3.push(key);
    };
    require_iter_create()(Enumerate, "Object", function() {
      var that = this;
      var keys3 = that._k;
      var key;
      do {
        if (that._i >= keys3.length) return { value: void 0, done: true };
      } while (!((key = keys3[that._i++]) in that._t));
      return { value: key, done: false };
    });
    $export($export.S, "Reflect", {
      enumerate: function enumerate(target) {
        return new Enumerate(target);
      }
    });
  }
});

// node_modules/core-js/modules/es6.reflect.get.js
var require_es6_reflect_get = __commonJS({
  "node_modules/core-js/modules/es6.reflect.get.js"() {
    var gOPD = require_object_gopd();
    var getPrototypeOf = require_object_gpo();
    var has = require_has();
    var $export = require_export();
    var isObject4 = require_is_object();
    var anObject = require_an_object();
    function get5(target, propertyKey) {
      var receiver = arguments.length < 3 ? target : arguments[2];
      var desc, proto5;
      if (anObject(target) === receiver) return target[propertyKey];
      if (desc = gOPD.f(target, propertyKey)) return has(desc, "value") ? desc.value : desc.get !== void 0 ? desc.get.call(receiver) : void 0;
      if (isObject4(proto5 = getPrototypeOf(target))) return get5(proto5, propertyKey, receiver);
    }
    $export($export.S, "Reflect", { get: get5 });
  }
});

// node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js
var require_es6_reflect_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js"() {
    var gOPD = require_object_gopd();
    var $export = require_export();
    var anObject = require_an_object();
    $export($export.S, "Reflect", {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        return gOPD.f(anObject(target), propertyKey);
      }
    });
  }
});

// node_modules/core-js/modules/es6.reflect.get-prototype-of.js
var require_es6_reflect_get_prototype_of = __commonJS({
  "node_modules/core-js/modules/es6.reflect.get-prototype-of.js"() {
    var $export = require_export();
    var getProto = require_object_gpo();
    var anObject = require_an_object();
    $export($export.S, "Reflect", {
      getPrototypeOf: function getPrototypeOf(target) {
        return getProto(anObject(target));
      }
    });
  }
});

// node_modules/core-js/modules/es6.reflect.has.js
var require_es6_reflect_has = __commonJS({
  "node_modules/core-js/modules/es6.reflect.has.js"() {
    var $export = require_export();
    $export($export.S, "Reflect", {
      has: function has(target, propertyKey) {
        return propertyKey in target;
      }
    });
  }
});

// node_modules/core-js/modules/es6.reflect.is-extensible.js
var require_es6_reflect_is_extensible = __commonJS({
  "node_modules/core-js/modules/es6.reflect.is-extensible.js"() {
    var $export = require_export();
    var anObject = require_an_object();
    var $isExtensible = Object.isExtensible;
    $export($export.S, "Reflect", {
      isExtensible: function isExtensible(target) {
        anObject(target);
        return $isExtensible ? $isExtensible(target) : true;
      }
    });
  }
});

// node_modules/core-js/modules/_own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js/modules/_own-keys.js"(exports, module2) {
    var gOPN = require_object_gopn();
    var gOPS = require_object_gops();
    var anObject = require_an_object();
    var Reflect2 = require_global().Reflect;
    module2.exports = Reflect2 && Reflect2.ownKeys || function ownKeys(it) {
      var keys3 = gOPN.f(anObject(it));
      var getSymbols = gOPS.f;
      return getSymbols ? keys3.concat(getSymbols(it)) : keys3;
    };
  }
});

// node_modules/core-js/modules/es6.reflect.own-keys.js
var require_es6_reflect_own_keys = __commonJS({
  "node_modules/core-js/modules/es6.reflect.own-keys.js"() {
    var $export = require_export();
    $export($export.S, "Reflect", { ownKeys: require_own_keys() });
  }
});

// node_modules/core-js/modules/es6.reflect.prevent-extensions.js
var require_es6_reflect_prevent_extensions = __commonJS({
  "node_modules/core-js/modules/es6.reflect.prevent-extensions.js"() {
    var $export = require_export();
    var anObject = require_an_object();
    var $preventExtensions = Object.preventExtensions;
    $export($export.S, "Reflect", {
      preventExtensions: function preventExtensions(target) {
        anObject(target);
        try {
          if ($preventExtensions) $preventExtensions(target);
          return true;
        } catch (e) {
          return false;
        }
      }
    });
  }
});

// node_modules/core-js/modules/es6.reflect.set.js
var require_es6_reflect_set = __commonJS({
  "node_modules/core-js/modules/es6.reflect.set.js"() {
    var dP = require_object_dp();
    var gOPD = require_object_gopd();
    var getPrototypeOf = require_object_gpo();
    var has = require_has();
    var $export = require_export();
    var createDesc = require_property_desc();
    var anObject = require_an_object();
    var isObject4 = require_is_object();
    function set5(target, propertyKey, V) {
      var receiver = arguments.length < 4 ? target : arguments[3];
      var ownDesc = gOPD.f(anObject(target), propertyKey);
      var existingDescriptor, proto5;
      if (!ownDesc) {
        if (isObject4(proto5 = getPrototypeOf(target))) {
          return set5(proto5, propertyKey, V, receiver);
        }
        ownDesc = createDesc(0);
      }
      if (has(ownDesc, "value")) {
        if (ownDesc.writable === false || !isObject4(receiver)) return false;
        if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
          if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
          existingDescriptor.value = V;
          dP.f(receiver, propertyKey, existingDescriptor);
        } else dP.f(receiver, propertyKey, createDesc(0, V));
        return true;
      }
      return ownDesc.set === void 0 ? false : (ownDesc.set.call(receiver, V), true);
    }
    $export($export.S, "Reflect", { set: set5 });
  }
});

// node_modules/core-js/modules/es6.reflect.set-prototype-of.js
var require_es6_reflect_set_prototype_of = __commonJS({
  "node_modules/core-js/modules/es6.reflect.set-prototype-of.js"() {
    var $export = require_export();
    var setProto = require_set_proto();
    if (setProto) $export($export.S, "Reflect", {
      setPrototypeOf: function setPrototypeOf(target, proto5) {
        setProto.check(target, proto5);
        try {
          setProto.set(target, proto5);
          return true;
        } catch (e) {
          return false;
        }
      }
    });
  }
});

// node_modules/core-js/es6/index.js
var require_es6 = __commonJS({
  "node_modules/core-js/es6/index.js"(exports, module2) {
    require_es6_symbol();
    require_es6_object_create();
    require_es6_object_define_property();
    require_es6_object_define_properties();
    require_es6_object_get_own_property_descriptor();
    require_es6_object_get_prototype_of();
    require_es6_object_keys();
    require_es6_object_get_own_property_names();
    require_es6_object_freeze();
    require_es6_object_seal();
    require_es6_object_prevent_extensions();
    require_es6_object_is_frozen();
    require_es6_object_is_sealed();
    require_es6_object_is_extensible();
    require_es6_object_assign();
    require_es6_object_is();
    require_es6_object_set_prototype_of();
    require_es6_object_to_string();
    require_es6_function_bind();
    require_es6_function_name();
    require_es6_function_has_instance();
    require_es6_parse_int();
    require_es6_parse_float();
    require_es6_number_constructor();
    require_es6_number_to_fixed();
    require_es6_number_to_precision();
    require_es6_number_epsilon();
    require_es6_number_is_finite();
    require_es6_number_is_integer();
    require_es6_number_is_nan();
    require_es6_number_is_safe_integer();
    require_es6_number_max_safe_integer();
    require_es6_number_min_safe_integer();
    require_es6_number_parse_float();
    require_es6_number_parse_int();
    require_es6_math_acosh();
    require_es6_math_asinh();
    require_es6_math_atanh();
    require_es6_math_cbrt();
    require_es6_math_clz32();
    require_es6_math_cosh();
    require_es6_math_expm1();
    require_es6_math_fround();
    require_es6_math_hypot();
    require_es6_math_imul();
    require_es6_math_log10();
    require_es6_math_log1p();
    require_es6_math_log2();
    require_es6_math_sign();
    require_es6_math_sinh();
    require_es6_math_tanh();
    require_es6_math_trunc();
    require_es6_string_from_code_point();
    require_es6_string_raw();
    require_es6_string_trim();
    require_es6_string_iterator();
    require_es6_string_code_point_at();
    require_es6_string_ends_with();
    require_es6_string_includes();
    require_es6_string_repeat();
    require_es6_string_starts_with();
    require_es6_string_anchor();
    require_es6_string_big();
    require_es6_string_blink();
    require_es6_string_bold();
    require_es6_string_fixed();
    require_es6_string_fontcolor();
    require_es6_string_fontsize();
    require_es6_string_italics();
    require_es6_string_link();
    require_es6_string_small();
    require_es6_string_strike();
    require_es6_string_sub();
    require_es6_string_sup();
    require_es6_date_now();
    require_es6_date_to_json();
    require_es6_date_to_iso_string();
    require_es6_date_to_string();
    require_es6_date_to_primitive();
    require_es6_array_is_array();
    require_es6_array_from();
    require_es6_array_of();
    require_es6_array_join();
    require_es6_array_slice();
    require_es6_array_sort();
    require_es6_array_for_each();
    require_es6_array_map();
    require_es6_array_filter();
    require_es6_array_some();
    require_es6_array_every();
    require_es6_array_reduce();
    require_es6_array_reduce_right();
    require_es6_array_index_of();
    require_es6_array_last_index_of();
    require_es6_array_copy_within();
    require_es6_array_fill();
    require_es6_array_find();
    require_es6_array_find_index();
    require_es6_array_species();
    require_es6_array_iterator();
    require_es6_regexp_constructor();
    require_es6_regexp_exec();
    require_es6_regexp_to_string();
    require_es6_regexp_flags();
    require_es6_regexp_match();
    require_es6_regexp_replace();
    require_es6_regexp_search();
    require_es6_regexp_split();
    require_es6_promise();
    require_es6_map();
    require_es6_set();
    require_es6_weak_map();
    require_es6_weak_set();
    require_es6_typed_array_buffer();
    require_es6_typed_data_view();
    require_es6_typed_int8_array();
    require_es6_typed_uint8_array();
    require_es6_typed_uint8_clamped_array();
    require_es6_typed_int16_array();
    require_es6_typed_uint16_array();
    require_es6_typed_int32_array();
    require_es6_typed_uint32_array();
    require_es6_typed_float32_array();
    require_es6_typed_float64_array();
    require_es6_reflect_apply();
    require_es6_reflect_construct();
    require_es6_reflect_define_property();
    require_es6_reflect_delete_property();
    require_es6_reflect_enumerate();
    require_es6_reflect_get();
    require_es6_reflect_get_own_property_descriptor();
    require_es6_reflect_get_prototype_of();
    require_es6_reflect_has();
    require_es6_reflect_is_extensible();
    require_es6_reflect_own_keys();
    require_es6_reflect_prevent_extensions();
    require_es6_reflect_set();
    require_es6_reflect_set_prototype_of();
    module2.exports = require_core();
  }
});

// node_modules/core-js/modules/es7.array.includes.js
var require_es7_array_includes = __commonJS({
  "node_modules/core-js/modules/es7.array.includes.js"() {
    "use strict";
    var $export = require_export();
    var $includes = require_array_includes()(true);
    $export($export.P, "Array", {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    require_add_to_unscopables()("includes");
  }
});

// node_modules/core-js/fn/array/includes.js
var require_includes = __commonJS({
  "node_modules/core-js/fn/array/includes.js"(exports, module2) {
    require_es7_array_includes();
    module2.exports = require_core().Array.includes;
  }
});

// node_modules/core-js/modules/_flatten-into-array.js
var require_flatten_into_array = __commonJS({
  "node_modules/core-js/modules/_flatten-into-array.js"(exports, module2) {
    "use strict";
    var isArray3 = require_is_array();
    var isObject4 = require_is_object();
    var toLength = require_to_length();
    var ctx = require_ctx();
    var IS_CONCAT_SPREADABLE = require_wks()("isConcatSpreadable");
    function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
      var targetIndex = start;
      var sourceIndex = 0;
      var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
      var element, spreadable;
      while (sourceIndex < sourceLen) {
        if (sourceIndex in source) {
          element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
          spreadable = false;
          if (isObject4(element)) {
            spreadable = element[IS_CONCAT_SPREADABLE];
            spreadable = spreadable !== void 0 ? !!spreadable : isArray3(element);
          }
          if (spreadable && depth > 0) {
            targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
          } else {
            if (targetIndex >= 9007199254740991) throw TypeError();
            target[targetIndex] = element;
          }
          targetIndex++;
        }
        sourceIndex++;
      }
      return targetIndex;
    }
    module2.exports = flattenIntoArray;
  }
});

// node_modules/core-js/modules/es7.array.flat-map.js
var require_es7_array_flat_map = __commonJS({
  "node_modules/core-js/modules/es7.array.flat-map.js"() {
    "use strict";
    var $export = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var toObject3 = require_to_object();
    var toLength = require_to_length();
    var aFunction = require_a_function();
    var arraySpeciesCreate = require_array_species_create();
    $export($export.P, "Array", {
      flatMap: function flatMap(callbackfn) {
        var O = toObject3(this);
        var sourceLen, A;
        aFunction(callbackfn);
        sourceLen = toLength(O.length);
        A = arraySpeciesCreate(O, 0);
        flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
        return A;
      }
    });
    require_add_to_unscopables()("flatMap");
  }
});

// node_modules/core-js/fn/array/flat-map.js
var require_flat_map = __commonJS({
  "node_modules/core-js/fn/array/flat-map.js"(exports, module2) {
    require_es7_array_flat_map();
    module2.exports = require_core().Array.flatMap;
  }
});

// node_modules/core-js/modules/_string-pad.js
var require_string_pad = __commonJS({
  "node_modules/core-js/modules/_string-pad.js"(exports, module2) {
    var toLength = require_to_length();
    var repeat = require_string_repeat();
    var defined = require_defined();
    module2.exports = function(that, maxLength, fillString, left2) {
      var S = String(defined(that));
      var stringLength = S.length;
      var fillStr = fillString === void 0 ? " " : String(fillString);
      var intMaxLength = toLength(maxLength);
      if (intMaxLength <= stringLength || fillStr == "") return S;
      var fillLen = intMaxLength - stringLength;
      var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
      if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
      return left2 ? stringFiller + S : S + stringFiller;
    };
  }
});

// node_modules/core-js/modules/es7.string.pad-start.js
var require_es7_string_pad_start = __commonJS({
  "node_modules/core-js/modules/es7.string.pad-start.js"() {
    "use strict";
    var $export = require_export();
    var $pad = require_string_pad();
    var userAgent = require_user_agent();
    var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
    $export($export.P + $export.F * WEBKIT_BUG, "String", {
      padStart: function padStart(maxLength) {
        return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : void 0, true);
      }
    });
  }
});

// node_modules/core-js/fn/string/pad-start.js
var require_pad_start = __commonJS({
  "node_modules/core-js/fn/string/pad-start.js"(exports, module2) {
    require_es7_string_pad_start();
    module2.exports = require_core().String.padStart;
  }
});

// node_modules/core-js/modules/es7.string.pad-end.js
var require_es7_string_pad_end = __commonJS({
  "node_modules/core-js/modules/es7.string.pad-end.js"() {
    "use strict";
    var $export = require_export();
    var $pad = require_string_pad();
    var userAgent = require_user_agent();
    var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
    $export($export.P + $export.F * WEBKIT_BUG, "String", {
      padEnd: function padEnd(maxLength) {
        return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : void 0, false);
      }
    });
  }
});

// node_modules/core-js/fn/string/pad-end.js
var require_pad_end = __commonJS({
  "node_modules/core-js/fn/string/pad-end.js"(exports, module2) {
    require_es7_string_pad_end();
    module2.exports = require_core().String.padEnd;
  }
});

// node_modules/core-js/modules/es7.string.trim-left.js
var require_es7_string_trim_left = __commonJS({
  "node_modules/core-js/modules/es7.string.trim-left.js"() {
    "use strict";
    require_string_trim()("trimLeft", function($trim) {
      return function trimLeft() {
        return $trim(this, 1);
      };
    }, "trimStart");
  }
});

// node_modules/core-js/fn/string/trim-start.js
var require_trim_start = __commonJS({
  "node_modules/core-js/fn/string/trim-start.js"(exports, module2) {
    require_es7_string_trim_left();
    module2.exports = require_core().String.trimLeft;
  }
});

// node_modules/core-js/modules/es7.string.trim-right.js
var require_es7_string_trim_right = __commonJS({
  "node_modules/core-js/modules/es7.string.trim-right.js"() {
    "use strict";
    require_string_trim()("trimRight", function($trim) {
      return function trimRight() {
        return $trim(this, 2);
      };
    }, "trimEnd");
  }
});

// node_modules/core-js/fn/string/trim-end.js
var require_trim_end = __commonJS({
  "node_modules/core-js/fn/string/trim-end.js"(exports, module2) {
    require_es7_string_trim_right();
    module2.exports = require_core().String.trimRight;
  }
});

// node_modules/core-js/modules/es7.symbol.async-iterator.js
var require_es7_symbol_async_iterator = __commonJS({
  "node_modules/core-js/modules/es7.symbol.async-iterator.js"() {
    require_wks_define()("asyncIterator");
  }
});

// node_modules/core-js/fn/symbol/async-iterator.js
var require_async_iterator = __commonJS({
  "node_modules/core-js/fn/symbol/async-iterator.js"(exports, module2) {
    require_es7_symbol_async_iterator();
    module2.exports = require_wks_ext().f("asyncIterator");
  }
});

// node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var require_es7_object_get_own_property_descriptors = __commonJS({
  "node_modules/core-js/modules/es7.object.get-own-property-descriptors.js"() {
    var $export = require_export();
    var ownKeys = require_own_keys();
    var toIObject = require_to_iobject();
    var gOPD = require_object_gopd();
    var createProperty = require_create_property();
    $export($export.S, "Object", {
      getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
        var O = toIObject(object);
        var getDesc = gOPD.f;
        var keys3 = ownKeys(O);
        var result = {};
        var i = 0;
        var key, desc;
        while (keys3.length > i) {
          desc = getDesc(O, key = keys3[i++]);
          if (desc !== void 0) createProperty(result, key, desc);
        }
        return result;
      }
    });
  }
});

// node_modules/core-js/fn/object/get-own-property-descriptors.js
var require_get_own_property_descriptors = __commonJS({
  "node_modules/core-js/fn/object/get-own-property-descriptors.js"(exports, module2) {
    require_es7_object_get_own_property_descriptors();
    module2.exports = require_core().Object.getOwnPropertyDescriptors;
  }
});

// node_modules/core-js/modules/_object-to-array.js
var require_object_to_array = __commonJS({
  "node_modules/core-js/modules/_object-to-array.js"(exports, module2) {
    var DESCRIPTORS = require_descriptors();
    var getKeys = require_object_keys();
    var toIObject = require_to_iobject();
    var isEnum = require_object_pie().f;
    module2.exports = function(isEntries) {
      return function(it) {
        var O = toIObject(it);
        var keys3 = getKeys(O);
        var length = keys3.length;
        var i = 0;
        var result = [];
        var key;
        while (length > i) {
          key = keys3[i++];
          if (!DESCRIPTORS || isEnum.call(O, key)) {
            result.push(isEntries ? [key, O[key]] : O[key]);
          }
        }
        return result;
      };
    };
  }
});

// node_modules/core-js/modules/es7.object.values.js
var require_es7_object_values = __commonJS({
  "node_modules/core-js/modules/es7.object.values.js"() {
    var $export = require_export();
    var $values = require_object_to_array()(false);
    $export($export.S, "Object", {
      values: function values(it) {
        return $values(it);
      }
    });
  }
});

// node_modules/core-js/fn/object/values.js
var require_values = __commonJS({
  "node_modules/core-js/fn/object/values.js"(exports, module2) {
    require_es7_object_values();
    module2.exports = require_core().Object.values;
  }
});

// node_modules/core-js/modules/es7.object.entries.js
var require_es7_object_entries = __commonJS({
  "node_modules/core-js/modules/es7.object.entries.js"() {
    var $export = require_export();
    var $entries = require_object_to_array()(true);
    $export($export.S, "Object", {
      entries: function entries(it) {
        return $entries(it);
      }
    });
  }
});

// node_modules/core-js/fn/object/entries.js
var require_entries = __commonJS({
  "node_modules/core-js/fn/object/entries.js"(exports, module2) {
    require_es7_object_entries();
    module2.exports = require_core().Object.entries;
  }
});

// node_modules/core-js/modules/es7.promise.finally.js
var require_es7_promise_finally = __commonJS({
  "node_modules/core-js/modules/es7.promise.finally.js"() {
    "use strict";
    var $export = require_export();
    var core = require_core();
    var global2 = require_global();
    var speciesConstructor = require_species_constructor();
    var promiseResolve = require_promise_resolve();
    $export($export.P + $export.R, "Promise", { "finally": function(onFinally) {
      var C = speciesConstructor(this, core.Promise || global2.Promise);
      var isFunction4 = typeof onFinally == "function";
      return this.then(
        isFunction4 ? function(x) {
          return promiseResolve(C, onFinally()).then(function() {
            return x;
          });
        } : onFinally,
        isFunction4 ? function(e) {
          return promiseResolve(C, onFinally()).then(function() {
            throw e;
          });
        } : onFinally
      );
    } });
  }
});

// node_modules/core-js/fn/promise/finally.js
var require_finally = __commonJS({
  "node_modules/core-js/fn/promise/finally.js"(exports, module2) {
    "use strict";
    require_es6_promise();
    require_es7_promise_finally();
    module2.exports = require_core().Promise["finally"];
  }
});

// node_modules/core-js/modules/web.timers.js
var require_web_timers = __commonJS({
  "node_modules/core-js/modules/web.timers.js"() {
    var global2 = require_global();
    var $export = require_export();
    var userAgent = require_user_agent();
    var slice = [].slice;
    var MSIE = /MSIE .\./.test(userAgent);
    var wrap2 = function(set5) {
      return function(fn, time) {
        var boundArgs = arguments.length > 2;
        var args = boundArgs ? slice.call(arguments, 2) : false;
        return set5(boundArgs ? function() {
          (typeof fn == "function" ? fn : Function(fn)).apply(this, args);
        } : fn, time);
      };
    };
    $export($export.G + $export.B + $export.F * MSIE, {
      setTimeout: wrap2(global2.setTimeout),
      setInterval: wrap2(global2.setInterval)
    });
  }
});

// node_modules/core-js/modules/web.immediate.js
var require_web_immediate = __commonJS({
  "node_modules/core-js/modules/web.immediate.js"() {
    var $export = require_export();
    var $task = require_task();
    $export($export.G + $export.B, {
      setImmediate: $task.set,
      clearImmediate: $task.clear
    });
  }
});

// node_modules/core-js/modules/web.dom.iterable.js
var require_web_dom_iterable = __commonJS({
  "node_modules/core-js/modules/web.dom.iterable.js"() {
    var $iterators = require_es6_array_iterator();
    var getKeys = require_object_keys();
    var redefine = require_redefine();
    var global2 = require_global();
    var hide = require_hide();
    var Iterators = require_iterators();
    var wks = require_wks();
    var ITERATOR = wks("iterator");
    var TO_STRING_TAG = wks("toStringTag");
    var ArrayValues = Iterators.Array;
    var DOMIterables = {
      CSSRuleList: true,
      // TODO: Not spec compliant, should be false.
      CSSStyleDeclaration: false,
      CSSValueList: false,
      ClientRectList: false,
      DOMRectList: false,
      DOMStringList: false,
      DOMTokenList: true,
      DataTransferItemList: false,
      FileList: false,
      HTMLAllCollection: false,
      HTMLCollection: false,
      HTMLFormElement: false,
      HTMLSelectElement: false,
      MediaList: true,
      // TODO: Not spec compliant, should be false.
      MimeTypeArray: false,
      NamedNodeMap: false,
      NodeList: true,
      PaintRequestList: false,
      Plugin: false,
      PluginArray: false,
      SVGLengthList: false,
      SVGNumberList: false,
      SVGPathSegList: false,
      SVGPointList: false,
      SVGStringList: false,
      SVGTransformList: false,
      SourceBufferList: false,
      StyleSheetList: true,
      // TODO: Not spec compliant, should be false.
      TextTrackCueList: false,
      TextTrackList: false,
      TouchList: false
    };
    for (collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
      NAME = collections[i];
      explicit = DOMIterables[NAME];
      Collection = global2[NAME];
      proto5 = Collection && Collection.prototype;
      if (proto5) {
        if (!proto5[ITERATOR]) hide(proto5, ITERATOR, ArrayValues);
        if (!proto5[TO_STRING_TAG]) hide(proto5, TO_STRING_TAG, NAME);
        Iterators[NAME] = ArrayValues;
        if (explicit) {
          for (key in $iterators) if (!proto5[key]) redefine(proto5, key, $iterators[key], true);
        }
      }
    }
    var NAME;
    var explicit;
    var Collection;
    var proto5;
    var key;
    var collections;
    var i;
  }
});

// node_modules/core-js/web/index.js
var require_web = __commonJS({
  "node_modules/core-js/web/index.js"(exports, module2) {
    require_web_timers();
    require_web_immediate();
    require_web_dom_iterable();
    module2.exports = require_core();
  }
});

// node_modules/@babel/polyfill/node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/@babel/polyfill/node_modules/regenerator-runtime/runtime.js"(exports, module2) {
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      };
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap2(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
        return generator;
      }
      exports2.wrap = wrap2;
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
      defineProperty(
        GeneratorFunctionPrototype,
        "constructor",
        { value: GeneratorFunction, configurable: true }
      );
      GeneratorFunction.displayName = define2(
        GeneratorFunctionPrototype,
        toStringTagSymbol,
        "GeneratorFunction"
      );
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error2) {
              return invoke("throw", error2, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        defineProperty(this, "_invoke", { value: enqueue });
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(
          wrap2(innerFn, outerFn, self2, tryLocsList),
          PromiseImpl
        );
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method;
        var method = delegate.iterator[methodName];
        if (method === undefined2) {
          context.delegate = null;
          if (methodName === "throw" && delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined2;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          if (methodName !== "return") {
            context.method = "throw";
            context.arg = new TypeError(
              "The iterator does not provide a '" + methodName + "' method"
            );
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(val) {
        var object = Object(val);
        var keys3 = [];
        for (var key in object) {
          keys3.push(key);
        }
        keys3.reverse();
        return function next() {
          while (keys3.length) {
            var key2 = keys3.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(
      // If this script is executing as a CommonJS module, use module.exports
      // as the regeneratorRuntime namespace. Otherwise create a new empty
      // object. Either way, the resulting object will be used to initialize
      // the regeneratorRuntime variable at the top of this file.
      typeof module2 === "object" ? module2.exports : {}
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/handsontable/lib/autoResize/autoResize.js
var require_autoResize = __commonJS({
  "node_modules/handsontable/lib/autoResize/autoResize.js"(exports, module2) {
    function autoResize2() {
      var defaults3 = {
        minHeight: 200,
        maxHeight: 300,
        minWidth: 100,
        maxWidth: 300
      }, el, body = document.body, text = document.createTextNode(""), span = document.createElement("SPAN"), observe = function(element, event2, handler) {
        element.addEventListener(event2, handler, false);
      }, unObserve = function(element, event2, handler) {
        element.removeEventListener(event2, handler, false);
      }, resize = function(newChar) {
        var width, scrollHeight;
        if (!newChar) {
          newChar = "";
        } else if (!/^[a-zA-Z \.,\\\/\|0-9]$/.test(newChar)) {
          newChar = ".";
        }
        if (text.textContent !== void 0) {
          text.textContent = el.value + newChar;
        } else {
          text.data = el.value + newChar;
        }
        span.style.fontSize = getComputedStyle3(el).fontSize;
        span.style.fontFamily = getComputedStyle3(el).fontFamily;
        span.style.whiteSpace = "pre";
        body.appendChild(span);
        width = span.clientWidth + 2;
        body.removeChild(span);
        el.style.height = defaults3.minHeight + "px";
        if (defaults3.minWidth > width) {
          el.style.width = defaults3.minWidth + "px";
        } else if (width > defaults3.maxWidth) {
          el.style.width = defaults3.maxWidth + "px";
        } else {
          el.style.width = width + "px";
        }
        scrollHeight = el.scrollHeight ? el.scrollHeight - 1 : 0;
        if (defaults3.minHeight > scrollHeight) {
          el.style.height = defaults3.minHeight + "px";
        } else if (defaults3.maxHeight < scrollHeight) {
          el.style.height = defaults3.maxHeight + "px";
          el.style.overflowY = "visible";
        } else {
          el.style.height = scrollHeight + "px";
        }
      }, delayedResize = function() {
        window.setTimeout(resize, 0);
      }, extendDefaults = function(config) {
        if (config && config.minHeight) {
          if (config.minHeight == "inherit") {
            defaults3.minHeight = el.clientHeight;
          } else {
            var minHeight = parseInt(config.minHeight);
            if (!isNaN(minHeight)) {
              defaults3.minHeight = minHeight;
            }
          }
        }
        if (config && config.maxHeight) {
          if (config.maxHeight == "inherit") {
            defaults3.maxHeight = el.clientHeight;
          } else {
            var maxHeight = parseInt(config.maxHeight);
            if (!isNaN(maxHeight)) {
              defaults3.maxHeight = maxHeight;
            }
          }
        }
        if (config && config.minWidth) {
          if (config.minWidth == "inherit") {
            defaults3.minWidth = el.clientWidth;
          } else {
            var minWidth = parseInt(config.minWidth);
            if (!isNaN(minWidth)) {
              defaults3.minWidth = minWidth;
            }
          }
        }
        if (config && config.maxWidth) {
          if (config.maxWidth == "inherit") {
            defaults3.maxWidth = el.clientWidth;
          } else {
            var maxWidth = parseInt(config.maxWidth);
            if (!isNaN(maxWidth)) {
              defaults3.maxWidth = maxWidth;
            }
          }
        }
        if (!span.firstChild) {
          span.className = "autoResize";
          span.style.display = "inline-block";
          span.appendChild(text);
        }
      }, init2 = function(el_, config, doObserve) {
        el = el_;
        extendDefaults(config);
        if (el.nodeName == "TEXTAREA") {
          el.style.resize = "none";
          el.style.overflowY = "";
          el.style.height = defaults3.minHeight + "px";
          el.style.minWidth = defaults3.minWidth + "px";
          el.style.maxWidth = defaults3.maxWidth + "px";
          el.style.overflowY = "hidden";
        }
        if (doObserve) {
          observe(el, "change", resize);
          observe(el, "cut", delayedResize);
          observe(el, "paste", delayedResize);
          observe(el, "drop", delayedResize);
          observe(el, "keydown", delayedResize);
          observe(el, "focus", resize);
          observe(el, "compositionstart", delayedResize);
          observe(el, "compositionupdate", delayedResize);
          observe(el, "compositionend", delayedResize);
        }
        resize();
      };
      function getComputedStyle3(element) {
        return element.currentStyle || document.defaultView.getComputedStyle(element);
      }
      return {
        init: function(el_, config, doObserve) {
          init2(el_, config, doObserve);
        },
        unObserve: function() {
          unObserve(el, "change", resize);
          unObserve(el, "cut", delayedResize);
          unObserve(el, "paste", delayedResize);
          unObserve(el, "drop", delayedResize);
          unObserve(el, "keydown", delayedResize);
          unObserve(el, "focus", resize);
          unObserve(el, "compositionstart", delayedResize);
          unObserve(el, "compositionupdate", delayedResize);
          unObserve(el, "compositionend", delayedResize);
        },
        resize
      };
    }
    if (typeof exports !== "undefined") {
      module2.exports = autoResize2;
    }
  }
});

// node_modules/pikaday/node_modules/moment/dist/moment.js
var moment_exports = {};
__export(moment_exports, {
  default: () => moment_default2
});
function hooks2() {
  return hookCallback2.apply(null, arguments);
}
function setHookCallback2(callback) {
  hookCallback2 = callback;
}
function isArray2(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject3(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp2(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty2(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp2(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined3(input) {
  return input === void 0;
}
function isNumber2(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate2(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map2(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0; i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend3(a, b) {
  for (var i in b) {
    if (hasOwnProp2(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp2(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp2(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC2(input, format4, locale3, strict) {
  return createLocalOrUTC2(input, format4, locale3, strict, true).utc();
}
function defaultParsingFlags2() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags2(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags2();
  }
  return m._pf;
}
function isValid4(m) {
  var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
  if (isNowValid) {
    flags = getParsingFlags2(m);
    parsedParts = some2.call(flags.parsedDateParts, function(i) {
      return i != null;
    });
    isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
  }
  if (Object.isFrozen == null || !Object.isFrozen(m)) {
    m._isValid = isNowValid;
  } else {
    return isNowValid;
  }
  return m._isValid;
}
function createInvalid3(flags) {
  var m = createUTC2(NaN);
  if (flags != null) {
    extend3(getParsingFlags2(m), flags);
  } else {
    getParsingFlags2(m).userInvalidated = true;
  }
  return m;
}
function copyConfig2(to3, from3) {
  var i, prop, val, momentPropertiesLen = momentProperties2.length;
  if (!isUndefined3(from3._isAMomentObject)) {
    to3._isAMomentObject = from3._isAMomentObject;
  }
  if (!isUndefined3(from3._i)) {
    to3._i = from3._i;
  }
  if (!isUndefined3(from3._f)) {
    to3._f = from3._f;
  }
  if (!isUndefined3(from3._l)) {
    to3._l = from3._l;
  }
  if (!isUndefined3(from3._strict)) {
    to3._strict = from3._strict;
  }
  if (!isUndefined3(from3._tzm)) {
    to3._tzm = from3._tzm;
  }
  if (!isUndefined3(from3._isUTC)) {
    to3._isUTC = from3._isUTC;
  }
  if (!isUndefined3(from3._offset)) {
    to3._offset = from3._offset;
  }
  if (!isUndefined3(from3._pf)) {
    to3._pf = getParsingFlags2(from3);
  }
  if (!isUndefined3(from3._locale)) {
    to3._locale = from3._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0; i < momentPropertiesLen; i++) {
      prop = momentProperties2[i];
      val = from3[prop];
      if (!isUndefined3(val)) {
        to3[prop] = val;
      }
    }
  }
  return to3;
}
function Moment2(config) {
  copyConfig2(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress2 === false) {
    updateInProgress2 = true;
    hooks2.updateOffset(this);
    updateInProgress2 = false;
  }
}
function isMoment2(obj) {
  return obj instanceof Moment2 || obj != null && obj._isAMomentObject != null;
}
function warn3(msg) {
  if (hooks2.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate2(msg, fn) {
  var firstTime = true;
  return extend3(function() {
    if (hooks2.deprecationHandler != null) {
      hooks2.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0; i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp2(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn3(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
function deprecateSimple2(name, msg) {
  if (hooks2.deprecationHandler != null) {
    hooks2.deprecationHandler(name, msg);
  }
  if (!deprecations2[name]) {
    warn3(msg);
    deprecations2[name] = true;
  }
}
function isFunction3(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set3(config) {
  var prop, i;
  for (i in config) {
    if (hasOwnProp2(config, i)) {
      prop = config[i];
      if (isFunction3(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs2(parentConfig, childConfig) {
  var res = extend3({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp2(childConfig, prop)) {
      if (isObject3(parentConfig[prop]) && isObject3(childConfig[prop])) {
        res[prop] = {};
        extend3(res[prop], parentConfig[prop]);
        extend3(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp2(parentConfig, prop) && !hasOwnProp2(childConfig, prop) && isObject3(parentConfig[prop])) {
      res[prop] = extend3({}, res[prop]);
    }
  }
  return res;
}
function Locale2(config) {
  if (config != null) {
    this.set(config);
  }
}
function calendar3(key, mom, now3) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction3(output) ? output.call(mom, now3) : output;
}
function zeroFill2(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign3 = number >= 0;
  return (sign3 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
function addFormatToken2(token3, padded, ordinal3, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token3) {
    formatTokenFunctions2[token3] = func;
  }
  if (padded) {
    formatTokenFunctions2[padded[0]] = function() {
      return zeroFill2(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal3) {
    formatTokenFunctions2[ordinal3] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token3
      );
    };
  }
}
function removeFormattingTokens2(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction2(format4) {
  var array = format4.match(formattingTokens2), i, length;
  for (i = 0, length = array.length; i < length; i++) {
    if (formatTokenFunctions2[array[i]]) {
      array[i] = formatTokenFunctions2[array[i]];
    } else {
      array[i] = removeFormattingTokens2(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction3(array[i2]) ? array[i2].call(mom, format4) : array[i2];
    }
    return output;
  };
}
function formatMoment2(m, format4) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format4 = expandFormat2(format4, m.localeData());
  formatFunctions2[format4] = formatFunctions2[format4] || makeFormatFunction2(format4);
  return formatFunctions2[format4](m);
}
function expandFormat2(format4, locale3) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale3.longDateFormat(input) || input;
  }
  localFormattingTokens2.lastIndex = 0;
  while (i >= 0 && localFormattingTokens2.test(format4)) {
    format4 = format4.replace(
      localFormattingTokens2,
      replaceLongDateFormatTokens
    );
    localFormattingTokens2.lastIndex = 0;
    i -= 1;
  }
  return format4;
}
function longDateFormat2(key) {
  var format4 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format4 || !formatUpper) {
    return format4;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens2).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
function invalidDate2() {
  return this._invalidDate;
}
function ordinal2(number) {
  return this._ordinal.replace("%d", number);
}
function relativeTime3(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction3(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture2(diff3, output) {
  var format4 = this._relativeTime[diff3 > 0 ? "future" : "past"];
  return isFunction3(format4) ? format4(output) : format4.replace(/%s/i, output);
}
function normalizeUnits2(units) {
  return typeof units === "string" ? aliases2[units] || aliases2[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits2(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp2(inputObject, prop)) {
      normalizedProp = normalizeUnits2(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
function getPrioritizedUnits2(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp2(unitsObj, u)) {
      units.push({ unit: u, priority: priorities2[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
function addRegexToken2(token3, regex, strictRegex) {
  regexes2[token3] = isFunction3(regex) ? regex : function(isStrict, localeData3) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken2(token3, config) {
  if (!hasOwnProp2(regexes2, token3)) {
    return new RegExp(unescapeFormat2(token3));
  }
  return regexes2[token3](config._strict, config._locale);
}
function unescapeFormat2(s) {
  return regexEscape2(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape2(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function absFloor2(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt2(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor2(coercedNumber);
  }
  return value;
}
function addParseToken2(token3, callback) {
  var i, func = callback, tokenLen;
  if (typeof token3 === "string") {
    token3 = [token3];
  }
  if (isNumber2(callback)) {
    func = function(input, array) {
      array[callback] = toInt2(input);
    };
  }
  tokenLen = token3.length;
  for (i = 0; i < tokenLen; i++) {
    tokens2[token3[i]] = func;
  }
}
function addWeekParseToken2(token3, callback) {
  addParseToken2(token3, function(input, array, config, token4) {
    config._w = config._w || {};
    callback(input, config._w, config, token4);
  });
}
function addTimeToArrayFromToken2(token3, input, config) {
  if (input != null && hasOwnProp2(tokens2, token3)) {
    tokens2[token3](input, config._a, config, token3);
  }
}
function isLeapYear2(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function daysInYear2(year) {
  return isLeapYear2(year) ? 366 : 365;
}
function getIsLeapYear2() {
  return isLeapYear2(this.year());
}
function makeGetSet2(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks2.updateOffset(this, keepTime);
      return this;
    } else {
      return get4(this, unit);
    }
  };
}
function get4(mom, unit) {
  if (!mom.isValid()) {
    return NaN;
  }
  var d = mom._d, isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
    case "Seconds":
      return isUTC ? d.getUTCSeconds() : d.getSeconds();
    case "Minutes":
      return isUTC ? d.getUTCMinutes() : d.getMinutes();
    case "Hours":
      return isUTC ? d.getUTCHours() : d.getHours();
    case "Date":
      return isUTC ? d.getUTCDate() : d.getDate();
    case "Day":
      return isUTC ? d.getUTCDay() : d.getDay();
    case "Month":
      return isUTC ? d.getUTCMonth() : d.getMonth();
    case "FullYear":
      return isUTC ? d.getUTCFullYear() : d.getFullYear();
    default:
      return NaN;
  }
}
function set$1(mom, unit, value) {
  var d, isUTC, year, month, date;
  if (!mom.isValid() || isNaN(value)) {
    return;
  }
  d = mom._d;
  isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
    case "Seconds":
      return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
    case "Minutes":
      return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
    case "Hours":
      return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
    case "Date":
      return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
    case "FullYear":
      break;
    default:
      return;
  }
  year = value;
  month = mom.month();
  date = mom.date();
  date = date === 29 && month === 1 && !isLeapYear2(year) ? 28 : date;
  void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
}
function stringGet2(units) {
  units = normalizeUnits2(units);
  if (isFunction3(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet2(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits2(units);
    var prioritized = getPrioritizedUnits2(units), i, prioritizedLen = prioritized.length;
    for (i = 0; i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits2(units);
    if (isFunction3(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function mod2(n, x) {
  return (n % x + x) % x;
}
function daysInMonth2(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod2(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear2(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
function localeMonths2(m, format4) {
  if (!m) {
    return isArray2(this._months) ? this._months : this._months["standalone"];
  }
  return isArray2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT2).test(format4) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort2(m, format4) {
  if (!m) {
    return isArray2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT2.test(format4) ? "format" : "standalone"][m.month()];
}
function handleStrictParse3(monthName, format4, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC2([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format4 === "MMM") {
      ii = indexOf2.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf2.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format4 === "MMM") {
      ii = indexOf2.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf2.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse2(monthName, format4, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse3.call(this, monthName, format4, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC2([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format4 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format4 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth2(mom, value) {
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt2(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber2(value)) {
        return mom;
      }
    }
  }
  var month = value, date = mom.date();
  date = date < 29 ? date : Math.min(date, daysInMonth2(mom.year(), month));
  void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
  return mom;
}
function getSetMonth2(value) {
  if (value != null) {
    setMonth2(this, value);
    hooks2.updateOffset(this, true);
    return this;
  } else {
    return get4(this, "Month");
  }
}
function getDaysInMonth2() {
  return daysInMonth2(this.year(), this.month());
}
function monthsShortRegex2(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp2(this, "_monthsRegex")) {
      computeMonthsParse2.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp2(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex2;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex2(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp2(this, "_monthsRegex")) {
      computeMonthsParse2.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp2(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex2;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse2() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
  for (i = 0; i < 12; i++) {
    mom = createUTC2([2e3, i]);
    shortP = regexEscape2(this.monthsShort(mom, ""));
    longP = regexEscape2(this.months(mom, ""));
    shortPieces.push(shortP);
    longPieces.push(longP);
    mixedPieces.push(longP);
    mixedPieces.push(shortP);
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
function createDate2(y, m, d, h, M, s, ms) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m, d, h, M, s, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m, d, h, M, s, ms);
  }
  return date;
}
function createUTCDate2(y) {
  var date, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset2(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate2(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks2(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset2(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear2(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear2(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear2(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear2(mom, dow, doy) {
  var weekOffset = firstWeekOffset2(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear2(resYear, dow, doy);
  } else if (week > weeksInYear2(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear2(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear2(year, dow, doy) {
  var weekOffset = firstWeekOffset2(year, dow, doy), weekOffsetNext = firstWeekOffset2(year + 1, dow, doy);
  return (daysInYear2(year) - weekOffset + weekOffsetNext) / 7;
}
function localeWeek2(mom) {
  return weekOfYear2(mom, this._week.dow, this._week.doy).week;
}
function localeFirstDayOfWeek2() {
  return this._week.dow;
}
function localeFirstDayOfYear2() {
  return this._week.doy;
}
function getSetWeek2(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek2(input) {
  var week = weekOfYear2(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
function parseWeekday2(input, locale3) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale3.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday2(input, locale3) {
  if (typeof input === "string") {
    return locale3.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n) {
  return ws.slice(n, 7).concat(ws.slice(0, n));
}
function localeWeekdays2(m, format4) {
  var weekdays = isArray2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format4) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort2(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin2(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format4, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC2([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format4 === "dddd") {
      ii = indexOf2.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format4 === "ddd") {
      ii = indexOf2.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf2.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format4 === "dddd") {
      ii = indexOf2.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format4 === "ddd") {
      ii = indexOf2.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf2.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse2(weekdayName, format4, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format4, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC2([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format4 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format4 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format4 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek2(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = get4(this, "Day");
  if (input != null) {
    input = parseWeekday2(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek2(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek2(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday2(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex2(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp2(this, "_weekdaysRegex")) {
      computeWeekdaysParse2.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp2(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex2;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex2(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp2(this, "_weekdaysRegex")) {
      computeWeekdaysParse2.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp2(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex2;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex2(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp2(this, "_weekdaysRegex")) {
      computeWeekdaysParse2.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp2(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex2;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse2() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC2([2e3, 1]).day(i);
    minp = regexEscape2(this.weekdaysMin(mom, ""));
    shortp = regexEscape2(this.weekdaysShort(mom, ""));
    longp = regexEscape2(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat2() {
  return this.hours() % 12 || 12;
}
function kFormat2() {
  return this.hours() || 24;
}
function meridiem2(token3, lowercase) {
  addFormatToken2(token3, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
function matchMeridiem2(isStrict, locale3) {
  return locale3._meridiemParse;
}
function localeIsPM2(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
function localeMeridiem2(hours3, minutes3, isLower) {
  if (hours3 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale2(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale2(names) {
  var i = 0, j, next, locale3, split;
  while (i < names.length) {
    split = normalizeLocale2(names[i]).split("-");
    j = split.length;
    next = normalizeLocale2(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale3 = loadLocale2(split.slice(0, j).join("-"));
      if (locale3) {
        return locale3;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale2;
}
function isLocaleNameSane(name) {
  return !!(name && name.match("^[^/\\\\]*$"));
}
function loadLocale2(name) {
  var oldLocale = null, aliasedRequire;
  if (locales2[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale2._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale2(oldLocale);
    } catch (e) {
      locales2[name] = null;
    }
  }
  return locales2[name];
}
function getSetGlobalLocale2(key, values) {
  var data;
  if (key) {
    if (isUndefined3(values)) {
      data = getLocale2(key);
    } else {
      data = defineLocale2(key, values);
    }
    if (data) {
      globalLocale2 = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale2._abbr;
}
function defineLocale2(name, config) {
  if (config !== null) {
    var locale3, parentConfig = baseConfig2;
    config.abbr = name;
    if (locales2[name] != null) {
      deprecateSimple2(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales2[name]._config;
    } else if (config.parentLocale != null) {
      if (locales2[config.parentLocale] != null) {
        parentConfig = locales2[config.parentLocale]._config;
      } else {
        locale3 = loadLocale2(config.parentLocale);
        if (locale3 != null) {
          parentConfig = locale3._config;
        } else {
          if (!localeFamilies2[config.parentLocale]) {
            localeFamilies2[config.parentLocale] = [];
          }
          localeFamilies2[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales2[name] = new Locale2(mergeConfigs2(parentConfig, config));
    if (localeFamilies2[name]) {
      localeFamilies2[name].forEach(function(x) {
        defineLocale2(x.name, x.config);
      });
    }
    getSetGlobalLocale2(name);
    return locales2[name];
  } else {
    delete locales2[name];
    return null;
  }
}
function updateLocale2(name, config) {
  if (config != null) {
    var locale3, tmpLocale, parentConfig = baseConfig2;
    if (locales2[name] != null && locales2[name].parentLocale != null) {
      locales2[name].set(mergeConfigs2(locales2[name]._config, config));
    } else {
      tmpLocale = loadLocale2(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs2(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale3 = new Locale2(config);
      locale3.parentLocale = locales2[name];
      locales2[name] = locale3;
    }
    getSetGlobalLocale2(name);
  } else {
    if (locales2[name] != null) {
      if (locales2[name].parentLocale != null) {
        locales2[name] = locales2[name].parentLocale;
        if (name === getSetGlobalLocale2()) {
          getSetGlobalLocale2(name);
        }
      } else if (locales2[name] != null) {
        delete locales2[name];
      }
    }
  }
  return locales2[name];
}
function getLocale2(key) {
  var locale3;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale2;
  }
  if (!isArray2(key)) {
    locale3 = loadLocale2(key);
    if (locale3) {
      return locale3;
    }
    key = [key];
  }
  return chooseLocale2(key);
}
function listLocales2() {
  return keys2(locales2);
}
function checkOverflow2(m) {
  var overflow, a = m._a;
  if (a && getParsingFlags2(m).overflow === -2) {
    overflow = a[MONTH2] < 0 || a[MONTH2] > 11 ? MONTH2 : a[DATE2] < 1 || a[DATE2] > daysInMonth2(a[YEAR2], a[MONTH2]) ? DATE2 : a[HOUR2] < 0 || a[HOUR2] > 24 || a[HOUR2] === 24 && (a[MINUTE2] !== 0 || a[SECOND2] !== 0 || a[MILLISECOND2] !== 0) ? HOUR2 : a[MINUTE2] < 0 || a[MINUTE2] > 59 ? MINUTE2 : a[SECOND2] < 0 || a[SECOND2] > 59 ? SECOND2 : a[MILLISECOND2] < 0 || a[MILLISECOND2] > 999 ? MILLISECOND2 : -1;
    if (getParsingFlags2(m)._overflowDayOfYear && (overflow < YEAR2 || overflow > DATE2)) {
      overflow = DATE2;
    }
    if (getParsingFlags2(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK2;
    }
    if (getParsingFlags2(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY2;
    }
    getParsingFlags2(m).overflow = overflow;
  }
  return m;
}
function configFromISO2(config) {
  var i, l, string = config._i, match = extendedIsoRegex2.exec(string) || basicIsoRegex2.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates2.length, isoTimesLen = isoTimes2.length;
  if (match) {
    getParsingFlags2(config).iso = true;
    for (i = 0, l = isoDatesLen; i < l; i++) {
      if (isoDates2[i][1].exec(match[1])) {
        dateFormat = isoDates2[i][0];
        allowTime = isoDates2[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l = isoTimesLen; i < l; i++) {
        if (isoTimes2[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes2[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex2.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat2(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings2(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear2(yearStr),
    defaultLocaleMonthsShort2.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear2(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC28222(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday2(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort2.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags2(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset2(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets2[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
    return h * 60 + m;
  }
}
function configFromRFC28222(config) {
  var match = rfc28222.exec(preprocessRFC28222(config._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings2(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday2(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset2(match[8], match[9], match[10]);
    config._d = createUTCDate2.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags2(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString2(config) {
  var matched = aspNetJsonRegex2.exec(config._i);
  if (matched !== null) {
    config._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO2(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC28222(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks2.createFromInputFallback(config);
  }
}
function defaults2(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray2(config) {
  var nowValue = new Date(hooks2.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray2(config) {
  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray2(config);
  if (config._w && config._a[DATE2] == null && config._a[MONTH2] == null) {
    dayOfYearFromWeekInfo2(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults2(config._a[YEAR2], currentDate[YEAR2]);
    if (config._dayOfYear > daysInYear2(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags2(config)._overflowDayOfYear = true;
    }
    date = createUTCDate2(yearToUse, 0, config._dayOfYear);
    config._a[MONTH2] = date.getUTCMonth();
    config._a[DATE2] = date.getUTCDate();
  }
  for (i = 0; i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
  }
  if (config._a[HOUR2] === 24 && config._a[MINUTE2] === 0 && config._a[SECOND2] === 0 && config._a[MILLISECOND2] === 0) {
    config._nextDay = true;
    config._a[HOUR2] = 0;
  }
  config._d = (config._useUTC ? createUTCDate2 : createDate2).apply(
    null,
    input
  );
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR2] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags2(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo2(config) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults2(
      w.GG,
      config._a[YEAR2],
      weekOfYear2(createLocal2(), 1, 4).year
    );
    week = defaults2(w.W, 1);
    weekday = defaults2(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear2(createLocal2(), dow, doy);
    weekYear = defaults2(w.gg, config._a[YEAR2], curWeek.year);
    week = defaults2(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear2(weekYear, dow, doy)) {
    getParsingFlags2(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags2(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks2(weekYear, week, weekday, dow, doy);
    config._a[YEAR2] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
function configFromStringAndFormat2(config) {
  if (config._f === hooks2.ISO_8601) {
    configFromISO2(config);
    return;
  }
  if (config._f === hooks2.RFC_2822) {
    configFromRFC28222(config);
    return;
  }
  config._a = [];
  getParsingFlags2(config).empty = true;
  var string = "" + config._i, i, parsedInput, tokens3, token3, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens3 = expandFormat2(config._f, config._locale).match(formattingTokens2) || [];
  tokenLen = tokens3.length;
  for (i = 0; i < tokenLen; i++) {
    token3 = tokens3[i];
    parsedInput = (string.match(getParseRegexForToken2(token3, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags2(config).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions2[token3]) {
      if (parsedInput) {
        getParsingFlags2(config).empty = false;
      } else {
        getParsingFlags2(config).unusedTokens.push(token3);
      }
      addTimeToArrayFromToken2(token3, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags2(config).unusedTokens.push(token3);
    }
  }
  getParsingFlags2(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags2(config).unusedInput.push(string);
  }
  if (config._a[HOUR2] <= 12 && getParsingFlags2(config).bigHour === true && config._a[HOUR2] > 0) {
    getParsingFlags2(config).bigHour = void 0;
  }
  getParsingFlags2(config).parsedDateParts = config._a.slice(0);
  getParsingFlags2(config).meridiem = config._meridiem;
  config._a[HOUR2] = meridiemFixWrap2(
    config._locale,
    config._a[HOUR2],
    config._meridiem
  );
  era = getParsingFlags2(config).era;
  if (era !== null) {
    config._a[YEAR2] = config._locale.erasConvertYear(era, config._a[YEAR2]);
  }
  configFromArray2(config);
  checkOverflow2(config);
}
function meridiemFixWrap2(locale3, hour, meridiem3) {
  var isPm;
  if (meridiem3 == null) {
    return hour;
  }
  if (locale3.meridiemHour != null) {
    return locale3.meridiemHour(hour, meridiem3);
  } else if (locale3.isPM != null) {
    isPm = locale3.isPM(meridiem3);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray2(config) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags2(config).invalidFormat = true;
    config._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i = 0; i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig2({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat2(tempConfig);
    if (isValid4(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags2(tempConfig).charsLeftOver;
    currentScore += getParsingFlags2(tempConfig).unusedTokens.length * 10;
    getParsingFlags2(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend3(config, bestMoment || tempConfig);
}
function configFromObject2(config) {
  if (config._d) {
    return;
  }
  var i = normalizeObjectUnits2(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config._a = map2(
    [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray2(config);
}
function createFromConfig2(config) {
  var res = new Moment2(checkOverflow2(prepareConfig2(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig2(config) {
  var input = config._i, format4 = config._f;
  config._locale = config._locale || getLocale2(config._l);
  if (input === null || format4 === void 0 && input === "") {
    return createInvalid3({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment2(input)) {
    return new Moment2(checkOverflow2(input));
  } else if (isDate2(input)) {
    config._d = input;
  } else if (isArray2(format4)) {
    configFromStringAndArray2(config);
  } else if (format4) {
    configFromStringAndFormat2(config);
  } else {
    configFromInput2(config);
  }
  if (!isValid4(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput2(config) {
  var input = config._i;
  if (isUndefined3(input)) {
    config._d = new Date(hooks2.now());
  } else if (isDate2(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString2(config);
  } else if (isArray2(input)) {
    config._a = map2(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray2(config);
  } else if (isObject3(input)) {
    configFromObject2(config);
  } else if (isNumber2(input)) {
    config._d = new Date(input);
  } else {
    hooks2.createFromInputFallback(config);
  }
}
function createLocalOrUTC2(input, format4, locale3, strict, isUTC) {
  var c = {};
  if (format4 === true || format4 === false) {
    strict = format4;
    format4 = void 0;
  }
  if (locale3 === true || locale3 === false) {
    strict = locale3;
    locale3 = void 0;
  }
  if (isObject3(input) && isObjectEmpty2(input) || isArray2(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale3;
  c._i = input;
  c._f = format4;
  c._strict = strict;
  return createFromConfig2(c);
}
function createLocal2(input, format4, locale3, strict) {
  return createLocalOrUTC2(input, format4, locale3, strict, false);
}
function pickBy2(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray2(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal2();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min2() {
  var args = [].slice.call(arguments, 0);
  return pickBy2("isBefore", args);
}
function max2() {
  var args = [].slice.call(arguments, 0);
  return pickBy2("isAfter", args);
}
function isDurationValid2(m) {
  var key, unitHasDecimal = false, i, orderLen = ordering2.length;
  for (key in m) {
    if (hasOwnProp2(m, key) && !(indexOf2.call(ordering2, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i = 0; i < orderLen; ++i) {
    if (m[ordering2[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering2[i]]) !== toInt2(m[ordering2[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration2(NaN);
}
function Duration2(duration) {
  var normalizedInput = normalizeObjectUnits2(duration), years3 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months3 = normalizedInput.month || 0, weeks3 = normalizedInput.week || normalizedInput.isoWeek || 0, days3 = normalizedInput.day || 0, hours3 = normalizedInput.hour || 0, minutes3 = normalizedInput.minute || 0, seconds3 = normalizedInput.second || 0, milliseconds3 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid2(normalizedInput);
  this._milliseconds = +milliseconds3 + seconds3 * 1e3 + // 1000
  minutes3 * 6e4 + // 1000 * 60
  hours3 * 1e3 * 60 * 60;
  this._days = +days3 + weeks3 * 7;
  this._months = +months3 + quarters * 3 + years3 * 12;
  this._data = {};
  this._locale = getLocale2();
  this._bubble();
}
function isDuration2(obj) {
  return obj instanceof Duration2;
}
function absRound2(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays2(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt2(array1[i]) !== toInt2(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset3(token3, separator) {
  addFormatToken2(token3, 0, 0, function() {
    var offset4 = this.utcOffset(), sign3 = "+";
    if (offset4 < 0) {
      offset4 = -offset4;
      sign3 = "-";
    }
    return sign3 + zeroFill2(~~(offset4 / 60), 2) + separator + zeroFill2(~~offset4 % 60, 2);
  });
}
function offsetFromString2(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes3;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset2) || ["-", 0, 0];
  minutes3 = +(parts[1] * 60) + toInt2(parts[2]);
  return minutes3 === 0 ? 0 : parts[0] === "+" ? minutes3 : -minutes3;
}
function cloneWithOffset2(input, model) {
  var res, diff3;
  if (model._isUTC) {
    res = model.clone();
    diff3 = (isMoment2(input) || isDate2(input) ? input.valueOf() : createLocal2(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff3);
    hooks2.updateOffset(res, false);
    return res;
  } else {
    return createLocal2(input).local();
  }
}
function getDateOffset2(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
function getSetOffset2(input, keepLocalTime, keepMinutes) {
  var offset4 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString2(matchShortOffset2, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset2(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset4 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract3(
          this,
          createDuration2(input - offset4, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks2.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset4 : getDateOffset2(this);
  }
}
function getSetZone2(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC2(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal2(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset2(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset2() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString2(matchOffset2, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset2(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal2(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime2() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted2() {
  if (!isUndefined3(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig2(c, this);
  c = prepareConfig2(c);
  if (c._a) {
    other = c._isUTC ? createUTC2(c._a) : createLocal2(c._a);
    this._isDSTShifted = this.isValid() && compareArrays2(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal2() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset2() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc2() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
function createDuration2(input, key) {
  var duration = input, match = null, sign3, ret, diffRes;
  if (isDuration2(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber2(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match = aspNetRegex2.exec(input)) {
    sign3 = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt2(match[DATE2]) * sign3,
      h: toInt2(match[HOUR2]) * sign3,
      m: toInt2(match[MINUTE2]) * sign3,
      s: toInt2(match[SECOND2]) * sign3,
      ms: toInt2(absRound2(match[MILLISECOND2] * 1e3)) * sign3
      // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex2.exec(input)) {
    sign3 = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso2(match[2], sign3),
      M: parseIso2(match[3], sign3),
      w: parseIso2(match[4], sign3),
      d: parseIso2(match[5], sign3),
      h: parseIso2(match[6], sign3),
      m: parseIso2(match[7], sign3),
      s: parseIso2(match[8], sign3)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference2(
      createLocal2(duration.from),
      createLocal2(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration2(duration);
  if (isDuration2(input) && hasOwnProp2(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration2(input) && hasOwnProp2(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
function parseIso2(inp, sign3) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign3;
}
function positiveMomentsDifference2(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference2(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset2(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference2(base, other);
  } else {
    res = positiveMomentsDifference2(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder2(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple2(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration2(val, period);
    addSubtract3(this, dur, direction);
    return this;
  };
}
function addSubtract3(mom, duration, isAdding, updateOffset) {
  var milliseconds3 = duration._milliseconds, days3 = absRound2(duration._days), months3 = absRound2(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months3) {
    setMonth2(mom, get4(mom, "Month") + months3 * isAdding);
  }
  if (days3) {
    set$1(mom, "Date", get4(mom, "Date") + days3 * isAdding);
  }
  if (milliseconds3) {
    mom._d.setTime(mom._d.valueOf() + milliseconds3 * isAdding);
  }
  if (updateOffset) {
    hooks2.updateOffset(mom, days3 || months3);
  }
}
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment2(input) || isDate2(input) || isString(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject3(input) && !isObjectEmpty2(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property, propertyLen = properties.length;
  for (i = 0; i < propertyLen; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp2(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray2(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber2(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject3(input) && !isObjectEmpty2(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property;
  for (i = 0; i < properties.length; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp2(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat2(myMoment, now3) {
  var diff3 = myMoment.diff(now3, "days", true);
  return diff3 < -6 ? "sameElse" : diff3 < -1 ? "lastWeek" : diff3 < 0 ? "lastDay" : diff3 < 1 ? "sameDay" : diff3 < 2 ? "nextDay" : diff3 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now3 = time || createLocal2(), sod = cloneWithOffset2(now3, this).startOf("day"), format4 = hooks2.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction3(formats[format4]) ? formats[format4].call(this, now3) : formats[format4]);
  return this.format(
    output || this.localeData().calendar(format4, this, createLocal2(now3))
  );
}
function clone4() {
  return new Moment2(this);
}
function isAfter2(input, units) {
  var localInput = isMoment2(input) ? input : createLocal2(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits2(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore2(input, units) {
  var localInput = isMoment2(input) ? input : createLocal2(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits2(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween2(from3, to3, units, inclusivity) {
  var localFrom = isMoment2(from3) ? from3 : createLocal2(from3), localTo = isMoment2(to3) ? to3 : createLocal2(to3);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame2(input, units) {
  var localInput = isMoment2(input) ? input : createLocal2(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits2(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter2(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore2(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff2(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset2(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits2(units);
  switch (units) {
    case "year":
      output = monthDiff2(this, that) / 12;
      break;
    case "month":
      output = monthDiff2(this, that);
      break;
    case "quarter":
      output = monthDiff2(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor2(output);
}
function monthDiff2(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff2(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
function toString2() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString3(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment2(
      m,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction3(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment2(m, "Z"));
    }
  }
  return formatMoment2(
    m,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect2() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format2(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks2.defaultFormatUtc : hooks2.defaultFormat;
  }
  var output = formatMoment2(this, inputString);
  return this.localeData().postformat(output);
}
function from2(time, withoutSuffix) {
  if (this.isValid() && (isMoment2(time) && time.isValid() || createLocal2(time).isValid())) {
    return createDuration2({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow2(withoutSuffix) {
  return this.from(createLocal2(), withoutSuffix);
}
function to2(time, withoutSuffix) {
  if (this.isValid() && (isMoment2(time) && time.isValid() || createLocal2(time).isValid())) {
    return createDuration2({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow2(withoutSuffix) {
  return this.to(createLocal2(), withoutSuffix);
}
function locale2(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale2(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
function localeData2() {
  return this._locale;
}
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf2(units) {
  var time, startOfDate;
  units = normalizeUnits2(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks2.updateOffset(this, true);
  return this;
}
function endOf2(units) {
  var time, startOfDate;
  units = normalizeUnits2(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks2.updateOffset(this, true);
  return this;
}
function valueOf3() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix2() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate2() {
  return new Date(this.valueOf());
}
function toArray2() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject2() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON2() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid4(this);
}
function parsingFlags2() {
  return extend3({}, getParsingFlags2(this));
}
function invalidAt2() {
  return getParsingFlags2(this).overflow;
}
function creationData2() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
function localeEras(m, format4) {
  var i, l, date, eras = this._eras || getLocale2("en")._eras;
  for (i = 0, l = eras.length; i < l; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date = hooks2(eras[i].since).startOf("day");
        eras[i].since = date.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date = hooks2(eras[i].until).startOf("day").valueOf();
        eras[i].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format4, strict) {
  var i, l, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l = eras.length; i < l; ++i) {
    name = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format4) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks2(era.since).year();
  } else {
    return hooks2(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l, dir, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks2(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp2(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp2(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp2(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale3) {
  return locale3.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale3) {
  return locale3.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale3) {
  return locale3.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale3) {
  return locale3._eraYearOrdinalRegex || matchUnsigned2;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    erasName = regexEscape2(eras[i].name);
    erasAbbr = regexEscape2(eras[i].abbr);
    erasNarrow = regexEscape2(eras[i].narrow);
    namePieces.push(erasName);
    abbrPieces.push(erasAbbr);
    narrowPieces.push(erasNarrow);
    mixedPieces.push(erasName);
    mixedPieces.push(erasAbbr);
    mixedPieces.push(erasNarrow);
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
function addWeekYearFormatToken2(token3, getter) {
  addFormatToken2(0, [token3, token3.length], 0, getter);
}
function getSetWeekYear2(input) {
  return getSetWeekYearHelper2.call(
    this,
    input,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear2(input) {
  return getSetWeekYearHelper2.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear2() {
  return weeksInYear2(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear2(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear2() {
  var weekInfo = this.localeData()._week;
  return weeksInYear2(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear2(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper2(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear2(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear2(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll2.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll2(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks2(weekYear, week, weekday, dow, doy), date = createUTCDate2(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
function getSetQuarter2(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
function getSetDayOfYear2(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
function parseMs2(input, array) {
  array[MILLISECOND2] = toInt2(("0." + input) * 1e3);
}
function getZoneAbbr2() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName2() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
function createUnix2(input) {
  return createLocal2(input * 1e3);
}
function createInZone2() {
  return createLocal2.apply(null, arguments).parseZone();
}
function preParsePostFormat2(string) {
  return string;
}
function get$1(format4, index2, field, setter) {
  var locale3 = getLocale2(), utc = createUTC2().set(setter, index2);
  return locale3[field](utc, format4);
}
function listMonthsImpl2(format4, index2, field) {
  if (isNumber2(format4)) {
    index2 = format4;
    format4 = void 0;
  }
  format4 = format4 || "";
  if (index2 != null) {
    return get$1(format4, index2, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1(format4, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl2(localeSorted, format4, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber2(format4)) {
      index2 = format4;
      format4 = void 0;
    }
    format4 = format4 || "";
  } else {
    format4 = localeSorted;
    index2 = format4;
    localeSorted = false;
    if (isNumber2(format4)) {
      index2 = format4;
      format4 = void 0;
    }
    format4 = format4 || "";
  }
  var locale3 = getLocale2(), shift = localeSorted ? locale3._week.dow : 0, i, out = [];
  if (index2 != null) {
    return get$1(format4, (index2 + shift) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1(format4, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths2(format4, index2) {
  return listMonthsImpl2(format4, index2, "months");
}
function listMonthsShort2(format4, index2) {
  return listMonthsImpl2(format4, index2, "monthsShort");
}
function listWeekdays2(localeSorted, format4, index2) {
  return listWeekdaysImpl2(localeSorted, format4, index2, "weekdays");
}
function listWeekdaysShort2(localeSorted, format4, index2) {
  return listWeekdaysImpl2(localeSorted, format4, index2, "weekdaysShort");
}
function listWeekdaysMin2(localeSorted, format4, index2) {
  return listWeekdaysImpl2(localeSorted, format4, index2, "weekdaysMin");
}
function abs3() {
  var data = this._data;
  this._milliseconds = mathAbs2(this._milliseconds);
  this._days = mathAbs2(this._days);
  this._months = mathAbs2(this._months);
  data.milliseconds = mathAbs2(data.milliseconds);
  data.seconds = mathAbs2(data.seconds);
  data.minutes = mathAbs2(data.minutes);
  data.hours = mathAbs2(data.hours);
  data.months = mathAbs2(data.months);
  data.years = mathAbs2(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration2(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil2(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble2() {
  var milliseconds3 = this._milliseconds, days3 = this._days, months3 = this._months, data = this._data, seconds3, minutes3, hours3, years3, monthsFromDays;
  if (!(milliseconds3 >= 0 && days3 >= 0 && months3 >= 0 || milliseconds3 <= 0 && days3 <= 0 && months3 <= 0)) {
    milliseconds3 += absCeil2(monthsToDays2(months3) + days3) * 864e5;
    days3 = 0;
    months3 = 0;
  }
  data.milliseconds = milliseconds3 % 1e3;
  seconds3 = absFloor2(milliseconds3 / 1e3);
  data.seconds = seconds3 % 60;
  minutes3 = absFloor2(seconds3 / 60);
  data.minutes = minutes3 % 60;
  hours3 = absFloor2(minutes3 / 60);
  data.hours = hours3 % 24;
  days3 += absFloor2(hours3 / 24);
  monthsFromDays = absFloor2(daysToMonths2(days3));
  months3 += monthsFromDays;
  days3 -= absCeil2(monthsToDays2(monthsFromDays));
  years3 = absFloor2(months3 / 12);
  months3 %= 12;
  data.days = days3;
  data.months = months3;
  data.years = years3;
  return this;
}
function daysToMonths2(days3) {
  return days3 * 4800 / 146097;
}
function monthsToDays2(months3) {
  return months3 * 146097 / 4800;
}
function as2(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days3, months3, milliseconds3 = this._milliseconds;
  units = normalizeUnits2(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days3 = this._days + milliseconds3 / 864e5;
    months3 = this._months + daysToMonths2(days3);
    switch (units) {
      case "month":
        return months3;
      case "quarter":
        return months3 / 3;
      case "year":
        return months3 / 12;
    }
  } else {
    days3 = this._days + Math.round(monthsToDays2(this._months));
    switch (units) {
      case "week":
        return days3 / 7 + milliseconds3 / 6048e5;
      case "day":
        return days3 + milliseconds3 / 864e5;
      case "hour":
        return days3 * 24 + milliseconds3 / 36e5;
      case "minute":
        return days3 * 1440 + milliseconds3 / 6e4;
      case "second":
        return days3 * 86400 + milliseconds3 / 1e3;
      case "millisecond":
        return Math.floor(days3 * 864e5) + milliseconds3;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function makeAs2(alias) {
  return function() {
    return this.as(alias);
  };
}
function clone$1() {
  return createDuration2(this);
}
function get$2(units) {
  units = normalizeUnits2(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter2(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
function weeks2() {
  return absFloor2(this.days() / 7);
}
function substituteTimeAgo2(string, number, withoutSuffix, isFuture, locale3) {
  return locale3.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds3, locale3) {
  var duration = createDuration2(posNegDuration).abs(), seconds3 = round2(duration.as("s")), minutes3 = round2(duration.as("m")), hours3 = round2(duration.as("h")), days3 = round2(duration.as("d")), months3 = round2(duration.as("M")), weeks3 = round2(duration.as("w")), years3 = round2(duration.as("y")), a = seconds3 <= thresholds3.ss && ["s", seconds3] || seconds3 < thresholds3.s && ["ss", seconds3] || minutes3 <= 1 && ["m"] || minutes3 < thresholds3.m && ["mm", minutes3] || hours3 <= 1 && ["h"] || hours3 < thresholds3.h && ["hh", hours3] || days3 <= 1 && ["d"] || days3 < thresholds3.d && ["dd", days3];
  if (thresholds3.w != null) {
    a = a || weeks3 <= 1 && ["w"] || weeks3 < thresholds3.w && ["ww", weeks3];
  }
  a = a || months3 <= 1 && ["M"] || months3 < thresholds3.M && ["MM", months3] || years3 <= 1 && ["y"] || ["yy", years3];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale3;
  return substituteTimeAgo2.apply(null, a);
}
function getSetRelativeTimeRounding2(roundingFunction) {
  if (roundingFunction === void 0) {
    return round2;
  }
  if (typeof roundingFunction === "function") {
    round2 = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold2(threshold, limit) {
  if (thresholds2[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds2[threshold];
  }
  thresholds2[threshold] = limit;
  if (threshold === "s") {
    thresholds2.ss = limit - 1;
  }
  return true;
}
function humanize2(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds2, locale3, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds2, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale3 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale3);
  if (withSuffix) {
    output = locale3.pastFuture(+this, output);
  }
  return locale3.postformat(output);
}
function sign2(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds3 = abs$1(this._milliseconds) / 1e3, days3 = abs$1(this._days), months3 = abs$1(this._months), minutes3, hours3, years3, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes3 = absFloor2(seconds3 / 60);
  hours3 = absFloor2(minutes3 / 60);
  seconds3 %= 60;
  minutes3 %= 60;
  years3 = absFloor2(months3 / 12);
  months3 %= 12;
  s = seconds3 ? seconds3.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign2(this._months) !== sign2(total) ? "-" : "";
  daysSign = sign2(this._days) !== sign2(total) ? "-" : "";
  hmsSign = sign2(this._milliseconds) !== sign2(total) ? "-" : "";
  return totalSign + "P" + (years3 ? ymSign + years3 + "Y" : "") + (months3 ? ymSign + months3 + "M" : "") + (days3 ? daysSign + days3 + "D" : "") + (hours3 || minutes3 || seconds3 ? "T" : "") + (hours3 ? hmsSign + hours3 + "H" : "") + (minutes3 ? hmsSign + minutes3 + "M" : "") + (seconds3 ? hmsSign + s + "S" : "");
}
var hookCallback2, some2, momentProperties2, updateInProgress2, deprecations2, keys2, defaultCalendar2, formattingTokens2, localFormattingTokens2, formatFunctions2, formatTokenFunctions2, defaultLongDateFormat2, defaultInvalidDate2, defaultOrdinal2, defaultDayOfMonthOrdinalParse2, defaultRelativeTime2, aliases2, priorities2, match12, match22, match32, match42, match62, match1to22, match3to42, match5to62, match1to32, match1to42, match1to62, matchUnsigned2, matchSigned2, matchOffset2, matchShortOffset2, matchTimestamp2, matchWord2, match1to2NoLeadingZero, match1to2HasZero, regexes2, tokens2, YEAR2, MONTH2, DATE2, HOUR2, MINUTE2, SECOND2, MILLISECOND2, WEEK2, WEEKDAY2, getSetYear2, indexOf2, defaultLocaleMonths2, defaultLocaleMonthsShort2, MONTHS_IN_FORMAT2, defaultMonthsShortRegex2, defaultMonthsRegex2, defaultLocaleWeek2, defaultLocaleWeekdays2, defaultLocaleWeekdaysShort2, defaultLocaleWeekdaysMin2, defaultWeekdaysRegex2, defaultWeekdaysShortRegex2, defaultWeekdaysMinRegex2, defaultLocaleMeridiemParse2, getSetHour2, baseConfig2, locales2, localeFamilies2, globalLocale2, extendedIsoRegex2, basicIsoRegex2, tzRegex2, isoDates2, isoTimes2, aspNetJsonRegex2, rfc28222, obsOffsets2, prototypeMin2, prototypeMax2, now2, ordering2, chunkOffset2, aspNetRegex2, isoRegex2, add3, subtract3, lang2, MS_PER_SECOND, MS_PER_MINUTE, MS_PER_HOUR, MS_PER_400_YEARS, getSetDayOfMonth2, getSetMinute2, getSetSecond2, token2, getSetMillisecond2, proto4, proto$1, mathAbs2, asMilliseconds2, asSeconds2, asMinutes2, asHours2, asDays2, asWeeks2, asMonths2, asQuarters, asYears2, valueOf$1, milliseconds2, seconds2, minutes2, hours2, days2, months2, years2, round2, thresholds2, abs$1, proto$2, moment_default2;
var init_moment = __esm({
  "node_modules/pikaday/node_modules/moment/dist/moment.js"() {
    if (Array.prototype.some) {
      some2 = Array.prototype.some;
    } else {
      some2 = function(fun) {
        var t = Object(this), len = t.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }
        return false;
      };
    }
    momentProperties2 = hooks2.momentProperties = [];
    updateInProgress2 = false;
    deprecations2 = {};
    hooks2.suppressDeprecationWarnings = false;
    hooks2.deprecationHandler = null;
    if (Object.keys) {
      keys2 = Object.keys;
    } else {
      keys2 = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp2(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    defaultCalendar2 = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    formattingTokens2 = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    localFormattingTokens2 = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    formatFunctions2 = {};
    formatTokenFunctions2 = {};
    defaultLongDateFormat2 = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    defaultInvalidDate2 = "Invalid date";
    defaultOrdinal2 = "%d";
    defaultDayOfMonthOrdinalParse2 = /\d{1,2}/;
    defaultRelativeTime2 = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    aliases2 = {
      D: "date",
      dates: "date",
      date: "date",
      d: "day",
      days: "day",
      day: "day",
      e: "weekday",
      weekdays: "weekday",
      weekday: "weekday",
      E: "isoWeekday",
      isoweekdays: "isoWeekday",
      isoweekday: "isoWeekday",
      DDD: "dayOfYear",
      dayofyears: "dayOfYear",
      dayofyear: "dayOfYear",
      h: "hour",
      hours: "hour",
      hour: "hour",
      ms: "millisecond",
      milliseconds: "millisecond",
      millisecond: "millisecond",
      m: "minute",
      minutes: "minute",
      minute: "minute",
      M: "month",
      months: "month",
      month: "month",
      Q: "quarter",
      quarters: "quarter",
      quarter: "quarter",
      s: "second",
      seconds: "second",
      second: "second",
      gg: "weekYear",
      weekyears: "weekYear",
      weekyear: "weekYear",
      GG: "isoWeekYear",
      isoweekyears: "isoWeekYear",
      isoweekyear: "isoWeekYear",
      w: "week",
      weeks: "week",
      week: "week",
      W: "isoWeek",
      isoweeks: "isoWeek",
      isoweek: "isoWeek",
      y: "year",
      years: "year",
      year: "year"
    };
    priorities2 = {
      date: 9,
      day: 11,
      weekday: 11,
      isoWeekday: 11,
      dayOfYear: 4,
      hour: 13,
      millisecond: 16,
      minute: 14,
      month: 8,
      quarter: 7,
      second: 15,
      weekYear: 1,
      isoWeekYear: 1,
      week: 5,
      isoWeek: 5,
      year: 1
    };
    match12 = /\d/;
    match22 = /\d\d/;
    match32 = /\d{3}/;
    match42 = /\d{4}/;
    match62 = /[+-]?\d{6}/;
    match1to22 = /\d\d?/;
    match3to42 = /\d\d\d\d?/;
    match5to62 = /\d\d\d\d\d\d?/;
    match1to32 = /\d{1,3}/;
    match1to42 = /\d{1,4}/;
    match1to62 = /[+-]?\d{1,6}/;
    matchUnsigned2 = /\d+/;
    matchSigned2 = /[+-]?\d+/;
    matchOffset2 = /Z|[+-]\d\d:?\d\d/gi;
    matchShortOffset2 = /Z|[+-]\d\d(?::?\d\d)?/gi;
    matchTimestamp2 = /[+-]?\d+(\.\d{1,3})?/;
    matchWord2 = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    match1to2NoLeadingZero = /^[1-9]\d?/;
    match1to2HasZero = /^([1-9]\d|\d)/;
    regexes2 = {};
    tokens2 = {};
    YEAR2 = 0;
    MONTH2 = 1;
    DATE2 = 2;
    HOUR2 = 3;
    MINUTE2 = 4;
    SECOND2 = 5;
    MILLISECOND2 = 6;
    WEEK2 = 7;
    WEEKDAY2 = 8;
    addFormatToken2("Y", 0, 0, function() {
      var y = this.year();
      return y <= 9999 ? zeroFill2(y, 4) : "+" + y;
    });
    addFormatToken2(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken2(0, ["YYYY", 4], 0, "year");
    addFormatToken2(0, ["YYYYY", 5], 0, "year");
    addFormatToken2(0, ["YYYYYY", 6, true], 0, "year");
    addRegexToken2("Y", matchSigned2);
    addRegexToken2("YY", match1to22, match22);
    addRegexToken2("YYYY", match1to42, match42);
    addRegexToken2("YYYYY", match1to62, match62);
    addRegexToken2("YYYYYY", match1to62, match62);
    addParseToken2(["YYYYY", "YYYYYY"], YEAR2);
    addParseToken2("YYYY", function(input, array) {
      array[YEAR2] = input.length === 2 ? hooks2.parseTwoDigitYear(input) : toInt2(input);
    });
    addParseToken2("YY", function(input, array) {
      array[YEAR2] = hooks2.parseTwoDigitYear(input);
    });
    addParseToken2("Y", function(input, array) {
      array[YEAR2] = parseInt(input, 10);
    });
    hooks2.parseTwoDigitYear = function(input) {
      return toInt2(input) + (toInt2(input) > 68 ? 1900 : 2e3);
    };
    getSetYear2 = makeGetSet2("FullYear", true);
    if (Array.prototype.indexOf) {
      indexOf2 = Array.prototype.indexOf;
    } else {
      indexOf2 = function(o) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    addFormatToken2("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken2("MMM", 0, 0, function(format4) {
      return this.localeData().monthsShort(this, format4);
    });
    addFormatToken2("MMMM", 0, 0, function(format4) {
      return this.localeData().months(this, format4);
    });
    addRegexToken2("M", match1to22, match1to2NoLeadingZero);
    addRegexToken2("MM", match1to22, match22);
    addRegexToken2("MMM", function(isStrict, locale3) {
      return locale3.monthsShortRegex(isStrict);
    });
    addRegexToken2("MMMM", function(isStrict, locale3) {
      return locale3.monthsRegex(isStrict);
    });
    addParseToken2(["M", "MM"], function(input, array) {
      array[MONTH2] = toInt2(input) - 1;
    });
    addParseToken2(["MMM", "MMMM"], function(input, array, config, token3) {
      var month = config._locale.monthsParse(input, token3, config._strict);
      if (month != null) {
        array[MONTH2] = month;
      } else {
        getParsingFlags2(config).invalidMonth = input;
      }
    });
    defaultLocaleMonths2 = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    );
    defaultLocaleMonthsShort2 = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
    MONTHS_IN_FORMAT2 = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    defaultMonthsShortRegex2 = matchWord2;
    defaultMonthsRegex2 = matchWord2;
    addFormatToken2("w", ["ww", 2], "wo", "week");
    addFormatToken2("W", ["WW", 2], "Wo", "isoWeek");
    addRegexToken2("w", match1to22, match1to2NoLeadingZero);
    addRegexToken2("ww", match1to22, match22);
    addRegexToken2("W", match1to22, match1to2NoLeadingZero);
    addRegexToken2("WW", match1to22, match22);
    addWeekParseToken2(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token3) {
        week[token3.substr(0, 1)] = toInt2(input);
      }
    );
    defaultLocaleWeek2 = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    addFormatToken2("d", 0, "do", "day");
    addFormatToken2("dd", 0, 0, function(format4) {
      return this.localeData().weekdaysMin(this, format4);
    });
    addFormatToken2("ddd", 0, 0, function(format4) {
      return this.localeData().weekdaysShort(this, format4);
    });
    addFormatToken2("dddd", 0, 0, function(format4) {
      return this.localeData().weekdays(this, format4);
    });
    addFormatToken2("e", 0, 0, "weekday");
    addFormatToken2("E", 0, 0, "isoWeekday");
    addRegexToken2("d", match1to22);
    addRegexToken2("e", match1to22);
    addRegexToken2("E", match1to22);
    addRegexToken2("dd", function(isStrict, locale3) {
      return locale3.weekdaysMinRegex(isStrict);
    });
    addRegexToken2("ddd", function(isStrict, locale3) {
      return locale3.weekdaysShortRegex(isStrict);
    });
    addRegexToken2("dddd", function(isStrict, locale3) {
      return locale3.weekdaysRegex(isStrict);
    });
    addWeekParseToken2(["dd", "ddd", "dddd"], function(input, week, config, token3) {
      var weekday = config._locale.weekdaysParse(input, token3, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags2(config).invalidWeekday = input;
      }
    });
    addWeekParseToken2(["d", "e", "E"], function(input, week, config, token3) {
      week[token3] = toInt2(input);
    });
    defaultLocaleWeekdays2 = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    defaultLocaleWeekdaysShort2 = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    defaultLocaleWeekdaysMin2 = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    defaultWeekdaysRegex2 = matchWord2;
    defaultWeekdaysShortRegex2 = matchWord2;
    defaultWeekdaysMinRegex2 = matchWord2;
    addFormatToken2("H", ["HH", 2], 0, "hour");
    addFormatToken2("h", ["hh", 2], 0, hFormat2);
    addFormatToken2("k", ["kk", 2], 0, kFormat2);
    addFormatToken2("hmm", 0, 0, function() {
      return "" + hFormat2.apply(this) + zeroFill2(this.minutes(), 2);
    });
    addFormatToken2("hmmss", 0, 0, function() {
      return "" + hFormat2.apply(this) + zeroFill2(this.minutes(), 2) + zeroFill2(this.seconds(), 2);
    });
    addFormatToken2("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill2(this.minutes(), 2);
    });
    addFormatToken2("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill2(this.minutes(), 2) + zeroFill2(this.seconds(), 2);
    });
    meridiem2("a", true);
    meridiem2("A", false);
    addRegexToken2("a", matchMeridiem2);
    addRegexToken2("A", matchMeridiem2);
    addRegexToken2("H", match1to22, match1to2HasZero);
    addRegexToken2("h", match1to22, match1to2NoLeadingZero);
    addRegexToken2("k", match1to22, match1to2NoLeadingZero);
    addRegexToken2("HH", match1to22, match22);
    addRegexToken2("hh", match1to22, match22);
    addRegexToken2("kk", match1to22, match22);
    addRegexToken2("hmm", match3to42);
    addRegexToken2("hmmss", match5to62);
    addRegexToken2("Hmm", match3to42);
    addRegexToken2("Hmmss", match5to62);
    addParseToken2(["H", "HH"], HOUR2);
    addParseToken2(["k", "kk"], function(input, array, config) {
      var kInput = toInt2(input);
      array[HOUR2] = kInput === 24 ? 0 : kInput;
    });
    addParseToken2(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken2(["h", "hh"], function(input, array, config) {
      array[HOUR2] = toInt2(input);
      getParsingFlags2(config).bigHour = true;
    });
    addParseToken2("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR2] = toInt2(input.substr(0, pos));
      array[MINUTE2] = toInt2(input.substr(pos));
      getParsingFlags2(config).bigHour = true;
    });
    addParseToken2("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR2] = toInt2(input.substr(0, pos1));
      array[MINUTE2] = toInt2(input.substr(pos1, 2));
      array[SECOND2] = toInt2(input.substr(pos2));
      getParsingFlags2(config).bigHour = true;
    });
    addParseToken2("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR2] = toInt2(input.substr(0, pos));
      array[MINUTE2] = toInt2(input.substr(pos));
    });
    addParseToken2("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR2] = toInt2(input.substr(0, pos1));
      array[MINUTE2] = toInt2(input.substr(pos1, 2));
      array[SECOND2] = toInt2(input.substr(pos2));
    });
    defaultLocaleMeridiemParse2 = /[ap]\.?m?\.?/i;
    getSetHour2 = makeGetSet2("Hours", true);
    baseConfig2 = {
      calendar: defaultCalendar2,
      longDateFormat: defaultLongDateFormat2,
      invalidDate: defaultInvalidDate2,
      ordinal: defaultOrdinal2,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse2,
      relativeTime: defaultRelativeTime2,
      months: defaultLocaleMonths2,
      monthsShort: defaultLocaleMonthsShort2,
      week: defaultLocaleWeek2,
      weekdays: defaultLocaleWeekdays2,
      weekdaysMin: defaultLocaleWeekdaysMin2,
      weekdaysShort: defaultLocaleWeekdaysShort2,
      meridiemParse: defaultLocaleMeridiemParse2
    };
    locales2 = {};
    localeFamilies2 = {};
    extendedIsoRegex2 = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    basicIsoRegex2 = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    tzRegex2 = /Z|[+-]\d\d(?::?\d\d)?/;
    isoDates2 = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ];
    isoTimes2 = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ];
    aspNetJsonRegex2 = /^\/?Date\((-?\d+)/i;
    rfc28222 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
    obsOffsets2 = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    hooks2.createFromInputFallback = deprecate2(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    hooks2.ISO_8601 = function() {
    };
    hooks2.RFC_2822 = function() {
    };
    prototypeMin2 = deprecate2(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal2.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid3();
        }
      }
    );
    prototypeMax2 = deprecate2(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal2.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid3();
        }
      }
    );
    now2 = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    ordering2 = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    offset3("Z", ":");
    offset3("ZZ", "");
    addRegexToken2("Z", matchShortOffset2);
    addRegexToken2("ZZ", matchShortOffset2);
    addParseToken2(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString2(matchShortOffset2, input);
    });
    chunkOffset2 = /([\+\-]|\d\d)/gi;
    hooks2.updateOffset = function() {
    };
    aspNetRegex2 = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
    isoRegex2 = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    createDuration2.fn = Duration2.prototype;
    createDuration2.invalid = createInvalid$1;
    add3 = createAdder2(1, "add");
    subtract3 = createAdder2(-1, "subtract");
    hooks2.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks2.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    lang2 = deprecate2(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    MS_PER_SECOND = 1e3;
    MS_PER_MINUTE = 60 * MS_PER_SECOND;
    MS_PER_HOUR = 60 * MS_PER_MINUTE;
    MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    addFormatToken2("N", 0, 0, "eraAbbr");
    addFormatToken2("NN", 0, 0, "eraAbbr");
    addFormatToken2("NNN", 0, 0, "eraAbbr");
    addFormatToken2("NNNN", 0, 0, "eraName");
    addFormatToken2("NNNNN", 0, 0, "eraNarrow");
    addFormatToken2("y", ["y", 1], "yo", "eraYear");
    addFormatToken2("y", ["yy", 2], 0, "eraYear");
    addFormatToken2("y", ["yyy", 3], 0, "eraYear");
    addFormatToken2("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken2("N", matchEraAbbr);
    addRegexToken2("NN", matchEraAbbr);
    addRegexToken2("NNN", matchEraAbbr);
    addRegexToken2("NNNN", matchEraName);
    addRegexToken2("NNNNN", matchEraNarrow);
    addParseToken2(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config, token3) {
        var era = config._locale.erasParse(input, token3, config._strict);
        if (era) {
          getParsingFlags2(config).era = era;
        } else {
          getParsingFlags2(config).invalidEra = input;
        }
      }
    );
    addRegexToken2("y", matchUnsigned2);
    addRegexToken2("yy", matchUnsigned2);
    addRegexToken2("yyy", matchUnsigned2);
    addRegexToken2("yyyy", matchUnsigned2);
    addRegexToken2("yo", matchEraYearOrdinal);
    addParseToken2(["y", "yy", "yyy", "yyyy"], YEAR2);
    addParseToken2(["yo"], function(input, array, config, token3) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR2] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array[YEAR2] = parseInt(input, 10);
      }
    });
    addFormatToken2(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken2(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    addWeekYearFormatToken2("gggg", "weekYear");
    addWeekYearFormatToken2("ggggg", "weekYear");
    addWeekYearFormatToken2("GGGG", "isoWeekYear");
    addWeekYearFormatToken2("GGGGG", "isoWeekYear");
    addRegexToken2("G", matchSigned2);
    addRegexToken2("g", matchSigned2);
    addRegexToken2("GG", match1to22, match22);
    addRegexToken2("gg", match1to22, match22);
    addRegexToken2("GGGG", match1to42, match42);
    addRegexToken2("gggg", match1to42, match42);
    addRegexToken2("GGGGG", match1to62, match62);
    addRegexToken2("ggggg", match1to62, match62);
    addWeekParseToken2(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token3) {
        week[token3.substr(0, 2)] = toInt2(input);
      }
    );
    addWeekParseToken2(["gg", "GG"], function(input, week, config, token3) {
      week[token3] = hooks2.parseTwoDigitYear(input);
    });
    addFormatToken2("Q", 0, "Qo", "quarter");
    addRegexToken2("Q", match12);
    addParseToken2("Q", function(input, array) {
      array[MONTH2] = (toInt2(input) - 1) * 3;
    });
    addFormatToken2("D", ["DD", 2], "Do", "date");
    addRegexToken2("D", match1to22, match1to2NoLeadingZero);
    addRegexToken2("DD", match1to22, match22);
    addRegexToken2("Do", function(isStrict, locale3) {
      return isStrict ? locale3._dayOfMonthOrdinalParse || locale3._ordinalParse : locale3._dayOfMonthOrdinalParseLenient;
    });
    addParseToken2(["D", "DD"], DATE2);
    addParseToken2("Do", function(input, array) {
      array[DATE2] = toInt2(input.match(match1to22)[0]);
    });
    getSetDayOfMonth2 = makeGetSet2("Date", true);
    addFormatToken2("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addRegexToken2("DDD", match1to32);
    addRegexToken2("DDDD", match32);
    addParseToken2(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt2(input);
    });
    addFormatToken2("m", ["mm", 2], 0, "minute");
    addRegexToken2("m", match1to22, match1to2HasZero);
    addRegexToken2("mm", match1to22, match22);
    addParseToken2(["m", "mm"], MINUTE2);
    getSetMinute2 = makeGetSet2("Minutes", false);
    addFormatToken2("s", ["ss", 2], 0, "second");
    addRegexToken2("s", match1to22, match1to2HasZero);
    addRegexToken2("ss", match1to22, match22);
    addParseToken2(["s", "ss"], SECOND2);
    getSetSecond2 = makeGetSet2("Seconds", false);
    addFormatToken2("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken2(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken2(0, ["SSS", 3], 0, "millisecond");
    addFormatToken2(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken2(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken2(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken2(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken2(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken2(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addRegexToken2("S", match1to32, match12);
    addRegexToken2("SS", match1to32, match22);
    addRegexToken2("SSS", match1to32, match32);
    for (token2 = "SSSS"; token2.length <= 9; token2 += "S") {
      addRegexToken2(token2, matchUnsigned2);
    }
    for (token2 = "S"; token2.length <= 9; token2 += "S") {
      addParseToken2(token2, parseMs2);
    }
    getSetMillisecond2 = makeGetSet2("Milliseconds", false);
    addFormatToken2("z", 0, 0, "zoneAbbr");
    addFormatToken2("zz", 0, 0, "zoneName");
    proto4 = Moment2.prototype;
    proto4.add = add3;
    proto4.calendar = calendar$1;
    proto4.clone = clone4;
    proto4.diff = diff2;
    proto4.endOf = endOf2;
    proto4.format = format2;
    proto4.from = from2;
    proto4.fromNow = fromNow2;
    proto4.to = to2;
    proto4.toNow = toNow2;
    proto4.get = stringGet2;
    proto4.invalidAt = invalidAt2;
    proto4.isAfter = isAfter2;
    proto4.isBefore = isBefore2;
    proto4.isBetween = isBetween2;
    proto4.isSame = isSame2;
    proto4.isSameOrAfter = isSameOrAfter2;
    proto4.isSameOrBefore = isSameOrBefore2;
    proto4.isValid = isValid$2;
    proto4.lang = lang2;
    proto4.locale = locale2;
    proto4.localeData = localeData2;
    proto4.max = prototypeMax2;
    proto4.min = prototypeMin2;
    proto4.parsingFlags = parsingFlags2;
    proto4.set = stringSet2;
    proto4.startOf = startOf2;
    proto4.subtract = subtract3;
    proto4.toArray = toArray2;
    proto4.toObject = toObject2;
    proto4.toDate = toDate2;
    proto4.toISOString = toISOString3;
    proto4.inspect = inspect2;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto4[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto4.toJSON = toJSON2;
    proto4.toString = toString2;
    proto4.unix = unix2;
    proto4.valueOf = valueOf3;
    proto4.creationData = creationData2;
    proto4.eraName = getEraName;
    proto4.eraNarrow = getEraNarrow;
    proto4.eraAbbr = getEraAbbr;
    proto4.eraYear = getEraYear;
    proto4.year = getSetYear2;
    proto4.isLeapYear = getIsLeapYear2;
    proto4.weekYear = getSetWeekYear2;
    proto4.isoWeekYear = getSetISOWeekYear2;
    proto4.quarter = proto4.quarters = getSetQuarter2;
    proto4.month = getSetMonth2;
    proto4.daysInMonth = getDaysInMonth2;
    proto4.week = proto4.weeks = getSetWeek2;
    proto4.isoWeek = proto4.isoWeeks = getSetISOWeek2;
    proto4.weeksInYear = getWeeksInYear2;
    proto4.weeksInWeekYear = getWeeksInWeekYear;
    proto4.isoWeeksInYear = getISOWeeksInYear2;
    proto4.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto4.date = getSetDayOfMonth2;
    proto4.day = proto4.days = getSetDayOfWeek2;
    proto4.weekday = getSetLocaleDayOfWeek2;
    proto4.isoWeekday = getSetISODayOfWeek2;
    proto4.dayOfYear = getSetDayOfYear2;
    proto4.hour = proto4.hours = getSetHour2;
    proto4.minute = proto4.minutes = getSetMinute2;
    proto4.second = proto4.seconds = getSetSecond2;
    proto4.millisecond = proto4.milliseconds = getSetMillisecond2;
    proto4.utcOffset = getSetOffset2;
    proto4.utc = setOffsetToUTC2;
    proto4.local = setOffsetToLocal2;
    proto4.parseZone = setOffsetToParsedOffset2;
    proto4.hasAlignedHourOffset = hasAlignedHourOffset2;
    proto4.isDST = isDaylightSavingTime2;
    proto4.isLocal = isLocal2;
    proto4.isUtcOffset = isUtcOffset2;
    proto4.isUtc = isUtc2;
    proto4.isUTC = isUtc2;
    proto4.zoneAbbr = getZoneAbbr2;
    proto4.zoneName = getZoneName2;
    proto4.dates = deprecate2(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth2
    );
    proto4.months = deprecate2(
      "months accessor is deprecated. Use month instead",
      getSetMonth2
    );
    proto4.years = deprecate2(
      "years accessor is deprecated. Use year instead",
      getSetYear2
    );
    proto4.zone = deprecate2(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone2
    );
    proto4.isDSTShifted = deprecate2(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted2
    );
    proto$1 = Locale2.prototype;
    proto$1.calendar = calendar3;
    proto$1.longDateFormat = longDateFormat2;
    proto$1.invalidDate = invalidDate2;
    proto$1.ordinal = ordinal2;
    proto$1.preparse = preParsePostFormat2;
    proto$1.postformat = preParsePostFormat2;
    proto$1.relativeTime = relativeTime3;
    proto$1.pastFuture = pastFuture2;
    proto$1.set = set3;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths2;
    proto$1.monthsShort = localeMonthsShort2;
    proto$1.monthsParse = localeMonthsParse2;
    proto$1.monthsRegex = monthsRegex2;
    proto$1.monthsShortRegex = monthsShortRegex2;
    proto$1.week = localeWeek2;
    proto$1.firstDayOfYear = localeFirstDayOfYear2;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek2;
    proto$1.weekdays = localeWeekdays2;
    proto$1.weekdaysMin = localeWeekdaysMin2;
    proto$1.weekdaysShort = localeWeekdaysShort2;
    proto$1.weekdaysParse = localeWeekdaysParse2;
    proto$1.weekdaysRegex = weekdaysRegex2;
    proto$1.weekdaysShortRegex = weekdaysShortRegex2;
    proto$1.weekdaysMinRegex = weekdaysMinRegex2;
    proto$1.isPM = localeIsPM2;
    proto$1.meridiem = localeMeridiem2;
    getSetGlobalLocale2("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt2(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks2.lang = deprecate2(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale2
    );
    hooks2.langData = deprecate2(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale2
    );
    mathAbs2 = Math.abs;
    asMilliseconds2 = makeAs2("ms");
    asSeconds2 = makeAs2("s");
    asMinutes2 = makeAs2("m");
    asHours2 = makeAs2("h");
    asDays2 = makeAs2("d");
    asWeeks2 = makeAs2("w");
    asMonths2 = makeAs2("M");
    asQuarters = makeAs2("Q");
    asYears2 = makeAs2("y");
    valueOf$1 = asMilliseconds2;
    milliseconds2 = makeGetter2("milliseconds");
    seconds2 = makeGetter2("seconds");
    minutes2 = makeGetter2("minutes");
    hours2 = makeGetter2("hours");
    days2 = makeGetter2("days");
    months2 = makeGetter2("months");
    years2 = makeGetter2("years");
    round2 = Math.round;
    thresholds2 = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    abs$1 = Math.abs;
    proto$2 = Duration2.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs3;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as2;
    proto$2.asMilliseconds = asMilliseconds2;
    proto$2.asSeconds = asSeconds2;
    proto$2.asMinutes = asMinutes2;
    proto$2.asHours = asHours2;
    proto$2.asDays = asDays2;
    proto$2.asWeeks = asWeeks2;
    proto$2.asMonths = asMonths2;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears2;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble2;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds2;
    proto$2.seconds = seconds2;
    proto$2.minutes = minutes2;
    proto$2.hours = hours2;
    proto$2.days = days2;
    proto$2.weeks = weeks2;
    proto$2.months = months2;
    proto$2.years = years2;
    proto$2.humanize = humanize2;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale2;
    proto$2.localeData = localeData2;
    proto$2.toIsoString = deprecate2(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang2;
    addFormatToken2("X", 0, 0, "unix");
    addFormatToken2("x", 0, 0, "valueOf");
    addRegexToken2("x", matchSigned2);
    addRegexToken2("X", matchTimestamp2);
    addParseToken2("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken2("x", function(input, array, config) {
      config._d = new Date(toInt2(input));
    });
    hooks2.version = "2.30.1";
    setHookCallback2(createLocal2);
    hooks2.fn = proto4;
    hooks2.min = min2;
    hooks2.max = max2;
    hooks2.now = now2;
    hooks2.utc = createUTC2;
    hooks2.unix = createUnix2;
    hooks2.months = listMonths2;
    hooks2.isDate = isDate2;
    hooks2.locale = getSetGlobalLocale2;
    hooks2.invalid = createInvalid3;
    hooks2.duration = createDuration2;
    hooks2.isMoment = isMoment2;
    hooks2.weekdays = listWeekdays2;
    hooks2.parseZone = createInZone2;
    hooks2.localeData = getLocale2;
    hooks2.isDuration = isDuration2;
    hooks2.monthsShort = listMonthsShort2;
    hooks2.weekdaysMin = listWeekdaysMin2;
    hooks2.defineLocale = defineLocale2;
    hooks2.updateLocale = updateLocale2;
    hooks2.locales = listLocales2;
    hooks2.weekdaysShort = listWeekdaysShort2;
    hooks2.normalizeUnits = normalizeUnits2;
    hooks2.relativeTimeRounding = getSetRelativeTimeRounding2;
    hooks2.relativeTimeThreshold = getSetRelativeTimeThreshold2;
    hooks2.calendarFormat = getCalendarFormat2;
    hooks2.prototype = proto4;
    hooks2.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    moment_default2 = hooks2;
  }
});

// node_modules/pikaday/pikaday.js
var require_pikaday = __commonJS({
  "node_modules/pikaday/pikaday.js"(exports, module2) {
    (function(root, factory) {
      "use strict";
      var moment;
      if (typeof exports === "object") {
        try {
          moment = (init_moment(), __toCommonJS(moment_exports));
        } catch (e) {
        }
        module2.exports = factory(moment);
      } else if (typeof define === "function" && define.amd) {
        define(function(req) {
          var id = "moment";
          try {
            moment = req(id);
          } catch (e) {
          }
          return factory(moment);
        });
      } else {
        root.Pikaday = factory(root.moment);
      }
    })(exports, function(moment) {
      "use strict";
      var hasMoment = typeof moment === "function", hasEventListeners = !!window.addEventListener, document2 = window.document, sto = window.setTimeout, addEvent2 = function(el, e, callback, capture) {
        if (hasEventListeners) {
          el.addEventListener(e, callback, !!capture);
        } else {
          el.attachEvent("on" + e, callback);
        }
      }, removeEvent2 = function(el, e, callback, capture) {
        if (hasEventListeners) {
          el.removeEventListener(e, callback, !!capture);
        } else {
          el.detachEvent("on" + e, callback);
        }
      }, fireEvent = function(el, eventName, data) {
        var ev;
        if (document2.createEvent) {
          ev = document2.createEvent("HTMLEvents");
          ev.initEvent(eventName, true, false);
          ev = extend4(ev, data);
          el.dispatchEvent(ev);
        } else if (document2.createEventObject) {
          ev = document2.createEventObject();
          ev = extend4(ev, data);
          el.fireEvent("on" + eventName, ev);
        }
      }, trim = function(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }, hasClass2 = function(el, cn) {
        return (" " + el.className + " ").indexOf(" " + cn + " ") !== -1;
      }, addClass2 = function(el, cn) {
        if (!hasClass2(el, cn)) {
          el.className = el.className === "" ? cn : el.className + " " + cn;
        }
      }, removeClass2 = function(el, cn) {
        el.className = trim((" " + el.className + " ").replace(" " + cn + " ", " "));
      }, isArray3 = function(obj) {
        return /Array/.test(Object.prototype.toString.call(obj));
      }, isDate3 = function(obj) {
        return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
      }, isWeekend = function(date) {
        var day = date.getDay();
        return day === 0 || day === 6;
      }, isLeapYear3 = function(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }, getDaysInMonth3 = function(year, month) {
        return [31, isLeapYear3(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
      }, setToStartOfDay = function(date) {
        if (isDate3(date)) date.setHours(0, 0, 0, 0);
      }, compareDates = function(a, b) {
        return a.getTime() === b.getTime();
      }, extend4 = function(to3, from3, overwrite) {
        var prop, hasProp;
        for (prop in from3) {
          hasProp = to3[prop] !== void 0;
          if (hasProp && typeof from3[prop] === "object" && from3[prop] !== null && from3[prop].nodeName === void 0) {
            if (isDate3(from3[prop])) {
              if (overwrite) {
                to3[prop] = new Date(from3[prop].getTime());
              }
            } else if (isArray3(from3[prop])) {
              if (overwrite) {
                to3[prop] = from3[prop].slice(0);
              }
            } else {
              to3[prop] = extend4({}, from3[prop], overwrite);
            }
          } else if (overwrite || !hasProp) {
            to3[prop] = from3[prop];
          }
        }
        return to3;
      }, adjustCalendar = function(calendar4) {
        if (calendar4.month < 0) {
          calendar4.year -= Math.ceil(Math.abs(calendar4.month) / 12);
          calendar4.month += 12;
        }
        if (calendar4.month > 11) {
          calendar4.year += Math.floor(Math.abs(calendar4.month) / 12);
          calendar4.month -= 12;
        }
        return calendar4;
      }, defaults3 = {
        // bind the picker to a form field
        field: null,
        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
        bound: void 0,
        // position of the datepicker, relative to the field (default to bottom & left)
        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
        position: "bottom left",
        // automatically fit in the viewport even if it means repositioning from the position option
        reposition: true,
        // the default output format for `.toString()` and `field` value
        format: "YYYY-MM-DD",
        // the initial date to view when first opened
        defaultDate: null,
        // make the `defaultDate` the initial selected value
        setDefaultDate: false,
        // first day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,
        // the default flag for moment's strict date parsing
        formatStrict: false,
        // the minimum/earliest date that can be selected
        minDate: null,
        // the maximum/latest date that can be selected
        maxDate: null,
        // number of years either side, or array of upper/lower range
        yearRange: 10,
        // show week numbers at head of row
        showWeekNumber: false,
        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: void 0,
        maxMonth: void 0,
        startRange: null,
        endRange: null,
        isRTL: false,
        // Additional text to append to the year in the calendar title
        yearSuffix: "",
        // Render the month after year in the calendar title
        showMonthAfterYear: false,
        // Render days of the calendar grid that fall in the next or previous month
        showDaysInNextAndPreviousMonths: false,
        // how many months are visible
        numberOfMonths: 1,
        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
        // only used for the first display or when a selected date is not visible
        mainCalendar: "left",
        // Specify a DOM element to render the calendar in
        container: void 0,
        // internationalization
        i18n: {
          previousMonth: "Previous Month",
          nextMonth: "Next Month",
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        },
        // Theme Classname
        theme: null,
        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null
      }, renderDayName = function(opts, day, abbr) {
        day += opts.firstDay;
        while (day >= 7) {
          day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
      }, renderDay = function(opts) {
        var arr = [];
        var ariaSelected = "false";
        if (opts.isEmpty) {
          if (opts.showDaysInNextAndPreviousMonths) {
            arr.push("is-outside-current-month");
          } else {
            return '<td class="is-empty"></td>';
          }
        }
        if (opts.isDisabled) {
          arr.push("is-disabled");
        }
        if (opts.isToday) {
          arr.push("is-today");
        }
        if (opts.isSelected) {
          arr.push("is-selected");
          ariaSelected = "true";
        }
        if (opts.isInRange) {
          arr.push("is-inrange");
        }
        if (opts.isStartRange) {
          arr.push("is-startrange");
        }
        if (opts.isEndRange) {
          arr.push("is-endrange");
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(" ") + '" aria-selected="' + ariaSelected + '"><button class="pika-button pika-day" type="button" data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' + opts.day + "</button></td>";
      }, renderWeek = function(d, m, y) {
        var onejan = new Date(y, 0, 1), weekNum = Math.ceil(((new Date(y, m, d) - onejan) / 864e5 + onejan.getDay() + 1) / 7);
        return '<td class="pika-week">' + weekNum + "</td>";
      }, renderRow = function(days3, isRTL) {
        return "<tr>" + (isRTL ? days3.reverse() : days3).join("") + "</tr>";
      }, renderBody = function(rows) {
        return "<tbody>" + rows.join("") + "</tbody>";
      }, renderHead = function(opts) {
        var i, arr = [];
        if (opts.showWeekNumber) {
          arr.push("<th></th>");
        }
        for (i = 0; i < 7; i++) {
          arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + "</abbr></th>");
        }
        return "<thead><tr>" + (opts.isRTL ? arr.reverse() : arr).join("") + "</tr></thead>";
      }, renderTitle = function(instance, c, year, month, refYear, randId) {
        var i, j, arr, opts = instance._o, isMinYear = year === opts.minYear, isMaxYear = year === opts.maxYear, html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">', monthHtml, yearHtml, prev = true, next = true;
        for (arr = [], i = 0; i < 12; i++) {
          arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? ' selected="selected"' : "") + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? 'disabled="disabled"' : "") + ">" + opts.i18n.months[i] + "</option>");
        }
        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join("") + "</select></div>";
        if (isArray3(opts.yearRange)) {
          i = opts.yearRange[0];
          j = opts.yearRange[1] + 1;
        } else {
          i = year - opts.yearRange;
          j = 1 + year + opts.yearRange;
        }
        for (arr = []; i < j && i <= opts.maxYear; i++) {
          if (i >= opts.minYear) {
            arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"' : "") + ">" + i + "</option>");
          }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join("") + "</select></div>";
        if (opts.showMonthAfterYear) {
          html += yearHtml + monthHtml;
        } else {
          html += monthHtml + yearHtml;
        }
        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
          prev = false;
        }
        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
          next = false;
        }
        if (c === 0) {
          html += '<button class="pika-prev' + (prev ? "" : " is-disabled") + '" type="button">' + opts.i18n.previousMonth + "</button>";
        }
        if (c === instance._o.numberOfMonths - 1) {
          html += '<button class="pika-next' + (next ? "" : " is-disabled") + '" type="button">' + opts.i18n.nextMonth + "</button>";
        }
        return html += "</div>";
      }, renderTable = function(opts, data, randId) {
        return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + "</table>";
      }, Pikaday2 = function(options) {
        var self2 = this, opts = self2.config(options);
        self2._onMouseDown = function(e) {
          if (!self2._v) {
            return;
          }
          e = e || window.event;
          var target = e.target || e.srcElement;
          if (!target) {
            return;
          }
          if (!hasClass2(target, "is-disabled")) {
            if (hasClass2(target, "pika-button") && !hasClass2(target, "is-empty") && !hasClass2(target.parentNode, "is-disabled")) {
              self2.setDate(new Date(target.getAttribute("data-pika-year"), target.getAttribute("data-pika-month"), target.getAttribute("data-pika-day")));
              if (opts.bound) {
                sto(function() {
                  self2.hide();
                  if (opts.field) {
                    opts.field.blur();
                  }
                }, 100);
              }
            } else if (hasClass2(target, "pika-prev")) {
              self2.prevMonth();
            } else if (hasClass2(target, "pika-next")) {
              self2.nextMonth();
            }
          }
          if (!hasClass2(target, "pika-select")) {
            if (e.preventDefault) {
              e.preventDefault();
            } else {
              e.returnValue = false;
              return false;
            }
          } else {
            self2._c = true;
          }
        };
        self2._onChange = function(e) {
          e = e || window.event;
          var target = e.target || e.srcElement;
          if (!target) {
            return;
          }
          if (hasClass2(target, "pika-select-month")) {
            self2.gotoMonth(target.value);
          } else if (hasClass2(target, "pika-select-year")) {
            self2.gotoYear(target.value);
          }
        };
        self2._onKeyChange = function(e) {
          e = e || window.event;
          if (self2.isVisible()) {
            switch (e.keyCode) {
              case 13:
              case 27:
                opts.field.blur();
                break;
              case 37:
                e.preventDefault();
                self2.adjustDate("subtract", 1);
                break;
              case 38:
                self2.adjustDate("subtract", 7);
                break;
              case 39:
                self2.adjustDate("add", 1);
                break;
              case 40:
                self2.adjustDate("add", 7);
                break;
            }
          }
        };
        self2._onInputChange = function(e) {
          var date;
          if (e.firedBy === self2) {
            return;
          }
          if (hasMoment) {
            date = moment(opts.field.value, opts.format, opts.formatStrict);
            date = date && date.isValid() ? date.toDate() : null;
          } else {
            date = new Date(Date.parse(opts.field.value));
          }
          if (isDate3(date)) {
            self2.setDate(date);
          }
          if (!self2._v) {
            self2.show();
          }
        };
        self2._onInputFocus = function() {
          self2.show();
        };
        self2._onInputClick = function() {
          self2.show();
        };
        self2._onInputBlur = function() {
          var pEl = document2.activeElement;
          do {
            if (hasClass2(pEl, "pika-single")) {
              return;
            }
          } while (pEl = pEl.parentNode);
          if (!self2._c) {
            self2._b = sto(function() {
              self2.hide();
            }, 50);
          }
          self2._c = false;
        };
        self2._onClick = function(e) {
          e = e || window.event;
          var target = e.target || e.srcElement, pEl = target;
          if (!target) {
            return;
          }
          if (!hasEventListeners && hasClass2(target, "pika-select")) {
            if (!target.onchange) {
              target.setAttribute("onchange", "return;");
              addEvent2(target, "change", self2._onChange);
            }
          }
          do {
            if (hasClass2(pEl, "pika-single") || pEl === opts.trigger) {
              return;
            }
          } while (pEl = pEl.parentNode);
          if (self2._v && target !== opts.trigger && pEl !== opts.trigger) {
            self2.hide();
          }
        };
        self2.el = document2.createElement("div");
        self2.el.className = "pika-single" + (opts.isRTL ? " is-rtl" : "") + (opts.theme ? " " + opts.theme : "");
        addEvent2(self2.el, "mousedown", self2._onMouseDown, true);
        addEvent2(self2.el, "touchend", self2._onMouseDown, true);
        addEvent2(self2.el, "change", self2._onChange);
        addEvent2(document2, "keydown", self2._onKeyChange);
        if (opts.field) {
          if (opts.container) {
            opts.container.appendChild(self2.el);
          } else if (opts.bound) {
            document2.body.appendChild(self2.el);
          } else {
            opts.field.parentNode.insertBefore(self2.el, opts.field.nextSibling);
          }
          addEvent2(opts.field, "change", self2._onInputChange);
          if (!opts.defaultDate) {
            if (hasMoment && opts.field.value) {
              opts.defaultDate = moment(opts.field.value, opts.format).toDate();
            } else {
              opts.defaultDate = new Date(Date.parse(opts.field.value));
            }
            opts.setDefaultDate = true;
          }
        }
        var defDate = opts.defaultDate;
        if (isDate3(defDate)) {
          if (opts.setDefaultDate) {
            self2.setDate(defDate, true);
          } else {
            self2.gotoDate(defDate);
          }
        } else {
          self2.gotoDate(/* @__PURE__ */ new Date());
        }
        if (opts.bound) {
          this.hide();
          self2.el.className += " is-bound";
          addEvent2(opts.trigger, "click", self2._onInputClick);
          addEvent2(opts.trigger, "focus", self2._onInputFocus);
          addEvent2(opts.trigger, "blur", self2._onInputBlur);
        } else {
          this.show();
        }
      };
      Pikaday2.prototype = {
        /**
         * configure functionality
         */
        config: function(options) {
          if (!this._o) {
            this._o = extend4({}, defaults3, true);
          }
          var opts = extend4(this._o, options, true);
          opts.isRTL = !!opts.isRTL;
          opts.field = opts.field && opts.field.nodeName ? opts.field : null;
          opts.theme = typeof opts.theme === "string" && opts.theme ? opts.theme : null;
          opts.bound = !!(opts.bound !== void 0 ? opts.field && opts.bound : opts.field);
          opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
          opts.disableWeekends = !!opts.disableWeekends;
          opts.disableDayFn = typeof opts.disableDayFn === "function" ? opts.disableDayFn : null;
          var nom = parseInt(opts.numberOfMonths, 10) || 1;
          opts.numberOfMonths = nom > 4 ? 4 : nom;
          if (!isDate3(opts.minDate)) {
            opts.minDate = false;
          }
          if (!isDate3(opts.maxDate)) {
            opts.maxDate = false;
          }
          if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) {
            opts.maxDate = opts.minDate = false;
          }
          if (opts.minDate) {
            this.setMinDate(opts.minDate);
          }
          if (opts.maxDate) {
            this.setMaxDate(opts.maxDate);
          }
          if (isArray3(opts.yearRange)) {
            var fallback = (/* @__PURE__ */ new Date()).getFullYear() - 10;
            opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
            opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
          } else {
            opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults3.yearRange;
            if (opts.yearRange > 100) {
              opts.yearRange = 100;
            }
          }
          return opts;
        },
        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format4) {
          return !isDate3(this._d) ? "" : hasMoment ? moment(this._d).format(format4 || this._o.format) : this._d.toDateString();
        },
        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function() {
          return hasMoment ? moment(this._d) : null;
        },
        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect) {
          if (hasMoment && moment.isMoment(date)) {
            this.setDate(date.toDate(), preventOnSelect);
          }
        },
        /**
         * return a Date object of the current selection with fallback for the current date
         */
        getDate: function() {
          return isDate3(this._d) ? new Date(this._d.getTime()) : /* @__PURE__ */ new Date();
        },
        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect) {
          if (!date) {
            this._d = null;
            if (this._o.field) {
              this._o.field.value = "";
              fireEvent(this._o.field, "change", { firedBy: this });
            }
            return this.draw();
          }
          if (typeof date === "string") {
            date = new Date(Date.parse(date));
          }
          if (!isDate3(date)) {
            return;
          }
          var min3 = this._o.minDate, max3 = this._o.maxDate;
          if (isDate3(min3) && date < min3) {
            date = min3;
          } else if (isDate3(max3) && date > max3) {
            date = max3;
          }
          this._d = new Date(date.getTime());
          setToStartOfDay(this._d);
          this.gotoDate(this._d);
          if (this._o.field) {
            this._o.field.value = this.toString();
            fireEvent(this._o.field, "change", { firedBy: this });
          }
          if (!preventOnSelect && typeof this._o.onSelect === "function") {
            this._o.onSelect.call(this, this.getDate());
          }
        },
        /**
         * change view to a specific date
         */
        gotoDate: function(date) {
          var newCalendar = true;
          if (!isDate3(date)) {
            return;
          }
          if (this.calendars) {
            var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1), lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1), visibleDate = date.getTime();
            lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
            lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
            newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
          }
          if (newCalendar) {
            this.calendars = [{
              month: date.getMonth(),
              year: date.getFullYear()
            }];
            if (this._o.mainCalendar === "right") {
              this.calendars[0].month += 1 - this._o.numberOfMonths;
            }
          }
          this.adjustCalendars();
        },
        adjustDate: function(sign3, days3) {
          var day = this.getDate();
          var difference2 = parseInt(days3) * 24 * 60 * 60 * 1e3;
          var newDay;
          if (sign3 === "add") {
            newDay = new Date(day.valueOf() + difference2);
          } else if (sign3 === "subtract") {
            newDay = new Date(day.valueOf() - difference2);
          }
          if (hasMoment) {
            if (sign3 === "add") {
              newDay = moment(day).add(days3, "days").toDate();
            } else if (sign3 === "subtract") {
              newDay = moment(day).subtract(days3, "days").toDate();
            }
          }
          this.setDate(newDay);
        },
        adjustCalendars: function() {
          this.calendars[0] = adjustCalendar(this.calendars[0]);
          for (var c = 1; c < this._o.numberOfMonths; c++) {
            this.calendars[c] = adjustCalendar({
              month: this.calendars[0].month + c,
              year: this.calendars[0].year
            });
          }
          this.draw();
        },
        gotoToday: function() {
          this.gotoDate(/* @__PURE__ */ new Date());
        },
        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month) {
          if (!isNaN(month)) {
            this.calendars[0].month = parseInt(month, 10);
            this.adjustCalendars();
          }
        },
        nextMonth: function() {
          this.calendars[0].month++;
          this.adjustCalendars();
        },
        prevMonth: function() {
          this.calendars[0].month--;
          this.adjustCalendars();
        },
        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year) {
          if (!isNaN(year)) {
            this.calendars[0].year = parseInt(year, 10);
            this.adjustCalendars();
          }
        },
        /**
         * change the minDate
         */
        setMinDate: function(value) {
          if (value instanceof Date) {
            setToStartOfDay(value);
            this._o.minDate = value;
            this._o.minYear = value.getFullYear();
            this._o.minMonth = value.getMonth();
          } else {
            this._o.minDate = defaults3.minDate;
            this._o.minYear = defaults3.minYear;
            this._o.minMonth = defaults3.minMonth;
            this._o.startRange = defaults3.startRange;
          }
          this.draw();
        },
        /**
         * change the maxDate
         */
        setMaxDate: function(value) {
          if (value instanceof Date) {
            setToStartOfDay(value);
            this._o.maxDate = value;
            this._o.maxYear = value.getFullYear();
            this._o.maxMonth = value.getMonth();
          } else {
            this._o.maxDate = defaults3.maxDate;
            this._o.maxYear = defaults3.maxYear;
            this._o.maxMonth = defaults3.maxMonth;
            this._o.endRange = defaults3.endRange;
          }
          this.draw();
        },
        setStartRange: function(value) {
          this._o.startRange = value;
        },
        setEndRange: function(value) {
          this._o.endRange = value;
        },
        /**
         * refresh the HTML
         */
        draw: function(force) {
          if (!this._v && !force) {
            return;
          }
          var opts = this._o, minYear = opts.minYear, maxYear = opts.maxYear, minMonth = opts.minMonth, maxMonth = opts.maxMonth, html = "", randId;
          if (this._y <= minYear) {
            this._y = minYear;
            if (!isNaN(minMonth) && this._m < minMonth) {
              this._m = minMonth;
            }
          }
          if (this._y >= maxYear) {
            this._y = maxYear;
            if (!isNaN(maxMonth) && this._m > maxMonth) {
              this._m = maxMonth;
            }
          }
          randId = "pika-title-" + Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 2);
          for (var c = 0; c < opts.numberOfMonths; c++) {
            html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + "</div>";
          }
          this.el.innerHTML = html;
          if (opts.bound) {
            if (opts.field.type !== "hidden") {
              sto(function() {
                opts.trigger.focus();
              }, 1);
            }
          }
          if (typeof this._o.onDraw === "function") {
            this._o.onDraw(this);
          }
          if (opts.bound) {
            opts.field.setAttribute("aria-label", "Use the arrow keys to pick a date");
          }
        },
        adjustPosition: function() {
          var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left2, top2, clientRect;
          if (this._o.container) return;
          this.el.style.position = "absolute";
          field = this._o.trigger;
          pEl = field;
          width = this.el.offsetWidth;
          height = this.el.offsetHeight;
          viewportWidth = window.innerWidth || document2.documentElement.clientWidth;
          viewportHeight = window.innerHeight || document2.documentElement.clientHeight;
          scrollTop = window.pageYOffset || document2.body.scrollTop || document2.documentElement.scrollTop;
          if (typeof field.getBoundingClientRect === "function") {
            clientRect = field.getBoundingClientRect();
            left2 = clientRect.left + window.pageXOffset;
            top2 = clientRect.bottom + window.pageYOffset;
          } else {
            left2 = pEl.offsetLeft;
            top2 = pEl.offsetTop + pEl.offsetHeight;
            while (pEl = pEl.offsetParent) {
              left2 += pEl.offsetLeft;
              top2 += pEl.offsetTop;
            }
          }
          if (this._o.reposition && left2 + width > viewportWidth || this._o.position.indexOf("right") > -1 && left2 - width + field.offsetWidth > 0) {
            left2 = left2 - width + field.offsetWidth;
          }
          if (this._o.reposition && top2 + height > viewportHeight + scrollTop || this._o.position.indexOf("top") > -1 && top2 - height - field.offsetHeight > 0) {
            top2 = top2 - height - field.offsetHeight;
          }
          this.el.style.left = left2 + "px";
          this.el.style.top = top2 + "px";
        },
        /**
         * render HTML for a particular month
         */
        render: function(year, month, randId) {
          var opts = this._o, now3 = /* @__PURE__ */ new Date(), days3 = getDaysInMonth3(year, month), before = new Date(year, month, 1).getDay(), data = [], row = [];
          setToStartOfDay(now3);
          if (opts.firstDay > 0) {
            before -= opts.firstDay;
            if (before < 0) {
              before += 7;
            }
          }
          var previousMonth = month === 0 ? 11 : month - 1, nextMonth = month === 11 ? 0 : month + 1, yearOfPreviousMonth = month === 0 ? year - 1 : year, yearOfNextMonth = month === 11 ? year + 1 : year, daysInPreviousMonth = getDaysInMonth3(yearOfPreviousMonth, previousMonth);
          var cells = days3 + before, after = cells;
          while (after > 7) {
            after -= 7;
          }
          cells += 7 - after;
          for (var i = 0, r = 0; i < cells; i++) {
            var day = new Date(year, month, 1 + (i - before)), isSelected = isDate3(this._d) ? compareDates(day, this._d) : false, isToday = compareDates(day, now3), isEmpty2 = i < before || i >= days3 + before, dayNumber = 1 + (i - before), monthNumber = month, yearNumber = year, isStartRange = opts.startRange && compareDates(opts.startRange, day), isEndRange = opts.endRange && compareDates(opts.endRange, day), isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange, isDisabled2 = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);
            if (isEmpty2) {
              if (i < before) {
                dayNumber = daysInPreviousMonth + dayNumber;
                monthNumber = previousMonth;
                yearNumber = yearOfPreviousMonth;
              } else {
                dayNumber = dayNumber - days3;
                monthNumber = nextMonth;
                yearNumber = yearOfNextMonth;
              }
            }
            var dayConfig = {
              day: dayNumber,
              month: monthNumber,
              year: yearNumber,
              isSelected,
              isToday,
              isDisabled: isDisabled2,
              isEmpty: isEmpty2,
              isStartRange,
              isEndRange,
              isInRange,
              showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths
            };
            row.push(renderDay(dayConfig));
            if (++r === 7) {
              if (opts.showWeekNumber) {
                row.unshift(renderWeek(i - before, month, year));
              }
              data.push(renderRow(row, opts.isRTL));
              row = [];
              r = 0;
            }
          }
          return renderTable(opts, data, randId);
        },
        isVisible: function() {
          return this._v;
        },
        show: function() {
          if (!this.isVisible()) {
            removeClass2(this.el, "is-hidden");
            this._v = true;
            this.draw();
            if (this._o.bound) {
              addEvent2(document2, "click", this._onClick);
              this.adjustPosition();
            }
            if (typeof this._o.onOpen === "function") {
              this._o.onOpen.call(this);
            }
          }
        },
        hide: function() {
          var v = this._v;
          if (v !== false) {
            if (this._o.bound) {
              removeEvent2(document2, "click", this._onClick);
            }
            this.el.style.position = "static";
            this.el.style.left = "auto";
            this.el.style.top = "auto";
            addClass2(this.el, "is-hidden");
            this._v = false;
            if (v !== void 0 && typeof this._o.onClose === "function") {
              this._o.onClose.call(this);
            }
          }
        },
        /**
         * GAME OVER
         */
        destroy: function() {
          this.hide();
          removeEvent2(this.el, "mousedown", this._onMouseDown, true);
          removeEvent2(this.el, "touchend", this._onMouseDown, true);
          removeEvent2(this.el, "change", this._onChange);
          if (this._o.field) {
            removeEvent2(this._o.field, "change", this._onInputChange);
            if (this._o.bound) {
              removeEvent2(this._o.trigger, "click", this._onInputClick);
              removeEvent2(this._o.trigger, "focus", this._onInputFocus);
              removeEvent2(this._o.trigger, "blur", this._onInputBlur);
            }
          }
          if (this.el.parentNode) {
            this.el.parentNode.removeChild(this.el);
          }
        }
      };
      return Pikaday2;
    });
  }
});

// node_modules/handsontable/lib/SheetClip/SheetClip.js
var require_SheetClip = __commonJS({
  "node_modules/handsontable/lib/SheetClip/SheetClip.js"(exports) {
    (function(global2) {
      "use strict";
      function countQuotes(str) {
        return str.split('"').length - 1;
      }
      var SheetClip3 = {
        /**
         * Decode spreadsheet string into array
         *
         * @param {String} str
         * @returns {Array}
         */
        parse: function(str) {
          var r, rLen, rows, arr = [], a = 0, c, cLen, multiline, last;
          rows = str.replace(/\r\n|\r/g, "\n").split("\n");
          if (rows.length > 1 && rows[rows.length - 1] === "") {
            rows.pop();
          }
          for (r = 0, rLen = rows.length; r < rLen; r += 1) {
            rows[r] = rows[r].split("	");
            for (c = 0, cLen = rows[r].length; c < cLen; c += 1) {
              if (!arr[a]) {
                arr[a] = [];
              }
              if (multiline && c === 0) {
                last = arr[a].length - 1;
                arr[a][last] = arr[a][last] + "\n" + rows[r][0];
                if (multiline && countQuotes(rows[r][0]) & 1) {
                  multiline = false;
                  arr[a][last] = arr[a][last].substring(0, arr[a][last].length - 1).replace(/""/g, '"');
                }
              } else {
                if (c === cLen - 1 && rows[r][c].indexOf('"') === 0 && countQuotes(rows[r][c]) & 1) {
                  arr[a].push(rows[r][c].substring(1).replace(/""/g, '"'));
                  multiline = true;
                } else {
                  arr[a].push(rows[r][c].replace(/""/g, '"'));
                  multiline = false;
                }
              }
            }
            if (!multiline) {
              a += 1;
            }
          }
          return arr;
        },
        /**
         * Encode array into valid spreadsheet string
         *
         * @param arr
         * @returns {String}
         */
        stringify: function(arr) {
          var r, rLen, c, cLen, str = "", val;
          for (r = 0, rLen = arr.length; r < rLen; r += 1) {
            cLen = arr[r].length;
            for (c = 0; c < cLen; c += 1) {
              if (c > 0) {
                str += "	";
              }
              val = arr[r][c];
              if (typeof val === "string") {
                if (val.indexOf("\n") > -1) {
                  str += '"' + val.replace(/"/g, '""') + '"';
                } else {
                  str += val;
                }
              } else if (val === null || val === void 0) {
                str += "";
              } else {
                str += val;
              }
            }
            if (r !== rLen - 1) {
              str += "\n";
            }
          }
          return str;
        }
      };
      if (typeof exports !== "undefined") {
        exports.parse = SheetClip3.parse;
        exports.stringify = SheetClip3.stringify;
      } else {
        global2.SheetClip = SheetClip3;
      }
    })(window);
  }
});

// node_modules/handsontable/lib/jsonpatch/json-patch-duplex.js
var require_json_patch_duplex = __commonJS({
  "node_modules/handsontable/lib/jsonpatch/json-patch-duplex.js"(exports) {
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var OriginalError = Error;
    var jsonpatch2;
    (function(jsonpatch3) {
      var _objectKeys = function(obj) {
        if (_isArray(obj)) {
          var keys3 = new Array(obj.length);
          for (var k = 0; k < keys3.length; k++) {
            keys3[k] = "" + k;
          }
          return keys3;
        }
        if (Object.keys) {
          return Object.keys(obj);
        }
        var keys3 = [];
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            keys3.push(i);
          }
        }
        return keys3;
      };
      function _equals(a, b) {
        switch (typeof a) {
          case "undefined":
          case "boolean":
          case "string":
          case "number":
            return a === b;
          case "object":
            if (a === null)
              return b === null;
            if (_isArray(a)) {
              if (!_isArray(b) || a.length !== b.length)
                return false;
              for (var i = 0, l = a.length; i < l; i++)
                if (!_equals(a[i], b[i]))
                  return false;
              return true;
            }
            var bKeys = _objectKeys(b);
            var bLength = bKeys.length;
            if (_objectKeys(a).length !== bLength)
              return false;
            for (var i = 0; i < bLength; i++)
              if (!_equals(a[i], b[i]))
                return false;
            return true;
          default:
            return false;
        }
      }
      var objOps = {
        add: function(obj, key) {
          obj[key] = this.value;
          return true;
        },
        remove: function(obj, key) {
          delete obj[key];
          return true;
        },
        replace: function(obj, key) {
          obj[key] = this.value;
          return true;
        },
        move: function(obj, key, tree) {
          var temp = { op: "_get", path: this.from };
          apply(tree, [temp]);
          apply(tree, [
            { op: "remove", path: this.from }
          ]);
          apply(tree, [
            { op: "add", path: this.path, value: temp.value }
          ]);
          return true;
        },
        copy: function(obj, key, tree) {
          var temp = { op: "_get", path: this.from };
          apply(tree, [temp]);
          apply(tree, [
            { op: "add", path: this.path, value: temp.value }
          ]);
          return true;
        },
        test: function(obj, key) {
          return _equals(obj[key], this.value);
        },
        _get: function(obj, key) {
          this.value = obj[key];
        }
      };
      var arrOps = {
        add: function(arr, i) {
          arr.splice(i, 0, this.value);
          return true;
        },
        remove: function(arr, i) {
          arr.splice(i, 1);
          return true;
        },
        replace: function(arr, i) {
          arr[i] = this.value;
          return true;
        },
        move: objOps.move,
        copy: objOps.copy,
        test: objOps.test,
        _get: objOps._get
      };
      var rootOps = {
        add: function(obj) {
          rootOps.remove.call(this, obj);
          for (var key in this.value) {
            if (this.value.hasOwnProperty(key)) {
              obj[key] = this.value[key];
            }
          }
          return true;
        },
        remove: function(obj) {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              objOps.remove.call(this, obj, key);
            }
          }
          return true;
        },
        replace: function(obj) {
          apply(obj, [
            { op: "remove", path: this.path }
          ]);
          apply(obj, [
            { op: "add", path: this.path, value: this.value }
          ]);
          return true;
        },
        move: objOps.move,
        copy: objOps.copy,
        test: function(obj) {
          return JSON.stringify(obj) === JSON.stringify(this.value);
        },
        _get: function(obj) {
          this.value = obj;
        }
      };
      var observeOps = {
        add: function(patches, path) {
          var patch = {
            op: "add",
            path: path + escapePathComponent(this.name),
            value: this.object[this.name]
          };
          patches.push(patch);
        },
        "delete": function(patches, path) {
          var patch = {
            op: "remove",
            path: path + escapePathComponent(this.name)
          };
          patches.push(patch);
        },
        update: function(patches, path) {
          var patch = {
            op: "replace",
            path: path + escapePathComponent(this.name),
            value: this.object[this.name]
          };
          patches.push(patch);
        }
      };
      function escapePathComponent(str) {
        if (str.indexOf("/") === -1 && str.indexOf("~") === -1)
          return str;
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      function _getPathRecursive(root, obj) {
        var found;
        for (var key in root) {
          if (root.hasOwnProperty(key)) {
            if (root[key] === obj) {
              return escapePathComponent(key) + "/";
            } else if (typeof root[key] === "object") {
              found = _getPathRecursive(root[key], obj);
              if (found != "") {
                return escapePathComponent(key) + "/" + found;
              }
            }
          }
        }
        return "";
      }
      function getPath(root, obj) {
        if (root === obj) {
          return "/";
        }
        var path = _getPathRecursive(root, obj);
        if (path === "") {
          throw new OriginalError("Object not found in root");
        }
        return "/" + path;
      }
      var beforeDict = [];
      var Mirror = /* @__PURE__ */ function() {
        function Mirror2(obj) {
          this.observers = [];
          this.obj = obj;
        }
        return Mirror2;
      }();
      var ObserverInfo = /* @__PURE__ */ function() {
        function ObserverInfo2(callback, observer) {
          this.callback = callback;
          this.observer = observer;
        }
        return ObserverInfo2;
      }();
      function getMirror(obj) {
        for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {
          if (beforeDict[i].obj === obj) {
            return beforeDict[i];
          }
        }
      }
      function getObserverFromMirror(mirror, callback) {
        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {
          if (mirror.observers[j].callback === callback) {
            return mirror.observers[j].observer;
          }
        }
      }
      function removeObserverFromMirror(mirror, observer) {
        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {
          if (mirror.observers[j].observer === observer) {
            mirror.observers.splice(j, 1);
            return;
          }
        }
      }
      function unobserve(root, observer) {
        observer.unobserve();
      }
      jsonpatch3.unobserve = unobserve;
      function deepClone2(obj) {
        if (typeof obj === "object") {
          return JSON.parse(JSON.stringify(obj));
        } else {
          return obj;
        }
      }
      function observe(obj, callback) {
        var patches = [];
        var root = obj;
        var observer;
        var mirror = getMirror(obj);
        if (!mirror) {
          mirror = new Mirror(obj);
          beforeDict.push(mirror);
        } else {
          observer = getObserverFromMirror(mirror, callback);
        }
        if (observer) {
          return observer;
        }
        observer = {};
        mirror.value = deepClone2(obj);
        if (callback) {
          observer.callback = callback;
          observer.next = null;
          var intervals = this.intervals || [100, 1e3, 1e4, 6e4];
          if (intervals.push === void 0) {
            throw new OriginalError("jsonpatch.intervals must be an array");
          }
          var currentInterval = 0;
          var dirtyCheck = function() {
            generate(observer);
          };
          var fastCheck = function() {
            clearTimeout(observer.next);
            observer.next = setTimeout(function() {
              dirtyCheck();
              currentInterval = 0;
              observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
            }, 0);
          };
          var slowCheck = function() {
            dirtyCheck();
            if (currentInterval == intervals.length)
              currentInterval = intervals.length - 1;
            observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
          };
          if (typeof window !== "undefined") {
            if (window.addEventListener) {
              window.addEventListener("mousedown", fastCheck);
              window.addEventListener("mouseup", fastCheck);
              window.addEventListener("keydown", fastCheck);
            } else {
              document.documentElement.attachEvent("onmousedown", fastCheck);
              document.documentElement.attachEvent("onmouseup", fastCheck);
              document.documentElement.attachEvent("onkeydown", fastCheck);
            }
          }
          observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
        }
        observer.patches = patches;
        observer.object = obj;
        observer.unobserve = function() {
          generate(observer);
          clearTimeout(observer.next);
          removeObserverFromMirror(mirror, observer);
          if (mirror.observers.length === 0) {
            beforeDict.splice(beforeDict.indexOf(mirror), 1);
          }
          if (typeof window !== "undefined") {
            if (window.removeEventListener) {
              window.removeEventListener("mousedown", fastCheck);
              window.removeEventListener("mouseup", fastCheck);
              window.removeEventListener("keydown", fastCheck);
            } else {
              document.documentElement.detachEvent("onmousedown", fastCheck);
              document.documentElement.detachEvent("onmouseup", fastCheck);
              document.documentElement.detachEvent("onkeydown", fastCheck);
            }
          }
        };
        mirror.observers.push(new ObserverInfo(callback, observer));
        return observer;
      }
      jsonpatch3.observe = observe;
      function generate(observer) {
        var mirror;
        for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {
          if (beforeDict[i].obj === observer.object) {
            mirror = beforeDict[i];
            break;
          }
        }
        _generate(mirror.value, observer.object, observer.patches, "");
        if (observer.patches.length) {
          apply(mirror.value, observer.patches);
        }
        var temp = observer.patches;
        if (temp.length > 0) {
          observer.patches = [];
          if (observer.callback) {
            observer.callback(temp);
          }
        }
        return temp;
      }
      jsonpatch3.generate = generate;
      function _generate(mirror, obj, patches, path) {
        var newKeys = _objectKeys(obj);
        var oldKeys = _objectKeys(mirror);
        var changed = false;
        var deleted = false;
        for (var t = oldKeys.length - 1; t >= 0; t--) {
          var key = oldKeys[t];
          var oldVal = mirror[key];
          if (obj.hasOwnProperty(key)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
              _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key));
            } else {
              if (oldVal != newVal) {
                changed = true;
                patches.push({ op: "replace", path: path + "/" + escapePathComponent(key), value: deepClone2(newVal) });
              }
            }
          } else {
            patches.push({ op: "remove", path: path + "/" + escapePathComponent(key) });
            deleted = true;
          }
        }
        if (!deleted && newKeys.length == oldKeys.length) {
          return;
        }
        for (var t = 0; t < newKeys.length; t++) {
          var key = newKeys[t];
          if (!mirror.hasOwnProperty(key)) {
            patches.push({ op: "add", path: path + "/" + escapePathComponent(key), value: deepClone2(obj[key]) });
          }
        }
      }
      var _isArray;
      if (Array.isArray) {
        _isArray = Array.isArray;
      } else {
        _isArray = function(obj) {
          return obj.push && typeof obj.length === "number";
        };
      }
      function isInteger(str) {
        var i = 0;
        var len = str.length;
        var charCode;
        while (i < len) {
          charCode = str.charCodeAt(i);
          if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
          }
          return false;
        }
        return true;
      }
      function apply(tree, patches, validate2) {
        var result = false, p = 0, plen = patches.length, patch, key;
        while (p < plen) {
          patch = patches[p];
          p++;
          var path = patch.path || "";
          var keys3 = path.split("/");
          var obj = tree;
          var t = 1;
          var len = keys3.length;
          var existingPathFragment = void 0;
          while (true) {
            key = keys3[t];
            if (validate2) {
              if (existingPathFragment === void 0) {
                if (obj[key] === void 0) {
                  existingPathFragment = keys3.slice(0, t).join("/");
                } else if (t == len - 1) {
                  existingPathFragment = patch.path;
                }
                if (existingPathFragment !== void 0) {
                  this.validator(patch, p - 1, tree, existingPathFragment);
                }
              }
            }
            t++;
            if (key === void 0) {
              if (t >= len) {
                result = rootOps[patch.op].call(patch, obj, key, tree);
                break;
              }
            }
            if (_isArray(obj)) {
              if (key === "-") {
                key = obj.length;
              } else {
                if (validate2 && !isInteger(key)) {
                  throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", p - 1, patch.path, patch);
                }
                key = parseInt(key, 10);
              }
              if (t >= len) {
                if (validate2 && patch.op === "add" && key > obj.length) {
                  throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", p - 1, patch.path, patch);
                }
                result = arrOps[patch.op].call(patch, obj, key, tree);
                break;
              }
            } else {
              if (key && key.indexOf("~") != -1)
                key = key.replace(/~1/g, "/").replace(/~0/g, "~");
              if (t >= len) {
                result = objOps[patch.op].call(patch, obj, key, tree);
                break;
              }
            }
            obj = obj[key];
          }
        }
        return result;
      }
      jsonpatch3.apply = apply;
      function compare(tree1, tree2) {
        var patches = [];
        _generate(tree1, tree2, patches, "");
        return patches;
      }
      jsonpatch3.compare = compare;
      var JsonPatchError = function(_super) {
        __extends(JsonPatchError2, _super);
        function JsonPatchError2(message, name, index2, operation, tree) {
          _super.call(this, message);
          this.message = message;
          this.name = name;
          this.index = index2;
          this.operation = operation;
          this.tree = tree;
        }
        return JsonPatchError2;
      }(OriginalError);
      jsonpatch3.JsonPatchError = JsonPatchError;
      jsonpatch3.Error = JsonPatchError;
      function hasUndefined(obj) {
        if (obj === void 0) {
          return true;
        }
        if (typeof obj == "array" || typeof obj == "object") {
          for (var i in obj) {
            if (hasUndefined(obj[i])) {
              return true;
            }
          }
        }
        return false;
      }
      function validator2(operation, index2, tree, existingPathFragment) {
        if (typeof operation !== "object" || operation === null || _isArray(operation)) {
          throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index2, operation, tree);
        } else if (!objOps[operation.op]) {
          throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, tree);
        } else if (typeof operation.path !== "string") {
          throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index2, operation, tree);
        } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
          throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index2, operation, tree);
        } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
          throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index2, operation, tree);
        } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
          throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index2, operation, tree);
        } else if (tree) {
          if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
              throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index2, operation, tree);
            }
          } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
            if (operation.path !== existingPathFragment) {
              throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index2, operation, tree);
            }
          } else if (operation.op === "move" || operation.op === "copy") {
            var existingValue = { op: "_get", path: operation.from, value: void 0 };
            var error2 = jsonpatch3.validate([existingValue], tree);
            if (error2 && error2.name === "OPERATION_PATH_UNRESOLVABLE") {
              throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index2, operation, tree);
            }
          }
        }
      }
      jsonpatch3.validator = validator2;
      function validate(sequence, tree) {
        try {
          if (!_isArray(sequence)) {
            throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
          }
          if (tree) {
            tree = JSON.parse(JSON.stringify(tree));
            apply.call(this, tree, sequence, true);
          } else {
            for (var i = 0; i < sequence.length; i++) {
              this.validator(sequence[i], i);
            }
          }
        } catch (e) {
          if (e instanceof JsonPatchError) {
            return e;
          } else {
            throw e;
          }
        }
      }
      jsonpatch3.validate = validate;
    })(jsonpatch2 || (jsonpatch2 = {}));
    if (typeof exports !== "undefined") {
      exports.apply = jsonpatch2.apply;
      exports.observe = jsonpatch2.observe;
      exports.unobserve = jsonpatch2.unobserve;
      exports.generate = jsonpatch2.generate;
      exports.compare = jsonpatch2.compare;
      exports.validate = jsonpatch2.validate;
      exports.validator = jsonpatch2.validator;
      exports.JsonPatchError = jsonpatch2.JsonPatchError;
      exports.Error = jsonpatch2.Error;
    }
  }
});

// node_modules/@babel/polyfill/lib/noConflict.js
require_es6();
require_includes();
require_flat_map();
require_pad_start();
require_pad_end();
require_trim_start();
require_trim_end();
require_async_iterator();
require_get_own_property_descriptors();
require_values();
require_entries();
require_finally();
require_web();
require_runtime();

// node_modules/handsontable/es/utils/staticRegister.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
var collection = /* @__PURE__ */ new Map();
function staticRegister() {
  var namespace = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "common";
  if (!collection.has(namespace)) {
    collection.set(namespace, /* @__PURE__ */ new Map());
  }
  var subCollection = collection.get(namespace);
  function register7(name, item) {
    subCollection.set(name, item);
  }
  function getItem6(name) {
    return subCollection.get(name);
  }
  function hasItem5(name) {
    return subCollection.has(name);
  }
  function getNames5() {
    return _toConsumableArray(subCollection.keys());
  }
  function getValues5() {
    return _toConsumableArray(subCollection.values());
  }
  return {
    register: register7,
    getItem: getItem6,
    hasItem: hasItem5,
    getNames: getNames5,
    getValues: getValues5
  };
}

// node_modules/handsontable/es/helpers/array.js
var array_exports = {};
__export(array_exports, {
  arrayAvg: () => arrayAvg,
  arrayEach: () => arrayEach,
  arrayFilter: () => arrayFilter,
  arrayFlatten: () => arrayFlatten,
  arrayMap: () => arrayMap,
  arrayMax: () => arrayMax,
  arrayMin: () => arrayMin,
  arrayReduce: () => arrayReduce,
  arraySum: () => arraySum,
  arrayUnique: () => arrayUnique,
  extendArray: () => extendArray,
  pivot: () => pivot,
  to2dArray: () => to2dArray
});
function to2dArray(arr) {
  var ilen = arr.length;
  var i = 0;
  while (i < ilen) {
    arr[i] = [arr[i]];
    i += 1;
  }
}
function extendArray(arr, extension) {
  var ilen = extension.length;
  var i = 0;
  while (i < ilen) {
    arr.push(extension[i]);
    i += 1;
  }
}
function pivot(arr) {
  var pivotedArr = [];
  if (!arr || arr.length === 0 || !arr[0] || arr[0].length === 0) {
    return pivotedArr;
  }
  var rowCount = arr.length;
  var colCount = arr[0].length;
  for (var i = 0; i < rowCount; i++) {
    for (var j = 0; j < colCount; j++) {
      if (!pivotedArr[j]) {
        pivotedArr[j] = [];
      }
      pivotedArr[j][i] = arr[i][j];
    }
  }
  return pivotedArr;
}
function arrayReduce(array, iteratee, accumulator, initFromArray) {
  var index2 = -1;
  var iterable = array;
  var result = accumulator;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  if (initFromArray && length) {
    index2 += 1;
    result = iterable[index2];
  }
  index2 += 1;
  while (index2 < length) {
    result = iteratee(result, iterable[index2], index2, iterable);
    index2 += 1;
  }
  return result;
}
function arrayFilter(array, predicate) {
  var index2 = 0;
  var iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  var result = [];
  var resIndex = -1;
  while (index2 < length) {
    var value = iterable[index2];
    if (predicate(value, index2, iterable)) {
      resIndex += 1;
      result[resIndex] = value;
    }
    index2 += 1;
  }
  return result;
}
function arrayMap(array, iteratee) {
  var index2 = 0;
  var iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  var result = [];
  var resIndex = -1;
  while (index2 < length) {
    var value = iterable[index2];
    resIndex += 1;
    result[resIndex] = iteratee(value, index2, iterable);
    index2 += 1;
  }
  return result;
}
function arrayEach(array, iteratee) {
  var index2 = 0;
  var iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  var length = iterable.length;
  while (index2 < length) {
    if (iteratee(iterable[index2], index2, iterable) === false) {
      break;
    }
    index2 += 1;
  }
  return array;
}
function arraySum(array) {
  return arrayReduce(array, function(a, b) {
    return a + b;
  }, 0);
}
function arrayMax(array) {
  return arrayReduce(array, function(a, b) {
    return a > b ? a : b;
  }, Array.isArray(array) ? array[0] : void 0);
}
function arrayMin(array) {
  return arrayReduce(array, function(a, b) {
    return a < b ? a : b;
  }, Array.isArray(array) ? array[0] : void 0);
}
function arrayAvg(array) {
  if (!array.length) {
    return 0;
  }
  return arraySum(array) / array.length;
}
function arrayFlatten(array) {
  return arrayReduce(array, function(initial, value) {
    return initial.concat(Array.isArray(value) ? arrayFlatten(value) : value);
  }, []);
}
function arrayUnique(array) {
  var unique = [];
  arrayEach(array, function(value) {
    if (unique.indexOf(value) === -1) {
      unique.push(value);
    }
  });
  return unique;
}

// node_modules/handsontable/es/helpers/object.js
var object_exports = {};
__export(object_exports, {
  clone: () => clone,
  createObjectPropListener: () => createObjectPropListener,
  deepClone: () => deepClone,
  deepExtend: () => deepExtend,
  deepObjectSize: () => deepObjectSize,
  defineGetter: () => defineGetter,
  duckSchema: () => duckSchema,
  extend: () => extend,
  getProperty: () => getProperty,
  hasOwnProperty: () => hasOwnProperty,
  inherit: () => inherit,
  isObject: () => isObject,
  isObjectEqual: () => isObjectEqual,
  mixin: () => mixin,
  objectEach: () => objectEach
});
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function duckSchema(object) {
  var schema;
  if (Array.isArray(object)) {
    schema = [];
  } else {
    schema = {};
    objectEach(object, function(value, key) {
      if (key === "__children") {
        return;
      }
      if (value && _typeof(value) === "object" && !Array.isArray(value)) {
        schema[key] = duckSchema(value);
      } else if (Array.isArray(value)) {
        if (value.length && _typeof(value[0]) === "object" && !Array.isArray(value[0])) {
          schema[key] = [duckSchema(value[0])];
        } else {
          schema[key] = [];
        }
      } else {
        schema[key] = null;
      }
    });
  }
  return schema;
}
function inherit(Child, Parent) {
  Parent.prototype.constructor = Parent;
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;
  return Child;
}
function extend(target, extension) {
  objectEach(extension, function(value, key) {
    target[key] = value;
  });
  return target;
}
function deepExtend(target, extension) {
  objectEach(extension, function(value, key) {
    if (extension[key] && _typeof(extension[key]) === "object") {
      if (!target[key]) {
        if (Array.isArray(extension[key])) {
          target[key] = [];
        } else if (Object.prototype.toString.call(extension[key]) === "[object Date]") {
          target[key] = extension[key];
        } else {
          target[key] = {};
        }
      }
      deepExtend(target[key], extension[key]);
    } else {
      target[key] = extension[key];
    }
  });
}
function deepClone(obj) {
  if (_typeof(obj) === "object") {
    return JSON.parse(JSON.stringify(obj));
  }
  return obj;
}
function clone(object) {
  var result = {};
  objectEach(object, function(value, key) {
    result[key] = value;
  });
  return result;
}
function mixin(Base) {
  if (!Base.MIXINS) {
    Base.MIXINS = [];
  }
  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    mixins[_key - 1] = arguments[_key];
  }
  arrayEach(mixins, function(mixinItem) {
    Base.MIXINS.push(mixinItem.MIXIN_NAME);
    objectEach(mixinItem, function(value, key) {
      if (Base.prototype[key] !== void 0) {
        throw new Error("Mixin conflict. Property '".concat(key, "' already exist and cannot be overwritten."));
      }
      if (typeof value === "function") {
        Base.prototype[key] = value;
      } else {
        var getter = function _getter(property, initialValue) {
          var propertyName = "_".concat(property);
          var initValue = function initValue2(newValue) {
            var result = newValue;
            if (Array.isArray(result) || isObject(result)) {
              result = deepClone(result);
            }
            return result;
          };
          return function() {
            if (this[propertyName] === void 0) {
              this[propertyName] = initValue(initialValue);
            }
            return this[propertyName];
          };
        };
        var setter = function _setter(property) {
          var propertyName = "_".concat(property);
          return function(newValue) {
            this[propertyName] = newValue;
          };
        };
        Object.defineProperty(Base.prototype, key, {
          get: getter(key, value),
          set: setter(key),
          configurable: true
        });
      }
    });
  });
  return Base;
}
function isObjectEqual(object1, object2) {
  return JSON.stringify(object1) === JSON.stringify(object2);
}
function isObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function defineGetter(object, property, value, options) {
  options.value = value;
  options.writable = options.writable !== false;
  options.enumerable = options.enumerable !== false;
  options.configurable = options.configurable !== false;
  Object.defineProperty(object, property, options);
}
function objectEach(object, iteratee) {
  for (var key in object) {
    if (!object.hasOwnProperty || object.hasOwnProperty && Object.prototype.hasOwnProperty.call(object, key)) {
      if (iteratee(object[key], key, object) === false) {
        break;
      }
    }
  }
  return object;
}
function getProperty(object, name) {
  var names = name.split(".");
  var result = object;
  objectEach(names, function(nameItem) {
    result = result[nameItem];
    if (result === void 0) {
      result = void 0;
      return false;
    }
  });
  return result;
}
function deepObjectSize(object) {
  if (!isObject(object)) {
    return 0;
  }
  var recursObjLen = function recursObjLen2(obj) {
    var result = 0;
    if (isObject(obj)) {
      objectEach(obj, function(key) {
        result += recursObjLen2(key);
      });
    } else {
      result += 1;
    }
    return result;
  };
  return recursObjLen(object);
}
function createObjectPropListener(defaultValue) {
  var _holder;
  var propertyToListen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "value";
  var privateProperty = "_".concat(propertyToListen);
  var holder2 = (_holder = {
    _touched: false
  }, _defineProperty(_holder, privateProperty, defaultValue), _defineProperty(_holder, "isTouched", function isTouched() {
    return this._touched;
  }), _holder);
  Object.defineProperty(holder2, propertyToListen, {
    get: function get5() {
      return this[privateProperty];
    },
    set: function set5(value) {
      this._touched = true;
      this[privateProperty] = value;
    },
    enumerable: true,
    configurable: true
  });
  return holder2;
}
function hasOwnProperty(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}

// node_modules/handsontable/es/pluginHooks.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
var REGISTERED_HOOKS = [
  /**
   * Fired after resetting a cell's meta. This happens when the {@link Core#updateSettings} method is called.
   *
   * @event Hooks#afterCellMetaReset
   */
  "afterCellMetaReset",
  /**
   * Fired after one or more cells has been changed. The changes are triggered in any situation when the
   * value is entered using an editor or changed using API (e.q setDataAtCell)
   *
   * __Note:__ For performance reasons, the `changes` array is null for `"loadData"` source.
   *
   * @event Hooks#afterChange
   * @param {Array} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`.
   * @param {String} [source] String that identifies source of hook call ([list of all available sources]{@link https://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   * @example
   * ```js
   * new Handsontable(element, {
   *   afterChange: (changes) => {
   *     changes.forEach(([row, prop, oldValue, newValue]) => {
   *       // Some logic...
   *     });
   *   }
   * })
   * ```
   */
  "afterChange",
  /**
   * Fired by {@link ObserveChanges} plugin after detecting changes in the data source. This hook is fired when
   * {@link Options#observeChanges} option is enabled.
   *
   * @event Hooks#afterChangesObserved
   */
  "afterChangesObserved",
  /**
   * Fired by {@link ContextMenu} after setting up the Context Menu's default options. These options are a collection
   * which user can select by setting an array of keys or an array of objects in {@link Options#contextMenu} option.
   *
   * @event Hooks#afterContextMenuDefaultOptions
   * @param {Array} predefinedItems An array of objects containing information about the pre-defined Context Menu items.
   */
  "afterContextMenuDefaultOptions",
  /**
   * Fired by {@link ContextMenu} plugin before setting up the Context Menu's items but after filtering these options by
   * user (`contextMenu` option). This hook can by helpful to determine if user use specified menu item or to set up
   * one of the menu item to by always visible.
   *
   * @event Hooks#beforeContextMenuSetItems
   * @param {Object[]} menuItems An array of objects containing information about to generated Context Menu items.
   */
  "beforeContextMenuSetItems",
  /**
   * Fired by {@link DropdownMenu} plugin after setting up the Dropdown Menu's default options. These options are a
   * collection which user can select by setting an array of keys or an array of objects in {@link Options#dropdownMenu}
   * option.
   *
   * @pro
   * @event Hooks#afterDropdownMenuDefaultOptions
   * @param {Object[]} predefinedItems An array of objects containing information about the pre-defined Context Menu items.
   */
  "afterDropdownMenuDefaultOptions",
  /**
   * Fired by {@link DropdownMenu} plugin before setting up the Dropdown Menu's items but after filtering these options
   * by user (`dropdownMenu` option). This hook can by helpful to determine if user use specified menu item or to set
   * up one of the menu item to by always visible.
   *
   * @pro
   * @event Hooks#beforeDropdownMenuSetItems
   * @param {Object[]} menuItems An array of objects containing information about to generated Dropdown Menu items.
   */
  "beforeDropdownMenuSetItems",
  /**
   * Fired by {@link ContextMenu} plugin after hiding the Context Menu. This hook is fired when {@link Options#contextMenu}
   * option is enabled.
   *
   * @event Hooks#afterContextMenuHide
   * @param {Object} context The Context Menu plugin instance.
   */
  "afterContextMenuHide",
  /**
   * Fired by {@link ContextMenu} plugin before opening the Context Menu. This hook is fired when {@link Options#contextMenu}
   * option is enabled.
   *
   * @event Hooks#beforeContextMenuShow
   * @param {Object} context The Context Menu instance.
   */
  "beforeContextMenuShow",
  /**
   * Fired by {@link ContextMenu} plugin after opening the Context Menu. This hook is fired when {@link Options#contextMenu}
   * option is enabled.
   *
   * @event Hooks#afterContextMenuShow
   * @param {Object} context The Context Menu plugin instance.
   */
  "afterContextMenuShow",
  /**
   * Fired by {@link CopyPaste} plugin after reaching the copy limit while copying data. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#afterCopyLimit
   * @param {Number} selectedRows Count of selected copyable rows.
   * @param {Number} selectedColumns Count of selected copyable columns.
   * @param {Number} copyRowsLimit Current copy rows limit.
   * @param {Number} copyColumnsLimit Current copy columns limit.
   */
  "afterCopyLimit",
  /**
   * Fired before created a new column.
   *
   * @event Hooks#beforeCreateCol
   * @param {Number} index Represents the visual index of first newly created column in the data source array.
   * @param {Number} amount Number of newly created columns in the data source array.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "beforeCreateCol",
  /**
   * Fired after created a new column.
   *
   * @event Hooks#afterCreateCol
   * @param {Number} index Represents the visual index of first newly created column in the data source.
   * @param {Number} amount Number of newly created columns in the data source.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "afterCreateCol",
  /**
   * Fired before created a new row.
   *
   * @event Hooks#beforeCreateRow
   * @param {Number} index Represents the visual index of first newly created row in the data source array.
   * @param {Number} amount Number of newly created rows in the data source array.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "beforeCreateRow",
  /**
   * Fired after created a new row.
   *
   * @event Hooks#afterCreateRow
   * @param {Number} index Represents the visual index of first newly created row in the data source array.
   * @param {Number} amount Number of newly created rows in the data source array.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "afterCreateRow",
  /**
   * Fired after the current cell is deselected.
   *
   * @event Hooks#afterDeselect
   */
  "afterDeselect",
  /**
   * Fired after destroying the Handsontable instance.
   *
   * @event Hooks#afterDestroy
   */
  "afterDestroy",
  /**
   * General hook which captures `keydown` events attached to the document body. These events are delegated to the
   * hooks system and consumed by Core and internal modules (e.g plugins, editors).
   *
   * @event Hooks#afterDocumentKeyDown
   * @param {Event} event A native `keydown` event object.
   */
  "afterDocumentKeyDown",
  /**
   * Fired inside the Walkontable's selection `draw` method. Can be used to add additional class names to cells, depending on the current selection.
   *
   * @event Hooks#afterDrawSelection
   * @param {Number} currentRow Row index of the currently processed cell.
   * @param {Number} currentColumn Column index of the currently cell.
   * @param {Number[]} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
   * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.
   * @since 0.38.1
   * @returns {String|undefined} Can return a `String`, which will act as an additional `className` to be added to the currently processed cell.
   */
  "afterDrawSelection",
  /**
   * Fired inside the Walkontable's `refreshSelections` method. Can be used to remove additional class names from all cells in the table.
   *
   * @event Hooks#beforeRemoveCellClassNames
   * @since 0.38.1
   * @returns {String[]|undefined} Can return an `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
   */
  "beforeRemoveCellClassNames",
  /**
   * Fired after getting the cell settings.
   *
   * @event Hooks#afterGetCellMeta
   * @param {Number} row Visual row index.
   * @param {Number} column Visual column index.
   * @param {Object} cellProperties Object containing the cell properties.
   */
  "afterGetCellMeta",
  /**
   * Fired after retrieving information about a column header and appending it to the table header.
   *
   * @event Hooks#afterGetColHeader
   * @param {Number} column Visual column index.
   * @param {HTMLTableCellElement} TH Header's TH element.
   */
  "afterGetColHeader",
  /**
   * Fired after retrieving information about a row header and appending it to the table header.
   *
   * @event Hooks#afterGetRowHeader
   * @param {Number} row Visual row index.
   * @param {HTMLTableCellElement} TH Header's TH element.
   */
  "afterGetRowHeader",
  /**
   * Fired after the Handsontable instance is initiated.
   *
   * @event Hooks#afterInit
   */
  "afterInit",
  /**
   * Fired after new data is loaded (by `loadData` or `updateSettings` method) into the data source array.
   *
   * @event Hooks#afterLoadData
   * @param {Boolean} initialLoad flag that determines whether the data has been loaded during the initialization.
   */
  "afterLoadData",
  /**
   * Fired after a scroll event, which is identified as a momentum scroll (e.g. on an iPad).
   *
   * @event Hooks#afterMomentumScroll
   */
  "afterMomentumScroll",
  /**
   * Fired after a `mousedown` event is triggered on the cell corner (the drag handle).
   *
   * @event Hooks#afterOnCellCornerMouseDown
   * @param {Event} event `mousedown` event object.
   */
  "afterOnCellCornerMouseDown",
  /**
   * Fired after a `dblclick` event is triggered on the cell corner (the drag handle).
   *
   * @event Hooks#afterOnCellCornerDblClick
   * @param {Event} event `dblclick` event object.
   */
  "afterOnCellCornerDblClick",
  /**
   * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate
   * indexes are negative.
   *
   * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseDown` called
   * with coordinates `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellMouseDown
   * @param {Event} event `mousedown` event object.
   * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseDown",
  /**
   * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate
   * indexes are negative.
   *
   * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseUp` called
   * with coordinates `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellMouseUp
   * @param {Event} event `mouseup` event object.
   * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseUp",
  /**
   * Fired after clicking right mouse button on a cell or row/column header.
   *
   * For example clicking on the row header of cell (0, 0) results with `afterOnCellContextMenu` called
   * with coordinates `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellContextMenu
   * @since 4.1.0
   * @param {Event} event `contextmenu` event object.
   * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellContextMenu",
  /**
   * Fired after hovering a cell or row/column header with the mouse cursor. In case the row/column header was
   * hovered, the index is negative.
   *
   * For example, hovering over the row header of cell (0, 0) results with `afterOnCellMouseOver` called
   * with coords `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellMouseOver
   * @param {Event} event `mouseover` event object.
   * @param {CellCoords} coords Hovered cell's visual coordinate object.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseOver",
  /**
   * Fired after leaving a cell or row/column header with the mouse cursor.
   *
   * @event Hooks#afterOnCellMouseOut
   * @param {Event} event `mouseout` event object.
   * @param {CellCoords} coords Leaved cell's visual coordinate object.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseOut",
  /**
   * Fired after one or more columns are removed.
   *
   * @event Hooks#afterRemoveCol
   * @param {Number} index Visual index of starter column.
   * @param {Number} amount An amount of removed columns.
   * @param {Number[]} physicalColumns An array of physical columns removed from the data source.
   * @param {String} [source] String that identifies source of hook call ([list of all available sources]{@link https://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "afterRemoveCol",
  /**
   * Fired after one or more rows are removed.
   *
   * @event Hooks#afterRemoveRow
   * @param {Number} index Visual index of starter row.
   * @param {Number} amount An amount of removed rows.
   * @param {Number[]} physicalRows An array of physical rows removed from the data source.
   * @param {String} [source] String that identifies source of hook call ([list of all available sources]{@link https://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "afterRemoveRow",
  /**
   * Fired after the Handsontable table is rendered.
   *
   * @event Hooks#afterRender
   * @param {Boolean} isForced Is `true` if rendering was triggered by a change of settings or data; or `false` if
   *                           rendering was triggered by scrolling or moving selection.
   */
  "afterRender",
  /**
   * Fired before starting rendering the cell.
   *
   * @event Hooks#beforeRenderer
   * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.
   * @param {Number} row Visual row index.
   * @param {Number} column Visual column index.
   * @param {String|Number} prop Column property name or a column index, if datasource is an array of arrays.
   * @param {*} value Value of the rendered cell.
   * @param {Object} cellProperties Object containing the cell's properties.
   */
  "beforeRenderer",
  /**
   * Fired after finishing rendering the cell (after the renderer finishes).
   *
   * @event Hooks#afterRenderer
   * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.
   * @param {Number} row Visual row index.
   * @param {Number} column Visual column index.
   * @param {String|Number} prop Column property name or a column index, if datasource is an array of arrays.
   * @param {*} value Value of the rendered cell.
   * @param {Object} cellProperties Object containing the cell's properties.
   */
  "afterRenderer",
  /**
   * Fired after the horizontal scroll event.
   *
   * @event Hooks#afterScrollHorizontally
   */
  "afterScrollHorizontally",
  /**
   * Fired after the vertical scroll event.
   *
   * @event Hooks#afterScrollVertically
   */
  "afterScrollVertically",
  /**
   * Fired after one or more cells are selected (e.g. during mouse move).
   *
   * @event Hooks#afterSelection
   * @param {Number} row Selection start visual row index.
   * @param {Number} column Selection start visual column index.
   * @param {Number} row2 Selection end visual row index.
   * @param {Number} column2 Selection end visual column index.
   * @param {Object} preventScrolling Object with `value` property where its value change will be observed.
   * @param {Number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   * @example
   * ```js
   * new Handsontable(element, {
   *   afterSelection: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
   *     // setting if prevent scrolling after selection
   *     preventScrolling.value = true;
   *   }
   * })
   * ```
   */
  "afterSelection",
  /**
   * Fired after one or more cells are selected.
   *
   * The `prop` and `prop2` arguments represent the source object property name instead of the column number.
   *
   * @event Hooks#afterSelectionByProp
   * @param {Number} row Selection start visual row index.
   * @param {String} prop Selection start data source object property name.
   * @param {Number} row2 Selection end visual row index.
   * @param {String} prop2 Selection end data source object property name.
   * @param {Object} preventScrolling Object with `value` property where its value change will be observed.
   * @param {Number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   * @example
   * ```js
   * new Handsontable(element, {
   *   afterSelectionByProp: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
   *     // setting if prevent scrolling after selection
   *     preventScrolling.value = true;
   *   }
   * })
   * ```
   */
  "afterSelectionByProp",
  /**
   * Fired after one or more cells are selected (e.g. on mouse up).
   *
   * @event Hooks#afterSelectionEnd
   * @param {Number} row Selection start visual row index.
   * @param {Number} column Selection start visual column index.
   * @param {Number} row2 Selection end visual row index.
   * @param {Number} column2 Selection end visual column index.
   * @param {Number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   */
  "afterSelectionEnd",
  /**
   * Fired after one or more cells are selected (e.g. on mouse up).
   *
   * The `prop` and `prop2` arguments represent the source object property name instead of the column number.
   *
   * @event Hooks#afterSelectionEndByProp
   * @param {Number} row Selection start visual row index.
   * @param {String} prop Selection start data source object property index.
   * @param {Number} row2 Selection end visual row index.
   * @param {String} prop2 Selection end data source object property index.
   * @param {Number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   */
  "afterSelectionEndByProp",
  /**
   * Fired after cell meta is changed.
   *
   * @event Hooks#afterSetCellMeta
   * @param {Number} row Visual row index.
   * @param {Number} column Visual column index.
   * @param {String} key The updated meta key.
   * @param {*} value The updated meta value.
   */
  "afterSetCellMeta",
  /**
   * Fired after cell meta is removed.
   *
   * @event Hooks#afterRemoveCellMeta
   * @param {Number} row Visual row index.
   * @param {Number} column Visual column index.
   * @param {String} key The removed meta key.
   * @param {*} value Value which was under removed key of cell meta.
   */
  "afterRemoveCellMeta",
  /**
   * Fired after cell data was changed.
   *
   * @event Hooks#afterSetDataAtCell
   * @param {Array} changes An array of changes in format `[[row, column, oldValue, value], ...]`.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "afterSetDataAtCell",
  /**
   * Fired after cell data was changed.
   *
   * @event Hooks#afterSetDataAtRowProp
   * @param {Array} changes An array of changes in format `[[row, prop, oldValue, value], ...]`.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "afterSetDataAtRowProp",
  /**
   * Fired after calling the `updateSettings` method.
   *
   * @event Hooks#afterUpdateSettings
   * @param {Object} newSettings New settings object.
   */
  "afterUpdateSettings",
  /**
   * @description
   * A plugin hook executed after validator function, only if validator function is defined.
   * Validation result is the first parameter. This can be used to determinate if validation passed successfully or not.
   *
   * __Returning false from the callback will mark the cell as invalid.__
   *
   * @event Hooks#afterValidate
   * @param {Boolean} isValid `true` if valid, `false` if not.
   * @param {*} value The value in question.
   * @param {Number} row Visual row index.
   * @param {String|Number} prop Property name / visual column index.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "afterValidate",
  /**
   * Fired before successful change of language (when proper language code was set)
   *
   * @event Hooks#beforeLanguageChange
   * @since 0.35.0
   * @param {String} languageCode New language code.
   */
  "beforeLanguageChange",
  /**
   * Fired after successful change of language (when proper language code was set).
   *
   * @event Hooks#afterLanguageChange
   * @since 0.35.0
   * @param {String} languageCode New language code.
   */
  "afterLanguageChange",
  /**
   * Fired by {@link Autofill} plugin before populating the data in the autofill feature. This hook is fired when
   * {@link Options#fillHandle} option is enabled.
   *
   * @event Hooks#beforeAutofill
   * @param {CellCoords} start Object containing information about first filled cell: `{row: 2, col: 0}`.
   * @param {CellCoords} end Object containing information about last filled cell: `{row: 4, col: 1}`.
   * @param {Array[]} data 2D array containing information about fill pattern: `[["1", "Ted"], ["1", "John"]]`.
   */
  "beforeAutofill",
  /**
   * Fired before aligning the cell contents.
   *
   * @event Hooks#beforeCellAlignment
   * @param {Object} stateBefore An object with class names defining the cell alignment.
   * @param {CellRange[]} range An array of CellRange coordinates where the alignment will be applied.
   * @param {String} type Type of the alignment - either `horizontal` or `vertical`.
   * @param {String} alignmentClass String defining the alignment class added to the cell.
   * Possible values:
   * * `htLeft`
   * * `htCenter`
   * * `htRight`
   * * `htJustify`
   * * `htTop`
   * * `htMiddle`
   * * `htBottom`
   */
  "beforeCellAlignment",
  /**
   * Fired before one or more cells is changed. Its main purpose is to alter changes silently after input and before
   * table rendering.
   *
   * @event Hooks#beforeChange
   * @param {Array[]} changes 2D array containing information about each of the edited cells.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   * @example
   * ```js
   * // To disregard a single change, set changes[i] to null or remove it from array using changes.splice(i, 1).
   * new Handsontable(element, {
   *   beforeChange: (changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     changes[0] = null;
   *   }
   * });
   * // To alter a single change, overwrite the desired value to changes[i][3].
   * new Handsontable(element, {
   *   beforeChange: (changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     changes[0][3] = 10;
   *   }
   * });
   * // To cancel all edit, return false from the callback or set array length to 0 (changes.length = 0).
   * new Handsontable(element, {
   *   beforeChange: (changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     return false;
   *   }
   * });
   * ```
   */
  "beforeChange",
  /**
   * Fired right before rendering the changes.
   *
   * @event Hooks#beforeChangeRender
   * @param {Array[]} changes Array in form of `[row, prop, oldValue, newValue]`.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "beforeChangeRender",
  /**
   * Fired before drawing the borders.
   *
   * @event Hooks#beforeDrawBorders
   * @param {Array} corners Array specifying the current selection borders.
   * @param {String} borderClassName Specifies the border class name.
   */
  "beforeDrawBorders",
  /**
   * Fired before getting cell settings.
   *
   * @event Hooks#beforeGetCellMeta
   * @param {Number} row Visual row index.
   * @param {Number} column Visual column index.
   * @param {Object} cellProperties Object containing the cell's properties.
   */
  "beforeGetCellMeta",
  /**
   * Fired before cell meta is removed.
   *
   * @event Hooks#beforeRemoveCellMeta
   * @param {Number} row Visual row index.
   * @param {Number} column Visual column index.
   * @param {String} key The removed meta key.
   * @param {*} value Value which is under removed key of cell meta.
   */
  "beforeRemoveCellMeta",
  /**
   * Fired before the Handsontable instance is initiated.
   *
   * @event Hooks#beforeInit
   */
  "beforeInit",
  /**
   * Fired before the Walkontable instance is initiated.
   *
   * @event Hooks#beforeInitWalkontable
   * @param {Object} walkontableConfig Walkontable configuration object.
   */
  "beforeInitWalkontable",
  /**
   * Fired before keydown event is handled. It can be used to overwrite default key bindings.
   *
   * __Note__: To prevent default behavior you need to call `event.stopImmediatePropagation()` in your `beforeKeyDown`
   * handler.
   *
   * @event Hooks#beforeKeyDown
   * @param {Event} event Original DOM event.
   */
  "beforeKeyDown",
  /**
   * Fired after the user clicked a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellMouseDown
   * @param {Event} event The `mousedown` event object.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   * @param {Object} controller An object with keys `row`, `column` and `cells` which contains boolean values. This
   *                            object allows or disallows changing the selection for the particular axies.
   */
  "beforeOnCellMouseDown",
  /**
   * Fired after the user clicked a cell.
   *
   * @event Hooks#beforeOnCellMouseUp
   * @param {Event} event The `mouseup` event object.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   * @param {Object} controller An object with keys `row`, `column` and `cells` which contains boolean values. This
   *                            object allows or disallows changing the selection for the particular axies.
   */
  "beforeOnCellMouseUp",
  /**
   * Fired after the user clicked a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellContextMenu
   * @since 4.1.0
   * @param {Event} event The `contextmenu` event object.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   */
  "beforeOnCellContextMenu",
  /**
   * Fired after the user moved cursor over a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellMouseOver
   * @param {Event} event The `mouseover` event object.
   * @param {CellCoords} coords CellCoords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   * @param {Object} controller An object with keys `row`, `column` and `cells` which contains boolean values. This
   *                            object allows or disallows changing the selection for the particular axies.
   */
  "beforeOnCellMouseOver",
  /**
   * Fired after the user moved cursor out from a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellMouseOut
   * @param {Event} event The `mouseout` event object.
   * @param {CellCoords} coords CellCoords object containing the visual coordinates of the leaved cell.
   * @param {HTMLTableCellElement} TD TD element.
   */
  "beforeOnCellMouseOut",
  /**
   * Fired before one or more columns are about to be removed.
   *
   * @event Hooks#beforeRemoveCol
   * @param {Number} index Visual index of starter column.
   * @param {Number} amount Amount of columns to be removed.
   * @param {Number[]} physicalColumns An array of physical columns removed from the data source.
   * @param {String} [source] String that identifies source of hook call ([list of all available sources]{@link https://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "beforeRemoveCol",
  /**
   * Fired when one or more rows are about to be removed.
   *
   * @event Hooks#beforeRemoveRow
   * @param {Number} index Visual index of starter column.
   * @param {Number} amount Amount of columns to be removed.
   * @param {Number[]} physicalRows An array of physical rows removed from the data source.
   * @param {String} [source] String that identifies source of hook call ([list of all available sources]{@link https://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "beforeRemoveRow",
  /**
   * Fired before the Handsontable table is rendered.
   *
   * @event Hooks#beforeRender
   * @param {Boolean} isForced If `true` rendering was triggered by a change of settings or data; or `false` if
   *                           rendering was triggered by scrolling or moving selection.
   */
  "beforeRender",
  /**
   * Fired before setting range is started but not finished yet.
   *
   * @event Hooks#beforeSetRangeStartOnly
   * @param {CellCoords} coords CellCoords instance.
   */
  "beforeSetRangeStartOnly",
  /**
   * Fired before setting range is started.
   *
   * @event Hooks#beforeSetRangeStart
   * @param {CellCoords} coords CellCoords instance.
   */
  "beforeSetRangeStart",
  /**
   * Fired before setting range is ended.
   *
   * @event Hooks#beforeSetRangeEnd
   * @param {CellCoords} coords CellCoords instance.
   */
  "beforeSetRangeEnd",
  /**
   * Fired before the logic of handling a touch scroll, when user started scrolling on a touch-enabled device.
   *
   * @event Hooks#beforeTouchScroll
   */
  "beforeTouchScroll",
  /**
   * Fired before cell validation, only if validator function is defined. This can be used to manipulate the value
   * of changed cell before it is applied to the validator function.
   *
   * __Note:__ this will not affect values of changes. This will change value *ONLY* for validation
   *
   * @event Hooks#beforeValidate
   * @param {*} value Value of the cell.
   * @param {Number} row Visual row index.
   * @param {String|Number} prop Property name / column index.
   * @param {String} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).
   */
  "beforeValidate",
  /**
   * Fired before cell value is rendered into the DOM (through renderer function). This can be used to manipulate the
   * value which is passed to the renderer without modifying the renderer itself.
   *
   * @event Hooks#beforeValueRender
   * @param {*} value Cell value to render.
   * @param {Object} cellProperties An object containing the cell properties.
   */
  "beforeValueRender",
  /**
   * Fired after Handsontable instance is constructed (using `new` operator).
   *
   * @event Hooks#construct
   */
  "construct",
  /**
   * Fired after Handsontable instance is initiated but before table is rendered.
   *
   * @event Hooks#init
   */
  "init",
  /**
   * Fired when a column index is about to be modified by a callback function.
   *
   * @event Hooks#modifyCol
   * @param {Number} column Visual column index.
   */
  "modifyCol",
  /**
   * Fired when a column index is about to be de-modified by a callback function.
   *
   * @event Hooks#unmodifyCol
   * @param {Number} column Physical column index.
   */
  "unmodifyCol",
  /**
   * Fired when a physical row index is about to be de-modified by a callback function.
   *
   * @event Hooks#unmodifyRow
   * @param {Number} row Physical row index.
   */
  "unmodifyRow",
  /**
   * Fired when a column header index is about to be modified by a callback function.
   *
   * @event Hooks#modifyColHeader
   * @param {Number} column Visual column header index.
   */
  "modifyColHeader",
  /**
   * Fired when a column width is about to be modified by a callback function.
   *
   * @event Hooks#modifyColWidth
   * @param {Number} width Current column width.
   * @param {Number} column Visual column index.
   */
  "modifyColWidth",
  /**
   * Fired when a row index is about to be modified by a callback function.
   *
   * @event Hooks#modifyRow
   * @param {Number} row Visual row index.
   */
  "modifyRow",
  /**
   * Fired when a row header index is about to be modified by a callback function.
   *
   * @event Hooks#modifyRowHeader
   * @param {Number} row Visual row header index.
   */
  "modifyRowHeader",
  /**
   * Fired when a row height is about to be modified by a callback function.
   *
   * @event Hooks#modifyRowHeight
   * @param {Number} height Row height.
   * @param {Number} row Visual row index.
   */
  "modifyRowHeight",
  /**
   * Fired when a data was retrieved or modified.
   *
   * @event Hooks#modifyData
   * @param {Number} row Row height.
   * @param {Number} column Column index.
   * @param {Object} valueHolder Object which contains original value which can be modified by overwriting `.value` property.
   * @param {String} ioMode String which indicates for what operation hook is fired (`get` or `set`).
   */
  "modifyData",
  /**
   * Fired when a data was retrieved or modified.
   *
   * @event Hooks#modifyRowData
   * @param {Number} row Physical row index.
   */
  "modifyRowData",
  /**
   * Used to modify the cell coordinates when using the `getCell` method.
   *
   * @event Hooks#modifyGetCellCoords
   * @since 0.36.0
   * @param {Number} row Visual row index.
   * @param {Number} column Visual column index.
   * @param {Boolean} topmost If set to `true`, it returns the TD element from the topmost overlay. For example,
   *                          if the wanted cell is in the range of fixed rows, it will return a TD element
   *                          from the `top` overlay.
   */
  "modifyGetCellCoords",
  /**
   * Fired by {@link PersistentState} plugin, after loading value, saved under given key, from browser local storage. This hook is fired when
   * {@link Options#persistentState} option is enabled.
   *
   * @event Hooks#persistentStateLoad
   * @param {String} key Key.
   * @param {Object} valuePlaceholder Object containing the loaded value under `valuePlaceholder.value` (if no value have been saved, `value` key will be undefined).
   */
  "persistentStateLoad",
  /**
   * Fired by {@link PersistentState} plugin after resetting data from local storage. If no key is given, all values associated with table will be cleared.
   * This hook is fired when {@link Options#persistentState} option is enabled.
   *
   * @event Hooks#persistentStateReset
   * @param {String} [key] Key.
   */
  "persistentStateReset",
  /**
   * Fired by {@link PersistentState} plugin, after saving value under given key in browser local storage. This hook is fired when
   * {@link Options#persistentState} option is enabled.
   *
   * @event Hooks#persistentStateSave
   * @param {String} key Key.
   * @param {Mixed} value Value to save.
   */
  "persistentStateSave",
  /**
   * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins before sorting the column. If you return `false` value inside callback for hook, then sorting
   * will be not applied by the Handsontable (useful for server-side sorting).
   *
   * This hook is fired when {@link Options#columnSorting} or {@link Options#multiColumnSorting} option is enabled.
   *
   * @event Hooks#beforeColumnSort
   * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).
   * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).
   */
  "beforeColumnSort",
  /**
   * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins after sorting the column. This hook is fired when {@link Options#columnSorting}
   * or {@link Options#multiColumnSorting} option is enabled.
   *
   * @event Hooks#afterColumnSort
   * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).
   * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).
   */
  "afterColumnSort",
  /**
   * Fired by {@link Autofill} plugin after setting range of autofill. This hook is fired when {@link Options#fillHandle}
   * option is enabled.
   *
   * @event Hooks#modifyAutofillRange
   * @param {Array} startArea Array of visual coordinates of the starting point for the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).
   * @param {Array} entireArea Array of visual coordinates of the entire area of the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).
   */
  "modifyAutofillRange",
  /**
   * Fired to allow modifying the copyable range with a callback function.
   *
   * @event Hooks#modifyCopyableRange
   * @param {Array[]} copyableRanges Array of objects defining copyable cells.
   */
  "modifyCopyableRange",
  /**
   * Fired by {@link CopyPaste} plugin before copying the values into clipboard and before clearing values of
   * the selected cells. This hook is fired when {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#beforeCut
   * @param {Array[]} data An array of arrays which contains data to cut.
   * @param {Object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       which will be cut out.
   * @returns {*} If returns `false` then operation of the cutting out is canceled.
   * @example
   * ```js
   * // To disregard a single row, remove it from the array using data.splice(i, 1).
   * new Handsontable(element, {
   *   beforeCut: function(data, coords) {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }
   * });
   * // To cancel a cutting action, just return `false`.
   * new Handsontable(element, {
   *   beforeCut: function(data, coords) {
   *     return false;
   *   }
   * });
   * ```
   */
  "beforeCut",
  /**
   * Fired by {@link CopyPaste} plugin after data was cut out from the table. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#afterCut
   * @param {Array[]} data An array of arrays which contains the cutted out data.
   * @param {Object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       which was cut out.
   */
  "afterCut",
  /**
   * Fired before values are copied into clipboard.
   *
   * @event Hooks#beforeCopy
   * @param {Array[]} data An array of arrays which contains data to copied.
   * @param {Object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                         which will copied.
   * @returns {*} If returns `false` then copying is canceled.
   *
   * @example
   * ```js
   * // To disregard a single row, remove it from array using data.splice(i, 1).
   * ...
   * new Handsontable(document.getElementById('example'), {
   *   beforeCopy: (data, coords) => {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }
   * });
   * ...
   *
   * // To cancel copying, return false from the callback.
   * ...
   * new Handsontable(document.getElementById('example'), {
   *   beforeCopy: (data, coords) => {
   *     return false;
   *   }
   * });
   * ...
   * ```
   */
  "beforeCopy",
  /**
   * Fired by {@link CopyPaste} plugin after data are pasted into table. This hook is fired when {@link Options#copyPaste}
   * option is enabled.
   *
   * @event Hooks#afterCopy
   * @param {Array[]} data An array of arrays which contains the copied data.
   * @param {Object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                         which was copied.
   */
  "afterCopy",
  /**
   * Fired by {@link CopyPaste} plugin before values are pasted into table. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#beforePaste
   * @param {Array[]} data An array of arrays which contains data to paste.
   * @param {Object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       that correspond to the previously selected area.
   * @returns {*} If returns `false` then pasting is canceled.
   * @example
   * ```js
   * // To disregard a single row, remove it from array using data.splice(i, 1).
   * new Handsontable(example, {
   *   beforePaste: (data, coords) => {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }
   * });
   * // To cancel pasting, return false from the callback.
   * new Handsontable(example, {
   *   beforePaste: (data, coords) => {
   *     return false;
   *   }
   * });
   * ```
   */
  "beforePaste",
  /**
   * Fired by {@link CopyPaste} plugin after values are pasted into table. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#afterPaste
   * @param {Array[]} data An array of arrays which contains the pasted data.
   * @param {Object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       that correspond to the previously selected area.
   */
  "afterPaste",
  /**
   * Fired by {@link ManualColumnMove} plugin before change order of the visual indexes. This hook is fired when
   * {@link Options#manualColumnMove} option is enabled.
   *
   * @event Hooks#beforeColumnMove
   * @param {Number[]} columns Array of visual column indexes to be moved.
   * @param {Number} target Visual column index being a target for moved columns.
   */
  "beforeColumnMove",
  /**
   * Fired by {@link ManualColumnMove} plugin after changing order of the visual indexes. This hook is fired when
   * {@link Options#manualColumnMove} option is enabled.
   *
   * @event Hooks#afterColumnMove
   * @param {Number[]} columns Array of visual column indexes that were moved.
   * @param {Number} target Visual column index being a target for moved columns.
   */
  "afterColumnMove",
  /**
   * Fired by {@link ManualRowMove} plugin before change order of the visual indexes. This hook is fired when
   * {@link Options#manualRowMove} option is enabled.
   *
   * @event Hooks#beforeRowMove
   * @param {Number[]} rows An array of visual row indexes to be moved.
   * @param {Number} target Visual row index being a target for moved rows.
   */
  "beforeRowMove",
  /**
   * Fired by {@link ManualRowMove} plugin after change order of the visual indexes. This hook is fired when
   * {@link Options#manualRowMove} option is enabled.
   *
   * @event Hooks#afterRowMove
   * @param {Number[]} rows An array of visual row indexes that were moved.
   * @param {Number} target Visual row index being a target for moved rows.
   */
  "afterRowMove",
  /**
   * Fired by {@link ManualColumnResize} plugin before rendering the table with modified column sizes. This hook is
   * fired when {@link Options#manualColumnResize} option is enabled.
   *
   * @event Hooks#beforeColumnResize
   * @param {Number} currentColumn Visual index of the resized column.
   * @param {Number} newSize Calculated new column width.
   * @param {Boolean} isDoubleClick Flag that determines whether there was a double-click.
   * @returns {Number} Returns a new column size or `undefined`, if column size should be calculated automatically.
   */
  "beforeColumnResize",
  /**
   * Fired by {@link ManualColumnResize} plugin after rendering the table with modified column sizes. This hook is
   * fired when {@link Options#manualColumnResize} option is enabled.
   *
   * @event Hooks#afterColumnResize
   * @param {Number} currentColumn Visual index of the resized column.
   * @param {Number} newSize Calculated new column width.
   * @param {Boolean} isDoubleClick Flag that determines whether there was a double-click.
   */
  "afterColumnResize",
  /**
   * Fired by {@link ManualRowResize} plugin before rendering the table with modified row sizes. This hook is
   * fired when {@link Options#manualRowResize} option is enabled.
   *
   * @event Hooks#beforeRowResize
   * @param {Number} currentRow Visual index of the resized row.
   * @param {Number} newSize Calculated new row height.
   * @param {Boolean} isDoubleClick Flag that determines whether there was a double-click.
   * @returns {Number} Returns the new row size or `undefined` if row size should be calculated automatically.
   */
  "beforeRowResize",
  /**
   * Fired by {@link ManualRowResize} plugin after rendering the table with modified row sizes. This hook is
   * fired when {@link Options#manualRowResize} option is enabled.
   *
   * @event Hooks#afterRowResize
   * @param {Number} currentRow Visual index of the resized row.
   * @param {Number} newSize Calculated new row height.
   * @param {Boolean} isDoubleClick Flag that determines whether there was a double-click.
   */
  "afterRowResize",
  /**
   * Fired after getting the column header renderers.
   *
   * @event Hooks#afterGetColumnHeaderRenderers
   * @param {Function[]} renderers An array of the column header renderers.
   */
  "afterGetColumnHeaderRenderers",
  /**
   * Fired after getting the row header renderers.
   *
   * @event Hooks#afterGetRowHeaderRenderers
   * @param {Function[]} renderers An array of the row header renderers.
   */
  "afterGetRowHeaderRenderers",
  /**
   * Fired before applying stretched column width to column.
   *
   * @event Hooks#beforeStretchingColumnWidth
   * @param {Number} stretchedWidth Calculated width.
   * @param {Number} column Visual column index.
   * @returns {Number} Returns new width which will be applied to the column element.
   */
  "beforeStretchingColumnWidth",
  /**
   * Fired by {@link Filters} plugin before applying [filtering]{@link http://docs.handsontable.com/pro/demo-filtering.html}. This hook is fired when
   * {@link Options#filters} option is enabled.
   *
   * @pro
   * @event Hooks#beforeFilter
   * @param {Object[]} conditionsStack An array of objects with added formulas.
   * ```js
   * // Example format of the conditionsStack argument:
   * [
   *   {
   *     column: 2,
   *     conditions: [
   *       {name: 'begins_with', args: [['S']]}
   *     ],
   *     operation: 'conjunction'
   *   },
   *   {
   *     column: 4,
   *     conditions: [
   *       {name: 'not_empty', args: []}
   *     ],
   *     operation: 'conjunction'
   *   },
   * ]
   * ```
   * @returns {Boolean} If hook returns `false` value then filtering won't be applied on the UI side (server-side filtering).
   */
  "beforeFilter",
  /**
   * Fired by {@link Filters} plugin after applying [filtering]{@link http://docs.handsontable.com/pro/demo-filtering.html}. This hook is fired when
   * {@link Options#filters} option is enabled.
   *
   * @pro
   * @event Hooks#afterFilter
   * @param {Object[]} conditionsStack An array of objects with added conditions.
   * ```js
   * // Example format of the conditionsStack argument:
   * [
   *   {
   *     column: 2,
   *     conditions: [
   *       {name: 'begins_with', args: [['S']]}
   *     ],
   *     operation: 'conjunction'
   *   },
   *   {
   *     column: 4,
   *     conditions: [
   *       {name: 'not_empty', args: []}
   *     ],
   *     operation: 'conjunction'
   *   },
   * ]
   * ```
   */
  "afterFilter",
  /**
   * Fired while retrieving the column header height.
   *
   * @event Hooks#modifyColumnHeaderHeight
   */
  "modifyColumnHeaderHeight",
  /**
   * Fired by {@link UndoRedo} plugin before the undo action. Contains information about the action that is being undone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#beforeUndo
   * @param {Object} action The action object. Contains information about the action being undone. The `actionType`
   *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).
   */
  "beforeUndo",
  /**
   * Fired by {@link UndoRedo} plugin after the undo action. Contains information about the action that is being undone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#afterUndo
   * @param {Object} action The action object. Contains information about the action being undone. The `actionType`
   *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).
   */
  "afterUndo",
  /**
   * Fired by {@link UndoRedo} plugin before the redo action. Contains information about the action that is being redone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#beforeRedo
   * @param {Object} action The action object. Contains information about the action being redone. The `actionType`
   *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).
   */
  "beforeRedo",
  /**
   * Fired by {@link UndoRedo} plugin after the redo action. Contains information about the action that is being redone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#afterRedo
   * @param {Object} action The action object. Contains information about the action being redone. The `actionType`
   *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).
   */
  "afterRedo",
  /**
   * Fired while retrieving the row header width.
   *
   * @event Hooks#modifyRowHeaderWidth
   * @param {Number} rowHeaderWidth Row header width.
   */
  "modifyRowHeaderWidth",
  /**
   * Fired from the `populateFromArray` method during the `autofill` process. Fired for each "autofilled" cell individually.
   *
   * @event Hooks#beforeAutofillInsidePopulate
   * @param {Object} index Object containing `row` and `col` properties, defining the number of rows/columns from the initial cell of the autofill.
   * @param {String} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.
   * @param {Array[]} input Contains an array of rows with data being used in the autofill.
   * @param {Array} deltas The deltas array passed to the `populateFromArray` method.
   */
  "beforeAutofillInsidePopulate",
  /**
   * Fired when the start of the selection is being modified (e.g. moving the selection with the arrow keys).
   *
   * @event Hooks#modifyTransformStart
   * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.
   */
  "modifyTransformStart",
  /**
   * Fired when the end of the selection is being modified (e.g. moving the selection with the arrow keys).
   *
   * @event Hooks#modifyTransformEnd
   * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.
   */
  "modifyTransformEnd",
  /**
   * Fired after the start of the selection is being modified (e.g. moving the selection with the arrow keys).
   *
   * @event Hooks#afterModifyTransformStart
   * @param {CellCoords} coords Coords of the freshly selected cell.
   * @param {Number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.
   * @param {Number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.
   */
  "afterModifyTransformStart",
  /**
   * Fired after the end of the selection is being modified (e.g. moving the selection with the arrow keys).
   *
   * @event Hooks#afterModifyTransformEnd
   * @param {CellCoords} coords Visual coords of the freshly selected cell.
   * @param {Number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.
   * @param {Number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.
   */
  "afterModifyTransformEnd",
  /**
   * Fired inside the `viewportRowCalculatorOverride` method. Allows modifying the row calculator parameters.
   *
   * @event Hooks#afterViewportRowCalculatorOverride
   * @param {Object} calc The row calculator.
   */
  "afterViewportRowCalculatorOverride",
  /**
   * Fired inside the `viewportColumnCalculatorOverride` method. Allows modifying the row calculator parameters.
   *
   * @event Hooks#afterViewportColumnCalculatorOverride
   * @param {Object} calc The row calculator.
   */
  "afterViewportColumnCalculatorOverride",
  /**
   * Fired after initializing all the plugins.
   *
   * @event Hooks#afterPluginsInitialized
   */
  "afterPluginsInitialized",
  /**
   * Used to skip the length cache calculation for a defined period of time.
   *
   * @event Hooks#skipLengthCache
   * @param {Number} delay The delay in milliseconds.
   */
  "skipLengthCache",
  /**
   * Fired by {@link TrimRows} plugin after trimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @pro
   * @event Hooks#afterTrimRow
   * @param {Number[]} rows Physical indexes of trimmed rows.
   */
  "afterTrimRow",
  /**
   * Fired by {@link TrimRows} plugin after untrimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @pro
   * @event Hooks#afterUntrimRow
   * @param {Number[]} rows Physical indexes of untrimmed rows.
   */
  "afterUntrimRow",
  /**
   * Fired by {@link DropdownMenu} plugin before opening the dropdown menu. This hook is fired when {@link Options#dropdownMenu}
   * option is enabled.
   *
   * @pro
   * @event Hooks#beforeDropdownMenuShow
   * @param {DropdownMenu} dropdownMenu The DropdownMenu instance.
   */
  "beforeDropdownMenuShow",
  /**
   * Fired by {@link DropdownMenu} plugin after opening the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}
   * option is enabled.
   *
   * @pro
   * @event Hooks#afterDropdownMenuShow
   * @param {DropdownMenu} dropdownMenu The DropdownMenu instance.
   */
  "afterDropdownMenuShow",
  /**
   * Fired by {@link DropdownMenu} plugin after hiding the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}
   * option is enabled.
   *
   * @pro
   * @event Hooks#afterDropdownMenuHide
   * @param {DropdownMenu} instance The DropdownMenu instance.
   */
  "afterDropdownMenuHide",
  /**
   * Fired by {@link HiddenRows} plugin to check whether the provided row index is hidden. This hook is fired when
   * {@link Options#hiddenRows} option is enabled.
   *
   * @pro
   * @event Hooks#hiddenRow
   * @param {Number} row The visual row index in question.
   */
  "hiddenRow",
  /**
   * Fired by {@link HiddenColumns} plugin to check whether the provided column index is hidden. This hook is fired when
   * {@link Options#hiddenColumns} option is enabled.
   *
   * @pro
   * @event Hooks#hiddenColumn
   * @param {Number} column The visual column index in question.
   */
  "hiddenColumn",
  /**
   * Fired by {@link NestedRows} plugin before adding a children to the NestedRows structure. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @pro
   * @event Hooks#beforeAddChild
   * @param {Object} parent The parent object.
   * @param {Object|undefined} element The element added as a child. If `undefined`, a blank child was added.
   * @param {Number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.
   */
  "beforeAddChild",
  /**
   * Fired by {@link NestedRows} plugin after adding a children to the NestedRows structure. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @pro
   * @event Hooks#afterAddChild
   * @param {Object} parent The parent object.
   * @param {Object|undefined} element The element added as a child. If `undefined`, a blank child was added.
   * @param {Number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.
   */
  "afterAddChild",
  /**
   * Fired by {@link NestedRows} plugin before detaching a child from its parent. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @pro
   * @event Hooks#beforeDetachChild
   * @param {Object} parent An object representing the parent from which the element is to be detached.
   * @param {Object} element The detached element.
   */
  "beforeDetachChild",
  /**
   * Fired by {@link NestedRows} plugin after detaching a child from its parent. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @pro
   * @event Hooks#afterDetachChild
   * @param {Object} parent An object representing the parent from which the element was detached.
   * @param {Object} element The detached element.
   */
  "afterDetachChild",
  /**
   * Fired after the editor is opened and rendered.
   *
   * @event Hooks#afterBeginEditing
   * @param {Number} row Visual row index of the edited cell.
   * @param {Number} column Visual column index of the edited cell.
   */
  "afterBeginEditing",
  /**
   * Fired by {@link MergeCells} plugin before cell merging. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#beforeMergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {Boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "beforeMergeCells",
  /**
   * Fired by {@link MergeCells} plugin after cell merging. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#afterMergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {Object} mergeParent The parent collection of the provided cell range.
   * @param {Boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "afterMergeCells",
  /**
   * Fired by {@link MergeCells} plugin before unmerging the cells. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#beforeUnmergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {Boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "beforeUnmergeCells",
  /**
   * Fired by {@link MergeCells} plugin after unmerging the cells. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#afterUnmergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {Boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "afterUnmergeCells",
  /**
   * Fired after the table was switched into listening mode. This allows Handsontable to capture keyboard events and
   * respond in the right way.
   *
   * @event Hooks#afterListen
   */
  "afterListen",
  /**
   * Fired after the table was switched off from the listening mode. This makes the Handsontable inert for any
   * keyboard events.
   *
   * @event Hooks#afterUnlisten
   */
  "afterUnlisten"
];
var Hooks = function() {
  _createClass(Hooks2, null, [{
    key: "getSingleton",
    value: function getSingleton() {
      return getGlobalSingleton();
    }
    /**
     *
     */
  }]);
  function Hooks2() {
    _classCallCheck(this, Hooks2);
    this.globalBucket = this.createEmptyBucket();
  }
  _createClass(Hooks2, [{
    key: "createEmptyBucket",
    value: function createEmptyBucket() {
      var bucket = /* @__PURE__ */ Object.create(null);
      arrayEach(REGISTERED_HOOKS, function(hook2) {
        return bucket[hook2] = [];
      });
      return bucket;
    }
    /**
     * Get hook bucket based on the context of the object or if argument is `undefined`, get the global hook bucket.
     *
     * @param {Object} [context=null] A Handsontable instance.
     * @returns {Object} Returns a global or Handsontable instance bucket.
     */
  }, {
    key: "getBucket",
    value: function getBucket() {
      var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (context) {
        if (!context.pluginHookBucket) {
          context.pluginHookBucket = this.createEmptyBucket();
        }
        return context.pluginHookBucket;
      }
      return this.globalBucket;
    }
    /**
     * Adds a listener (globally or locally) to a specified hook name.
     * If the `context` parameter is provided, the hook will be added only to the instance it references.
     * Otherwise, the callback will be used everytime the hook fires on any Handsontable instance.
     * You can provide an array of callback functions as the `callback` argument, this way they will all be fired
     * once the hook is triggered.
     *
     * @see Core#addHook
     * @param {String} key Hook name.
     * @param {Function|Array} callback Callback function or an array of functions.
     * @param {Object} [context=null] The context for the hook callback to be added - a Handsontable instance or leave empty.
     * @returns {Hooks} Instance of Hooks.
     *
     * @example
     * ```js
     * // single callback, added locally
     * Handsontable.hooks.add('beforeInit', myCallback, hotInstance);
     *
     * // single callback, added globally
     * Handsontable.hooks.add('beforeInit', myCallback);
     *
     * // multiple callbacks, added locally
     * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback], hotInstance);
     *
     * // multiple callbacks, added globally
     * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback]);
     * ```
     */
  }, {
    key: "add",
    value: function add5(key, callback) {
      var _this = this;
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (Array.isArray(callback)) {
        arrayEach(callback, function(c) {
          return _this.add(key, c, context);
        });
      } else {
        var bucket = this.getBucket(context);
        if (typeof bucket[key] === "undefined") {
          this.register(key);
          bucket[key] = [];
        }
        callback.skip = false;
        if (bucket[key].indexOf(callback) === -1) {
          var foundInitialHook = false;
          if (callback.initialHook) {
            arrayEach(bucket[key], function(cb, i) {
              if (cb.initialHook) {
                bucket[key][i] = callback;
                foundInitialHook = true;
                return false;
              }
            });
          }
          if (!foundInitialHook) {
            bucket[key].push(callback);
          }
        }
      }
      return this;
    }
    /**
     * Adds a listener to a specified hook. After the hook runs this listener will be automatically removed from the bucket.
     *
     * @see Core#addHookOnce
     * @param {String} key Hook/Event name.
     * @param {Function|Array} callback Callback function.
     * @param {Object} [context=null] A Handsontable instance.
     *
     * @example
     * ```js
     * Handsontable.hooks.once('beforeInit', myCallback, hotInstance);
     * ```
     */
  }, {
    key: "once",
    value: function once(key, callback) {
      var _this2 = this;
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (Array.isArray(callback)) {
        arrayEach(callback, function(c) {
          return _this2.once(key, c, context);
        });
      } else {
        callback.runOnce = true;
        this.add(key, callback, context);
      }
    }
    /**
     * Removes a listener from a hook with a given name. If the `context` argument is provided, it removes a listener from a local hook assigned to the given Handsontable instance.
     *
     * @see Core#removeHook
     * @param {String} key Hook/Event name.
     * @param {Function} callback Callback function (needs the be the function that was previously added to the hook).
     * @param {Object} [context=null] Handsontable instance.
     * @return {Boolean} Returns `true` if hook was removed, `false` otherwise.
     *
     * @example
     * ```js
     * Handsontable.hooks.remove('beforeInit', myCallback);
     * ```
     */
  }, {
    key: "remove",
    value: function remove(key, callback) {
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var bucket = this.getBucket(context);
      if (typeof bucket[key] !== "undefined") {
        if (bucket[key].indexOf(callback) >= 0) {
          callback.skip = true;
          return true;
        }
      }
      return false;
    }
    /**
     * Checks whether there are any registered listeners for the provided hook name.
     * If the `context` parameter is provided, it only checks for listeners assigned to the given Handsontable instance.
     *
     * @param {String} key Hook name.
     * @param {Object} [context=null] A Handsontable instance.
     * @returns {Boolean} `true` for success, `false` otherwise.
     */
  }, {
    key: "has",
    value: function has(key) {
      var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var bucket = this.getBucket(context);
      return !!(bucket[key] !== void 0 && bucket[key].length);
    }
    /**
     * Runs all local and global callbacks assigned to the hook identified by the `key` parameter.
     * It returns either a return value from the last called callback or the first parameter (`p1`) passed to the `run` function.
     *
     * @see Core#runHooks
     * @param {Object} context Handsontable instance.
     * @param {String} key Hook/Event name.
     * @param {*} [p1] Parameter to be passed as an argument to the callback function.
     * @param {*} [p2] Parameter to be passed as an argument to the callback function.
     * @param {*} [p3] Parameter to be passed as an argument to the callback function.
     * @param {*} [p4] Parameter to be passed as an argument to the callback function.
     * @param {*} [p5] Parameter to be passed as an argument to the callback function.
     * @param {*} [p6] Parameter to be passed as an argument to the callback function.
     * @returns {*} Either a return value from the last called callback or `p1`.
     *
     * @example
     * ```js
     * Handsontable.hooks.run(hot, 'beforeInit');
     * ```
     */
  }, {
    key: "run",
    value: function run(context, key, p1, p2, p3, p4, p5, p6) {
      {
        var globalHandlers = this.globalBucket[key];
        var length = globalHandlers ? globalHandlers.length : 0;
        var index2 = 0;
        if (length) {
          while (index2 < length) {
            if (!globalHandlers[index2] || globalHandlers[index2].skip) {
              index2 += 1;
              continue;
            }
            var res = globalHandlers[index2].call(context, p1, p2, p3, p4, p5, p6);
            if (res !== void 0) {
              p1 = res;
            }
            if (globalHandlers[index2] && globalHandlers[index2].runOnce) {
              this.remove(key, globalHandlers[index2]);
            }
            index2 += 1;
          }
        }
      }
      {
        var localHandlers = this.getBucket(context)[key];
        var _length = localHandlers ? localHandlers.length : 0;
        var _index = 0;
        if (_length) {
          while (_index < _length) {
            if (!localHandlers[_index] || localHandlers[_index].skip) {
              _index += 1;
              continue;
            }
            var _res = localHandlers[_index].call(context, p1, p2, p3, p4, p5, p6);
            if (_res !== void 0) {
              p1 = _res;
            }
            if (localHandlers[_index] && localHandlers[_index].runOnce) {
              this.remove(key, localHandlers[_index], context);
            }
            _index += 1;
          }
        }
      }
      return p1;
    }
    /**
     * Destroy all listeners connected to the context. If no context is provided, the global listeners will be destroyed.
     *
     * @param {Object} [context=null] A Handsontable instance.
     * @example
     * ```js
     * // destroy the global listeners
     * Handsontable.hooks.destroy();
     *
     * // destroy the local listeners
     * Handsontable.hooks.destroy(hotInstance);
     * ```
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      objectEach(this.getBucket(context), function(value, key, bucket) {
        return bucket[key].length = 0;
      });
    }
    /**
     * Registers a hook name (adds it to the list of the known hook names). Used by plugins.
     * It is not necessary to call register, but if you use it, your plugin hook will be used returned by
     * the `getRegistered` method. (which itself is used in the demo http://docs.handsontable.com/tutorial-callbacks.html).
     *
     * @param key {String} The hook name.
     *
     * @example
     * ```js
     * Handsontable.hooks.register('myHook');
     * ```
     */
  }, {
    key: "register",
    value: function register7(key) {
      if (!this.isRegistered(key)) {
        REGISTERED_HOOKS.push(key);
      }
    }
    /**
     * Deregisters a hook name (removes it from the list of known hook names).
     *
     * @param key {String} Hook name.
     *
     * @example
     * ```js
     * Handsontable.hooks.deregister('myHook');
     * ```
     */
  }, {
    key: "deregister",
    value: function deregister(key) {
      if (this.isRegistered(key)) {
        REGISTERED_HOOKS.splice(REGISTERED_HOOKS.indexOf(key), 1);
      }
    }
    /**
     * Returns a boolean depending on if a hook by such name has been registered.
     *
     * @param key {String} Hook name.
     * @returns {Boolean} `true` for success, `false` otherwise.
     *
     * @example
     * ```js
     * Handsontable.hooks.isRegistered('beforeInit');
     *
     * // Results:
     * true
     * ```
     */
  }, {
    key: "isRegistered",
    value: function isRegistered(key) {
      return REGISTERED_HOOKS.indexOf(key) >= 0;
    }
    /**
     * Returns an array of registered hooks.
     *
     * @returns {Array} An array of registered hooks.
     *
     * @example
     * ```js
     * Handsontable.hooks.getRegistered();
     *
     * // Results:
     * [
     * ...
     *   'beforeInit',
     *   'beforeRender',
     *   'beforeSetRangeEnd',
     *   'beforeDrawBorders',
     *   'beforeChange',
     * ...
     * ]
     * ```
     */
  }, {
    key: "getRegistered",
    value: function getRegistered() {
      return REGISTERED_HOOKS;
    }
  }]);
  return Hooks2;
}();
var globalSingleton = new Hooks();
function getGlobalSingleton() {
  return globalSingleton;
}
var pluginHooks_default = Hooks;

// node_modules/handsontable/es/3rdparty/walkontable/src/calculator/viewportColumns.js
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties2(Constructor, staticProps);
  return Constructor;
}
var privatePool = /* @__PURE__ */ new WeakMap();
var ViewportColumnsCalculator = function() {
  _createClass2(ViewportColumnsCalculator2, null, [{
    key: "DEFAULT_WIDTH",
    /**
     * Default column width
     *
     * @type {Number}
     */
    get: function get5() {
      return 50;
    }
    /**
     * @param {Number} viewportWidth Width of the viewport
     * @param {Number} scrollOffset Current horizontal scroll position of the viewport
     * @param {Number} totalColumns Total number of rows
     * @param {Function} columnWidthFn Function that returns the width of the column at a given index (in px)
     * @param {Function} overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin)
     * @param {Boolean} onlyFullyVisible if `true`, only startRow and endRow will be indexes of rows that are fully in viewport
     * @param {Boolean} stretchH
     * @param {Function} [stretchingColumnWidthFn] Function that returns the new width of the stretched column.
     */
  }]);
  function ViewportColumnsCalculator2(viewportWidth, scrollOffset, totalColumns, columnWidthFn, overrideFn, onlyFullyVisible, stretchH) {
    var stretchingColumnWidthFn = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : function(width) {
      return width;
    };
    _classCallCheck2(this, ViewportColumnsCalculator2);
    privatePool.set(this, {
      viewportWidth,
      scrollOffset,
      totalColumns,
      columnWidthFn,
      overrideFn,
      onlyFullyVisible,
      stretchingColumnWidthFn
    });
    this.count = 0;
    this.startColumn = null;
    this.endColumn = null;
    this.startPosition = null;
    this.stretchAllRatio = 0;
    this.stretchLastWidth = 0;
    this.stretch = stretchH;
    this.totalTargetWidth = 0;
    this.needVerifyLastColumnWidth = true;
    this.stretchAllColumnsWidth = [];
    this.calculate();
  }
  _createClass2(ViewportColumnsCalculator2, [{
    key: "calculate",
    value: function calculate() {
      var sum = 0;
      var needReverse = true;
      var startPositions = [];
      var columnWidth;
      var priv = privatePool.get(this);
      var onlyFullyVisible = priv.onlyFullyVisible;
      var overrideFn = priv.overrideFn;
      var scrollOffset = priv.scrollOffset;
      var totalColumns = priv.totalColumns;
      var viewportWidth = priv.viewportWidth;
      for (var i = 0; i < totalColumns; i++) {
        columnWidth = this._getColumnWidth(i);
        if (sum <= scrollOffset && !onlyFullyVisible) {
          this.startColumn = i;
        }
        var compensatedViewportWidth = scrollOffset > 0 ? viewportWidth + 1 : viewportWidth;
        if (sum >= scrollOffset && sum + columnWidth <= scrollOffset + compensatedViewportWidth) {
          if (this.startColumn === null || this.startColumn === void 0) {
            this.startColumn = i;
          }
          this.endColumn = i;
        }
        startPositions.push(sum);
        sum += columnWidth;
        if (!onlyFullyVisible) {
          this.endColumn = i;
        }
        if (sum >= scrollOffset + viewportWidth) {
          needReverse = false;
          break;
        }
      }
      if (this.endColumn === totalColumns - 1 && needReverse) {
        this.startColumn = this.endColumn;
        while (this.startColumn > 0) {
          var viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];
          if (viewportSum <= viewportWidth || !onlyFullyVisible) {
            this.startColumn -= 1;
          }
          if (viewportSum > viewportWidth) {
            break;
          }
        }
      }
      if (this.startColumn !== null && overrideFn) {
        overrideFn(this);
      }
      this.startPosition = startPositions[this.startColumn];
      if (this.startPosition === void 0) {
        this.startPosition = null;
      }
      if (this.startColumn !== null) {
        this.count = this.endColumn - this.startColumn + 1;
      }
    }
    /**
     * Recalculate columns stretching.
     *
     * @param {Number} totalWidth
     */
  }, {
    key: "refreshStretching",
    value: function refreshStretching(totalWidth) {
      if (this.stretch === "none") {
        return;
      }
      var totalColumnsWidth = totalWidth;
      this.totalTargetWidth = totalColumnsWidth;
      var priv = privatePool.get(this);
      var totalColumns = priv.totalColumns;
      var sumAll = 0;
      for (var i = 0; i < totalColumns; i++) {
        var columnWidth = this._getColumnWidth(i);
        var permanentColumnWidth = priv.stretchingColumnWidthFn(void 0, i);
        if (typeof permanentColumnWidth === "number") {
          totalColumnsWidth -= permanentColumnWidth;
        } else {
          sumAll += columnWidth;
        }
      }
      var remainingSize = totalColumnsWidth - sumAll;
      if (this.stretch === "all" && remainingSize > 0) {
        this.stretchAllRatio = totalColumnsWidth / sumAll;
        this.stretchAllColumnsWidth = [];
        this.needVerifyLastColumnWidth = true;
      } else if (this.stretch === "last" && totalColumnsWidth !== Infinity) {
        var _columnWidth = this._getColumnWidth(totalColumns - 1);
        var lastColumnWidth = remainingSize + _columnWidth;
        this.stretchLastWidth = lastColumnWidth >= 0 ? lastColumnWidth : _columnWidth;
      }
    }
    /**
     * Get stretched column width based on stretchH (all or last) setting passed in handsontable instance.
     *
     * @param {Number} column
     * @param {Number} baseWidth
     * @returns {Number|null}
     */
  }, {
    key: "getStretchedColumnWidth",
    value: function getStretchedColumnWidth(column, baseWidth) {
      var result = null;
      if (this.stretch === "all" && this.stretchAllRatio !== 0) {
        result = this._getStretchedAllColumnWidth(column, baseWidth);
      } else if (this.stretch === "last" && this.stretchLastWidth !== 0) {
        result = this._getStretchedLastColumnWidth(column);
      }
      return result;
    }
    /**
     * @param {Number} column
     * @param {Number} baseWidth
     * @returns {Number}
     * @private
     */
  }, {
    key: "_getStretchedAllColumnWidth",
    value: function _getStretchedAllColumnWidth(column, baseWidth) {
      var sumRatioWidth = 0;
      var priv = privatePool.get(this);
      var totalColumns = priv.totalColumns;
      if (!this.stretchAllColumnsWidth[column]) {
        var stretchedWidth = Math.round(baseWidth * this.stretchAllRatio);
        var newStretchedWidth = priv.stretchingColumnWidthFn(stretchedWidth, column);
        if (newStretchedWidth === void 0) {
          this.stretchAllColumnsWidth[column] = stretchedWidth;
        } else {
          this.stretchAllColumnsWidth[column] = isNaN(newStretchedWidth) ? this._getColumnWidth(column) : newStretchedWidth;
        }
      }
      if (this.stretchAllColumnsWidth.length === totalColumns && this.needVerifyLastColumnWidth) {
        this.needVerifyLastColumnWidth = false;
        for (var i = 0; i < this.stretchAllColumnsWidth.length; i++) {
          sumRatioWidth += this.stretchAllColumnsWidth[i];
        }
        if (sumRatioWidth !== this.totalTargetWidth) {
          this.stretchAllColumnsWidth[this.stretchAllColumnsWidth.length - 1] += this.totalTargetWidth - sumRatioWidth;
        }
      }
      return this.stretchAllColumnsWidth[column];
    }
    /**
     * @param {Number} column
     * @returns {Number|null}
     * @private
     */
  }, {
    key: "_getStretchedLastColumnWidth",
    value: function _getStretchedLastColumnWidth(column) {
      var priv = privatePool.get(this);
      var totalColumns = priv.totalColumns;
      if (column === totalColumns - 1) {
        return this.stretchLastWidth;
      }
      return null;
    }
    /**
     * @param {Number} column Column index.
     * @returns {Number}
     * @private
     */
  }, {
    key: "_getColumnWidth",
    value: function _getColumnWidth(column) {
      var width = privatePool.get(this).columnWidthFn(column);
      if (isNaN(width)) {
        width = ViewportColumnsCalculator2.DEFAULT_WIDTH;
      }
      return width;
    }
  }]);
  return ViewportColumnsCalculator2;
}();
var viewportColumns_default = ViewportColumnsCalculator;

// node_modules/handsontable/es/3rdparty/walkontable/src/calculator/viewportRows.js
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties3(Constructor, staticProps);
  return Constructor;
}
var privatePool2 = /* @__PURE__ */ new WeakMap();
var ViewportRowsCalculator = function() {
  _createClass3(ViewportRowsCalculator2, null, [{
    key: "DEFAULT_HEIGHT",
    /**
     * Default row height
     *
     * @type {Number}
     */
    get: function get5() {
      return 23;
    }
    /**
     * @param {Number} viewportHeight Height of the viewport
     * @param {Number} scrollOffset Current vertical scroll position of the viewport
     * @param {Number} totalRows Total number of rows
     * @param {Function} rowHeightFn Function that returns the height of the row at a given index (in px)
     * @param {Function} overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin)
     * @param {Boolean} onlyFullyVisible if `true`, only startRow and endRow will be indexes of rows that are fully in viewport
     * @param {Number} horizontalScrollbarHeight
     */
  }]);
  function ViewportRowsCalculator2(viewportHeight, scrollOffset, totalRows, rowHeightFn, overrideFn, onlyFullyVisible, horizontalScrollbarHeight) {
    _classCallCheck3(this, ViewportRowsCalculator2);
    privatePool2.set(this, {
      viewportHeight,
      scrollOffset,
      totalRows,
      rowHeightFn,
      overrideFn,
      onlyFullyVisible,
      horizontalScrollbarHeight
    });
    this.count = 0;
    this.startRow = null;
    this.endRow = null;
    this.startPosition = null;
    this.calculate();
  }
  _createClass3(ViewportRowsCalculator2, [{
    key: "calculate",
    value: function calculate() {
      var sum = 0;
      var needReverse = true;
      var startPositions = [];
      var priv = privatePool2.get(this);
      var onlyFullyVisible = priv.onlyFullyVisible;
      var overrideFn = priv.overrideFn;
      var rowHeightFn = priv.rowHeightFn;
      var scrollOffset = priv.scrollOffset;
      var totalRows = priv.totalRows;
      var viewportHeight = priv.viewportHeight;
      var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;
      var rowHeight;
      for (var i = 0; i < totalRows; i++) {
        rowHeight = rowHeightFn(i);
        if (isNaN(rowHeight)) {
          rowHeight = ViewportRowsCalculator2.DEFAULT_HEIGHT;
        }
        if (sum <= scrollOffset && !onlyFullyVisible) {
          this.startRow = i;
        }
        if (sum >= scrollOffset && sum + rowHeight <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
          if (this.startRow === null) {
            this.startRow = i;
          }
          this.endRow = i;
        }
        startPositions.push(sum);
        sum += rowHeight;
        if (!onlyFullyVisible) {
          this.endRow = i;
        }
        if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
          needReverse = false;
          break;
        }
      }
      if (this.endRow === totalRows - 1 && needReverse) {
        this.startRow = this.endRow;
        while (this.startRow > 0) {
          var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];
          if (viewportSum <= viewportHeight - horizontalScrollbarHeight || !onlyFullyVisible) {
            this.startRow -= 1;
          }
          if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {
            break;
          }
        }
      }
      if (this.startRow !== null && overrideFn) {
        overrideFn(this);
      }
      this.startPosition = startPositions[this.startRow];
      if (this.startPosition === void 0) {
        this.startPosition = null;
      }
      if (this.startRow !== null) {
        this.count = this.endRow - this.startRow + 1;
      }
    }
  }]);
  return ViewportRowsCalculator2;
}();
var viewportRows_default = ViewportRowsCalculator;

// node_modules/handsontable/es/3rdparty/walkontable/src/cell/coords.js
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties4(Constructor, staticProps);
  return Constructor;
}
var CellCoords = function() {
  function CellCoords2(row, column) {
    _classCallCheck4(this, CellCoords2);
    this.row = null;
    this.col = null;
    if (typeof row !== "undefined" && typeof column !== "undefined") {
      this.row = row;
      this.col = column;
    }
  }
  _createClass4(CellCoords2, [{
    key: "isValid",
    value: function isValid5(wot) {
      if (this.row < 0 || this.col < 0) {
        return false;
      }
      if (this.row >= wot.getSetting("totalRows") || this.col >= wot.getSetting("totalColumns")) {
        return false;
      }
      return true;
    }
    /**
     * Checks if this cell coordinates are the same as cell coordinates given as an argument.
     *
     * @param {CellCoords} cellCoords Cell coordinates to equal.
     * @returns {Boolean}
     */
  }, {
    key: "isEqual",
    value: function isEqual(cellCoords) {
      if (cellCoords === this) {
        return true;
      }
      return this.row === cellCoords.row && this.col === cellCoords.col;
    }
    /**
     * Checks if tested coordinates are positioned in south-east from this cell coordinates.
     *
     * @param {Object} testedCoords Cell coordinates to check.
     * @returns {Boolean}
     */
  }, {
    key: "isSouthEastOf",
    value: function isSouthEastOf(testedCoords) {
      return this.row >= testedCoords.row && this.col >= testedCoords.col;
    }
    /**
     * Checks if tested coordinates are positioned in north-east from this cell coordinates.
     *
     * @param {Object} testedCoords Cell coordinates to check.
     * @returns {Boolean}
     */
  }, {
    key: "isNorthWestOf",
    value: function isNorthWestOf(testedCoords) {
      return this.row <= testedCoords.row && this.col <= testedCoords.col;
    }
    /**
     * Checks if tested coordinates are positioned in south-west from this cell coordinates.
     *
     * @param {Object} testedCoords Cell coordinates to check.
     * @returns {Boolean}
     */
  }, {
    key: "isSouthWestOf",
    value: function isSouthWestOf(testedCoords) {
      return this.row >= testedCoords.row && this.col <= testedCoords.col;
    }
    /**
     * Checks if tested coordinates are positioned in north-east from this cell coordinates.
     *
     * @param {Object} testedCoords Cell coordinates to check.
     * @returns {Boolean}
     */
  }, {
    key: "isNorthEastOf",
    value: function isNorthEastOf(testedCoords) {
      return this.row <= testedCoords.row && this.col >= testedCoords.col;
    }
    /**
     * Converts CellCoords to literal object with `row` and `col` properties.
     *
     * @return {Object} Returns a literal object with `row` and `col` properties.
     */
  }, {
    key: "toObject",
    value: function toObject3() {
      return {
        row: this.row,
        col: this.col
      };
    }
  }]);
  return CellCoords2;
}();
var coords_default = CellCoords;

// node_modules/handsontable/es/3rdparty/walkontable/src/cell/range.js
function _classCallCheck5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass5(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties5(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties5(Constructor, staticProps);
  return Constructor;
}
var CellRange = function() {
  function CellRange2(highlight) {
    var from3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : highlight;
    var to3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : highlight;
    _classCallCheck5(this, CellRange2);
    this.highlight = highlight;
    this.from = from3;
    this.to = to3;
  }
  _createClass5(CellRange2, [{
    key: "setHighlight",
    value: function setHighlight(coords) {
      this.highlight = coords;
      return this;
    }
    /**
     * Set the new coordinates where selection starts from.
     *
     * @param {CellCoords} coords Coordinates to use.
     */
  }, {
    key: "setFrom",
    value: function setFrom(coords) {
      this.from = coords;
      return this;
    }
    /**
     * Set new coordinates where selection ends from.
     *
     * @param {CellCoords} coords Coordinates to use.
     */
  }, {
    key: "setTo",
    value: function setTo(coords) {
      this.to = coords;
      return this;
    }
    /**
     * Checks if given coordinates are valid in context of a given Walkontable instance.
     *
     * @param {Walkontable} wot The Walkontable instance.
     * @returns {Boolean}
     */
  }, {
    key: "isValid",
    value: function isValid5(wot) {
      return this.from.isValid(wot) && this.to.isValid(wot);
    }
    /**
     * Checks if this cell range is restricted to one cell
     *
     * @returns {Boolean}
     */
  }, {
    key: "isSingle",
    value: function isSingle() {
      return this.from.row === this.to.row && this.from.col === this.to.col;
    }
    /**
     * Returns selected range height (in number of rows).
     *
     * @returns {Number}
     */
  }, {
    key: "getHeight",
    value: function getHeight() {
      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;
    }
    /**
     * Returns selected range width (in number of columns).
     *
     * @returns {Number}
     */
  }, {
    key: "getWidth",
    value: function getWidth() {
      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;
    }
    /**
     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.
     *
     * @param {CellCoords} cellCoords The cell coordinates to check.
     * @returns {Boolean}
     */
  }, {
    key: "includes",
    value: function includes(cellCoords) {
      var row = cellCoords.row, col = cellCoords.col;
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();
      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;
    }
    /**
     * Checks if given range is within of this range.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {Boolean}
     */
  }, {
    key: "includesRange",
    value: function includesRange(cellRange) {
      return this.includes(cellRange.getTopLeftCorner()) && this.includes(cellRange.getBottomRightCorner());
    }
    /**
     * Checks if given range is equal to this range.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {Boolean}
     */
  }, {
    key: "isEqual",
    value: function isEqual(cellRange) {
      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);
    }
    /**
     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B
     * if intersection of A and B or B and A is not empty.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {Boolean}
     */
  }, {
    key: "overlaps",
    value: function overlaps(cellRange) {
      return cellRange.isSouthEastOf(this.getTopLeftCorner()) && cellRange.isNorthWestOf(this.getBottomRightCorner());
    }
    /**
     * Checks if tested coordinates are positioned in south-east from this cell range.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {Boolean}
     */
  }, {
    key: "isSouthEastOf",
    value: function isSouthEastOf(cellRange) {
      return this.getTopLeftCorner().isSouthEastOf(cellRange) || this.getBottomRightCorner().isSouthEastOf(cellRange);
    }
    /**
     * Checks if tested coordinates are positioned in north-west from this cell range.
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {Boolean}
     */
  }, {
    key: "isNorthWestOf",
    value: function isNorthWestOf(cellRange) {
      return this.getTopLeftCorner().isNorthWestOf(cellRange) || this.getBottomRightCorner().isNorthWestOf(cellRange);
    }
    /**
     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. the current range's last
     * column is 5 and the provided range's first column is 3).
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {Boolean}
     */
  }, {
    key: "isOverlappingHorizontally",
    value: function isOverlappingHorizontally(cellRange) {
      return this.getTopRightCorner().col >= cellRange.getTopLeftCorner().col && this.getTopRightCorner().col <= cellRange.getTopRightCorner().col || this.getTopLeftCorner().col <= cellRange.getTopRightCorner().col && this.getTopLeftCorner().col >= cellRange.getTopLeftCorner().col;
    }
    /**
     * Returns `true` if the provided range is overlapping the current range vertically (e.g. the current range's last
     *  row is 5 and the provided range's first row is 3).
     *
     * @param {CellRange} cellRange The cells range to check.
     * @returns {Boolean}
     */
  }, {
    key: "isOverlappingVertically",
    value: function isOverlappingVertically(cellRange) {
      return this.getBottomRightCorner().row >= cellRange.getTopRightCorner().row && this.getBottomRightCorner().row <= cellRange.getBottomRightCorner().row || this.getTopRightCorner().row <= cellRange.getBottomRightCorner().row && this.getTopRightCorner().row >= cellRange.getTopRightCorner().row;
    }
    /**
     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.
     *
     * @param {CellCoords} cellCoords
     * @returns {Boolean}
     */
  }, {
    key: "expand",
    value: function expand(cellCoords) {
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();
      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {
        this.from = new coords_default(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));
        this.to = new coords_default(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));
        return true;
      }
      return false;
    }
    /**
     * Expand the current object by the range passed in the first argument.
     *
     * @param {CellRange} expandingRange Object extending the range.
     * @returns {Boolean}
     */
  }, {
    key: "expandByRange",
    value: function expandByRange(expandingRange) {
      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {
        return false;
      }
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();
      var initialDirection = this.getDirection();
      var expandingTopLeft = expandingRange.getTopLeftCorner();
      var expandingBottomRight = expandingRange.getBottomRightCorner();
      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);
      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);
      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);
      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);
      var finalFrom = new coords_default(resultTopRow, resultTopCol);
      var finalTo = new coords_default(resultBottomRow, resultBottomCol);
      this.from = finalFrom;
      this.to = finalTo;
      this.setDirection(initialDirection);
      if (this.highlight.row === this.getBottomRightCorner().row && this.getVerticalDirection() === "N-S") {
        this.flipDirectionVertically();
      }
      if (this.highlight.col === this.getTopRightCorner().col && this.getHorizontalDirection() === "W-E") {
        this.flipDirectionHorizontally();
      }
      return true;
    }
    /**
     * Gets the direction of the selection.
     *
     * @returns {String} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.
     */
  }, {
    key: "getDirection",
    value: function getDirection() {
      if (this.from.isNorthWestOf(this.to)) {
        return "NW-SE";
      } else if (this.from.isNorthEastOf(this.to)) {
        return "NE-SW";
      } else if (this.from.isSouthEastOf(this.to)) {
        return "SE-NW";
      } else if (this.from.isSouthWestOf(this.to)) {
        return "SW-NE";
      }
    }
    /**
     * Sets the direction of the selection.
     *
     * @param {String} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.
     */
  }, {
    key: "setDirection",
    value: function setDirection(direction) {
      switch (direction) {
        case "NW-SE":
          var _ref = [this.getTopLeftCorner(), this.getBottomRightCorner()];
          this.from = _ref[0];
          this.to = _ref[1];
          break;
        case "NE-SW":
          var _ref2 = [this.getTopRightCorner(), this.getBottomLeftCorner()];
          this.from = _ref2[0];
          this.to = _ref2[1];
          break;
        case "SE-NW":
          var _ref3 = [this.getBottomRightCorner(), this.getTopLeftCorner()];
          this.from = _ref3[0];
          this.to = _ref3[1];
          break;
        case "SW-NE":
          var _ref4 = [this.getBottomLeftCorner(), this.getTopRightCorner()];
          this.from = _ref4[0];
          this.to = _ref4[1];
          break;
        default:
          break;
      }
    }
    /**
     * Gets the vertical direction of the range.
     *
     * @returns {String} Returns one of the values: `N-S` (north->south), `S-N` (south->north).
     */
  }, {
    key: "getVerticalDirection",
    value: function getVerticalDirection() {
      return ["NE-SW", "NW-SE"].indexOf(this.getDirection()) > -1 ? "N-S" : "S-N";
    }
    /**
     * Gets the horizontal direction of the range.
     *
     * @returns {String} Returns one of the values: `W-E` (west->east), `E-W` (east->west).
     */
  }, {
    key: "getHorizontalDirection",
    value: function getHorizontalDirection() {
      return ["NW-SE", "SW-NE"].indexOf(this.getDirection()) > -1 ? "W-E" : "E-W";
    }
    /**
     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).
     */
  }, {
    key: "flipDirectionVertically",
    value: function flipDirectionVertically() {
      var direction = this.getDirection();
      switch (direction) {
        case "NW-SE":
          this.setDirection("SW-NE");
          break;
        case "NE-SW":
          this.setDirection("SE-NW");
          break;
        case "SE-NW":
          this.setDirection("NE-SW");
          break;
        case "SW-NE":
          this.setDirection("NW-SE");
          break;
        default:
          break;
      }
    }
    /**
     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).
     */
  }, {
    key: "flipDirectionHorizontally",
    value: function flipDirectionHorizontally() {
      var direction = this.getDirection();
      switch (direction) {
        case "NW-SE":
          this.setDirection("NE-SW");
          break;
        case "NE-SW":
          this.setDirection("NW-SE");
          break;
        case "SE-NW":
          this.setDirection("SW-NE");
          break;
        case "SW-NE":
          this.setDirection("SE-NW");
          break;
        default:
          break;
      }
    }
    /**
     * Gets the top left corner of this range.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getTopLeftCorner",
    value: function getTopLeftCorner() {
      return new coords_default(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
    }
    /**
     * Gets the bottom right corner of this range.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getBottomRightCorner",
    value: function getBottomRightCorner() {
      return new coords_default(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
    }
    /**
     * Gets the top right corner of this range.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getTopRightCorner",
    value: function getTopRightCorner() {
      return new coords_default(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
    }
    /**
     * Gets the bottom left corner of this range.
     *
     * @returns {CellCoords}
     */
  }, {
    key: "getBottomLeftCorner",
    value: function getBottomLeftCorner() {
      return new coords_default(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
    }
    /**
     * Checks if coordinates match to one of the 4th corners of this range.
     *
     * @param {CellCoords} coords Cell coordinates to check.
     * @param {CellRange} [expandedRange]
     * @returns {Boolean}
     */
  }, {
    key: "isCorner",
    value: function isCorner(coords, expandedRange) {
      if (expandedRange && expandedRange.includes(coords) && (this.getTopLeftCorner().isEqual(new coords_default(expandedRange.from.row, expandedRange.from.col)) || this.getTopRightCorner().isEqual(new coords_default(expandedRange.from.row, expandedRange.to.col)) || this.getBottomLeftCorner().isEqual(new coords_default(expandedRange.to.row, expandedRange.from.col)) || this.getBottomRightCorner().isEqual(new coords_default(expandedRange.to.row, expandedRange.to.col)))) {
        return true;
      }
      return coords.isEqual(this.getTopLeftCorner()) || coords.isEqual(this.getTopRightCorner()) || coords.isEqual(this.getBottomLeftCorner()) || coords.isEqual(this.getBottomRightCorner());
    }
    /**
     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the
     * bottom-right corner of this range then the coordinates for top-left will be returned.
     *
     * @param {CellCoords} coords Cell coordinates to check.
     * @param {CellRange} [expandedRange]
     * @returns {CellCoords}
     */
  }, {
    key: "getOppositeCorner",
    value: function getOppositeCorner(coords, expandedRange) {
      if (!(coords instanceof coords_default)) {
        return false;
      }
      if (expandedRange) {
        if (expandedRange.includes(coords)) {
          if (this.getTopLeftCorner().isEqual(new coords_default(expandedRange.from.row, expandedRange.from.col))) {
            return this.getBottomRightCorner();
          }
          if (this.getTopRightCorner().isEqual(new coords_default(expandedRange.from.row, expandedRange.to.col))) {
            return this.getBottomLeftCorner();
          }
          if (this.getBottomLeftCorner().isEqual(new coords_default(expandedRange.to.row, expandedRange.from.col))) {
            return this.getTopRightCorner();
          }
          if (this.getBottomRightCorner().isEqual(new coords_default(expandedRange.to.row, expandedRange.to.col))) {
            return this.getTopLeftCorner();
          }
        }
      }
      if (coords.isEqual(this.getBottomRightCorner())) {
        return this.getTopLeftCorner();
      } else if (coords.isEqual(this.getTopLeftCorner())) {
        return this.getBottomRightCorner();
      } else if (coords.isEqual(this.getTopRightCorner())) {
        return this.getBottomLeftCorner();
      } else if (coords.isEqual(this.getBottomLeftCorner())) {
        return this.getTopRightCorner();
      }
    }
    /**
     * @param {CellRange} range
     * @returns {Array}
     */
  }, {
    key: "getBordersSharedWith",
    value: function getBordersSharedWith(range) {
      if (!this.includesRange(range)) {
        return [];
      }
      var thisBorders = {
        top: Math.min(this.from.row, this.to.row),
        bottom: Math.max(this.from.row, this.to.row),
        left: Math.min(this.from.col, this.to.col),
        right: Math.max(this.from.col, this.to.col)
      };
      var rangeBorders = {
        top: Math.min(range.from.row, range.to.row),
        bottom: Math.max(range.from.row, range.to.row),
        left: Math.min(range.from.col, range.to.col),
        right: Math.max(range.from.col, range.to.col)
      };
      var result = [];
      if (thisBorders.top === rangeBorders.top) {
        result.push("top");
      }
      if (thisBorders.right === rangeBorders.right) {
        result.push("right");
      }
      if (thisBorders.bottom === rangeBorders.bottom) {
        result.push("bottom");
      }
      if (thisBorders.left === rangeBorders.left) {
        result.push("left");
      }
      return result;
    }
    /**
     * Get inner selected cell coords defined by this range
     *
     * @returns {Array}
     */
  }, {
    key: "getInner",
    value: function getInner() {
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();
      var out = [];
      for (var r = topLeft.row; r <= bottomRight.row; r++) {
        for (var c = topLeft.col; c <= bottomRight.col; c++) {
          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {
            out.push(new coords_default(r, c));
          }
        }
      }
      return out;
    }
    /**
     * Get all selected cell coords defined by this range
     *
     * @returns {Array}
     */
  }, {
    key: "getAll",
    value: function getAll2() {
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();
      var out = [];
      for (var r = topLeft.row; r <= bottomRight.row; r++) {
        for (var c = topLeft.col; c <= bottomRight.col; c++) {
          if (topLeft.row === r && topLeft.col === c) {
            out.push(topLeft);
          } else if (bottomRight.row === r && bottomRight.col === c) {
            out.push(bottomRight);
          } else {
            out.push(new coords_default(r, c));
          }
        }
      }
      return out;
    }
    /**
     * Runs a callback function against all cells in the range. You can break the iteration by returning
     * `false` in the callback function
     *
     * @param callback {Function}
     */
  }, {
    key: "forAll",
    value: function forAll(callback) {
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();
      for (var r = topLeft.row; r <= bottomRight.row; r++) {
        for (var c = topLeft.col; c <= bottomRight.col; c++) {
          var breakIteration = callback(r, c);
          if (breakIteration === false) {
            return;
          }
        }
      }
    }
    /**
     * Convert CellRange to literal object.
     *
     * @return {Object} Returns a literal object with `from` and `to` properties which each of that object
     *                  contains `row` and `col` keys.
     */
  }, {
    key: "toObject",
    value: function toObject3() {
      return {
        from: this.from.toObject(),
        to: this.to.toObject()
      };
    }
  }]);
  return CellRange2;
}();
var range_default = CellRange;

// node_modules/handsontable/es/3rdparty/walkontable/src/filter/column.js
function _classCallCheck6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass6(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties6(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties6(Constructor, staticProps);
  return Constructor;
}
var ColumnFilter = function() {
  function ColumnFilter2(offset4, total, countTH) {
    _classCallCheck6(this, ColumnFilter2);
    this.offset = offset4;
    this.total = total;
    this.countTH = countTH;
  }
  _createClass6(ColumnFilter2, [{
    key: "offsetted",
    value: function offsetted(index2) {
      return index2 + this.offset;
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "unOffsetted",
    value: function unOffsetted(index2) {
      return index2 - this.offset;
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "renderedToSource",
    value: function renderedToSource(index2) {
      return this.offsetted(index2);
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "sourceToRendered",
    value: function sourceToRendered(index2) {
      return this.unOffsetted(index2);
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "offsettedTH",
    value: function offsettedTH(index2) {
      return index2 - this.countTH;
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "unOffsettedTH",
    value: function unOffsettedTH(index2) {
      return index2 + this.countTH;
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "visibleRowHeadedColumnToSourceColumn",
    value: function visibleRowHeadedColumnToSourceColumn(index2) {
      return this.renderedToSource(this.offsettedTH(index2));
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "sourceColumnToVisibleRowHeadedColumn",
    value: function sourceColumnToVisibleRowHeadedColumn(index2) {
      return this.unOffsettedTH(this.sourceToRendered(index2));
    }
  }]);
  return ColumnFilter2;
}();
var column_default = ColumnFilter;

// node_modules/handsontable/es/3rdparty/walkontable/src/filter/row.js
function _classCallCheck7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass7(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties7(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties7(Constructor, staticProps);
  return Constructor;
}
var RowFilter = function() {
  function RowFilter2(offset4, total, countTH) {
    _classCallCheck7(this, RowFilter2);
    this.offset = offset4;
    this.total = total;
    this.countTH = countTH;
  }
  _createClass7(RowFilter2, [{
    key: "offsetted",
    value: function offsetted(index2) {
      return index2 + this.offset;
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "unOffsetted",
    value: function unOffsetted(index2) {
      return index2 - this.offset;
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "renderedToSource",
    value: function renderedToSource(index2) {
      return this.offsetted(index2);
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "sourceToRendered",
    value: function sourceToRendered(index2) {
      return this.unOffsetted(index2);
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "offsettedTH",
    value: function offsettedTH(index2) {
      return index2 - this.countTH;
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "unOffsettedTH",
    value: function unOffsettedTH(index2) {
      return index2 + this.countTH;
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "visibleColHeadedRowToSourceRow",
    value: function visibleColHeadedRowToSourceRow(index2) {
      return this.renderedToSource(this.offsettedTH(index2));
    }
    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "sourceRowToVisibleColHeadedRow",
    value: function sourceRowToVisibleColHeadedRow(index2) {
      return this.unOffsettedTH(this.sourceToRendered(index2));
    }
  }]);
  return RowFilter2;
}();
var row_default = RowFilter;

// node_modules/handsontable/es/helpers/dom/element.js
var element_exports = {};
__export(element_exports, {
  HTML_CHARACTERS: () => HTML_CHARACTERS,
  addClass: () => addClass,
  addEvent: () => addEvent,
  closest: () => closest,
  closestDown: () => closestDown,
  empty: () => empty,
  fastInnerHTML: () => fastInnerHTML,
  fastInnerText: () => fastInnerText,
  getCaretPosition: () => getCaretPosition,
  getComputedStyle: () => getComputedStyle2,
  getCssTransform: () => getCssTransform,
  getParent: () => getParent,
  getScrollLeft: () => getScrollLeft,
  getScrollTop: () => getScrollTop,
  getScrollableElement: () => getScrollableElement,
  getScrollbarWidth: () => getScrollbarWidth,
  getSelectionEndPosition: () => getSelectionEndPosition,
  getSelectionText: () => getSelectionText,
  getStyle: () => getStyle,
  getTrimmingContainer: () => getTrimmingContainer,
  getWindowScrollLeft: () => getWindowScrollLeft,
  getWindowScrollTop: () => getWindowScrollTop,
  hasClass: () => hasClass,
  hasHorizontalScrollbar: () => hasHorizontalScrollbar,
  hasVerticalScrollbar: () => hasVerticalScrollbar,
  index: () => index,
  innerHeight: () => innerHeight,
  innerWidth: () => innerWidth,
  isChildOf: () => isChildOf,
  isChildOfWebComponentTable: () => isChildOfWebComponentTable,
  isInput: () => isInput,
  isOutsideInput: () => isOutsideInput,
  isVisible: () => isVisible,
  offset: () => offset,
  outerHeight: () => outerHeight,
  outerWidth: () => outerWidth,
  overlayContainsElement: () => overlayContainsElement,
  polymerUnwrap: () => polymerUnwrap,
  polymerWrap: () => polymerWrap,
  removeClass: () => removeClass,
  removeEvent: () => removeEvent,
  removeTextNodes: () => removeTextNodes,
  resetCssTransform: () => resetCssTransform,
  setCaretPosition: () => setCaretPosition,
  setOverlayPosition: () => setOverlayPosition
});

// node_modules/handsontable/es/helpers/browser.js
var browser_exports = {};
__export(browser_exports, {
  isChrome: () => isChrome,
  isEdge: () => isEdge,
  isIE: () => isIE,
  isIE8: () => isIE8,
  isIE9: () => isIE9,
  isMSBrowser: () => isMSBrowser,
  isMobileBrowser: () => isMobileBrowser,
  isSafari: () => isSafari,
  setBrowserMeta: () => setBrowserMeta
});
var tester = function tester2(testerFunc) {
  var result = {
    value: false
  };
  result.test = function(ua, vendor) {
    result.value = testerFunc(ua, vendor);
  };
  return result;
};
var browsers = {
  chrome: tester(function(ua, vendor) {
    return /Chrome/.test(ua) && /Google/.test(vendor);
  }),
  edge: tester(function(ua) {
    return /Edge/.test(ua);
  }),
  ie: tester(function(ua) {
    return /Trident/.test(ua);
  }),
  ie8: tester(function() {
    return !document.createTextNode("test").textContent;
  }),
  ie9: tester(function() {
    return !!document.documentMode;
  }),
  mobile: tester(function(ua) {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
  }),
  safari: tester(function(ua, vendor) {
    return /Safari/.test(ua) && /Apple Computer/.test(vendor);
  })
};
function setBrowserMeta() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$userAgent = _ref.userAgent, userAgent = _ref$userAgent === void 0 ? navigator.userAgent : _ref$userAgent, _ref$vendor = _ref.vendor, vendor = _ref$vendor === void 0 ? navigator.vendor : _ref$vendor;
  objectEach(browsers, function(_ref2) {
    var test = _ref2.test;
    return void test(userAgent, vendor);
  });
}
setBrowserMeta();
function isChrome() {
  return browsers.chrome.value;
}
function isEdge() {
  return browsers.edge.value;
}
function isIE() {
  return browsers.ie.value;
}
function isIE8() {
  return browsers.ie8.value;
}
function isIE9() {
  return browsers.ie9.value;
}
function isMSBrowser() {
  return browsers.ie.value || browsers.edge.value;
}
function isMobileBrowser() {
  return browsers.mobile.value;
}
function isSafari() {
  return browsers.safari.value;
}

// node_modules/handsontable/es/helpers/feature.js
var feature_exports = {};
__export(feature_exports, {
  cancelAnimationFrame: () => cancelAnimationFrame,
  getComparisonFunction: () => getComparisonFunction,
  hasCaptionProblem: () => hasCaptionProblem,
  isTouchSupported: () => isTouchSupported,
  isWebComponentSupportedNatively: () => isWebComponentSupportedNatively,
  requestAnimationFrame: () => requestAnimationFrame
});
function _typeof2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
var lastTime = 0;
var vendors = ["ms", "moz", "webkit", "o"];
var _requestAnimationFrame = window.requestAnimationFrame;
var _cancelAnimationFrame = window.cancelAnimationFrame;
for (x = 0; x < vendors.length && !_requestAnimationFrame; ++x) {
  _requestAnimationFrame = window["".concat(vendors[x], "RequestAnimationFrame")];
  _cancelAnimationFrame = window["".concat(vendors[x], "CancelAnimationFrame")] || window["".concat(vendors[x], "CancelRequestAnimationFrame")];
}
var x;
if (!_requestAnimationFrame) {
  _requestAnimationFrame = function _requestAnimationFrame2(callback) {
    var currTime = (/* @__PURE__ */ new Date()).getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function() {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}
if (!_cancelAnimationFrame) {
  _cancelAnimationFrame = function _cancelAnimationFrame2(id) {
    clearTimeout(id);
  };
}
function requestAnimationFrame(callback) {
  return _requestAnimationFrame.call(window, callback);
}
function cancelAnimationFrame(id) {
  _cancelAnimationFrame.call(window, id);
}
function isTouchSupported() {
  return "ontouchstart" in window;
}
function isWebComponentSupportedNatively() {
  var test = document.createElement("div");
  return !!(test.createShadowRoot && test.createShadowRoot.toString().match(/\[native code\]/));
}
var _hasCaptionProblem;
function detectCaptionProblem() {
  var TABLE = document.createElement("TABLE");
  TABLE.style.borderSpacing = "0";
  TABLE.style.borderWidth = "0";
  TABLE.style.padding = "0";
  var TBODY = document.createElement("TBODY");
  TABLE.appendChild(TBODY);
  TBODY.appendChild(document.createElement("TR"));
  TBODY.firstChild.appendChild(document.createElement("TD"));
  TBODY.firstChild.firstChild.innerHTML = "<tr><td>t<br>t</td></tr>";
  var CAPTION = document.createElement("CAPTION");
  CAPTION.innerHTML = "c<br>c<br>c<br>c";
  CAPTION.style.padding = "0";
  CAPTION.style.margin = "0";
  TABLE.insertBefore(CAPTION, TBODY);
  document.body.appendChild(TABLE);
  _hasCaptionProblem = TABLE.offsetHeight < 2 * TABLE.lastChild.offsetHeight;
  document.body.removeChild(TABLE);
}
function hasCaptionProblem() {
  if (_hasCaptionProblem === void 0) {
    detectCaptionProblem();
  }
  return _hasCaptionProblem;
}
var comparisonFunction;
function getComparisonFunction(language) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (comparisonFunction) {
    return comparisonFunction;
  }
  if ((typeof Intl === "undefined" ? "undefined" : _typeof2(Intl)) === "object") {
    comparisonFunction = new Intl.Collator(language, options).compare;
  } else if (typeof String.prototype.localeCompare === "function") {
    comparisonFunction = function comparisonFunction2(a, b) {
      return "".concat(a).localeCompare(b);
    };
  } else {
    comparisonFunction = function comparisonFunction2(a, b) {
      if (a === b) {
        return 0;
      }
      return a > b ? -1 : 1;
    };
  }
  return comparisonFunction;
}

// node_modules/handsontable/es/helpers/dom/element.js
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _nonIterableSpread2();
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray2(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function getParent(element) {
  var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var iteration = -1;
  var parent = null;
  var elementToCheck = element;
  while (elementToCheck !== null) {
    if (iteration === level) {
      parent = elementToCheck;
      break;
    }
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      iteration += 1;
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return parent;
}
function closest(element, nodes, until) {
  var elementToCheck = element;
  while (elementToCheck !== null && elementToCheck !== until) {
    if (elementToCheck.nodeType === Node.ELEMENT_NODE && (nodes.indexOf(elementToCheck.nodeName) > -1 || nodes.indexOf(elementToCheck) > -1)) {
      return elementToCheck;
    }
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return null;
}
function closestDown(element, nodes, until) {
  var matched = [];
  var elementToCheck = element;
  while (elementToCheck) {
    elementToCheck = closest(elementToCheck, nodes, until);
    if (!elementToCheck || until && !until.contains(elementToCheck)) {
      break;
    }
    matched.push(elementToCheck);
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  var length = matched.length;
  return length ? matched[length - 1] : null;
}
function isChildOf(child, parent) {
  var node = child.parentNode;
  var queriedParents = [];
  if (typeof parent === "string") {
    queriedParents = Array.prototype.slice.call(document.querySelectorAll(parent), 0);
  } else {
    queriedParents.push(parent);
  }
  while (node !== null) {
    if (queriedParents.indexOf(node) > -1) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
function isChildOfWebComponentTable(element) {
  var hotTableName = "hot-table";
  var result = false;
  var parentNode = polymerWrap(element);
  function isHotTable(testElement) {
    return testElement.nodeType === Node.ELEMENT_NODE && testElement.nodeName === hotTableName.toUpperCase();
  }
  while (parentNode !== null) {
    if (isHotTable(parentNode)) {
      result = true;
      break;
    } else if (parentNode.host && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      result = isHotTable(parentNode.host);
      if (result) {
        break;
      }
      parentNode = parentNode.host;
    }
    parentNode = parentNode.parentNode;
  }
  return result;
}
function polymerWrap(element) {
  return typeof Polymer !== "undefined" && typeof wrap === "function" ? wrap(element) : element;
}
function polymerUnwrap(element) {
  return typeof Polymer !== "undefined" && typeof unwrap === "function" ? unwrap(element) : element;
}
function index(element) {
  var i = 0;
  var elementToCheck = element;
  if (elementToCheck.previousSibling) {
    while (elementToCheck = elementToCheck.previousSibling) {
      i += 1;
    }
  }
  return i;
}
function overlayContainsElement(overlayType, element) {
  var overlayElement = document.querySelector(".ht_clone_".concat(overlayType));
  return overlayElement ? overlayElement.contains(element) : null;
}
var classListSupport = !!document.documentElement.classList;
var _hasClass;
var _addClass;
var _removeClass;
function filterEmptyClassNames(classNames) {
  var result = [];
  if (!classNames || !classNames.length) {
    return result;
  }
  var len = 0;
  while (classNames[len]) {
    result.push(classNames[len]);
    len += 1;
  }
  return result;
}
if (classListSupport) {
  isSupportMultipleClassesArg = function() {
    var element = document.createElement("div");
    element.classList.add("test", "test2");
    return element.classList.contains("test2");
  }();
  _hasClass = function _hasClass2(element, className) {
    if (element.classList === void 0 || typeof className !== "string" || className === "") {
      return false;
    }
    return element.classList.contains(className);
  };
  _addClass = function _addClass2(element, classes) {
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    if (className.length > 0) {
      if (isSupportMultipleClassesArg) {
        var _element$classList;
        (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray2(className));
      } else {
        var len = 0;
        while (className && className[len]) {
          element.classList.add(className[len]);
          len += 1;
        }
      }
    }
  };
  _removeClass = function _removeClass2(element, classes) {
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    className = filterEmptyClassNames(className);
    if (className.length > 0) {
      if (isSupportMultipleClassesArg) {
        var _element$classList2;
        (_element$classList2 = element.classList).remove.apply(_element$classList2, _toConsumableArray2(className));
      } else {
        var len = 0;
        while (className && className[len]) {
          element.classList.remove(className[len]);
          len += 1;
        }
      }
    }
  };
} else {
  createClassNameRegExp = function createClassNameRegExp2(className) {
    return new RegExp("(\\s|^)".concat(className, "(\\s|$)"));
  };
  _hasClass = function _hasClass2(element, className) {
    return element.className !== void 0 && createClassNameRegExp(className).test(element.className);
  };
  _addClass = function _addClass2(element, classes) {
    var len = 0;
    var _className = element.className;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    if (_className === "") {
      _className = className.join(" ");
    } else {
      while (className && className[len]) {
        if (!createClassNameRegExp(className[len]).test(_className)) {
          _className += " ".concat(className[len]);
        }
        len += 1;
      }
    }
    element.className = _className;
  };
  _removeClass = function _removeClass2(element, classes) {
    var len = 0;
    var _className = element.className;
    var className = classes;
    if (typeof className === "string") {
      className = className.split(" ");
    }
    while (className && className[len]) {
      _className = _className.replace(createClassNameRegExp(className[len]), " ").trim();
      len += 1;
    }
    if (element.className !== _className) {
      element.className = _className;
    }
  };
}
var isSupportMultipleClassesArg;
var createClassNameRegExp;
function hasClass(element, className) {
  return _hasClass(element, className);
}
function addClass(element, className) {
  return _addClass(element, className);
}
function removeClass(element, className) {
  return _removeClass(element, className);
}
function removeTextNodes(element, parent) {
  if (element.nodeType === 3) {
    parent.removeChild(element);
  } else if (["TABLE", "THEAD", "TBODY", "TFOOT", "TR"].indexOf(element.nodeName) > -1) {
    var childs = element.childNodes;
    for (var i = childs.length - 1; i >= 0; i--) {
      removeTextNodes(childs[i], element);
    }
  }
}
function empty(element) {
  var child;
  while (child = element.lastChild) {
    element.removeChild(child);
  }
}
var HTML_CHARACTERS = /(<(.*)>|&(.*);)/;
function fastInnerHTML(element, content) {
  if (HTML_CHARACTERS.test(content)) {
    element.innerHTML = content;
  } else {
    fastInnerText(element, content);
  }
}
var textContextSupport = !!document.createTextNode("test").textContent;
function fastInnerText(element, content) {
  var child = element.firstChild;
  if (child && child.nodeType === 3 && child.nextSibling === null) {
    if (textContextSupport) {
      child.textContent = content;
    } else {
      child.data = content;
    }
  } else {
    empty(element);
    element.appendChild(document.createTextNode(content));
  }
}
function isVisible(elem) {
  var next = elem;
  while (polymerUnwrap(next) !== document.documentElement) {
    if (next === null) {
      return false;
    } else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      if (next.host) {
        if (next.host.impl) {
          return isVisible(next.host.impl);
        } else if (next.host) {
          return isVisible(next.host);
        }
        throw new Error("Lost in Web Components world");
      } else {
        return false;
      }
    } else if (next.style.display === "none") {
      return false;
    }
    next = next.parentNode;
  }
  return true;
}
function offset(elem) {
  var docElem = document.documentElement;
  var elementToCheck = elem;
  var offsetLeft;
  var offsetTop;
  var lastElem;
  var box;
  if (hasCaptionProblem() && elementToCheck.firstChild && elementToCheck.firstChild.nodeName === "CAPTION") {
    box = elementToCheck.getBoundingClientRect();
    return {
      top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
      left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
    };
  }
  offsetLeft = elementToCheck.offsetLeft;
  offsetTop = elementToCheck.offsetTop;
  lastElem = elementToCheck;
  while (elementToCheck = elementToCheck.offsetParent) {
    if (elementToCheck === document.body) {
      break;
    }
    offsetLeft += elementToCheck.offsetLeft;
    offsetTop += elementToCheck.offsetTop;
    lastElem = elementToCheck;
  }
  if (lastElem && lastElem.style.position === "fixed") {
    offsetLeft += window.pageXOffset || docElem.scrollLeft;
    offsetTop += window.pageYOffset || docElem.scrollTop;
  }
  return {
    left: offsetLeft,
    top: offsetTop
  };
}
function getWindowScrollTop() {
  var res = window.scrollY;
  if (res === void 0) {
    res = document.documentElement.scrollTop;
  }
  return res;
}
function getWindowScrollLeft() {
  var res = window.scrollX;
  if (res === void 0) {
    res = document.documentElement.scrollLeft;
  }
  return res;
}
function getScrollTop(element) {
  if (element === window) {
    return getWindowScrollTop();
  }
  return element.scrollTop;
}
function getScrollLeft(element) {
  if (element === window) {
    return getWindowScrollLeft();
  }
  return element.scrollLeft;
}
function getScrollableElement(element) {
  var props = ["auto", "scroll"];
  var el = element.parentNode;
  var overflow;
  var overflowX;
  var overflowY;
  var computedStyle = "";
  var computedOverflow = "";
  var computedOverflowY = "";
  var computedOverflowX = "";
  while (el && el.style && document.body !== el) {
    overflow = el.style.overflow;
    overflowX = el.style.overflowX;
    overflowY = el.style.overflowY;
    if (overflow === "scroll" || overflowX === "scroll" || overflowY === "scroll") {
      return el;
    } else if (window.getComputedStyle) {
      computedStyle = window.getComputedStyle(el);
      computedOverflow = computedStyle.getPropertyValue("overflow");
      computedOverflowY = computedStyle.getPropertyValue("overflow-y");
      computedOverflowX = computedStyle.getPropertyValue("overflow-x");
      if (computedOverflow === "scroll" || computedOverflowX === "scroll" || computedOverflowY === "scroll") {
        return el;
      }
    }
    if (el.clientHeight <= el.scrollHeight + 1 && (props.indexOf(overflowY) !== -1 || props.indexOf(overflow) !== -1 || props.indexOf(computedOverflow) !== -1 || props.indexOf(computedOverflowY) !== -1)) {
      return el;
    }
    if (el.clientWidth <= el.scrollWidth + 1 && (props.indexOf(overflowX) !== -1 || props.indexOf(overflow) !== -1 || props.indexOf(computedOverflow) !== -1 || props.indexOf(computedOverflowX) !== -1)) {
      return el;
    }
    el = el.parentNode;
  }
  return window;
}
function getTrimmingContainer(base) {
  var el = base.parentNode;
  while (el && el.style && document.body !== el) {
    if (el.style.overflow !== "visible" && el.style.overflow !== "") {
      return el;
    }
    var computedStyle = getComputedStyle2(el);
    var allowedProperties = ["scroll", "hidden", "auto"];
    var property = computedStyle.getPropertyValue("overflow");
    var propertyY = computedStyle.getPropertyValue("overflow-y");
    var propertyX = computedStyle.getPropertyValue("overflow-x");
    if (allowedProperties.includes(property) || allowedProperties.includes(propertyY) || allowedProperties.includes(propertyX)) {
      return el;
    }
    el = el.parentNode;
  }
  return window;
}
function getStyle(element, prop) {
  if (!element) {
    return;
  } else if (element === window) {
    if (prop === "width") {
      return window.innerWidth + "px";
    } else if (prop === "height") {
      return window.innerHeight + "px";
    }
    return;
  }
  var styleProp = element.style[prop], computedStyle;
  if (styleProp !== "" && styleProp !== void 0) {
    return styleProp;
  } else {
    computedStyle = getComputedStyle2(element);
    if (computedStyle[prop] !== "" && computedStyle[prop] !== void 0) {
      return computedStyle[prop];
    }
  }
}
function getComputedStyle2(element) {
  return element.currentStyle || document.defaultView.getComputedStyle(element);
}
function outerWidth(element) {
  return element.offsetWidth;
}
function outerHeight(elem) {
  if (hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === "CAPTION") {
    return elem.offsetHeight + elem.firstChild.offsetHeight;
  }
  return elem.offsetHeight;
}
function innerHeight(element) {
  return element.clientHeight || element.innerHeight;
}
function innerWidth(element) {
  return element.clientWidth || element.innerWidth;
}
function addEvent(element, event2, callback) {
  if (window.addEventListener) {
    element.addEventListener(event2, callback, false);
  } else {
    element.attachEvent("on" + event2, callback);
  }
}
function removeEvent(element, event2, callback) {
  if (window.removeEventListener) {
    element.removeEventListener(event2, callback, false);
  } else {
    element.detachEvent("on" + event2, callback);
  }
}
function getCaretPosition(el) {
  if (el.selectionStart) {
    return el.selectionStart;
  } else if (document.selection) {
    el.focus();
    var r = document.selection.createRange();
    if (r == null) {
      return 0;
    }
    var re = el.createTextRange();
    var rc = re.duplicate();
    re.moveToBookmark(r.getBookmark());
    rc.setEndPoint("EndToStart", re);
    return rc.text.length;
  }
  return 0;
}
function getSelectionEndPosition(el) {
  if (el.selectionEnd) {
    return el.selectionEnd;
  } else if (document.selection) {
    var r = document.selection.createRange();
    if (r == null) {
      return 0;
    }
    var re = el.createTextRange();
    return re.text.indexOf(r.text) + r.text.length;
  }
  return 0;
}
function getSelectionText() {
  var text = "";
  if (window.getSelection) {
    text = window.getSelection().toString();
  } else if (document.selection && document.selection.type !== "Control") {
    text = document.selection.createRange().text;
  }
  return text;
}
function setCaretPosition(element, pos, endPos) {
  if (endPos === void 0) {
    endPos = pos;
  }
  if (element.setSelectionRange) {
    element.focus();
    try {
      element.setSelectionRange(pos, endPos);
    } catch (err) {
      var elementParent = element.parentNode;
      var parentDisplayValue = elementParent.style.display;
      elementParent.style.display = "block";
      element.setSelectionRange(pos, endPos);
      elementParent.style.display = parentDisplayValue;
    }
  } else if (element.createTextRange) {
    var range = element.createTextRange();
    range.collapse(true);
    range.moveEnd("character", endPos);
    range.moveStart("character", pos);
    range.select();
  }
}
var cachedScrollbarWidth;
function walkontableCalculateScrollbarWidth() {
  var inner = document.createElement("div");
  inner.style.height = "200px";
  inner.style.width = "100%";
  var outer = document.createElement("div");
  outer.style.boxSizing = "content-box";
  outer.style.height = "150px";
  outer.style.left = "0px";
  outer.style.overflow = "hidden";
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.width = "200px";
  outer.style.visibility = "hidden";
  outer.appendChild(inner);
  (document.body || document.documentElement).appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  var w2 = inner.offsetWidth;
  if (w1 == w2) {
    w2 = outer.clientWidth;
  }
  (document.body || document.documentElement).removeChild(outer);
  return w1 - w2;
}
function getScrollbarWidth() {
  if (cachedScrollbarWidth === void 0) {
    cachedScrollbarWidth = walkontableCalculateScrollbarWidth();
  }
  return cachedScrollbarWidth;
}
function hasVerticalScrollbar(element) {
  return element.offsetWidth !== element.clientWidth;
}
function hasHorizontalScrollbar(element) {
  return element.offsetHeight !== element.clientHeight;
}
function setOverlayPosition(overlayElem, left2, top2) {
  if (isIE8() || isIE9()) {
    overlayElem.style.top = top2;
    overlayElem.style.left = left2;
  } else if (isSafari()) {
    overlayElem.style["-webkit-transform"] = "translate3d(" + left2 + "," + top2 + ",0)";
  } else {
    overlayElem.style.transform = "translate3d(" + left2 + "," + top2 + ",0)";
  }
}
function getCssTransform(element) {
  var transform;
  if (element.style.transform && (transform = element.style.transform) !== "") {
    return ["transform", transform];
  } else if (element.style["-webkit-transform"] && (transform = element.style["-webkit-transform"]) !== "") {
    return ["-webkit-transform", transform];
  }
  return -1;
}
function resetCssTransform(element) {
  if (element.style.transform && element.style.transform !== "") {
    element.style.transform = "";
  } else if (element.style["-webkit-transform"] && element.style["-webkit-transform"] !== "") {
    element.style["-webkit-transform"] = "";
  }
}
function isInput(element) {
  var inputs = ["INPUT", "SELECT", "TEXTAREA"];
  return element && (inputs.indexOf(element.nodeName) > -1 || element.contentEditable === "true");
}
function isOutsideInput(element) {
  return isInput(element) && element.className.indexOf("handsontableInput") == -1 && element.className.indexOf("copyPaste") == -1;
}

// node_modules/handsontable/es/helpers/dom/event.js
var event_exports = {};
__export(event_exports, {
  isImmediatePropagationStopped: () => isImmediatePropagationStopped,
  isLeftClick: () => isLeftClick,
  isRightClick: () => isRightClick,
  pageX: () => pageX,
  pageY: () => pageY,
  stopImmediatePropagation: () => stopImmediatePropagation,
  stopPropagation: () => stopPropagation
});
function stopImmediatePropagation(event2) {
  event2.isImmediatePropagationEnabled = false;
  event2.cancelBubble = true;
}
function isImmediatePropagationStopped(event2) {
  return event2.isImmediatePropagationEnabled === false;
}
function stopPropagation(event2) {
  if (typeof event2.stopPropagation === "function") {
    event2.stopPropagation();
  } else {
    event2.cancelBubble = true;
  }
}
function pageX(event2) {
  if (event2.pageX) {
    return event2.pageX;
  }
  return event2.clientX + getWindowScrollLeft();
}
function pageY(event2) {
  if (event2.pageY) {
    return event2.pageY;
  }
  return event2.clientY + getWindowScrollTop();
}
function isRightClick(event2) {
  return event2.button === 2;
}
function isLeftClick(event2) {
  return event2.button === 0;
}

// node_modules/handsontable/es/eventManager.js
function _classCallCheck8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass8(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties8(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties8(Constructor, staticProps);
  return Constructor;
}
var listenersCounter = 0;
var EventManager = function() {
  function EventManager2() {
    var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    _classCallCheck8(this, EventManager2);
    this.context = context || this;
    if (!this.context.eventListeners) {
      this.context.eventListeners = [];
    }
  }
  _createClass8(EventManager2, [{
    key: "addEventListener",
    value: function addEventListener(element, eventName, callback) {
      var _this = this;
      var context = this.context;
      function callbackProxy(event2) {
        callback.call(this, extendEvent(context, event2));
      }
      this.context.eventListeners.push({
        element,
        event: eventName,
        callback,
        callbackProxy
      });
      element.addEventListener(eventName, callbackProxy, false);
      listenersCounter += 1;
      return function() {
        _this.removeEventListener(element, eventName, callback);
      };
    }
    /**
     * Remove the event listener previously registered.
     *
     * @param {Element} element Target element.
     * @param {String} eventName Event name.
     * @param {Function} callback Function to remove from the event target. It must be the same as during registration listener.
     */
  }, {
    key: "removeEventListener",
    value: function removeEventListener(element, eventName, callback) {
      var len = this.context.eventListeners.length;
      var tmpEvent;
      while (len) {
        len -= 1;
        tmpEvent = this.context.eventListeners[len];
        if (tmpEvent.event === eventName && tmpEvent.element === element) {
          if (callback && callback !== tmpEvent.callback) {
            continue;
          }
          this.context.eventListeners.splice(len, 1);
          tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, false);
          listenersCounter -= 1;
        }
      }
    }
    /**
     * Clear all previously registered events.
     *
     * @private
     * @since 0.15.0-beta3
     */
  }, {
    key: "clearEvents",
    value: function clearEvents() {
      if (!this.context) {
        return;
      }
      var len = this.context.eventListeners.length;
      while (len) {
        len -= 1;
        var event2 = this.context.eventListeners[len];
        if (event2) {
          this.removeEventListener(event2.element, event2.event, event2.callback);
        }
      }
    }
    /**
     * Clear all previously registered events.
     */
  }, {
    key: "clear",
    value: function clear() {
      this.clearEvents();
    }
    /**
     * Destroy instance of EventManager.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.clearEvents();
      this.context = null;
    }
    /**
     * Trigger event at the specified target element.
     *
     * @param {Element} element Target element.
     * @param {String} eventName Event name.
     */
  }, {
    key: "fireEvent",
    value: function fireEvent(element, eventName) {
      var options = {
        bubbles: true,
        cancelable: eventName !== "mousemove",
        view: window,
        detail: 0,
        screenX: 0,
        screenY: 0,
        clientX: 1,
        clientY: 1,
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        metaKey: false,
        button: 0,
        relatedTarget: void 0
      };
      var event2;
      if (document.createEvent) {
        event2 = document.createEvent("MouseEvents");
        event2.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, options.relatedTarget || document.body.parentNode);
      } else {
        event2 = document.createEventObject();
      }
      if (element.dispatchEvent) {
        element.dispatchEvent(event2);
      } else {
        element.fireEvent("on".concat(eventName), event2);
      }
    }
  }]);
  return EventManager2;
}();
function extendEvent(context, event2) {
  var componentName = "HOT-TABLE";
  var isHotTableSpotted;
  var fromElement;
  var realTarget;
  var target;
  var len;
  event2.isTargetWebComponent = false;
  event2.realTarget = event2.target;
  var nativeStopImmediatePropagation = event2.stopImmediatePropagation;
  event2.stopImmediatePropagation = function() {
    nativeStopImmediatePropagation.apply(this);
    stopImmediatePropagation(this);
  };
  if (!EventManager.isHotTableEnv) {
    return event2;
  }
  event2 = polymerWrap(event2);
  len = event2.path ? event2.path.length : 0;
  while (len) {
    len -= 1;
    if (event2.path[len].nodeName === componentName) {
      isHotTableSpotted = true;
    } else if (isHotTableSpotted && event2.path[len].shadowRoot) {
      target = event2.path[len];
      break;
    }
    if (len === 0 && !target) {
      target = event2.path[len];
    }
  }
  if (!target) {
    target = event2.target;
  }
  event2.isTargetWebComponent = true;
  if (isWebComponentSupportedNatively()) {
    event2.realTarget = event2.srcElement || event2.toElement;
  } else if (hasOwnProperty(context, "hot") || context.isHotTableEnv || context.wtTable) {
    if (hasOwnProperty(context, "hot")) {
      fromElement = context.hot ? context.hot.view.wt.wtTable.TABLE : null;
    } else if (context.isHotTableEnv) {
      fromElement = context.view.activeWt.wtTable.TABLE.parentNode.parentNode;
    } else if (context.wtTable) {
      fromElement = context.wtTable.TABLE.parentNode.parentNode;
    }
    realTarget = closest(event2.target, [componentName], fromElement);
    if (realTarget) {
      event2.realTarget = fromElement.querySelector(componentName) || event2.target;
    } else {
      event2.realTarget = event2.target;
    }
  }
  Object.defineProperty(event2, "target", {
    get: function get5() {
      return polymerWrap(target);
    },
    enumerable: true,
    configurable: true
  });
  return event2;
}
var eventManager_default = EventManager;
function getListenersCounter() {
  return listenersCounter;
}

// node_modules/handsontable/es/helpers/string.js
var string_exports = {};
__export(string_exports, {
  equalsIgnoreCase: () => equalsIgnoreCase,
  isPercentValue: () => isPercentValue,
  randomString: () => randomString,
  stripTags: () => stripTags,
  substitute: () => substitute,
  toUpperCaseFirst: () => toUpperCaseFirst
});

// node_modules/handsontable/es/helpers/mixed.js
var mixed_exports = {};
__export(mixed_exports, {
  _injectProductInfo: () => _injectProductInfo,
  isDefined: () => isDefined,
  isEmpty: () => isEmpty,
  isRegExp: () => isRegExp,
  isUndefined: () => isUndefined2,
  stringify: () => stringify
});

// node_modules/moment/src/lib/utils/hooks.js
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}

// node_modules/moment/src/lib/utils/is-array.js
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}

// node_modules/moment/src/lib/utils/is-object.js
function isObject2(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}

// node_modules/moment/src/lib/utils/is-object-empty.js
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (obj.hasOwnProperty(k)) {
        return false;
      }
    }
    return true;
  }
}

// node_modules/moment/src/lib/utils/is-undefined.js
function isUndefined(input) {
  return input === void 0;
}

// node_modules/moment/src/lib/utils/is-number.js
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}

// node_modules/moment/src/lib/utils/is-date.js
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}

// node_modules/moment/src/lib/utils/map.js
function map(arr, fn) {
  var res = [], i;
  for (i = 0; i < arr.length; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}

// node_modules/moment/src/lib/utils/has-own-prop.js
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}

// node_modules/moment/src/lib/utils/extend.js
function extend2(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}

// node_modules/moment/src/lib/create/utc.js
function createUTC(input, format4, locale3, strict) {
  return createLocalOrUTC(input, format4, locale3, strict, true).utc();
}

// node_modules/moment/src/lib/create/parsing-flags.js
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}

// node_modules/moment/src/lib/utils/some.js
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t = Object(this);
    var len = t.length >>> 0;
    for (var i = 0; i < len; i++) {
      if (i in t && fun.call(this, t[i], i, t)) {
        return true;
      }
    }
    return false;
  };
}

// node_modules/moment/src/lib/create/valid.js
function isValid(m) {
  if (m._isValid == null) {
    var flags = getParsingFlags(m);
    var parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    });
    var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m)) {
      m._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m._isValid;
}
function createInvalid(flags) {
  var m = createUTC(NaN);
  if (flags != null) {
    extend2(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}

// node_modules/moment/src/lib/moment/constructor.js
var momentProperties = hooks.momentProperties = [];
function copyConfig(to3, from3) {
  var i, prop, val;
  if (!isUndefined(from3._isAMomentObject)) {
    to3._isAMomentObject = from3._isAMomentObject;
  }
  if (!isUndefined(from3._i)) {
    to3._i = from3._i;
  }
  if (!isUndefined(from3._f)) {
    to3._f = from3._f;
  }
  if (!isUndefined(from3._l)) {
    to3._l = from3._l;
  }
  if (!isUndefined(from3._strict)) {
    to3._strict = from3._strict;
  }
  if (!isUndefined(from3._tzm)) {
    to3._tzm = from3._tzm;
  }
  if (!isUndefined(from3._isUTC)) {
    to3._isUTC = from3._isUTC;
  }
  if (!isUndefined(from3._offset)) {
    to3._offset = from3._offset;
  }
  if (!isUndefined(from3._pf)) {
    to3._pf = getParsingFlags(from3);
  }
  if (!isUndefined(from3._locale)) {
    to3._locale = from3._locale;
  }
  if (momentProperties.length > 0) {
    for (i = 0; i < momentProperties.length; i++) {
      prop = momentProperties[i];
      val = from3[prop];
      if (!isUndefined(val)) {
        to3[prop] = val;
      }
    }
  }
  return to3;
}
var updateInProgress = false;
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}

// node_modules/moment/src/lib/utils/abs-floor.js
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}

// node_modules/moment/src/lib/utils/to-int.js
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}

// node_modules/moment/src/lib/utils/compare-arrays.js
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}

// node_modules/moment/src/lib/utils/deprecate.js
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend2(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [];
      var arg;
      for (var i = 0; i < arguments.length; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (var key in arguments[0]) {
            arg += key + ": " + arguments[0][key] + ", ";
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

// node_modules/moment/src/lib/utils/is-function.js
function isFunction(input) {
  return input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}

// node_modules/moment/src/lib/locale/set.js
function set(config) {
  var prop, i;
  for (i in config) {
    prop = config[i];
    if (isFunction(prop)) {
      this[i] = prop;
    } else {
      this["_" + i] = prop;
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend2({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
        res[prop] = {};
        extend2(res[prop], parentConfig[prop]);
        extend2(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
      res[prop] = extend2({}, res[prop]);
    }
  }
  return res;
}

// node_modules/moment/src/lib/locale/constructor.js
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}

// node_modules/moment/src/lib/utils/keys.js
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i, res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}

// node_modules/moment/src/lib/locale/calendar.js
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now3) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now3) : output;
}

// node_modules/moment/src/lib/locale/formats.js
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format4 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format4 || !formatUpper) {
    return format4;
  }
  this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
    return val.slice(1);
  });
  return this._longDateFormat[key];
}

// node_modules/moment/src/lib/locale/invalid.js
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}

// node_modules/moment/src/lib/locale/ordinal.js
var defaultOrdinal = "%d";
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}

// node_modules/moment/src/lib/locale/relative.js
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff3, output) {
  var format4 = this._relativeTime[diff3 > 0 ? "future" : "past"];
  return isFunction(format4) ? format4(output) : format4.replace(/%s/i, output);
}

// node_modules/moment/src/lib/units/aliases.js
var aliases = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}

// node_modules/moment/src/lib/units/priorities.js
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [];
  for (var u in unitsObj) {
    units.push({ unit: u, priority: priorities[u] });
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}

// node_modules/moment/src/lib/utils/zero-fill.js
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign3 = number >= 0;
  return (sign3 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

// node_modules/moment/src/lib/format/format.js
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
var formatFunctions = {};
var formatTokenFunctions = {};
function addFormatToken(token3, padded, ordinal3, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token3) {
    formatTokenFunctions[token3] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal3) {
    formatTokenFunctions[ordinal3] = function() {
      return this.localeData().ordinal(func.apply(this, arguments), token3);
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format4) {
  var array = format4.match(formattingTokens), i, length;
  for (i = 0, length = array.length; i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction(array[i2]) ? array[i2].call(mom, format4) : array[i2];
    }
    return output;
  };
}
function formatMoment(m, format4) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format4 = expandFormat(format4, m.localeData());
  formatFunctions[format4] = formatFunctions[format4] || makeFormatFunction(format4);
  return formatFunctions[format4](m);
}
function expandFormat(format4, locale3) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale3.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format4)) {
    format4 = format4.replace(localFormattingTokens, replaceLongDateFormatTokens);
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format4;
}

// node_modules/moment/src/lib/parse/regex.js
var match1 = /\d/;
var match2 = /\d\d/;
var match3 = /\d{3}/;
var match4 = /\d{4}/;
var match6 = /[+-]?\d{6}/;
var match1to2 = /\d\d?/;
var match3to4 = /\d\d\d\d?/;
var match5to6 = /\d\d\d\d\d\d?/;
var match1to3 = /\d{1,3}/;
var match1to4 = /\d{1,4}/;
var match1to6 = /[+-]?\d{1,6}/;
var matchUnsigned = /\d+/;
var matchSigned = /[+-]?\d+/;
var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
var regexes = {};
function addRegexToken(token3, regex, strictRegex) {
  regexes[token3] = isFunction(regex) ? regex : function(isStrict, localeData3) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token3, config) {
  if (!hasOwnProp(regexes, token3)) {
    return new RegExp(unescapeFormat(token3));
  }
  return regexes[token3](config._strict, config._locale);
}
function unescapeFormat(s) {
  return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
    return p1 || p2 || p3 || p4;
  }));
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}

// node_modules/moment/src/lib/parse/token.js
var tokens = {};
function addParseToken(token3, callback) {
  var i, func = callback;
  if (typeof token3 === "string") {
    token3 = [token3];
  }
  if (isNumber(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  for (i = 0; i < token3.length; i++) {
    tokens[token3[i]] = func;
  }
}
function addWeekParseToken(token3, callback) {
  addParseToken(token3, function(input, array, config, token4) {
    config._w = config._w || {};
    callback(input, config._w, config, token4);
  });
}
function addTimeToArrayFromToken(token3, input, config) {
  if (input != null && hasOwnProp(tokens, token3)) {
    tokens[token3](input, config._a, config, token3);
  }
}

// node_modules/moment/src/lib/units/constants.js
var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// node_modules/moment/src/lib/units/year.js
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? "" + y : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}

// node_modules/moment/src/lib/moment/get-set.js
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set2(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set2(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units);
    for (var i = 0; i < prioritized.length; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}

// node_modules/moment/src/lib/utils/mod.js
function mod(n, x) {
  return (n % x + x) % x;
}

// node_modules/moment/src/lib/utils/index-of.js
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o) {
    var i;
    for (i = 0; i < this.length; ++i) {
      if (this[i] === o) {
        return i;
      }
    }
    return -1;
  };
}

// node_modules/moment/src/lib/units/month.js
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format4) {
  return this.localeData().monthsShort(this, format4);
});
addFormatToken("MMMM", 0, 0, function(format4) {
  return this.localeData().months(this, format4);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale3) {
  return locale3.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale3) {
  return locale3.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config, token3) {
  var month = config._locale.monthsParse(input, token3, config._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config).invalidMonth = input;
  }
});
var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
function localeMonths(m, format4) {
  if (!m) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format4) ? "format" : "standalone"][m.month()];
}
var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
function localeMonthsShort(m, format4) {
  if (!m) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format4) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format4, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format4 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format4 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format4, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format4, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
      this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format4 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format4 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
var defaultMonthsShortRegex = matchWord;
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
var defaultMonthsRegex = matchWord;
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i = 0; i < 12; i++) {
    shortPieces[i] = regexEscape(shortPieces[i]);
    longPieces[i] = regexEscape(longPieces[i]);
  }
  for (i = 0; i < 24; i++) {
    mixedPieces[i] = regexEscape(mixedPieces[i]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
}

// node_modules/moment/src/lib/create/date-from-array.js
function createDate(y, m, d, h, M, s, ms) {
  var date = new Date(y, m, d, h, M, s, ms);
  if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
    date.setFullYear(y);
  }
  return date;
}
function createUTCDate(y) {
  var date = new Date(Date.UTC.apply(null, arguments));
  if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
    date.setUTCFullYear(y);
  }
  return date;
}

// node_modules/moment/src/lib/units/week-calendar-utils.js
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// node_modules/moment/src/lib/units/week.js
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token3) {
  week[token3.substr(0, 1)] = toInt(input);
});
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 1st is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}

// node_modules/moment/src/lib/units/day-of-week.js
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format4) {
  return this.localeData().weekdaysMin(this, format4);
});
addFormatToken("ddd", 0, 0, function(format4) {
  return this.localeData().weekdaysShort(this, format4);
});
addFormatToken("dddd", 0, 0, function(format4) {
  return this.localeData().weekdays(this, format4);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale3) {
  return locale3.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale3) {
  return locale3.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale3) {
  return locale3.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token3) {
  var weekday = config._locale.weekdaysParse(input, token3, config._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config, token3) {
  week[token3] = toInt(input);
});
function parseWeekday(input, locale3) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale3.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale3) {
  if (typeof input === "string") {
    return locale3.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
function localeWeekdays(m, format4) {
  if (!m) {
    return isArray(this._weekdays) ? this._weekdays : this._weekdays["standalone"];
  }
  return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format4) ? "format" : "standalone"][m.day()];
}
var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
function localeWeekdaysShort(m) {
  return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
function localeWeekdaysMin(m) {
  return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse2(weekdayName, format4, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format4 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format4 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format4 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format4 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format4, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse2.call(this, weekdayName, format4, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", ".?") + "$", "i");
      this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", ".?") + "$", "i");
      this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", ".?") + "$", "i");
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format4 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format4 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format4 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
var defaultWeekdaysRegex = matchWord;
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = this.weekdaysMin(mom, "");
    shortp = this.weekdaysShort(mom, "");
    longp = this.weekdays(mom, "");
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i = 0; i < 7; i++) {
    shortPieces[i] = regexEscape(shortPieces[i]);
    longPieces[i] = regexEscape(longPieces[i]);
    mixedPieces[i] = regexEscape(mixedPieces[i]);
  }
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
}

// node_modules/moment/src/lib/units/hour.js
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token3, lowercase) {
  addFormatToken(token3, 0, 0, function() {
    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale3) {
  return locale3._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config) {
  config._isPm = config._locale.isPM(input);
  config._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config) {
  array[HOUR] = toInt(input);
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmmss", function(input, array, config) {
  var pos1 = input.length - 4;
  var pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config).bigHour = true;
});
addParseToken("Hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config) {
  var pos1 = input.length - 4;
  var pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem(hours3, minutes3, isLower) {
  if (hours3 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var getSetHour = makeGetSet("Hours", true);

// node_modules/moment/src/lib/locale/base-config.js
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};

// node_modules/moment/src/lib/locale/locales.js
var locales = {};
var localeFamilies = {};
var globalLocale;
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j, next, locale3, split;
  while (i < names.length) {
    split = normalizeLocale(names[i]).split("-");
    j = split.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale3 = loadLocale(split.slice(0, j).join("-"));
      if (locale3) {
        return locale3;
      }
      if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return null;
}
function loadLocale(name) {
  var oldLocale = null;
  if (!locales[name] && typeof module !== "undefined" && module && module.exports) {
    try {
      oldLocale = globalLocale._abbr;
      var aliasedRequire = __require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        if (!localeFamilies[config.parentLocale]) {
          localeFamilies[config.parentLocale] = [];
        }
        localeFamilies[config.parentLocale].push({
          name,
          config
        });
        return null;
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale3, tmpLocale, parentConfig = baseConfig;
    tmpLocale = loadLocale(name);
    if (tmpLocale != null) {
      parentConfig = tmpLocale._config;
    }
    config = mergeConfigs(parentConfig, config);
    locale3 = new Locale(config);
    locale3.parentLocale = locales[name];
    locales[name] = locale3;
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale3;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale3 = loadLocale(key);
    if (locale3) {
      return locale3;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}

// node_modules/moment/src/lib/create/check-overflow.js
function checkOverflow(m) {
  var overflow;
  var a = m._a;
  if (a && getParsingFlags(m).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}

// node_modules/moment/src/lib/utils/defaults.js
function defaults(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}

// node_modules/moment/src/lib/create/from-array.js
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i = 0; i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
    week = defaults(w.W, 1);
    weekday = defaults(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    var curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
    week = defaults(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}

// node_modules/moment/src/lib/create/from-string.js
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
var isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  // YYYYMM is NOT allowed by the standard
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/]
];
var isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
];
var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
function configFromISO(config) {
  var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
  if (match) {
    getParsingFlags(config).iso = true;
    for (i = 0, l = isoDates.length; i < l; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l = isoTimes.length; i < l; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
var obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10);
    var m = hm % 100, h = (hm - m) / 100;
    return h * 60 + m;
  }
}
function configFromRFC2822(config) {
  var match = rfc2822.exec(preprocessRFC2822(config._i));
  if (match) {
    var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  hooks.createFromInputFallback(config);
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config) {
    config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
  }
);

// node_modules/moment/src/lib/create/from-string-and-format.js
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i, parsedInput, tokens3, token3, skipped, stringLength = string.length, totalParsedInputLength = 0;
  tokens3 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  for (i = 0; i < tokens3.length; i++) {
    token3 = tokens3[i];
    parsedInput = (string.match(getParseRegexForToken(token3, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token3]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token3);
      }
      addTimeToArrayFromToken(token3, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token3);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale3, hour, meridiem3) {
  var isPm;
  if (meridiem3 == null) {
    return hour;
  }
  if (locale3.meridiemHour != null) {
    return locale3.meridiemHour(hour, meridiem3);
  } else if (locale3.isPM != null) {
    isPm = locale3.isPM(meridiem3);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}

// node_modules/moment/src/lib/create/from-string-and-array.js
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore;
  if (config._f.length === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i = 0; i < config._f.length; i++) {
    currentScore = 0;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat(tempConfig);
    if (!isValid(tempConfig)) {
      continue;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (scoreToBeat == null || currentScore < scoreToBeat) {
      scoreToBeat = currentScore;
      bestMoment = tempConfig;
    }
  }
  extend2(config, bestMoment || tempConfig);
}

// node_modules/moment/src/lib/create/from-object.js
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i = normalizeObjectUnits(config._i);
  config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
    return obj && parseInt(obj, 10);
  });
  configFromArray(config);
}

// node_modules/moment/src/lib/create/from-anything.js
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format4 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format4 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config._d = input;
  } else if (isArray(format4)) {
    configFromStringAndArray(config);
  } else if (format4) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray(input)) {
    config._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject2(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format4, locale3, strict, isUTC) {
  var c = {};
  if (locale3 === true || locale3 === false) {
    strict = locale3;
    locale3 = void 0;
  }
  if (isObject2(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale3;
  c._i = input;
  c._f = format4;
  c._strict = strict;
  return createFromConfig(c);
}

// node_modules/moment/src/lib/create/local.js
function createLocal(input, format4, locale3, strict) {
  return createLocalOrUTC(input, format4, locale3, strict, false);
}

// node_modules/moment/src/lib/moment/min-max.js
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
var prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}

// node_modules/moment/src/lib/moment/now.js
var now = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
};

// node_modules/moment/src/lib/duration/valid.js
var ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
function isDurationValid(m) {
  for (var key in m) {
    if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  var unitHasDecimal = false;
  for (var i = 0; i < ordering.length; ++i) {
    if (m[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid2() {
  return this._isValid;
}
function createInvalid2() {
  return createDuration(NaN);
}

// node_modules/moment/src/lib/duration/constructor.js
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years3 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months3 = normalizedInput.month || 0, weeks3 = normalizedInput.week || 0, days3 = normalizedInput.day || 0, hours3 = normalizedInput.hour || 0, minutes3 = normalizedInput.minute || 0, seconds3 = normalizedInput.second || 0, milliseconds3 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds3 + seconds3 * 1e3 + // 1000
  minutes3 * 6e4 + // 1000 * 60
  hours3 * 1e3 * 60 * 60;
  this._days = +days3 + weeks3 * 7;
  this._months = +months3 + quarters * 3 + years3 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}

// node_modules/moment/src/lib/utils/abs-round.js
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}

// node_modules/moment/src/lib/units/offset.js
function offset2(token3, separator) {
  addFormatToken(token3, 0, 0, function() {
    var offset4 = this.utcOffset();
    var sign3 = "+";
    if (offset4 < 0) {
      offset4 = -offset4;
      sign3 = "-";
    }
    return sign3 + zeroFill(~~(offset4 / 60), 2) + separator + zeroFill(~~offset4 % 60, 2);
  });
}
offset2("Z", ":");
offset2("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher);
  if (matches === null) {
    return null;
  }
  var chunk = matches[matches.length - 1] || [];
  var parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  var minutes3 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes3 === 0 ? 0 : parts[0] === "+" ? minutes3 : -minutes3;
}
function cloneWithOffset(input, model) {
  var res, diff3;
  if (model._isUTC) {
    res = model.clone();
    diff3 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff3);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset4 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset4 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(this, createDuration(input - offset4, "m"), 1, false);
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset4 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {};
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// node_modules/moment/src/lib/duration/create.js
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match = null, sign3, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input)) {
    duration = {};
    if (key) {
      duration[key] = input;
    } else {
      duration.milliseconds = input;
    }
  } else if (!!(match = aspNetRegex.exec(input))) {
    sign3 = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign3,
      h: toInt(match[HOUR]) * sign3,
      m: toInt(match[MINUTE]) * sign3,
      s: toInt(match[SECOND]) * sign3,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign3
      // the millisecond decimal point is included in the match
    };
  } else if (!!(match = isoRegex.exec(input))) {
    sign3 = match[1] === "-" ? -1 : match[1] === "+" ? 1 : 1;
    duration = {
      y: parseIso(match[2], sign3),
      M: parseIso(match[3], sign3),
      w: parseIso(match[4], sign3),
      d: parseIso(match[5], sign3),
      h: parseIso(match[6], sign3),
      m: parseIso(match[7], sign3),
      s: parseIso(match[8], sign3)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid2;
function parseIso(inp, sign3) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign3;
}
function positiveMomentsDifference(base, other) {
  var res = { milliseconds: 0, months: 0 };
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}

// node_modules/moment/src/lib/moment/add-subtract.js
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
      tmp = val;
      val = period;
      period = tmp;
    }
    val = typeof val === "string" ? +val : val;
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds3 = duration._milliseconds, days3 = absRound(duration._days), months3 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months3) {
    setMonth(mom, get(mom, "Month") + months3 * isAdding);
  }
  if (days3) {
    set2(mom, "Date", get(mom, "Date") + days3 * isAdding);
  }
  if (milliseconds3) {
    mom._d.setTime(mom._d.valueOf() + milliseconds3 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days3 || months3);
  }
}
var add = createAdder(1, "add");
var subtract = createAdder(-1, "subtract");

// node_modules/moment/src/lib/moment/calendar.js
function getCalendarFormat(myMoment, now3) {
  var diff3 = myMoment.diff(now3, "days", true);
  return diff3 < -6 ? "sameElse" : diff3 < -1 ? "lastWeek" : diff3 < 0 ? "lastDay" : diff3 < 1 ? "sameDay" : diff3 < 2 ? "nextDay" : diff3 < 7 ? "nextWeek" : "sameElse";
}
function calendar2(time, formats) {
  var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format4 = hooks.calendarFormat(this, sod) || "sameElse";
  var output = formats && (isFunction(formats[format4]) ? formats[format4].call(this, now3) : formats[format4]);
  return this.format(output || this.localeData().calendar(format4, this, createLocal(now3)));
}

// node_modules/moment/src/lib/moment/clone.js
function clone2() {
  return new Moment(this);
}

// node_modules/moment/src/lib/moment/compare.js
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(!isUndefined(units) ? units : "millisecond");
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(!isUndefined(units) ? units : "millisecond");
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from3, to3, units, inclusivity) {
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(from3, units) : !this.isBefore(from3, units)) && (inclusivity[1] === ")" ? this.isBefore(to3, units) : !this.isAfter(to3, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units || "millisecond");
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}

// node_modules/moment/src/lib/moment/diff.js
function diff(input, units, asFloat) {
  var that, zoneDelta, delta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}

// node_modules/moment/src/lib/moment/format.js
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true;
  var m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this._d.valueOf()).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment";
  var zone = "";
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  var prefix = "[" + func + '("]';
  var year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  var datetime = "-MM-DD[T]HH:mm:ss.SSS";
  var suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}

// node_modules/moment/src/lib/moment/from.js
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}

// node_modules/moment/src/lib/moment/to.js
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}

// node_modules/moment/src/lib/moment/locale.js
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}

// node_modules/moment/src/lib/moment/start-end-of.js
function startOf(units) {
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      this.month(0);
    case "quarter":
    case "month":
      this.date(1);
    case "week":
    case "isoWeek":
    case "day":
    case "date":
      this.hours(0);
    case "hour":
      this.minutes(0);
    case "minute":
      this.seconds(0);
    case "second":
      this.milliseconds(0);
  }
  if (units === "week") {
    this.weekday(0);
  }
  if (units === "isoWeek") {
    this.isoWeekday(1);
  }
  if (units === "quarter") {
    this.month(Math.floor(this.month() / 3) * 3);
  }
  return this;
}
function endOf(units) {
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond") {
    return this;
  }
  if (units === "date") {
    units = "day";
  }
  return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
}

// node_modules/moment/src/lib/moment/to-type.js
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m = this;
  return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}
function toObject() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}

// node_modules/moment/src/lib/moment/valid.js
function isValid3() {
  return isValid(this);
}
function parsingFlags() {
  return extend2({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}

// node_modules/moment/src/lib/moment/creation-data.js
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}

// node_modules/moment/src/lib/units/week-year.js
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token3, getter) {
  addFormatToken(0, [token3, token3.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token3) {
  week[token3.substr(0, 2)] = toInt(input);
});
addWeekParseToken(["gg", "GG"], function(input, week, config, token3) {
  week[token3] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}

// node_modules/moment/src/lib/units/quarter.js
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// node_modules/moment/src/lib/units/day-of-month.js
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale3) {
  return isStrict ? locale3._dayOfMonthOrdinalParse || locale3._ordinalParse : locale3._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);

// node_modules/moment/src/lib/units/day-of-year.js
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config) {
  config._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}

// node_modules/moment/src/lib/units/minute.js
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);

// node_modules/moment/src/lib/units/second.js
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);

// node_modules/moment/src/lib/units/millisecond.js
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
var getSetMillisecond = makeGetSet("Milliseconds", false);

// node_modules/moment/src/lib/units/timezone.js
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}

// node_modules/moment/src/lib/moment/prototype.js
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar2;
proto.clone = clone2;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid3;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
proto.toJSON = toJSON;
proto.toString = toString;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
var prototype_default = proto;

// node_modules/moment/src/lib/moment/moment.js
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}

// node_modules/moment/src/lib/locale/pre-post-format.js
function preParsePostFormat(string) {
  return string;
}

// node_modules/moment/src/lib/locale/prototype.js
var proto2 = Locale.prototype;
proto2.calendar = calendar;
proto2.longDateFormat = longDateFormat;
proto2.invalidDate = invalidDate;
proto2.ordinal = ordinal;
proto2.preparse = preParsePostFormat;
proto2.postformat = preParsePostFormat;
proto2.relativeTime = relativeTime;
proto2.pastFuture = pastFuture;
proto2.set = set;
proto2.months = localeMonths;
proto2.monthsShort = localeMonthsShort;
proto2.monthsParse = localeMonthsParse;
proto2.monthsRegex = monthsRegex;
proto2.monthsShortRegex = monthsShortRegex;
proto2.week = localeWeek;
proto2.firstDayOfYear = localeFirstDayOfYear;
proto2.firstDayOfWeek = localeFirstDayOfWeek;
proto2.weekdays = localeWeekdays;
proto2.weekdaysMin = localeWeekdaysMin;
proto2.weekdaysShort = localeWeekdaysShort;
proto2.weekdaysParse = localeWeekdaysParse;
proto2.weekdaysRegex = weekdaysRegex;
proto2.weekdaysShortRegex = weekdaysShortRegex;
proto2.weekdaysMinRegex = weekdaysMinRegex;
proto2.isPM = localeIsPM;
proto2.meridiem = localeMeridiem;

// node_modules/moment/src/lib/locale/lists.js
function get2(format4, index2, field, setter) {
  var locale3 = getLocale();
  var utc = createUTC().set(setter, index2);
  return locale3[field](utc, format4);
}
function listMonthsImpl(format4, index2, field) {
  if (isNumber(format4)) {
    index2 = format4;
    format4 = void 0;
  }
  format4 = format4 || "";
  if (index2 != null) {
    return get2(format4, index2, field, "month");
  }
  var i;
  var out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get2(format4, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format4, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format4)) {
      index2 = format4;
      format4 = void 0;
    }
    format4 = format4 || "";
  } else {
    format4 = localeSorted;
    index2 = format4;
    localeSorted = false;
    if (isNumber(format4)) {
      index2 = format4;
      format4 = void 0;
    }
    format4 = format4 || "";
  }
  var locale3 = getLocale(), shift = localeSorted ? locale3._week.dow : 0;
  if (index2 != null) {
    return get2(format4, (index2 + shift) % 7, field, "day");
  }
  var i;
  var out = [];
  for (i = 0; i < 7; i++) {
    out[i] = get2(format4, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format4, index2) {
  return listMonthsImpl(format4, index2, "months");
}
function listMonthsShort(format4, index2) {
  return listMonthsImpl(format4, index2, "monthsShort");
}
function listWeekdays(localeSorted, format4, index2) {
  return listWeekdaysImpl(localeSorted, format4, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format4, index2) {
  return listWeekdaysImpl(localeSorted, format4, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format4, index2) {
  return listWeekdaysImpl(localeSorted, format4, index2, "weekdaysMin");
}

// node_modules/moment/src/lib/locale/en.js
getSetGlobalLocale("en", {
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});

// node_modules/moment/src/lib/locale/locale.js
hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);

// node_modules/moment/src/lib/duration/abs.js
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}

// node_modules/moment/src/lib/duration/add-subtract.js
function addSubtract2(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add2(input, value) {
  return addSubtract2(this, input, value, 1);
}
function subtract2(input, value) {
  return addSubtract2(this, input, value, -1);
}

// node_modules/moment/src/lib/utils/abs-ceil.js
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}

// node_modules/moment/src/lib/duration/bubble.js
function bubble() {
  var milliseconds3 = this._milliseconds;
  var days3 = this._days;
  var months3 = this._months;
  var data = this._data;
  var seconds3, minutes3, hours3, years3, monthsFromDays;
  if (!(milliseconds3 >= 0 && days3 >= 0 && months3 >= 0 || milliseconds3 <= 0 && days3 <= 0 && months3 <= 0)) {
    milliseconds3 += absCeil(monthsToDays(months3) + days3) * 864e5;
    days3 = 0;
    months3 = 0;
  }
  data.milliseconds = milliseconds3 % 1e3;
  seconds3 = absFloor(milliseconds3 / 1e3);
  data.seconds = seconds3 % 60;
  minutes3 = absFloor(seconds3 / 60);
  data.minutes = minutes3 % 60;
  hours3 = absFloor(minutes3 / 60);
  data.hours = hours3 % 24;
  days3 += absFloor(hours3 / 24);
  monthsFromDays = absFloor(daysToMonths(days3));
  months3 += monthsFromDays;
  days3 -= absCeil(monthsToDays(monthsFromDays));
  years3 = absFloor(months3 / 12);
  months3 %= 12;
  data.days = days3;
  data.months = months3;
  data.years = years3;
  return this;
}
function daysToMonths(days3) {
  return days3 * 4800 / 146097;
}
function monthsToDays(months3) {
  return months3 * 146097 / 4800;
}

// node_modules/moment/src/lib/duration/as.js
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days3;
  var months3;
  var milliseconds3 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "year") {
    days3 = this._days + milliseconds3 / 864e5;
    months3 = this._months + daysToMonths(days3);
    return units === "month" ? months3 : months3 / 12;
  } else {
    days3 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days3 / 7 + milliseconds3 / 6048e5;
      case "day":
        return days3 + milliseconds3 / 864e5;
      case "hour":
        return days3 * 24 + milliseconds3 / 36e5;
      case "minute":
        return days3 * 1440 + milliseconds3 / 6e4;
      case "second":
        return days3 * 86400 + milliseconds3 / 1e3;
      case "millisecond":
        return Math.floor(days3 * 864e5) + milliseconds3;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf2() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms");
var asSeconds = makeAs("s");
var asMinutes = makeAs("m");
var asHours = makeAs("h");
var asDays = makeAs("d");
var asWeeks = makeAs("w");
var asMonths = makeAs("M");
var asYears = makeAs("y");

// node_modules/moment/src/lib/duration/clone.js
function clone3() {
  return createDuration(this);
}

// node_modules/moment/src/lib/duration/get.js
function get3(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds");
var seconds = makeGetter("seconds");
var minutes = makeGetter("minutes");
var hours = makeGetter("hours");
var days = makeGetter("days");
var months = makeGetter("months");
var years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}

// node_modules/moment/src/lib/duration/humanize.js
var round = Math.round;
var thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month
  M: 11
  // months to year
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale3) {
  return locale3.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime2(posNegDuration, withoutSuffix, locale3) {
  var duration = createDuration(posNegDuration).abs();
  var seconds3 = round(duration.as("s"));
  var minutes3 = round(duration.as("m"));
  var hours3 = round(duration.as("h"));
  var days3 = round(duration.as("d"));
  var months3 = round(duration.as("M"));
  var years3 = round(duration.as("y"));
  var a = seconds3 <= thresholds.ss && ["s", seconds3] || seconds3 < thresholds.s && ["ss", seconds3] || minutes3 <= 1 && ["m"] || minutes3 < thresholds.m && ["mm", minutes3] || hours3 <= 1 && ["h"] || hours3 < thresholds.h && ["hh", hours3] || days3 <= 1 && ["d"] || days3 < thresholds.d && ["dd", days3] || months3 <= 1 && ["M"] || months3 < thresholds.M && ["MM", months3] || years3 <= 1 && ["y"] || ["yy", years3];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale3;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(withSuffix) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var locale3 = this.localeData();
  var output = relativeTime2(this, !withSuffix, locale3);
  if (withSuffix) {
    output = locale3.pastFuture(+this, output);
  }
  return locale3.postformat(output);
}

// node_modules/moment/src/lib/duration/iso-string.js
var abs2 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString2() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds3 = abs2(this._milliseconds) / 1e3;
  var days3 = abs2(this._days);
  var months3 = abs2(this._months);
  var minutes3, hours3, years3;
  minutes3 = absFloor(seconds3 / 60);
  hours3 = absFloor(minutes3 / 60);
  seconds3 %= 60;
  minutes3 %= 60;
  years3 = absFloor(months3 / 12);
  months3 %= 12;
  var Y = years3;
  var M = months3;
  var D = days3;
  var h = hours3;
  var m = minutes3;
  var s = seconds3 ? seconds3.toFixed(3).replace(/\.?0+$/, "") : "";
  var total = this.asSeconds();
  if (!total) {
    return "P0D";
  }
  var totalSign = total < 0 ? "-" : "";
  var ymSign = sign(this._months) !== sign(total) ? "-" : "";
  var daysSign = sign(this._days) !== sign(total) ? "-" : "";
  var hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (Y ? ymSign + Y + "Y" : "") + (M ? ymSign + M + "M" : "") + (D ? daysSign + D + "D" : "") + (h || m || s ? "T" : "") + (h ? hmsSign + h + "H" : "") + (m ? hmsSign + m + "M" : "") + (s ? hmsSign + s + "S" : "");
}

// node_modules/moment/src/lib/duration/prototype.js
var proto3 = Duration.prototype;
proto3.isValid = isValid2;
proto3.abs = abs;
proto3.add = add2;
proto3.subtract = subtract2;
proto3.as = as;
proto3.asMilliseconds = asMilliseconds;
proto3.asSeconds = asSeconds;
proto3.asMinutes = asMinutes;
proto3.asHours = asHours;
proto3.asDays = asDays;
proto3.asWeeks = asWeeks;
proto3.asMonths = asMonths;
proto3.asYears = asYears;
proto3.valueOf = valueOf2;
proto3._bubble = bubble;
proto3.clone = clone3;
proto3.get = get3;
proto3.milliseconds = milliseconds;
proto3.seconds = seconds;
proto3.minutes = minutes;
proto3.hours = hours;
proto3.days = days;
proto3.weeks = weeks;
proto3.months = months;
proto3.years = years;
proto3.humanize = humanize;
proto3.toISOString = toISOString2;
proto3.toString = toISOString2;
proto3.toJSON = toISOString2;
proto3.locale = locale;
proto3.localeData = localeData;
proto3.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString2);
proto3.lang = lang;

// node_modules/moment/src/lib/units/timestamp.js
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config) {
  config._d = new Date(parseFloat(input, 10) * 1e3);
});
addParseToken("x", function(input, array, config) {
  config._d = new Date(toInt(input));
});

// node_modules/moment/src/moment.js
hooks.version = "2.20.1";
setHookCallback(createLocal);
hooks.fn = prototype_default;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = prototype_default;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "YYYY-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
var moment_default = hooks;

// node_modules/handsontable/es/helpers/templateLiteralTag.js
function toSingleLine(strings) {
  for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    expressions[_key - 1] = arguments[_key];
  }
  var result = arrayReduce(strings, function(previousValue, currentValue, index2) {
    var valueWithoutWhiteSpaces = currentValue.replace(/(?:\r?\n\s+)/g, "");
    var expressionForIndex = expressions[index2] ? expressions[index2] : "";
    return previousValue + valueWithoutWhiteSpaces + expressionForIndex;
  }, "");
  return result.trim();
}

// node_modules/handsontable/es/helpers/mixed.js
function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          Your license key of Handsontable Pro has expired.‌‌‌‌ \n          Renew your maintenance plan at https://handsontable.com or downgrade to the previous version of the software.\n          "]);
  _templateObject = function _templateObject8() {
    return data;
  };
  return data;
}
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _typeof3(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof3 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof3 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof3(obj);
}
function stringify(value) {
  var result;
  switch (_typeof3(value)) {
    case "string":
    case "number":
      result = "".concat(value);
      break;
    case "object":
      result = value === null ? "" : value.toString();
      break;
    case "undefined":
      result = "";
      break;
    default:
      result = value.toString();
      break;
  }
  return result;
}
function isDefined(variable) {
  return typeof variable !== "undefined";
}
function isUndefined2(variable) {
  return typeof variable === "undefined";
}
function isEmpty(variable) {
  return variable === null || variable === "" || isUndefined2(variable);
}
function isRegExp(variable) {
  return Object.prototype.toString.call(variable) === "[object RegExp]";
}
var _m = "length";
var _hd = function _hd2(v) {
  return parseInt(v, 16);
};
var _pi = function _pi2(v) {
  return parseInt(v, 10);
};
var _ss = function _ss2(v, s, l) {
  return v["substr"](s, l);
};
var _cp = function _cp2(v) {
  return v["codePointAt"](0) - 65;
};
var _norm = function _norm2(v) {
  return "".concat(v).replace(/\-/g, "");
};
var _extractTime = function _extractTime2(v) {
  return _hd(_ss(_norm(v), _hd("12"), _cp("F"))) / (_hd(_ss(_norm(v), _cp("B"), ~~![][_m])) || 9);
};
var _ignored = function _ignored2() {
  return typeof location !== "undefined" && /^([a-z0-9\-]+\.)?\x68\x61\x6E\x64\x73\x6F\x6E\x74\x61\x62\x6C\x65\x2E\x63\x6F\x6D$/i.test(location.host);
};
var _notified = false;
function _injectProductInfo(key, element) {
  key = _norm(key || "");
  var warningMessage = "";
  var showDomMessage = true;
  var schemaValidity = _checkKeySchema(key);
  var ignored = _ignored();
  var trial = isEmpty(key) || key === "trial";
  if (trial || schemaValidity) {
    if (schemaValidity) {
      var releaseTime = Math.floor(moment_default("19/12/2018", "DD/MM/YYYY").toDate().getTime() / 864e5);
      var keyGenTime = _extractTime(key);
      if (keyGenTime > 45e3 || keyGenTime !== parseInt(keyGenTime, 10)) {
        warningMessage = "The license key provided to Handsontable Pro is invalid. Make sure you pass it correctly.";
      }
      if (!warningMessage) {
        if (releaseTime > keyGenTime + 1) {
          warningMessage = toSingleLine(_templateObject());
        }
        showDomMessage = releaseTime > keyGenTime + 15;
      }
    } else {
      warningMessage = "Evaluation version of Handsontable Pro. Not licensed for use in a production environment.";
    }
  } else {
    warningMessage = "The license key provided to Handsontable Pro is invalid. Make sure you pass it correctly.";
  }
  if (ignored) {
    warningMessage = false;
    showDomMessage = false;
  }
  if (warningMessage && !_notified) {
    console[trial ? "info" : "warn"](warningMessage);
    _notified = true;
  }
  if (showDomMessage && element.parentNode) {
    var message = document.createElement("div");
    message.id = "hot-display-license-info";
    message.appendChild(document.createTextNode("Evaluation version of Handsontable Pro."));
    message.appendChild(document.createElement("br"));
    message.appendChild(document.createTextNode("Not licensed for production use."));
    element.parentNode.insertBefore(message, element.nextSibling);
  }
}
function _checkKeySchema(v) {
  var z = [][_m];
  var p = z;
  if (v[_m] !== _cp("Z")) {
    return false;
  }
  for (var c = "", i = "B<H4P+".split(""), j = _cp(i.shift()); j; j = _cp(i.shift() || "A")) {
    --j < ""[_m] ? p = p | (_pi("".concat(_pi(_hd(c) + (_hd(_ss(v, Math.abs(j), 2)) + []).padStart(2, "0")))) % 97 || 2) >> 1 : c = _ss(v, j, !j ? 6 : i[_m] === 1 ? 9 : 8);
  }
  return p === z;
}

// node_modules/handsontable/es/helpers/string.js
function toUpperCaseFirst(string) {
  return string[0].toUpperCase() + string.substr(1);
}
function equalsIgnoreCase() {
  var unique = [];
  for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
    strings[_key] = arguments[_key];
  }
  var length = strings.length;
  while (length) {
    length -= 1;
    var string = stringify(strings[length]).toLowerCase();
    if (unique.indexOf(string) === -1) {
      unique.push(string);
    }
  }
  return unique.length === 1;
}
function randomString() {
  function s4() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return s4() + s4() + s4() + s4();
}
function isPercentValue(value) {
  return /^([0-9][0-9]?%$)|(^100%$)/.test(value);
}
function substitute(template) {
  var variables = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return "".concat(template).replace(/(?:\\)?\[([^[\]]+)]/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.substr(1, match.length - 1);
    }
    return variables[name] === void 0 ? "" : variables[name];
  });
}
var STRIP_TAGS_REGEX = /<\/?\w+\/?>|<\w+[\s|/][^>]*>/gi;
function stripTags(string) {
  return "".concat(string).replace(STRIP_TAGS_REGEX, "");
}

// node_modules/handsontable/es/helpers/function.js
var function_exports = {};
__export(function_exports, {
  curry: () => curry,
  curryRight: () => curryRight,
  debounce: () => debounce,
  isFunction: () => isFunction2,
  partial: () => partial,
  pipe: () => pipe,
  throttle: () => throttle,
  throttleAfterHits: () => throttleAfterHits
});
function isFunction2(func) {
  return typeof func === "function";
}
function throttle(func) {
  var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  var lastCalled = 0;
  var result = {
    lastCallThrottled: true
  };
  var lastTimer = null;
  function _throttle() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var stamp = Date.now();
    var needCall = false;
    result.lastCallThrottled = true;
    if (!lastCalled) {
      lastCalled = stamp;
      needCall = true;
    }
    var remaining = wait - (stamp - lastCalled);
    if (needCall) {
      result.lastCallThrottled = false;
      func.apply(this, args);
    } else {
      if (lastTimer) {
        clearTimeout(lastTimer);
      }
      lastTimer = setTimeout(function() {
        result.lastCallThrottled = false;
        func.apply(_this, args);
        lastCalled = 0;
        lastTimer = void 0;
      }, remaining);
    }
    return result;
  }
  return _throttle;
}
function throttleAfterHits(func) {
  var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  var hits = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
  var funcThrottle = throttle(func, wait);
  var remainHits = hits;
  function _clearHits() {
    remainHits = hits;
  }
  function _throttleAfterHits() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (remainHits) {
      remainHits -= 1;
      return func.apply(this, args);
    }
    return funcThrottle.apply(this, args);
  }
  _throttleAfterHits.clearHits = _clearHits;
  return _throttleAfterHits;
}
function debounce(func) {
  var wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  var lastTimer = null;
  var result;
  function _debounce() {
    var _this2 = this;
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    if (lastTimer) {
      clearTimeout(lastTimer);
    }
    lastTimer = setTimeout(function() {
      result = func.apply(_this2, args);
    }, wait);
    return result;
  }
  return _debounce;
}
function pipe() {
  for (var _len4 = arguments.length, functions = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    functions[_key4] = arguments[_key4];
  }
  var firstFunc = functions[0], restFunc = functions.slice(1);
  return function _pipe() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return arrayReduce(restFunc, function(acc, fn) {
      return fn(acc);
    }, firstFunc.apply(this, args));
  };
}
function partial(func) {
  for (var _len6 = arguments.length, params = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    params[_key6 - 1] = arguments[_key6];
  }
  return function _partial() {
    for (var _len7 = arguments.length, restParams = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      restParams[_key7] = arguments[_key7];
    }
    return func.apply(this, params.concat(restParams));
  };
}
function curry(func) {
  var argsLength = func.length;
  function given(argsSoFar) {
    return function _curry() {
      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        params[_key8] = arguments[_key8];
      }
      var passedArgsSoFar = argsSoFar.concat(params);
      var result;
      if (passedArgsSoFar.length >= argsLength) {
        result = func.apply(this, passedArgsSoFar);
      } else {
        result = given(passedArgsSoFar);
      }
      return result;
    };
  }
  return given([]);
}
function curryRight(func) {
  var argsLength = func.length;
  function given(argsSoFar) {
    return function _curry() {
      for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        params[_key9] = arguments[_key9];
      }
      var passedArgsSoFar = argsSoFar.concat(params.reverse());
      var result;
      if (passedArgsSoFar.length >= argsLength) {
        result = func.apply(this, passedArgsSoFar);
      } else {
        result = given(passedArgsSoFar);
      }
      return result;
    };
  }
  return given([]);
}

// node_modules/handsontable/es/3rdparty/walkontable/src/event.js
function _classCallCheck9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass9(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties9(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties9(Constructor, staticProps);
  return Constructor;
}
var privatePool3 = /* @__PURE__ */ new WeakMap();
var Event2 = function() {
  function Event3(instance) {
    _classCallCheck9(this, Event3);
    this.instance = instance;
    this.eventManager = new eventManager_default(instance);
    privatePool3.set(this, {
      selectedCellBeforeTouchEnd: void 0,
      dblClickTimeout: [null, null],
      dblClickOrigin: [null, null]
    });
    this.registerEvents();
  }
  _createClass9(Event3, [{
    key: "registerEvents",
    value: function registerEvents2() {
      var _this = this;
      this.eventManager.addEventListener(this.instance.wtTable.holder, "contextmenu", function(event2) {
        return _this.onContextMenu(event2);
      });
      this.eventManager.addEventListener(this.instance.wtTable.TABLE, "mouseover", function(event2) {
        return _this.onMouseOver(event2);
      });
      this.eventManager.addEventListener(this.instance.wtTable.TABLE, "mouseout", function(event2) {
        return _this.onMouseOut(event2);
      });
      var initTouchEvents = function initTouchEvents2() {
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "touchstart", function(event2) {
          return _this.onTouchStart(event2);
        });
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "touchend", function(event2) {
          return _this.onTouchEnd(event2);
        });
        if (!_this.instance.momentumScrolling) {
          _this.instance.momentumScrolling = {};
        }
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "scroll", function() {
          clearTimeout(_this.instance.momentumScrolling._timeout);
          if (!_this.instance.momentumScrolling.ongoing) {
            _this.instance.getSetting("onBeforeTouchScroll");
          }
          _this.instance.momentumScrolling.ongoing = true;
          _this.instance.momentumScrolling._timeout = setTimeout(function() {
            if (!_this.instance.touchApplied) {
              _this.instance.momentumScrolling.ongoing = false;
              _this.instance.getSetting("onAfterMomentumScroll");
            }
          }, 200);
        });
      };
      var initMouseEvents = function initMouseEvents2() {
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "mouseup", function(event2) {
          return _this.onMouseUp(event2);
        });
        _this.eventManager.addEventListener(_this.instance.wtTable.holder, "mousedown", function(event2) {
          return _this.onMouseDown(event2);
        });
      };
      if (isMobileBrowser()) {
        initTouchEvents();
      } else {
        if (isTouchSupported()) {
          initTouchEvents();
        }
        initMouseEvents();
      }
      this.eventManager.addEventListener(window, "resize", function() {
        if (_this.instance.getSetting("stretchH") !== "none") {
          _this.instance.draw();
        }
      });
    }
    /**
     * Checks if an element is already selected.
     *
     * @private
     * @param {Element} touchTarget
     * @returns {Boolean}
     */
  }, {
    key: "selectedCellWasTouched",
    value: function selectedCellWasTouched(touchTarget) {
      var priv = privatePool3.get(this);
      var cellUnderFinger = this.parentCell(touchTarget);
      var coordsOfCellUnderFinger = cellUnderFinger.coords;
      if (priv.selectedCellBeforeTouchEnd && coordsOfCellUnderFinger) {
        var _ref = [coordsOfCellUnderFinger.row, priv.selectedCellBeforeTouchEnd.from.row], rowTouched = _ref[0], rowSelected = _ref[1];
        var _ref2 = [coordsOfCellUnderFinger.col, priv.selectedCellBeforeTouchEnd.from.col], colTouched = _ref2[0], colSelected = _ref2[1];
        return rowTouched === rowSelected && colTouched === colSelected;
      }
      return false;
    }
    /**
     * Gets closest TD or TH element.
     *
     * @private
     * @param {Element} elem
     * @returns {Object} Contains coordinates and reference to TD or TH if it exists. Otherwise it's empty object.
     */
  }, {
    key: "parentCell",
    value: function parentCell(elem) {
      var cell = {};
      var TABLE = this.instance.wtTable.TABLE;
      var TD = closestDown(elem, ["TD", "TH"], TABLE);
      if (TD) {
        cell.coords = this.instance.wtTable.getCoords(TD);
        cell.TD = TD;
      } else if (hasClass(elem, "wtBorder") && hasClass(elem, "current")) {
        cell.coords = this.instance.selections.getCell().cellRange.highlight;
        cell.TD = this.instance.wtTable.getCell(cell.coords);
      } else if (hasClass(elem, "wtBorder") && hasClass(elem, "area")) {
        if (this.instance.selections.createOrGetArea().cellRange) {
          cell.coords = this.instance.selections.createOrGetArea().cellRange.to;
          cell.TD = this.instance.wtTable.getCell(cell.coords);
        }
      }
      return cell;
    }
    /**
     * onMouseDown callback.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event2) {
      var priv = privatePool3.get(this);
      var activeElement = document.activeElement;
      var getParentNode = partial(getParent, event2.realTarget);
      var realTarget = event2.realTarget;
      if (realTarget === activeElement || getParentNode(0) === activeElement || getParentNode(1) === activeElement) {
        return;
      }
      var cell = this.parentCell(realTarget);
      if (hasClass(realTarget, "corner")) {
        this.instance.getSetting("onCellCornerMouseDown", event2, realTarget);
      } else if (cell.TD && this.instance.hasSetting("onCellMouseDown")) {
        this.instance.getSetting("onCellMouseDown", event2, cell.coords, cell.TD, this.instance);
      }
      if (event2.button !== 2 && cell.TD) {
        priv.dblClickOrigin[0] = cell.TD;
        clearTimeout(priv.dblClickTimeout[0]);
        priv.dblClickTimeout[0] = setTimeout(function() {
          priv.dblClickOrigin[0] = null;
        }, 1e3);
      }
    }
    /**
     * onContextMenu callback.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onContextMenu",
    value: function onContextMenu(event2) {
      if (this.instance.hasSetting("onCellContextMenu")) {
        var cell = this.parentCell(event2.realTarget);
        if (cell.TD) {
          this.instance.getSetting("onCellContextMenu", event2, cell.coords, cell.TD, this.instance);
        }
      }
    }
    /**
     * onMouseOver callback.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event2) {
      if (!this.instance.hasSetting("onCellMouseOver")) {
        return;
      }
      var table = this.instance.wtTable.TABLE;
      var td = closestDown(event2.realTarget, ["TD", "TH"], table);
      var mainWOT = this.instance.cloneSource || this.instance;
      if (td && td !== mainWOT.lastMouseOver && isChildOf(td, table)) {
        mainWOT.lastMouseOver = td;
        this.instance.getSetting("onCellMouseOver", event2, this.instance.wtTable.getCoords(td), td, this.instance);
      }
    }
    /**
     * onMouseOut callback.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseOut",
    value: function onMouseOut(event2) {
      if (!this.instance.hasSetting("onCellMouseOut")) {
        return;
      }
      var table = this.instance.wtTable.TABLE;
      var lastTD = closestDown(event2.realTarget, ["TD", "TH"], table);
      var nextTD = closestDown(event2.relatedTarget, ["TD", "TH"], table);
      if (lastTD && lastTD !== nextTD && isChildOf(lastTD, table)) {
        this.instance.getSetting("onCellMouseOut", event2, this.instance.wtTable.getCoords(lastTD), lastTD, this.instance);
      }
    }
    /**
     * onMouseUp callback.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2(event2) {
      if (event2.button === 2) {
        return;
      }
      var priv = privatePool3.get(this);
      var cell = this.parentCell(event2.realTarget);
      if (cell.TD && this.instance.hasSetting("onCellMouseUp")) {
        this.instance.getSetting("onCellMouseUp", event2, cell.coords, cell.TD, this.instance);
      }
      if (cell.TD === priv.dblClickOrigin[0] && cell.TD === priv.dblClickOrigin[1]) {
        if (hasClass(event2.realTarget, "corner")) {
          this.instance.getSetting("onCellCornerDblClick", event2, cell.coords, cell.TD, this.instance);
        } else {
          this.instance.getSetting("onCellDblClick", event2, cell.coords, cell.TD, this.instance);
        }
        priv.dblClickOrigin[0] = null;
        priv.dblClickOrigin[1] = null;
      } else if (cell.TD === priv.dblClickOrigin[0]) {
        priv.dblClickOrigin[1] = cell.TD;
        clearTimeout(priv.dblClickTimeout[1]);
        priv.dblClickTimeout[1] = setTimeout(function() {
          priv.dblClickOrigin[1] = null;
        }, 500);
      }
    }
    /**
     * onTouchStart callback. Simulates mousedown event.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onTouchStart",
    value: function onTouchStart(event2) {
      var priv = privatePool3.get(this);
      priv.selectedCellBeforeTouchEnd = this.instance.selections.getCell().cellRange;
      this.instance.touchApplied = true;
      this.onMouseDown(event2);
    }
    /**
     * onTouchEnd callback. Simulates mouseup event.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onTouchEnd",
    value: function onTouchEnd(event2) {
      var excludeTags = ["A", "BUTTON", "INPUT"];
      var target = event2.target;
      this.instance.touchApplied = false;
      if (this.selectedCellWasTouched(target) === false && excludeTags.includes(target.tagName)) {
        event2.preventDefault();
      }
      this.onMouseUp(event2);
    }
    /**
     * Clears double-click timeouts and destroys the internal eventManager instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var priv = privatePool3.get(this);
      clearTimeout(priv.dblClickTimeout[0]);
      clearTimeout(priv.dblClickTimeout[1]);
      this.eventManager.destroy();
    }
  }]);
  return Event3;
}();
var event_default = Event2;

// node_modules/handsontable/es/helpers/unicode.js
var unicode_exports = {};
__export(unicode_exports, {
  KEY_CODES: () => KEY_CODES,
  isCtrlKey: () => isCtrlKey,
  isCtrlMetaKey: () => isCtrlMetaKey,
  isKey: () => isKey,
  isMetaKey: () => isMetaKey,
  isPrintableChar: () => isPrintableChar
});
var KEY_CODES = {
  MOUSE_LEFT: 1,
  MOUSE_RIGHT: 3,
  MOUSE_MIDDLE: 2,
  BACKSPACE: 8,
  COMMA: 188,
  INSERT: 45,
  DELETE: 46,
  END: 35,
  ENTER: 13,
  ESCAPE: 27,
  CONTROL: 17,
  COMMAND_LEFT: 91,
  COMMAND_RIGHT: 93,
  COMMAND_FIREFOX: 224,
  ALT: 18,
  HOME: 36,
  PAGE_DOWN: 34,
  PAGE_UP: 33,
  PERIOD: 190,
  SPACE: 32,
  SHIFT: 16,
  CAPS_LOCK: 20,
  TAB: 9,
  ARROW_RIGHT: 39,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_DOWN: 40,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  A: 65,
  C: 67,
  D: 68,
  F: 70,
  L: 76,
  O: 79,
  P: 80,
  S: 83,
  V: 86,
  X: 88
};
function isPrintableChar(keyCode) {
  return keyCode === 32 || // space
  keyCode >= 48 && keyCode <= 57 || // 0-9
  keyCode >= 96 && keyCode <= 111 || // numpad
  keyCode >= 186 && keyCode <= 192 || // ;=,-./`
  keyCode >= 219 && keyCode <= 222 || // []{}\|"'
  keyCode >= 226 || // special chars (229 for Asian chars)
  keyCode >= 65 && keyCode <= 90;
}
function isMetaKey(keyCode) {
  var metaKeys = [KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_UP, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_RIGHT, KEY_CODES.HOME, KEY_CODES.END, KEY_CODES.DELETE, KEY_CODES.BACKSPACE, KEY_CODES.F1, KEY_CODES.F2, KEY_CODES.F3, KEY_CODES.F4, KEY_CODES.F5, KEY_CODES.F6, KEY_CODES.F7, KEY_CODES.F8, KEY_CODES.F9, KEY_CODES.F10, KEY_CODES.F11, KEY_CODES.F12, KEY_CODES.TAB, KEY_CODES.PAGE_DOWN, KEY_CODES.PAGE_UP, KEY_CODES.ENTER, KEY_CODES.ESCAPE, KEY_CODES.SHIFT, KEY_CODES.CAPS_LOCK, KEY_CODES.ALT];
  return metaKeys.indexOf(keyCode) !== -1;
}
function isCtrlKey(keyCode) {
  var keys3 = [];
  if (window.navigator.platform.includes("Mac")) {
    keys3.push(KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX);
  } else {
    keys3.push(KEY_CODES.CONTROL);
  }
  return keys3.includes(keyCode);
}
function isCtrlMetaKey(keyCode) {
  return [KEY_CODES.CONTROL, KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX].includes(keyCode);
}
function isKey(keyCode, baseCode) {
  var keys3 = baseCode.split("|");
  var result = false;
  arrayEach(keys3, function(key) {
    if (keyCode === KEY_CODES[key]) {
      result = true;
      return false;
    }
  });
  return result;
}

// node_modules/handsontable/es/3rdparty/walkontable/src/overlays.js
function _classCallCheck10(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties10(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass10(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties10(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties10(Constructor, staticProps);
  return Constructor;
}
var Overlays = function() {
  function Overlays2(wotInstance) {
    _classCallCheck10(this, Overlays2);
    var BODY_LINE_HEIGHT = parseInt(getComputedStyle(document.body).lineHeight, 10);
    var FALLBACK_BODY_LINE_HEIGHT = parseInt(getComputedStyle(document.body).fontSize, 10) * 1.2;
    this.wot = wotInstance;
    this.instance = this.wot;
    this.eventManager = new eventManager_default(this.wot);
    this.wot.update("scrollbarWidth", getScrollbarWidth());
    this.wot.update("scrollbarHeight", getScrollbarWidth());
    this.scrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
    this.prepareOverlays();
    this.destroyed = false;
    this.keyPressed = false;
    this.spreaderLastSize = {
      width: null,
      height: null
    };
    this.overlayScrollPositions = {
      master: {
        top: 0,
        left: 0
      },
      top: {
        top: null,
        left: 0
      },
      bottom: {
        top: null,
        left: 0
      },
      left: {
        top: 0,
        left: null
      }
    };
    this.pendingScrollCallbacks = {
      master: {
        top: 0,
        left: 0
      },
      top: {
        left: 0
      },
      bottom: {
        left: 0
      },
      left: {
        top: 0
      }
    };
    this.verticalScrolling = false;
    this.horizontalScrolling = false;
    this.delegatedScrollCallback = false;
    this.registeredListeners = [];
    this.browserLineHeight = BODY_LINE_HEIGHT || FALLBACK_BODY_LINE_HEIGHT;
    this.registerListeners();
  }
  _createClass10(Overlays2, [{
    key: "prepareOverlays",
    value: function prepareOverlays() {
      var syncScroll = false;
      if (this.topOverlay) {
        syncScroll = this.topOverlay.updateStateOfRendering() || syncScroll;
      } else {
        this.topOverlay = base_default.createOverlay(base_default.CLONE_TOP, this.wot);
      }
      if (!base_default.hasOverlay(base_default.CLONE_BOTTOM)) {
        this.bottomOverlay = {
          needFullRender: false,
          updateStateOfRendering: function updateStateOfRendering() {
            return false;
          }
        };
      }
      if (!base_default.hasOverlay(base_default.CLONE_BOTTOM_LEFT_CORNER)) {
        this.bottomLeftCornerOverlay = {
          needFullRender: false,
          updateStateOfRendering: function updateStateOfRendering() {
            return false;
          }
        };
      }
      if (this.bottomOverlay) {
        syncScroll = this.bottomOverlay.updateStateOfRendering() || syncScroll;
      } else {
        this.bottomOverlay = base_default.createOverlay(base_default.CLONE_BOTTOM, this.wot);
      }
      if (this.leftOverlay) {
        syncScroll = this.leftOverlay.updateStateOfRendering() || syncScroll;
      } else {
        this.leftOverlay = base_default.createOverlay(base_default.CLONE_LEFT, this.wot);
      }
      if (this.topOverlay.needFullRender && this.leftOverlay.needFullRender) {
        if (this.topLeftCornerOverlay) {
          syncScroll = this.topLeftCornerOverlay.updateStateOfRendering() || syncScroll;
        } else {
          this.topLeftCornerOverlay = base_default.createOverlay(base_default.CLONE_TOP_LEFT_CORNER, this.wot);
        }
      }
      if (this.bottomOverlay.needFullRender && this.leftOverlay.needFullRender) {
        if (this.bottomLeftCornerOverlay) {
          syncScroll = this.bottomLeftCornerOverlay.updateStateOfRendering() || syncScroll;
        } else {
          this.bottomLeftCornerOverlay = base_default.createOverlay(base_default.CLONE_BOTTOM_LEFT_CORNER, this.wot);
        }
      }
      if (this.wot.getSetting("debug") && !this.debug) {
        this.debug = base_default.createOverlay(base_default.CLONE_DEBUG, this.wot);
      }
      return syncScroll;
    }
    /**
     * Refresh and redraw table
     */
  }, {
    key: "refreshAll",
    value: function refreshAll() {
      if (!this.wot.drawn) {
        return;
      }
      if (!this.wot.wtTable.holder.parentNode) {
        this.destroy();
        return;
      }
      this.wot.draw(true);
      if (this.verticalScrolling) {
        this.leftOverlay.onScroll();
      }
      if (this.horizontalScrolling) {
        this.topOverlay.onScroll();
      }
      this.verticalScrolling = false;
      this.horizontalScrolling = false;
    }
    /**
     * Register all necessary event listeners.
     */
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this = this;
      var topOverlayScrollable = this.topOverlay.mainTableScrollableElement;
      var leftOverlayScrollable = this.leftOverlay.mainTableScrollableElement;
      var listenersToRegister = [];
      listenersToRegister.push([document.documentElement, "keydown", function(event2) {
        return _this.onKeyDown(event2);
      }]);
      listenersToRegister.push([document.documentElement, "keyup", function() {
        return _this.onKeyUp();
      }]);
      listenersToRegister.push([document, "visibilitychange", function() {
        return _this.onKeyUp();
      }]);
      listenersToRegister.push([topOverlayScrollable, "scroll", function(event2) {
        return _this.onTableScroll(event2);
      }]);
      if (topOverlayScrollable !== leftOverlayScrollable) {
        listenersToRegister.push([leftOverlayScrollable, "scroll", function(event2) {
          return _this.onTableScroll(event2);
        }]);
      }
      var isHighPixelRatio = window.devicePixelRatio && window.devicePixelRatio > 1;
      if (isHighPixelRatio || !isChrome()) {
        listenersToRegister.push([this.instance.wtTable.wtRootElement.parentNode, "wheel", function(event2) {
          return _this.onCloneWheel(event2);
        }]);
      } else {
        if (this.topOverlay.needFullRender) {
          listenersToRegister.push([this.topOverlay.clone.wtTable.holder, "wheel", function(event2) {
            return _this.onCloneWheel(event2);
          }]);
        }
        if (this.bottomOverlay.needFullRender) {
          listenersToRegister.push([this.bottomOverlay.clone.wtTable.holder, "wheel", function(event2) {
            return _this.onCloneWheel(event2);
          }]);
        }
        if (this.leftOverlay.needFullRender) {
          listenersToRegister.push([this.leftOverlay.clone.wtTable.holder, "wheel", function(event2) {
            return _this.onCloneWheel(event2);
          }]);
        }
        if (this.topLeftCornerOverlay && this.topLeftCornerOverlay.needFullRender) {
          listenersToRegister.push([this.topLeftCornerOverlay.clone.wtTable.holder, "wheel", function(event2) {
            return _this.onCloneWheel(event2);
          }]);
        }
        if (this.bottomLeftCornerOverlay && this.bottomLeftCornerOverlay.needFullRender) {
          listenersToRegister.push([this.bottomLeftCornerOverlay.clone.wtTable.holder, "wheel", function(event2) {
            return _this.onCloneWheel(event2);
          }]);
        }
      }
      if (this.topOverlay.trimmingContainer !== window && this.leftOverlay.trimmingContainer !== window) {
        listenersToRegister.push([window, "wheel", function(event2) {
          var overlay;
          var deltaY = event2.wheelDeltaY || event2.deltaY;
          var deltaX = event2.wheelDeltaX || event2.deltaX;
          if (_this.topOverlay.clone.wtTable.holder.contains(event2.realTarget)) {
            overlay = "top";
          } else if (_this.bottomOverlay.clone && _this.bottomOverlay.clone.wtTable.holder.contains(event2.realTarget)) {
            overlay = "bottom";
          } else if (_this.leftOverlay.clone.wtTable.holder.contains(event2.realTarget)) {
            overlay = "left";
          } else if (_this.topLeftCornerOverlay && _this.topLeftCornerOverlay.clone && _this.topLeftCornerOverlay.clone.wtTable.holder.contains(event2.realTarget)) {
            overlay = "topLeft";
          } else if (_this.bottomLeftCornerOverlay && _this.bottomLeftCornerOverlay.clone && _this.bottomLeftCornerOverlay.clone.wtTable.holder.contains(event2.realTarget)) {
            overlay = "bottomLeft";
          }
          if (overlay === "top" && deltaY !== 0 || overlay === "left" && deltaX !== 0 || overlay === "bottom" && deltaY !== 0 || (overlay === "topLeft" || overlay === "bottomLeft") && (deltaY !== 0 || deltaX !== 0)) {
            event2.preventDefault();
          }
        }]);
      }
      while (listenersToRegister.length) {
        var listener = listenersToRegister.pop();
        this.eventManager.addEventListener(listener[0], listener[1], listener[2]);
        this.registeredListeners.push(listener);
      }
    }
    /**
     * Deregister all previously registered listeners.
     */
  }, {
    key: "deregisterListeners",
    value: function deregisterListeners() {
      while (this.registeredListeners.length) {
        var listener = this.registeredListeners.pop();
        this.eventManager.removeEventListener(listener[0], listener[1], listener[2]);
      }
    }
    /**
     * Scroll listener
     *
     * @param {Event} event
     */
  }, {
    key: "onTableScroll",
    value: function onTableScroll(event2) {
      var masterHorizontal = this.leftOverlay.mainTableScrollableElement;
      var masterVertical = this.topOverlay.mainTableScrollableElement;
      var target = event2.target;
      if (this.keyPressed) {
        if (masterVertical !== window && target !== window && !event2.target.contains(masterVertical) || masterHorizontal !== window && target !== window && !event2.target.contains(masterHorizontal)) {
          return;
        }
      }
      this.syncScrollPositions(event2);
    }
    /**
     * Wheel listener for cloned overlays.
     *
     * @param {Event} event
     */
  }, {
    key: "onCloneWheel",
    value: function onCloneWheel(event2) {
      if (this.scrollableElement !== window) {
        event2.preventDefault();
      }
      var masterHorizontal = this.leftOverlay.mainTableScrollableElement;
      var masterVertical = this.topOverlay.mainTableScrollableElement;
      var target = event2.target;
      var shouldNotWheelVertically = masterVertical !== window && target !== window && !event2.target.contains(masterVertical);
      var shouldNotWheelHorizontally = masterHorizontal !== window && target !== window && !event2.target.contains(masterHorizontal);
      if (this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally)) {
        return;
      }
      this.translateMouseWheelToScroll(event2);
    }
    /**
     * Key down listener
     */
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event2) {
      this.keyPressed = isKey(event2.keyCode, "ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT");
    }
    /**
     * Key up listener
     */
  }, {
    key: "onKeyUp",
    value: function onKeyUp() {
      this.keyPressed = false;
    }
    /**
     * Translate wheel event into scroll event and sync scroll overlays position
     *
     * @private
     * @param {Event} event
     * @returns {Boolean}
     */
  }, {
    key: "translateMouseWheelToScroll",
    value: function translateMouseWheelToScroll(event2) {
      var deltaY = isNaN(event2.deltaY) ? -1 * event2.wheelDeltaY : event2.deltaY;
      var deltaX = isNaN(event2.deltaX) ? -1 * event2.wheelDeltaX : event2.deltaX;
      if (event2.deltaMode === 1) {
        deltaX += deltaX * this.browserLineHeight;
        deltaY += deltaY * this.browserLineHeight;
      }
      this.scrollVertically(deltaY);
      this.scrollHorizontally(deltaX);
      return false;
    }
  }, {
    key: "scrollVertically",
    value: function scrollVertically(distance) {
      if (distance === 0) {
        return 0;
      }
      this.scrollableElement.scrollTop += distance;
    }
  }, {
    key: "scrollHorizontally",
    value: function scrollHorizontally(distance) {
      if (distance === 0) {
        return 0;
      }
      this.scrollableElement.scrollLeft += distance;
    }
    /**
     * Synchronize scroll position between master table and overlay table.
     *
     * @private
     * @param {Event|Object} event
     */
  }, {
    key: "syncScrollPositions",
    value: function syncScrollPositions() {
      if (this.destroyed) {
        return;
      }
      var topHolder = this.topOverlay.clone.wtTable.holder;
      var leftHolder = this.leftOverlay.clone.wtTable.holder;
      var _ref = [this.scrollableElement.scrollLeft, this.scrollableElement.scrollTop], scrollLeft = _ref[0], scrollTop = _ref[1];
      this.horizontalScrolling = topHolder.scrollLeft !== scrollLeft;
      this.verticalScrolling = leftHolder.scrollTop !== scrollTop;
      if (this.horizontalScrolling) {
        topHolder.scrollLeft = scrollLeft;
        var bottomHolder = this.bottomOverlay.needFullRender ? this.bottomOverlay.clone.wtTable.holder : null;
        if (bottomHolder) {
          bottomHolder.scrollLeft = scrollLeft;
        }
      }
      if (this.verticalScrolling) {
        leftHolder.scrollTop = scrollTop;
      }
      this.refreshAll();
    }
    /**
     * Synchronize overlay scrollbars with the master scrollbar
     */
  }, {
    key: "syncScrollWithMaster",
    value: function syncScrollWithMaster() {
      var master = this.topOverlay.mainTableScrollableElement;
      var scrollLeft = master.scrollLeft, scrollTop = master.scrollTop;
      if (this.topOverlay.needFullRender) {
        this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;
      }
      if (this.bottomOverlay.needFullRender) {
        this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;
      }
      if (this.leftOverlay.needFullRender) {
        this.leftOverlay.clone.wtTable.holder.scrollTop = scrollTop;
      }
    }
    /**
     * Update the main scrollable elements for all the overlays.
     */
  }, {
    key: "updateMainScrollableElements",
    value: function updateMainScrollableElements() {
      this.deregisterListeners();
      this.leftOverlay.updateMainScrollableElement();
      this.topOverlay.updateMainScrollableElement();
      if (this.bottomOverlay.needFullRender) {
        this.bottomOverlay.updateMainScrollableElement();
      }
      this.scrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
      this.registerListeners();
    }
    /**
     *
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.eventManager.destroy();
      this.topOverlay.destroy();
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.destroy();
      }
      this.leftOverlay.destroy();
      if (this.topLeftCornerOverlay) {
        this.topLeftCornerOverlay.destroy();
      }
      if (this.bottomLeftCornerOverlay && this.bottomLeftCornerOverlay.clone) {
        this.bottomLeftCornerOverlay.destroy();
      }
      if (this.debug) {
        this.debug.destroy();
      }
      this.destroyed = true;
    }
    /**
     * @param {Boolean} [fastDraw=false]
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (this.topOverlay.areElementSizesAdjusted && this.leftOverlay.areElementSizesAdjusted) {
        var container = this.wot.wtTable.wtRootElement.parentNode || this.wot.wtTable.wtRootElement;
        var width = container.clientWidth;
        var height = container.clientHeight;
        if (width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height) {
          this.spreaderLastSize.width = width;
          this.spreaderLastSize.height = height;
          this.adjustElementsSize();
        }
      }
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.refresh(fastDraw);
      }
      this.leftOverlay.refresh(fastDraw);
      this.topOverlay.refresh(fastDraw);
      if (this.topLeftCornerOverlay) {
        this.topLeftCornerOverlay.refresh(fastDraw);
      }
      if (this.bottomLeftCornerOverlay && this.bottomLeftCornerOverlay.clone) {
        this.bottomLeftCornerOverlay.refresh(fastDraw);
      }
      if (this.debug) {
        this.debug.refresh(fastDraw);
      }
    }
    /**
     * Adjust overlays elements size and master table size
     *
     * @param {Boolean} [force=false]
     */
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var totalColumns = this.wot.getSetting("totalColumns");
      var totalRows = this.wot.getSetting("totalRows");
      var headerRowSize = this.wot.wtViewport.getRowHeaderWidth();
      var headerColumnSize = this.wot.wtViewport.getColumnHeaderHeight();
      var hiderStyle = this.wot.wtTable.hider.style;
      hiderStyle.width = "".concat(headerRowSize + this.leftOverlay.sumCellSizes(0, totalColumns), "px");
      hiderStyle.height = "".concat(headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1, "px");
      this.topOverlay.adjustElementsSize(force);
      this.leftOverlay.adjustElementsSize(force);
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.adjustElementsSize(force);
      }
    }
    /**
     *
     */
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      if (!this.topOverlay.areElementSizesAdjusted || !this.leftOverlay.areElementSizesAdjusted) {
        this.adjustElementsSize();
      }
      this.topOverlay.applyToDOM();
      if (this.bottomOverlay.clone) {
        this.bottomOverlay.applyToDOM();
      }
      this.leftOverlay.applyToDOM();
    }
    /**
     * Get the parent overlay of the provided element.
     *
     * @param {HTMLElement} element
     * @returns {Object|null}
     */
  }, {
    key: "getParentOverlay",
    value: function getParentOverlay(element) {
      if (!element) {
        return null;
      }
      var overlays = [this.topOverlay, this.leftOverlay, this.bottomOverlay, this.topLeftCornerOverlay, this.bottomLeftCornerOverlay];
      var result = null;
      arrayEach(overlays, function(elem) {
        if (!elem) {
          return;
        }
        if (elem.clone && elem.clone.wtTable.TABLE.contains(element)) {
          result = elem.clone;
        }
      });
      return result;
    }
  }]);
  return Overlays2;
}();
var overlays_default = Overlays;

// node_modules/handsontable/es/helpers/number.js
var number_exports = {};
__export(number_exports, {
  isNumeric: () => isNumeric,
  rangeEach: () => rangeEach,
  rangeEachReverse: () => rangeEachReverse,
  valueAccordingPercent: () => valueAccordingPercent
});
function _typeof4(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof4 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof4 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof4(obj);
}
function isNumeric(n) {
  var t = _typeof4(n);
  return t == "number" ? !isNaN(n) && isFinite(n) : t == "string" ? !n.length ? false : n.length == 1 ? /\d/.test(n) : /^\s*[+-]?\s*(?:(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/i.test(n) : t == "object" ? !!n && typeof n.valueOf() == "number" && !(n instanceof Date) : false;
}
function rangeEach(rangeFrom, rangeTo, iteratee) {
  var index2 = -1;
  if (typeof rangeTo === "function") {
    iteratee = rangeTo;
    rangeTo = rangeFrom;
  } else {
    index2 = rangeFrom - 1;
  }
  while (++index2 <= rangeTo) {
    if (iteratee(index2) === false) {
      break;
    }
  }
}
function rangeEachReverse(rangeFrom, rangeTo, iteratee) {
  var index2 = rangeFrom + 1;
  if (typeof rangeTo === "function") {
    iteratee = rangeTo;
    rangeTo = 0;
  }
  while (--index2 >= rangeTo) {
    if (iteratee(index2) === false) {
      break;
    }
  }
}
function valueAccordingPercent(value, percent) {
  percent = parseInt(percent.toString().replace("%", ""), 10);
  percent = parseInt(value * percent / 100, 10);
  return percent;
}

// node_modules/handsontable/es/3rdparty/walkontable/src/scroll.js
function _classCallCheck11(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties11(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass11(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties11(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties11(Constructor, staticProps);
  return Constructor;
}
var Scroll = function() {
  function Scroll2(wotInstance) {
    _classCallCheck11(this, Scroll2);
    this.wot = wotInstance;
    this.instance = wotInstance;
  }
  _createClass11(Scroll2, [{
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);
      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);
      return scrolledHorizontally || scrolledVertically;
    }
    /**
     * Scrolls viewport to a column.
     *
     * @param {Number} column Visual column index.
     * @param {Boolean} [snapToRight]
     * @param {Boolean} [snapToLeft]
     * @returns {Boolean}
     */
  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      if (!this.wot.drawn) {
        return false;
      }
      var _this$_getVariables = this._getVariables(), fixedColumnsLeft = _this$_getVariables.fixedColumnsLeft, leftOverlay = _this$_getVariables.leftOverlay, totalColumns = _this$_getVariables.totalColumns;
      var result = false;
      if (column >= 0 && column <= Math.max(totalColumns - 1, 0)) {
        if (column >= fixedColumnsLeft && (column < this.getFirstVisibleColumn() || snapToLeft)) {
          result = leftOverlay.scrollTo(column);
        } else if (column > this.getLastVisibleColumn() || snapToRight) {
          result = leftOverlay.scrollTo(column, true);
        }
      }
      return result;
    }
    /**
     * Scrolls viewport to a row.
     *
     * @param {Number} row Visual row index.
     * @param {Boolean} [snapToTop]
     * @param {Boolean} [snapToBottom]
     * @returns {Boolean}
     */
  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      if (!this.wot.drawn) {
        return false;
      }
      var _this$_getVariables2 = this._getVariables(), fixedRowsBottom = _this$_getVariables2.fixedRowsBottom, fixedRowsTop = _this$_getVariables2.fixedRowsTop, topOverlay = _this$_getVariables2.topOverlay, totalRows = _this$_getVariables2.totalRows;
      var result = false;
      if (row >= 0 && row <= Math.max(totalRows - 1, 0)) {
        if (row >= fixedRowsTop && (row < this.getFirstVisibleRow() || snapToTop)) {
          result = topOverlay.scrollTo(row);
        } else if (row > this.getLastVisibleRow() && row < totalRows - fixedRowsBottom || snapToBottom) {
          result = topOverlay.scrollTo(row, true);
        }
      }
      return result;
    }
    /**
     * Get first visible row based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {Number}
     */
  }, {
    key: "getFirstVisibleRow",
    value: function getFirstVisibleRow() {
      var _this$_getVariables3 = this._getVariables(), topOverlay = _this$_getVariables3.topOverlay, wtTable = _this$_getVariables3.wtTable, wtViewport = _this$_getVariables3.wtViewport, totalRows = _this$_getVariables3.totalRows, fixedRowsTop = _this$_getVariables3.fixedRowsTop;
      var firstVisibleRow = wtTable.getFirstVisibleRow();
      if (topOverlay.mainTableScrollableElement === window) {
        var rootElementOffset = offset(wtTable.wtRootElement);
        var totalTableHeight = innerHeight(wtTable.hider);
        var windowHeight = innerHeight(window);
        var windowScrollTop = getScrollTop(window);
        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {
          var rowsHeight = wtViewport.getColumnHeaderHeight();
          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);
          rangeEachReverse(totalRows, 1, function(row) {
            rowsHeight += topOverlay.sumCellSizes(row - 1, row);
            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {
              firstVisibleRow = row;
              return false;
            }
          });
        }
      }
      return firstVisibleRow;
    }
    /**
     * Get last visible row based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {Number}
     */
  }, {
    key: "getLastVisibleRow",
    value: function getLastVisibleRow() {
      var _this$_getVariables4 = this._getVariables(), topOverlay = _this$_getVariables4.topOverlay, wtTable = _this$_getVariables4.wtTable, wtViewport = _this$_getVariables4.wtViewport, totalRows = _this$_getVariables4.totalRows;
      var lastVisibleRow = wtTable.getLastVisibleRow();
      if (topOverlay.mainTableScrollableElement === window) {
        var rootElementOffset = offset(wtTable.wtRootElement);
        var windowHeight = innerHeight(window);
        var windowScrollTop = getScrollTop(window);
        if (rootElementOffset.top > windowScrollTop) {
          var rowsHeight = wtViewport.getColumnHeaderHeight();
          rangeEach(1, totalRows, function(row) {
            rowsHeight += topOverlay.sumCellSizes(row - 1, row);
            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {
              lastVisibleRow = row - 2;
              return false;
            }
          });
        }
      }
      return lastVisibleRow;
    }
    /**
     * Get first visible column based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {Number}
     */
  }, {
    key: "getFirstVisibleColumn",
    value: function getFirstVisibleColumn() {
      var _this$_getVariables5 = this._getVariables(), leftOverlay = _this$_getVariables5.leftOverlay, wtTable = _this$_getVariables5.wtTable, wtViewport = _this$_getVariables5.wtViewport, totalColumns = _this$_getVariables5.totalColumns;
      var firstVisibleColumn = wtTable.getFirstVisibleColumn();
      if (leftOverlay.mainTableScrollableElement === window) {
        var rootElementOffset = offset(wtTable.wtRootElement);
        var totalTableWidth = innerWidth(wtTable.hider);
        var windowWidth = innerWidth(window);
        var windowScrollLeft = getScrollLeft(window);
        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {
          var columnsWidth = wtViewport.getRowHeaderWidth();
          rangeEachReverse(totalColumns, 1, function(column) {
            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);
            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {
              firstVisibleColumn = column;
              return false;
            }
          });
        }
      }
      return firstVisibleColumn;
    }
    /**
     * Get last visible column based on virtual dom and how table is visible in browser window viewport.
     *
     * @returns {Number}
     */
  }, {
    key: "getLastVisibleColumn",
    value: function getLastVisibleColumn() {
      var _this$_getVariables6 = this._getVariables(), leftOverlay = _this$_getVariables6.leftOverlay, wtTable = _this$_getVariables6.wtTable, wtViewport = _this$_getVariables6.wtViewport, totalColumns = _this$_getVariables6.totalColumns;
      var lastVisibleColumn = wtTable.getLastVisibleColumn();
      if (leftOverlay.mainTableScrollableElement === window) {
        var rootElementOffset = offset(wtTable.wtRootElement);
        var windowWidth = innerWidth(window);
        var windowScrollLeft = getScrollLeft(window);
        if (rootElementOffset.left > windowScrollLeft) {
          var columnsWidth = wtViewport.getRowHeaderWidth();
          rangeEach(1, totalColumns, function(column) {
            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);
            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {
              lastVisibleColumn = column - 2;
              return false;
            }
          });
        }
      }
      return lastVisibleColumn;
    }
    /**
     * Returns collection of variables used to rows and columns visibility calculations.
     *
     * @returns {Object}
     * @private
     */
  }, {
    key: "_getVariables",
    value: function _getVariables() {
      var wot = this.wot;
      var topOverlay = wot.wtOverlays.topOverlay;
      var leftOverlay = wot.wtOverlays.leftOverlay;
      var wtTable = wot.wtTable;
      var wtViewport = wot.wtViewport;
      var totalRows = wot.getSetting("totalRows");
      var totalColumns = wot.getSetting("totalColumns");
      var fixedRowsTop = wot.getSetting("fixedRowsTop");
      var fixedRowsBottom = wot.getSetting("fixedRowsBottom");
      var fixedColumnsLeft = wot.getSetting("fixedColumnsLeft");
      return {
        topOverlay,
        leftOverlay,
        wtTable,
        wtViewport,
        totalRows,
        totalColumns,
        fixedRowsTop,
        fixedRowsBottom,
        fixedColumnsLeft
      };
    }
  }]);
  return Scroll2;
}();
var scroll_default = Scroll;

// node_modules/handsontable/es/3rdparty/walkontable/src/settings.js
function _classCallCheck12(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties12(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass12(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties12(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties12(Constructor, staticProps);
  return Constructor;
}
var Settings = function() {
  function Settings2(wotInstance, settings) {
    var _this = this;
    _classCallCheck12(this, Settings2);
    this.wot = wotInstance;
    this.instance = wotInstance;
    this.defaults = {
      table: void 0,
      debug: false,
      // shows WalkontableDebugOverlay
      // presentation mode
      externalRowCalculator: false,
      stretchH: "none",
      // values: all, last, none
      currentRowClassName: null,
      currentColumnClassName: null,
      preventOverflow: function preventOverflow() {
        return false;
      },
      // data source
      data: void 0,
      freezeOverlays: false,
      fixedColumnsLeft: 0,
      fixedRowsTop: 0,
      fixedRowsBottom: 0,
      minSpareRows: 0,
      // this must be array of functions: [function (row, TH) {}]
      rowHeaders: function rowHeaders() {
        return [];
      },
      // this must be array of functions: [function (column, TH) {}]
      columnHeaders: function columnHeaders() {
        return [];
      },
      totalRows: void 0,
      totalColumns: void 0,
      cellRenderer: function cellRenderer(row, column, TD) {
        var cellData = _this.getSetting("data", row, column);
        fastInnerText(TD, cellData === void 0 || cellData === null ? "" : cellData);
      },
      // columnWidth: 50,
      columnWidth: function columnWidth() {
      },
      rowHeight: function rowHeight() {
      },
      defaultRowHeight: 23,
      defaultColumnWidth: 50,
      selections: null,
      hideBorderOnMouseDownOver: false,
      viewportRowCalculatorOverride: null,
      viewportColumnCalculatorOverride: null,
      // callbacks
      onCellMouseDown: null,
      onCellContextMenu: null,
      onCellMouseOver: null,
      onCellMouseOut: null,
      onCellMouseUp: null,
      //    onCellMouseOut: null,
      onCellDblClick: null,
      onCellCornerMouseDown: null,
      onCellCornerDblClick: null,
      beforeDraw: null,
      onDraw: null,
      onBeforeRemoveCellClassNames: null,
      onAfterDrawSelection: null,
      onBeforeDrawBorders: null,
      onScrollVertically: null,
      onScrollHorizontally: null,
      onBeforeTouchScroll: null,
      onAfterMomentumScroll: null,
      onBeforeStretchingColumnWidth: function onBeforeStretchingColumnWidth(width) {
        return width;
      },
      onModifyRowHeaderWidth: null,
      onModifyGetCellCoords: null,
      // constants
      scrollbarWidth: 10,
      scrollbarHeight: 10,
      renderAllRows: false,
      groups: false,
      rowHeaderWidth: null,
      columnHeaderHeight: null,
      headerClassName: null
    };
    this.settings = {};
    objectEach(this.defaults, function(value, key) {
      if (settings[key] !== void 0) {
        _this.settings[key] = settings[key];
      } else if (value === void 0) {
        throw new Error('A required setting "'.concat(key, '" was not provided'));
      } else {
        _this.settings[key] = value;
      }
    });
  }
  _createClass12(Settings2, [{
    key: "update",
    value: function update(settings, value) {
      var _this2 = this;
      if (value === void 0) {
        objectEach(settings, function(settingValue, key) {
          _this2.settings[key] = settingValue;
        });
      } else {
        this.settings[settings] = value;
      }
      return this.wot;
    }
    /**
     * Get setting by name
     *
     * @param {String} key
     * @param {*} param1
     * @param {*} param2
     * @param {*} param3
     * @param {*} param4
     * @returns {*}
     */
  }, {
    key: "getSetting",
    value: function getSetting(key, param1, param2, param3, param4) {
      if (typeof this.settings[key] === "function") {
        return this.settings[key](param1, param2, param3, param4);
      } else if (param1 !== void 0 && Array.isArray(this.settings[key])) {
        return this.settings[key][param1];
      }
      return this.settings[key];
    }
    /**
     * Checks if setting exists
     *
     * @param {Boolean} key
     * @returns {Boolean}
     */
  }, {
    key: "has",
    value: function has(key) {
      return !!this.settings[key];
    }
  }]);
  return Settings2;
}();
var settings_default = Settings;

// node_modules/handsontable/es/helpers/console.js
function warn2() {
  if (isDefined(console)) {
    var _console2;
    (_console2 = console).warn.apply(_console2, arguments);
  }
}
function error() {
  if (isDefined(console)) {
    var _console4;
    (_console4 = console).error.apply(_console4, arguments);
  }
}

// node_modules/handsontable/es/3rdparty/walkontable/src/tableRenderer.js
function _templateObject2() {
  var data = _taggedTemplateLiteral2(['Performance tip: Handsontable rendered more than 1000 visible rows. Consider limiting the number \n          of rendered rows by specifying the table height and/or turning off the "renderAllRows" option.']);
  _templateObject2 = function _templateObject8() {
    return data;
  };
  return data;
}
function _taggedTemplateLiteral2(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck13(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties13(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass13(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties13(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties13(Constructor, staticProps);
  return Constructor;
}
var performanceWarningAppeared = false;
var TableRenderer = function() {
  function TableRenderer2(wtTable) {
    _classCallCheck13(this, TableRenderer2);
    this.wtTable = wtTable;
    this.wot = wtTable.instance;
    this.instance = wtTable.instance;
    this.rowFilter = wtTable.rowFilter;
    this.columnFilter = wtTable.columnFilter;
    this.TABLE = wtTable.TABLE;
    this.THEAD = wtTable.THEAD;
    this.TBODY = wtTable.TBODY;
    this.COLGROUP = wtTable.COLGROUP;
    this.rowHeaders = [];
    this.rowHeaderCount = 0;
    this.columnHeaders = [];
    this.columnHeaderCount = 0;
    this.fixedRowsTop = 0;
    this.fixedRowsBottom = 0;
  }
  _createClass13(TableRenderer2, [{
    key: "render",
    value: function render() {
      if (!this.wtTable.isWorkingOnClone()) {
        var skipRender = {};
        this.wot.getSetting("beforeDraw", true, skipRender);
        if (skipRender.skipRender === true) {
          return;
        }
      }
      this.rowHeaders = this.wot.getSetting("rowHeaders");
      this.rowHeaderCount = this.rowHeaders.length;
      this.fixedRowsTop = this.wot.getSetting("fixedRowsTop");
      this.fixedRowsBottom = this.wot.getSetting("fixedRowsBottom");
      this.columnHeaders = this.wot.getSetting("columnHeaders");
      this.columnHeaderCount = this.columnHeaders.length;
      var columnsToRender = this.wtTable.getRenderedColumnsCount();
      var rowsToRender = this.wtTable.getRenderedRowsCount();
      var totalColumns = this.wot.getSetting("totalColumns");
      var totalRows = this.wot.getSetting("totalRows");
      var workspaceWidth;
      var adjusted = false;
      if (base_default.isOverlayTypeOf(this.wot.cloneOverlay, base_default.CLONE_BOTTOM) || base_default.isOverlayTypeOf(this.wot.cloneOverlay, base_default.CLONE_BOTTOM_LEFT_CORNER)) {
        this.columnHeaders = [];
        this.columnHeaderCount = 0;
      }
      if (totalColumns >= 0) {
        this.adjustAvailableNodes();
        adjusted = true;
        this.renderColumnHeaders();
        this.renderRows(totalRows, rowsToRender, columnsToRender);
        if (!this.wtTable.isWorkingOnClone()) {
          workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();
          this.wot.wtViewport.containerWidth = null;
        }
        this.adjustColumnWidths(columnsToRender);
        this.markOversizedColumnHeaders();
        this.adjustColumnHeaderHeights();
      }
      if (!adjusted) {
        this.adjustAvailableNodes();
      }
      this.removeRedundantRows(rowsToRender);
      if (!this.wtTable.isWorkingOnClone() || this.wot.isOverlayName(base_default.CLONE_BOTTOM)) {
        this.markOversizedRows();
      }
      if (!this.wtTable.isWorkingOnClone()) {
        this.wot.wtViewport.createVisibleCalculators();
        this.wot.wtOverlays.refresh(false);
        this.wot.wtOverlays.applyToDOM();
        var hiderWidth = outerWidth(this.wtTable.hider);
        var tableWidth = outerWidth(this.wtTable.TABLE);
        if (hiderWidth !== 0 && tableWidth !== hiderWidth) {
          this.adjustColumnWidths(columnsToRender);
        }
        if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {
          this.wot.wtViewport.containerWidth = null;
          var firstRendered = this.wtTable.getFirstRenderedColumn();
          var lastRendered = this.wtTable.getLastRenderedColumn();
          var defaultColumnWidth = this.wot.getSetting("defaultColumnWidth");
          var rowHeaderWidthSetting = this.wot.getSetting("rowHeaderWidth");
          rowHeaderWidthSetting = this.instance.getSetting("onModifyRowHeaderWidth", rowHeaderWidthSetting);
          if (rowHeaderWidthSetting !== null && rowHeaderWidthSetting !== void 0) {
            for (var i = 0; i < this.rowHeaderCount; i++) {
              var width = Array.isArray(rowHeaderWidthSetting) ? rowHeaderWidthSetting[i] : rowHeaderWidthSetting;
              width = width === null || width === void 0 ? defaultColumnWidth : width;
              this.COLGROUP.childNodes[i].style.width = "".concat(width, "px");
            }
          }
          for (var _i = firstRendered; _i < lastRendered; _i++) {
            var _width = this.wtTable.getStretchedColumnWidth(_i);
            var renderedIndex = this.columnFilter.sourceToRendered(_i);
            this.COLGROUP.childNodes[renderedIndex + this.rowHeaderCount].style.width = "".concat(_width, "px");
          }
        }
        this.wot.getSetting("onDraw", true);
      } else if (this.wot.isOverlayName(base_default.CLONE_BOTTOM)) {
        this.wot.cloneSource.wtOverlays.adjustElementsSize();
      }
    }
    /**
     * @param {Number} renderedRowsCount
     */
  }, {
    key: "removeRedundantRows",
    value: function removeRedundantRows(renderedRowsCount) {
      while (this.wtTable.tbodyChildrenLength > renderedRowsCount) {
        this.TBODY.removeChild(this.TBODY.lastChild);
        this.wtTable.tbodyChildrenLength -= 1;
      }
    }
    /**
     * @param {Number} totalRows
     * @param {Number} rowsToRender
     * @param {Number} columnsToRender
     */
  }, {
    key: "renderRows",
    value: function renderRows(totalRows, rowsToRender, columnsToRender) {
      var TR;
      var visibleRowIndex = 0;
      var sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);
      var isWorkingOnClone = this.wtTable.isWorkingOnClone();
      while (sourceRowIndex < totalRows && sourceRowIndex >= 0) {
        if (!performanceWarningAppeared && visibleRowIndex > 1e3) {
          performanceWarningAppeared = true;
          warn2(toSingleLine(_templateObject2()));
        }
        if (rowsToRender !== void 0 && visibleRowIndex === rowsToRender) {
          break;
        }
        TR = this.getOrCreateTrForRow(visibleRowIndex, TR);
        this.renderRowHeaders(sourceRowIndex, TR);
        this.adjustColumns(TR, columnsToRender + this.rowHeaderCount);
        this.renderCells(sourceRowIndex, TR, columnsToRender);
        if (!isWorkingOnClone || // Necessary to refresh oversized row heights after editing cell in overlays
        this.wot.isOverlayName(base_default.CLONE_BOTTOM)) {
          this.resetOversizedRow(sourceRowIndex);
        }
        if (TR.firstChild) {
          var height = this.wot.wtTable.getRowHeight(sourceRowIndex);
          if (height) {
            height -= 1;
            TR.firstChild.style.height = "".concat(height, "px");
          } else {
            TR.firstChild.style.height = "";
          }
        }
        visibleRowIndex += 1;
        sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);
      }
    }
    /**
     * Reset the oversized row cache for the provided index
     *
     * @param {Number} sourceRow Row index
     */
  }, {
    key: "resetOversizedRow",
    value: function resetOversizedRow(sourceRow) {
      if (this.wot.getSetting("externalRowCalculator")) {
        return;
      }
      if (this.wot.wtViewport.oversizedRows && this.wot.wtViewport.oversizedRows[sourceRow]) {
        this.wot.wtViewport.oversizedRows[sourceRow] = void 0;
      }
    }
    /**
     * Check if any of the rendered rows is higher than expected, and if so, cache them
     */
  }, {
    key: "markOversizedRows",
    value: function markOversizedRows() {
      if (this.wot.getSetting("externalRowCalculator")) {
        return;
      }
      var rowCount = this.instance.wtTable.TBODY.childNodes.length;
      var expectedTableHeight = rowCount * this.instance.wtSettings.settings.defaultRowHeight;
      var actualTableHeight = innerHeight(this.instance.wtTable.TBODY) - 1;
      var previousRowHeight;
      var rowInnerHeight;
      var sourceRowIndex;
      var currentTr;
      var rowHeader;
      if (expectedTableHeight === actualTableHeight && !this.instance.getSetting("fixedRowsBottom")) {
        return;
      }
      while (rowCount) {
        rowCount -= 1;
        sourceRowIndex = this.instance.wtTable.rowFilter.renderedToSource(rowCount);
        previousRowHeight = this.instance.wtTable.getRowHeight(sourceRowIndex);
        currentTr = this.instance.wtTable.getTrForRow(sourceRowIndex);
        rowHeader = currentTr.querySelector("th");
        if (rowHeader) {
          rowInnerHeight = innerHeight(rowHeader);
        } else {
          rowInnerHeight = innerHeight(currentTr) - 1;
        }
        if (!previousRowHeight && this.instance.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {
          rowInnerHeight += 1;
          this.instance.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;
        }
      }
    }
    /**
     * Check if any of the rendered columns is higher than expected, and if so, cache them.
     */
  }, {
    key: "markOversizedColumnHeaders",
    value: function markOversizedColumnHeaders() {
      var overlayName = this.wot.getOverlayName();
      if (!this.columnHeaderCount || this.wot.wtViewport.hasOversizedColumnHeadersMarked[overlayName] || this.wtTable.isWorkingOnClone()) {
        return;
      }
      var columnCount = this.wtTable.getRenderedColumnsCount();
      for (var i = 0; i < this.columnHeaderCount; i++) {
        for (var renderedColumnIndex = -1 * this.rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
          this.markIfOversizedColumnHeader(renderedColumnIndex);
        }
      }
      this.wot.wtViewport.hasOversizedColumnHeadersMarked[overlayName] = true;
    }
    /**
     *
     */
  }, {
    key: "adjustColumnHeaderHeights",
    value: function adjustColumnHeaderHeights() {
      var columnHeaders = this.wot.getSetting("columnHeaders");
      var children = this.wot.wtTable.THEAD.childNodes;
      var oversizedColumnHeaders = this.wot.wtViewport.oversizedColumnHeaders;
      for (var i = 0, len = columnHeaders.length; i < len; i++) {
        if (oversizedColumnHeaders[i]) {
          if (!children[i] || children[i].childNodes.length === 0) {
            return;
          }
          children[i].childNodes[0].style.height = "".concat(oversizedColumnHeaders[i], "px");
        }
      }
    }
    /**
     * Check if column header for the specified column is higher than expected, and if so, cache it
     *
     * @param {Number} col Index of column
     */
  }, {
    key: "markIfOversizedColumnHeader",
    value: function markIfOversizedColumnHeader(col) {
      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);
      var level = this.columnHeaderCount;
      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
      var previousColHeaderHeight;
      var currentHeader;
      var currentHeaderHeight;
      var columnHeaderHeightSetting = this.wot.getSetting("columnHeaderHeight") || [];
      while (level) {
        level -= 1;
        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);
        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);
        if (!currentHeader) {
          continue;
        }
        currentHeaderHeight = innerHeight(currentHeader);
        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {
          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;
        }
        if (Array.isArray(columnHeaderHeightSetting)) {
          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {
            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];
          }
        } else if (!isNaN(columnHeaderHeightSetting)) {
          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;
        }
        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {
          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;
        }
      }
    }
    /**
     * @param {Number} sourceRowIndex
     * @param {HTMLTableRowElement} TR
     * @param {Number} columnsToRender
     * @returns {HTMLTableCellElement}
     */
  }, {
    key: "renderCells",
    value: function renderCells(sourceRowIndex, TR, columnsToRender) {
      var TD;
      var sourceColIndex;
      for (var visibleColIndex = 0; visibleColIndex < columnsToRender; visibleColIndex++) {
        sourceColIndex = this.columnFilter.renderedToSource(visibleColIndex);
        if (visibleColIndex === 0) {
          TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(sourceColIndex)];
        } else {
          TD = TD.nextSibling;
        }
        if (TD.nodeName === "TH") {
          TD = replaceThWithTd(TD, TR);
        }
        if (!hasClass(TD, "hide")) {
          TD.className = "";
        }
        TD.removeAttribute("style");
        this.wot.wtSettings.settings.cellRenderer(sourceRowIndex, sourceColIndex, TD);
      }
      return TD;
    }
    /**
     * @param {Number} columnsToRender Number of columns to render.
     */
  }, {
    key: "adjustColumnWidths",
    value: function adjustColumnWidths(columnsToRender) {
      var scrollbarCompensation = 0;
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var defaultColumnWidth = this.wot.getSetting("defaultColumnWidth");
      var rowHeaderWidthSetting = this.wot.getSetting("rowHeaderWidth");
      if (mainHolder.offsetHeight < mainHolder.scrollHeight) {
        scrollbarCompensation = getScrollbarWidth();
      }
      this.wot.wtViewport.columnsRenderCalculator.refreshStretching(this.wot.wtViewport.getViewportWidth() - scrollbarCompensation);
      rowHeaderWidthSetting = this.instance.getSetting("onModifyRowHeaderWidth", rowHeaderWidthSetting);
      if (rowHeaderWidthSetting !== null && rowHeaderWidthSetting !== void 0) {
        for (var i = 0; i < this.rowHeaderCount; i++) {
          var width = Array.isArray(rowHeaderWidthSetting) ? rowHeaderWidthSetting[i] : rowHeaderWidthSetting;
          width = width === null || width === void 0 ? defaultColumnWidth : width;
          this.COLGROUP.childNodes[i].style.width = "".concat(width, "px");
        }
      }
      for (var renderedColIndex = 0; renderedColIndex < columnsToRender; renderedColIndex++) {
        var _width2 = this.wtTable.getStretchedColumnWidth(this.columnFilter.renderedToSource(renderedColIndex));
        this.COLGROUP.childNodes[renderedColIndex + this.rowHeaderCount].style.width = "".concat(_width2, "px");
      }
    }
    /**
     * @param {HTMLTableCellElement} TR
     */
  }, {
    key: "appendToTbody",
    value: function appendToTbody(TR) {
      this.TBODY.appendChild(TR);
      this.wtTable.tbodyChildrenLength += 1;
    }
    /**
     * @param {Number} rowIndex
     * @param {HTMLTableRowElement} currentTr
     * @returns {HTMLTableCellElement}
     */
  }, {
    key: "getOrCreateTrForRow",
    value: function getOrCreateTrForRow(rowIndex, currentTr) {
      var TR;
      if (rowIndex >= this.wtTable.tbodyChildrenLength) {
        TR = this.createRow();
        this.appendToTbody(TR);
      } else if (rowIndex === 0) {
        TR = this.TBODY.firstChild;
      } else {
        TR = currentTr.nextSibling;
      }
      if (TR.className) {
        TR.removeAttribute("class");
      }
      return TR;
    }
    /**
     * @returns {HTMLTableCellElement}
     */
  }, {
    key: "createRow",
    value: function createRow() {
      var TR = document.createElement("TR");
      for (var visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
        TR.appendChild(document.createElement("TH"));
      }
      return TR;
    }
    /**
     * @param {Number} row
     * @param {Number} col
     * @param {HTMLTableCellElement} TH
     */
  }, {
    key: "renderRowHeader",
    value: function renderRowHeader(row, col, TH) {
      TH.className = "";
      TH.removeAttribute("style");
      this.rowHeaders[col](row, TH, col);
    }
    /**
     * @param {Number} row
     * @param {HTMLTableCellElement} TR
     */
  }, {
    key: "renderRowHeaders",
    value: function renderRowHeaders(row, TR) {
      for (var TH = TR.firstChild, visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
        if (!TH) {
          TH = document.createElement("TH");
          TR.appendChild(TH);
        } else if (TH.nodeName === "TD") {
          TH = replaceTdWithTh(TH, TR);
        }
        this.renderRowHeader(row, visibleColIndex, TH);
        TH = TH.nextSibling;
      }
    }
    /**
     * Adjust the number of COL and TH elements to match the number of columns and headers that need to be rendered
     */
  }, {
    key: "adjustAvailableNodes",
    value: function adjustAvailableNodes() {
      this.adjustColGroups();
      this.adjustThead();
    }
    /**
     * Renders the column headers
     */
  }, {
    key: "renderColumnHeaders",
    value: function renderColumnHeaders() {
      if (!this.columnHeaderCount) {
        return;
      }
      var columnCount = this.wtTable.getRenderedColumnsCount();
      for (var i = 0; i < this.columnHeaderCount; i++) {
        var TR = this.getTrForColumnHeaders(i);
        for (var renderedColumnIndex = -1 * this.rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
          var sourceCol = this.columnFilter.renderedToSource(renderedColumnIndex);
          this.renderColumnHeader(i, sourceCol, TR.childNodes[renderedColumnIndex + this.rowHeaderCount]);
        }
      }
    }
    /**
     * Adjusts the number of COL elements to match the number of columns that need to be rendered
     */
  }, {
    key: "adjustColGroups",
    value: function adjustColGroups() {
      var columnCount = this.wtTable.getRenderedColumnsCount();
      while (this.wtTable.colgroupChildrenLength < columnCount + this.rowHeaderCount) {
        this.COLGROUP.appendChild(document.createElement("COL"));
        this.wtTable.colgroupChildrenLength += 1;
      }
      while (this.wtTable.colgroupChildrenLength > columnCount + this.rowHeaderCount) {
        this.COLGROUP.removeChild(this.COLGROUP.lastChild);
        this.wtTable.colgroupChildrenLength -= 1;
      }
      if (this.rowHeaderCount) {
        addClass(this.COLGROUP.childNodes[0], "rowHeader");
      }
    }
    /**
     * Adjusts the number of TH elements in THEAD to match the number of headers and columns that need to be rendered
     */
  }, {
    key: "adjustThead",
    value: function adjustThead() {
      var columnCount = this.wtTable.getRenderedColumnsCount();
      var TR = this.THEAD.firstChild;
      if (this.columnHeaders.length) {
        for (var i = 0, len = this.columnHeaders.length; i < len; i++) {
          TR = this.THEAD.childNodes[i];
          if (!TR) {
            TR = document.createElement("TR");
            this.THEAD.appendChild(TR);
          }
          this.theadChildrenLength = TR.childNodes.length;
          while (this.theadChildrenLength < columnCount + this.rowHeaderCount) {
            TR.appendChild(document.createElement("TH"));
            this.theadChildrenLength += 1;
          }
          while (this.theadChildrenLength > columnCount + this.rowHeaderCount) {
            TR.removeChild(TR.lastChild);
            this.theadChildrenLength -= 1;
          }
        }
        var theadChildrenLength = this.THEAD.childNodes.length;
        if (theadChildrenLength > this.columnHeaders.length) {
          for (var _i2 = this.columnHeaders.length; _i2 < theadChildrenLength; _i2++) {
            this.THEAD.removeChild(this.THEAD.lastChild);
          }
        }
      } else if (TR) {
        empty(TR);
      }
    }
    /**
     * @param {Number} index
     * @returns {HTMLTableCellElement}
     */
  }, {
    key: "getTrForColumnHeaders",
    value: function getTrForColumnHeaders(index2) {
      return this.THEAD.childNodes[index2];
    }
    /**
     * @param {Number} row
     * @param {Number} col
     * @param {HTMLTableCellElement} TH
     * @returns {*}
     */
  }, {
    key: "renderColumnHeader",
    value: function renderColumnHeader(row, col, TH) {
      TH.className = "";
      TH.removeAttribute("style");
      return this.columnHeaders[row](col, TH, row);
    }
    /**
     * Add and/or remove the TDs to match the desired number
     *
     * @param {HTMLTableCellElement} TR Table row in question
     * @param {Number} desiredCount The desired number of TDs in the TR
     */
  }, {
    key: "adjustColumns",
    value: function adjustColumns(TR, desiredCount) {
      var count = TR.childNodes.length;
      while (count < desiredCount) {
        var TD = document.createElement("TD");
        TR.appendChild(TD);
        count += 1;
      }
      while (count > desiredCount) {
        TR.removeChild(TR.lastChild);
        count -= 1;
      }
    }
    /**
     * @param {Number} columnsToRender
     */
  }, {
    key: "removeRedundantColumns",
    value: function removeRedundantColumns(columnsToRender) {
      while (this.wtTable.tbodyChildrenLength > columnsToRender) {
        this.TBODY.removeChild(this.TBODY.lastChild);
        this.wtTable.tbodyChildrenLength -= 1;
      }
    }
  }]);
  return TableRenderer2;
}();
function replaceTdWithTh(TD, TR) {
  var TH = document.createElement("TH");
  TR.insertBefore(TH, TD);
  TR.removeChild(TD);
  return TH;
}
function replaceThWithTd(TH, TR) {
  var TD = document.createElement("TD");
  TR.insertBefore(TD, TH);
  TR.removeChild(TH);
  return TD;
}
var tableRenderer_default = TableRenderer;

// node_modules/handsontable/es/3rdparty/walkontable/src/table.js
function _toConsumableArray3(arr) {
  return _arrayWithoutHoles3(arr) || _iterableToArray3(arr) || _nonIterableSpread3();
}
function _nonIterableSpread3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray3(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles3(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function _typeof5(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof5 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof5 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof5(obj);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _classCallCheck14(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties14(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass14(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties14(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties14(Constructor, staticProps);
  return Constructor;
}
var Table = function() {
  function Table2(wotInstance, table) {
    var _this = this;
    _classCallCheck14(this, Table2);
    this.wot = wotInstance;
    this.instance = this.wot;
    this.TABLE = table;
    this.TBODY = null;
    this.THEAD = null;
    this.COLGROUP = null;
    this.tableOffset = 0;
    this.holderOffset = 0;
    removeTextNodes(this.TABLE);
    this.spreader = this.createSpreader(this.TABLE);
    this.hider = this.createHider(this.spreader);
    this.holder = this.createHolder(this.hider);
    this.wtRootElement = this.holder.parentNode;
    this.alignOverlaysWithTrimmingContainer();
    this.fixTableDomTree();
    this.colgroupChildrenLength = this.COLGROUP.childNodes.length;
    this.theadChildrenLength = this.THEAD.firstChild ? this.THEAD.firstChild.childNodes.length : 0;
    this.tbodyChildrenLength = this.TBODY.childNodes.length;
    this.rowFilter = null;
    this.columnFilter = null;
    this.correctHeaderWidth = false;
    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth;
    this.wot.wtSettings.settings.rowHeaderWidth = function() {
      return _this._modifyRowHeaderWidth(origRowHeaderWidth);
    };
  }
  _createClass14(Table2, [{
    key: "fixTableDomTree",
    value: function fixTableDomTree() {
      this.TBODY = this.TABLE.querySelector("tbody");
      if (!this.TBODY) {
        this.TBODY = document.createElement("tbody");
        this.TABLE.appendChild(this.TBODY);
      }
      this.THEAD = this.TABLE.querySelector("thead");
      if (!this.THEAD) {
        this.THEAD = document.createElement("thead");
        this.TABLE.insertBefore(this.THEAD, this.TBODY);
      }
      this.COLGROUP = this.TABLE.querySelector("colgroup");
      if (!this.COLGROUP) {
        this.COLGROUP = document.createElement("colgroup");
        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
      }
      if (this.wot.getSetting("columnHeaders").length && !this.THEAD.childNodes.length) {
        this.THEAD.appendChild(document.createElement("TR"));
      }
    }
    /**
     * @param table
     * @returns {HTMLElement}
     */
  }, {
    key: "createSpreader",
    value: function createSpreader(table) {
      var parent = table.parentNode;
      var spreader;
      if (!parent || parent.nodeType !== 1 || !hasClass(parent, "wtHolder")) {
        spreader = document.createElement("div");
        spreader.className = "wtSpreader";
        if (parent) {
          parent.insertBefore(spreader, table);
        }
        spreader.appendChild(table);
      }
      spreader.style.position = "relative";
      return spreader;
    }
    /**
     * @param spreader
     * @returns {HTMLElement}
     */
  }, {
    key: "createHider",
    value: function createHider(spreader) {
      var parent = spreader.parentNode;
      var hider;
      if (!parent || parent.nodeType !== 1 || !hasClass(parent, "wtHolder")) {
        hider = document.createElement("div");
        hider.className = "wtHider";
        if (parent) {
          parent.insertBefore(hider, spreader);
        }
        hider.appendChild(spreader);
      }
      return hider;
    }
    /**
     *
     * @param hider
     * @returns {HTMLElement}
     */
  }, {
    key: "createHolder",
    value: function createHolder(hider) {
      var parent = hider.parentNode;
      var holder2;
      if (!parent || parent.nodeType !== 1 || !hasClass(parent, "wtHolder")) {
        holder2 = document.createElement("div");
        holder2.style.position = "relative";
        holder2.className = "wtHolder";
        if (parent) {
          parent.insertBefore(holder2, hider);
        }
        if (!this.isWorkingOnClone()) {
          holder2.parentNode.className += "ht_master handsontable";
        }
        holder2.appendChild(hider);
      }
      return holder2;
    }
  }, {
    key: "alignOverlaysWithTrimmingContainer",
    value: function alignOverlaysWithTrimmingContainer() {
      var trimmingElement = getTrimmingContainer(this.wtRootElement);
      if (!this.isWorkingOnClone()) {
        this.holder.parentNode.style.position = "relative";
        if (trimmingElement === window) {
          var preventOverflow = this.wot.getSetting("preventOverflow");
          if (!preventOverflow) {
            this.holder.style.overflow = "visible";
            this.wtRootElement.style.overflow = "visible";
          }
        } else {
          this.holder.style.width = getStyle(trimmingElement, "width");
          this.holder.style.height = getStyle(trimmingElement, "height");
          this.holder.style.overflow = "";
        }
      }
    }
  }, {
    key: "isWorkingOnClone",
    value: function isWorkingOnClone() {
      return !!this.wot.cloneSource;
    }
    /**
     * Redraws the table
     *
     * @param {Boolean} fastDraw If TRUE, will try to avoid full redraw and only update the border positions. If FALSE or UNDEFINED, will perform a full redraw
     * @returns {Table}
     */
  }, {
    key: "draw",
    value: function draw(fastDraw) {
      var _this$wot = this.wot, wtOverlays = _this$wot.wtOverlays, wtViewport = _this$wot.wtViewport;
      var totalRows = this.instance.getSetting("totalRows");
      var rowHeaders = this.wot.getSetting("rowHeaders").length;
      var columnHeaders = this.wot.getSetting("columnHeaders").length;
      var syncScroll = false;
      var runFastDraw = fastDraw;
      if (!this.isWorkingOnClone()) {
        this.holderOffset = offset(this.holder);
        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);
        if (rowHeaders && !this.wot.getSetting("fixedColumnsLeft")) {
          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();
          var previousState = this.correctHeaderWidth;
          this.correctHeaderWidth = leftScrollPos > 0;
          if (previousState !== this.correctHeaderWidth) {
            runFastDraw = false;
          }
        }
      }
      if (!this.isWorkingOnClone()) {
        syncScroll = wtOverlays.prepareOverlays();
      }
      if (runFastDraw) {
        if (!this.isWorkingOnClone()) {
          wtViewport.createVisibleCalculators();
        }
        if (wtOverlays) {
          wtOverlays.refresh(true);
        }
      } else {
        if (this.isWorkingOnClone()) {
          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;
        } else {
          this.tableOffset = offset(this.TABLE);
        }
        var startRow;
        if (base_default.isOverlayTypeOf(this.wot.cloneOverlay, base_default.CLONE_DEBUG) || base_default.isOverlayTypeOf(this.wot.cloneOverlay, base_default.CLONE_TOP) || base_default.isOverlayTypeOf(this.wot.cloneOverlay, base_default.CLONE_TOP_LEFT_CORNER)) {
          startRow = 0;
        } else if (base_default.isOverlayTypeOf(this.instance.cloneOverlay, base_default.CLONE_BOTTOM) || base_default.isOverlayTypeOf(this.instance.cloneOverlay, base_default.CLONE_BOTTOM_LEFT_CORNER)) {
          startRow = Math.max(totalRows - this.wot.getSetting("fixedRowsBottom"), 0);
        } else {
          startRow = wtViewport.rowsRenderCalculator.startRow;
        }
        var startColumn;
        if (base_default.isOverlayTypeOf(this.wot.cloneOverlay, base_default.CLONE_DEBUG) || base_default.isOverlayTypeOf(this.wot.cloneOverlay, base_default.CLONE_LEFT) || base_default.isOverlayTypeOf(this.wot.cloneOverlay, base_default.CLONE_TOP_LEFT_CORNER) || base_default.isOverlayTypeOf(this.wot.cloneOverlay, base_default.CLONE_BOTTOM_LEFT_CORNER)) {
          startColumn = 0;
        } else {
          startColumn = wtViewport.columnsRenderCalculator.startColumn;
        }
        this.rowFilter = new row_default(startRow, totalRows, columnHeaders);
        this.columnFilter = new column_default(startColumn, this.wot.getSetting("totalColumns"), rowHeaders);
        this.alignOverlaysWithTrimmingContainer();
        this._doDraw();
      }
      this.refreshSelections(runFastDraw);
      if (!this.isWorkingOnClone()) {
        wtOverlays.topOverlay.resetFixedPosition();
        if (wtOverlays.bottomOverlay.clone) {
          wtOverlays.bottomOverlay.resetFixedPosition();
        }
        wtOverlays.leftOverlay.resetFixedPosition();
        if (wtOverlays.topLeftCornerOverlay) {
          wtOverlays.topLeftCornerOverlay.resetFixedPosition();
        }
        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {
          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();
        }
      }
      if (syncScroll) {
        wtOverlays.syncScrollWithMaster();
      }
      this.wot.drawn = true;
      return this;
    }
  }, {
    key: "_doDraw",
    value: function _doDraw() {
      var wtRenderer = new tableRenderer_default(this);
      wtRenderer.render();
    }
  }, {
    key: "removeClassFromCells",
    value: function removeClassFromCells(className) {
      var nodes = this.TABLE.querySelectorAll(".".concat(className));
      for (var i = 0, len = nodes.length; i < len; i++) {
        removeClass(nodes[i], className);
      }
    }
    /**
     * Refresh the table selection by re-rendering Selection instances connected with that instance.
     *
     * @param {Boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.
     */
  }, {
    key: "refreshSelections",
    value: function refreshSelections(fastDraw) {
      if (!this.wot.selections) {
        return;
      }
      var highlights = Array.from(this.wot.selections);
      var len = highlights.length;
      if (fastDraw) {
        var classesToRemove = [];
        for (var i = 0; i < len; i++) {
          var _highlights$i$setting = highlights[i].settings, highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName, highlightRowClassName = _highlights$i$setting.highlightRowClassName, highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;
          var classNames = highlights[i].classNames;
          var classNamesLength = classNames.length;
          for (var j = 0; j < classNamesLength; j++) {
            if (!classesToRemove.includes(classNames[j])) {
              classesToRemove.push(classNames[j]);
            }
          }
          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {
            classesToRemove.push(highlightHeaderClassName);
          }
          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {
            classesToRemove.push(highlightRowClassName);
          }
          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {
            classesToRemove.push(highlightColumnClassName);
          }
        }
        var additionalClassesToRemove = this.wot.getSetting("onBeforeRemoveCellClassNames");
        if (Array.isArray(additionalClassesToRemove)) {
          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {
            classesToRemove.push(additionalClassesToRemove[_i]);
          }
        }
        var classesToRemoveLength = classesToRemove.length;
        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {
          this.removeClassFromCells(classesToRemove[_i2]);
        }
      }
      for (var _i3 = 0; _i3 < len; _i3++) {
        highlights[_i3].draw(this.wot, fastDraw);
      }
    }
    /**
     * Get cell element at coords.
     *
     * @param {CellCoords} coords
     * @returns {HTMLElement|Number} HTMLElement on success or Number one of the exit codes on error:
     *  -1 row before viewport
     *  -2 row after viewport
     */
  }, {
    key: "getCell",
    value: function getCell(coords) {
      var row = coords.row;
      var column = coords.col;
      var hookResult = this.wot.getSetting("onModifyGetCellCoords", row, column);
      if (hookResult && Array.isArray(hookResult)) {
        var _hookResult = _slicedToArray(hookResult, 2);
        row = _hookResult[0];
        column = _hookResult[1];
      }
      if (this.isRowBeforeRenderedRows(row)) {
        return -1;
      } else if (this.isRowAfterRenderedRows(row)) {
        return -2;
      }
      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
      if (TR) {
        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];
      }
    }
    /**
     * getColumnHeader
     *
     * @param {Number} col Column index
     * @param {Number} [level=0] Header level (0 = most distant to the table)
     * @returns {Object} HTMLElement on success or undefined on error
     */
  }, {
    key: "getColumnHeader",
    value: function getColumnHeader(col) {
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var TR = this.THEAD.childNodes[level];
      if (TR) {
        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
      }
    }
    /**
     * getRowHeader
     *
     * @param {Number} row Row index
     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`
     */
  }, {
    key: "getRowHeader",
    value: function getRowHeader(row) {
      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
        return null;
      }
      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
      if (TR) {
        return TR.childNodes[0];
      }
    }
    /**
     * Returns cell coords object for a given TD (or a child element of a TD element).
     *
     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).
     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.
     */
  }, {
    key: "getCoords",
    value: function getCoords(TD) {
      var cellElement = TD;
      if (cellElement.nodeName !== "TD" && cellElement.nodeName !== "TH") {
        cellElement = closest(cellElement, ["TD", "TH"]);
      }
      if (cellElement === null) {
        return null;
      }
      var TR = cellElement.parentNode;
      var CONTAINER = TR.parentNode;
      var row = index(TR);
      var col = cellElement.cellIndex;
      if (overlayContainsElement(base_default.CLONE_TOP_LEFT_CORNER, cellElement) || overlayContainsElement(base_default.CLONE_TOP, cellElement)) {
        if (CONTAINER.nodeName === "THEAD") {
          row -= CONTAINER.childNodes.length;
        }
      } else if (CONTAINER === this.THEAD) {
        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
      } else {
        row = this.rowFilter.renderedToSource(row);
      }
      if (overlayContainsElement(base_default.CLONE_TOP_LEFT_CORNER, cellElement) || overlayContainsElement(base_default.CLONE_LEFT, cellElement)) {
        col = this.columnFilter.offsettedTH(col);
      } else {
        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);
      }
      return new coords_default(row, col);
    }
  }, {
    key: "getTrForRow",
    value: function getTrForRow(row) {
      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
    }
  }, {
    key: "getFirstRenderedRow",
    value: function getFirstRenderedRow() {
      return this.wot.wtViewport.rowsRenderCalculator.startRow;
    }
  }, {
    key: "getFirstVisibleRow",
    value: function getFirstVisibleRow() {
      return this.wot.wtViewport.rowsVisibleCalculator.startRow;
    }
  }, {
    key: "getFirstRenderedColumn",
    value: function getFirstRenderedColumn() {
      return this.wot.wtViewport.columnsRenderCalculator.startColumn;
    }
    /**
     * @returns {Number} Returns -1 if no row is visible
     */
  }, {
    key: "getFirstVisibleColumn",
    value: function getFirstVisibleColumn() {
      return this.wot.wtViewport.columnsVisibleCalculator.startColumn;
    }
    /**
     * @returns {Number} Returns -1 if no row is visible
     */
  }, {
    key: "getLastRenderedRow",
    value: function getLastRenderedRow() {
      return this.wot.wtViewport.rowsRenderCalculator.endRow;
    }
  }, {
    key: "getLastVisibleRow",
    value: function getLastVisibleRow() {
      return this.wot.wtViewport.rowsVisibleCalculator.endRow;
    }
  }, {
    key: "getLastRenderedColumn",
    value: function getLastRenderedColumn() {
      return this.wot.wtViewport.columnsRenderCalculator.endColumn;
    }
    /**
     * @returns {Number} Returns -1 if no column is visible
     */
  }, {
    key: "getLastVisibleColumn",
    value: function getLastVisibleColumn() {
      return this.wot.wtViewport.columnsVisibleCalculator.endColumn;
    }
  }, {
    key: "isRowBeforeRenderedRows",
    value: function isRowBeforeRenderedRows(row) {
      return this.rowFilter && this.rowFilter.sourceToRendered(row) < 0 && row >= 0;
    }
  }, {
    key: "isRowAfterViewport",
    value: function isRowAfterViewport(row) {
      return this.rowFilter && this.rowFilter.sourceToRendered(row) > this.getLastVisibleRow();
    }
  }, {
    key: "isRowAfterRenderedRows",
    value: function isRowAfterRenderedRows(row) {
      return this.rowFilter && this.rowFilter.sourceToRendered(row) > this.getLastRenderedRow();
    }
  }, {
    key: "isColumnBeforeViewport",
    value: function isColumnBeforeViewport(column) {
      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;
    }
  }, {
    key: "isColumnAfterViewport",
    value: function isColumnAfterViewport(column) {
      return this.columnFilter && this.columnFilter.sourceToRendered(column) > this.getLastVisibleColumn();
    }
  }, {
    key: "isLastRowFullyVisible",
    value: function isLastRowFullyVisible() {
      return this.getLastVisibleRow() === this.getLastRenderedRow();
    }
  }, {
    key: "isLastColumnFullyVisible",
    value: function isLastColumnFullyVisible() {
      return this.getLastVisibleColumn() === this.getLastRenderedColumn();
    }
  }, {
    key: "getRenderedColumnsCount",
    value: function getRenderedColumnsCount() {
      var columnsCount = this.wot.wtViewport.columnsRenderCalculator.count;
      var totalColumns = this.wot.getSetting("totalColumns");
      if (this.wot.isOverlayName(base_default.CLONE_DEBUG)) {
        columnsCount = totalColumns;
      } else if (this.wot.isOverlayName(base_default.CLONE_LEFT) || this.wot.isOverlayName(base_default.CLONE_TOP_LEFT_CORNER) || this.wot.isOverlayName(base_default.CLONE_BOTTOM_LEFT_CORNER)) {
        return Math.min(this.wot.getSetting("fixedColumnsLeft"), totalColumns);
      }
      return columnsCount;
    }
  }, {
    key: "getRenderedRowsCount",
    value: function getRenderedRowsCount() {
      var rowsCount = this.wot.wtViewport.rowsRenderCalculator.count;
      var totalRows = this.wot.getSetting("totalRows");
      if (this.wot.isOverlayName(base_default.CLONE_DEBUG)) {
        rowsCount = totalRows;
      } else if (this.wot.isOverlayName(base_default.CLONE_TOP) || this.wot.isOverlayName(base_default.CLONE_TOP_LEFT_CORNER)) {
        rowsCount = Math.min(this.wot.getSetting("fixedRowsTop"), totalRows);
      } else if (this.wot.isOverlayName(base_default.CLONE_BOTTOM) || this.wot.isOverlayName(base_default.CLONE_BOTTOM_LEFT_CORNER)) {
        rowsCount = Math.min(this.wot.getSetting("fixedRowsBottom"), totalRows);
      }
      return rowsCount;
    }
  }, {
    key: "getVisibleRowsCount",
    value: function getVisibleRowsCount() {
      return this.wot.wtViewport.rowsVisibleCalculator.count;
    }
  }, {
    key: "allRowsInViewport",
    value: function allRowsInViewport() {
      return this.wot.getSetting("totalRows") === this.getVisibleRowsCount();
    }
    /**
     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height
     *
     * @param {Number} sourceRow
     * @returns {Number}
     */
  }, {
    key: "getRowHeight",
    value: function getRowHeight(sourceRow) {
      var height = this.wot.wtSettings.settings.rowHeight(sourceRow);
      var oversizedHeight = this.wot.wtViewport.oversizedRows[sourceRow];
      if (oversizedHeight !== void 0) {
        height = height === void 0 ? oversizedHeight : Math.max(height, oversizedHeight);
      }
      return height;
    }
  }, {
    key: "getColumnHeaderHeight",
    value: function getColumnHeaderHeight(level) {
      var height = this.wot.wtSettings.settings.defaultRowHeight;
      var oversizedHeight = this.wot.wtViewport.oversizedColumnHeaders[level];
      if (oversizedHeight !== void 0) {
        height = height ? Math.max(height, oversizedHeight) : oversizedHeight;
      }
      return height;
    }
  }, {
    key: "getVisibleColumnsCount",
    value: function getVisibleColumnsCount() {
      return this.wot.wtViewport.columnsVisibleCalculator.count;
    }
  }, {
    key: "allColumnsInViewport",
    value: function allColumnsInViewport() {
      return this.wot.getSetting("totalColumns") === this.getVisibleColumnsCount();
    }
  }, {
    key: "getColumnWidth",
    value: function getColumnWidth(sourceColumn) {
      var width = this.wot.wtSettings.settings.columnWidth;
      if (typeof width === "function") {
        width = width(sourceColumn);
      } else if (_typeof5(width) === "object") {
        width = width[sourceColumn];
      }
      return width || this.wot.wtSettings.settings.defaultColumnWidth;
    }
  }, {
    key: "getStretchedColumnWidth",
    value: function getStretchedColumnWidth(sourceColumn) {
      var columnWidth = this.getColumnWidth(sourceColumn);
      var width = columnWidth === null || columnWidth === void 0 ? this.instance.wtSettings.settings.defaultColumnWidth : columnWidth;
      var calculator = this.wot.wtViewport.columnsRenderCalculator;
      if (calculator) {
        var stretchedWidth = calculator.getStretchedColumnWidth(sourceColumn, width);
        if (stretchedWidth) {
          width = stretchedWidth;
        }
      }
      return width;
    }
    /**
     * Modify row header widths provided by user in class contructor.
     *
     * @private
     */
  }, {
    key: "_modifyRowHeaderWidth",
    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {
      var widths = isFunction2(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;
      if (Array.isArray(widths)) {
        widths = _toConsumableArray3(widths);
        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);
      } else {
        widths = this._correctRowHeaderWidth(widths);
      }
      return widths;
    }
    /**
     * Correct row header width if necessary.
     *
     * @private
     */
  }, {
    key: "_correctRowHeaderWidth",
    value: function _correctRowHeaderWidth(width) {
      var rowHeaderWidth = width;
      if (typeof width !== "number") {
        rowHeaderWidth = this.wot.getSetting("defaultColumnWidth");
      }
      if (this.correctHeaderWidth) {
        rowHeaderWidth += 1;
      }
      return rowHeaderWidth;
    }
  }]);
  return Table2;
}();
var table_default = Table;

// node_modules/handsontable/es/3rdparty/walkontable/src/viewport.js
function _classCallCheck15(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties15(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass15(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties15(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties15(Constructor, staticProps);
  return Constructor;
}
var Viewport = function() {
  function Viewport2(wotInstance) {
    var _this = this;
    _classCallCheck15(this, Viewport2);
    this.wot = wotInstance;
    this.instance = this.wot;
    this.oversizedRows = [];
    this.oversizedColumnHeaders = [];
    this.hasOversizedColumnHeadersMarked = {};
    this.clientHeight = 0;
    this.containerWidth = NaN;
    this.rowHeaderWidth = NaN;
    this.rowsVisibleCalculator = null;
    this.columnsVisibleCalculator = null;
    this.eventManager = new eventManager_default(this.wot);
    this.eventManager.addEventListener(window, "resize", function() {
      _this.clientHeight = _this.getWorkspaceHeight();
    });
  }
  _createClass15(Viewport2, [{
    key: "getWorkspaceHeight",
    value: function getWorkspaceHeight() {
      var trimmingContainer = this.instance.wtOverlays.topOverlay.trimmingContainer;
      var elemHeight;
      var height = 0;
      if (trimmingContainer === window) {
        height = document.documentElement.clientHeight;
      } else {
        elemHeight = outerHeight(trimmingContainer);
        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;
      }
      return height;
    }
  }, {
    key: "getWorkspaceWidth",
    value: function getWorkspaceWidth() {
      var width;
      var totalColumns = this.wot.getSetting("totalColumns");
      var trimmingContainer = this.instance.wtOverlays.leftOverlay.trimmingContainer;
      var overflow;
      var stretchSetting = this.wot.getSetting("stretchH");
      var docOffsetWidth = document.documentElement.offsetWidth;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (preventOverflow) {
        return outerWidth(this.instance.wtTable.wtRootElement);
      }
      if (this.wot.getSetting("freezeOverlays")) {
        width = Math.min(docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
      } else {
        width = Math.min(this.getContainerFillWidth(), docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
      }
      if (trimmingContainer === window && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {
        return document.documentElement.clientWidth;
      }
      if (trimmingContainer !== window) {
        overflow = getStyle(this.instance.wtOverlays.leftOverlay.trimmingContainer, "overflow");
        if (overflow === "scroll" || overflow === "hidden" || overflow === "auto") {
          return Math.max(width, trimmingContainer.clientWidth);
        }
      }
      if (stretchSetting === "none" || !stretchSetting) {
        return Math.max(width, outerWidth(this.instance.wtTable.TABLE));
      }
      return width;
    }
    /**
     * Checks if viewport has vertical scroll
     *
     * @returns {Boolean}
     */
  }, {
    key: "hasVerticalScroll",
    value: function hasVerticalScroll() {
      return this.getWorkspaceActualHeight() > this.getWorkspaceHeight();
    }
    /**
     * Checks if viewport has horizontal scroll
     *
     * @returns {Boolean}
     */
  }, {
    key: "hasHorizontalScroll",
    value: function hasHorizontalScroll() {
      return this.getWorkspaceActualWidth() > this.getWorkspaceWidth();
    }
    /**
     * @param from
     * @param length
     * @returns {Number}
     */
  }, {
    key: "sumColumnWidths",
    value: function sumColumnWidths(from3, length) {
      var wtTable = this.wot.wtTable;
      var sum = 0;
      var column = from3;
      while (column < length) {
        sum += wtTable.getColumnWidth(column);
        column += 1;
      }
      return sum;
    }
    /**
     * @returns {Number}
     */
  }, {
    key: "getContainerFillWidth",
    value: function getContainerFillWidth() {
      if (this.containerWidth) {
        return this.containerWidth;
      }
      var mainContainer = this.instance.wtTable.holder;
      var dummyElement = document.createElement("div");
      dummyElement.style.width = "100%";
      dummyElement.style.height = "1px";
      mainContainer.appendChild(dummyElement);
      var fillWidth = dummyElement.offsetWidth;
      this.containerWidth = fillWidth;
      mainContainer.removeChild(dummyElement);
      return fillWidth;
    }
    /**
     * @returns {Number}
     */
  }, {
    key: "getWorkspaceOffset",
    value: function getWorkspaceOffset() {
      return offset(this.wot.wtTable.TABLE);
    }
    /**
     * @returns {Number}
     */
  }, {
    key: "getWorkspaceActualHeight",
    value: function getWorkspaceActualHeight() {
      return outerHeight(this.wot.wtTable.TABLE);
    }
    /**
     * @returns {Number}
     */
  }, {
    key: "getWorkspaceActualWidth",
    value: function getWorkspaceActualWidth() {
      return outerWidth(this.wot.wtTable.TABLE) || outerWidth(this.wot.wtTable.TBODY) || outerWidth(this.wot.wtTable.THEAD);
    }
    /**
     * @returns {Number}
     */
  }, {
    key: "getColumnHeaderHeight",
    value: function getColumnHeaderHeight() {
      if (isNaN(this.columnHeaderHeight)) {
        this.columnHeaderHeight = outerHeight(this.wot.wtTable.THEAD);
      }
      return this.columnHeaderHeight;
    }
    /**
     * @returns {Number}
     */
  }, {
    key: "getViewportHeight",
    value: function getViewportHeight() {
      var containerHeight = this.getWorkspaceHeight();
      if (containerHeight === Infinity) {
        return containerHeight;
      }
      var columnHeaderHeight = this.getColumnHeaderHeight();
      if (columnHeaderHeight > 0) {
        containerHeight -= columnHeaderHeight;
      }
      return containerHeight;
    }
    /**
     * @returns {Number}
     */
  }, {
    key: "getRowHeaderWidth",
    value: function getRowHeaderWidth() {
      var rowHeadersHeightSetting = this.instance.getSetting("rowHeaderWidth");
      var rowHeaders = this.instance.getSetting("rowHeaders");
      if (rowHeadersHeightSetting) {
        this.rowHeaderWidth = 0;
        for (var i = 0, len = rowHeaders.length; i < len; i++) {
          this.rowHeaderWidth += rowHeadersHeightSetting[i] || rowHeadersHeightSetting;
        }
      }
      if (this.wot.cloneSource) {
        return this.wot.cloneSource.wtViewport.getRowHeaderWidth();
      }
      if (isNaN(this.rowHeaderWidth)) {
        if (rowHeaders.length) {
          var TH = this.instance.wtTable.TABLE.querySelector("TH");
          this.rowHeaderWidth = 0;
          for (var _i = 0, _len = rowHeaders.length; _i < _len; _i++) {
            if (TH) {
              this.rowHeaderWidth += outerWidth(TH);
              TH = TH.nextSibling;
            } else {
              this.rowHeaderWidth += 50;
            }
          }
        } else {
          this.rowHeaderWidth = 0;
        }
      }
      this.rowHeaderWidth = this.instance.getSetting("onModifyRowHeaderWidth", this.rowHeaderWidth) || this.rowHeaderWidth;
      return this.rowHeaderWidth;
    }
    /**
     * @returns {Number}
     */
  }, {
    key: "getViewportWidth",
    value: function getViewportWidth() {
      var containerWidth = this.getWorkspaceWidth();
      if (containerWidth === Infinity) {
        return containerWidth;
      }
      var rowHeaderWidth = this.getRowHeaderWidth();
      if (rowHeaderWidth > 0) {
        return containerWidth - rowHeaderWidth;
      }
      return containerWidth;
    }
    /**
     * Creates:
     *  - rowsRenderCalculator (before draw, to qualify rows for rendering)
     *  - rowsVisibleCalculator (after draw, to measure which rows are actually visible)
     *
     * @returns {ViewportRowsCalculator}
     */
  }, {
    key: "createRowsCalculator",
    value: function createRowsCalculator() {
      var _this2 = this;
      var visible = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var height;
      var scrollbarHeight;
      var fixedRowsHeight;
      this.rowHeaderWidth = NaN;
      if (this.wot.wtSettings.settings.renderAllRows && !visible) {
        height = Infinity;
      } else {
        height = this.getViewportHeight();
      }
      var pos = this.wot.wtOverlays.topOverlay.getScrollPosition() - this.wot.wtOverlays.topOverlay.getTableParentOffset();
      if (pos < 0) {
        pos = 0;
      }
      var fixedRowsTop = this.wot.getSetting("fixedRowsTop");
      var fixedRowsBottom = this.wot.getSetting("fixedRowsBottom");
      var totalRows = this.wot.getSetting("totalRows");
      if (fixedRowsTop) {
        fixedRowsHeight = this.wot.wtOverlays.topOverlay.sumCellSizes(0, fixedRowsTop);
        pos += fixedRowsHeight;
        height -= fixedRowsHeight;
      }
      if (fixedRowsBottom && this.wot.wtOverlays.bottomOverlay.clone) {
        fixedRowsHeight = this.wot.wtOverlays.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
        height -= fixedRowsHeight;
      }
      if (this.wot.wtTable.holder.clientHeight === this.wot.wtTable.holder.offsetHeight) {
        scrollbarHeight = 0;
      } else {
        scrollbarHeight = getScrollbarWidth();
      }
      return new viewportRows_default(height, pos, this.wot.getSetting("totalRows"), function(sourceRow) {
        return _this2.wot.wtTable.getRowHeight(sourceRow);
      }, visible ? null : this.wot.wtSettings.settings.viewportRowCalculatorOverride, visible, scrollbarHeight);
    }
    /**
     * Creates:
     *  - columnsRenderCalculator (before draw, to qualify columns for rendering)
     *  - columnsVisibleCalculator (after draw, to measure which columns are actually visible)
     *
     * @returns {ViewportRowsCalculator}
     */
  }, {
    key: "createColumnsCalculator",
    value: function createColumnsCalculator() {
      var _this3 = this;
      var visible = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var width = this.getViewportWidth();
      var pos = this.wot.wtOverlays.leftOverlay.getScrollPosition() - this.wot.wtOverlays.leftOverlay.getTableParentOffset();
      this.columnHeaderHeight = NaN;
      if (pos < 0) {
        pos = 0;
      }
      var fixedColumnsLeft = this.wot.getSetting("fixedColumnsLeft");
      if (fixedColumnsLeft) {
        var fixedColumnsWidth = this.wot.wtOverlays.leftOverlay.sumCellSizes(0, fixedColumnsLeft);
        pos += fixedColumnsWidth;
        width -= fixedColumnsWidth;
      }
      if (this.wot.wtTable.holder.clientWidth !== this.wot.wtTable.holder.offsetWidth) {
        width -= getScrollbarWidth();
      }
      return new viewportColumns_default(width, pos, this.wot.getSetting("totalColumns"), function(sourceCol) {
        return _this3.wot.wtTable.getColumnWidth(sourceCol);
      }, visible ? null : this.wot.wtSettings.settings.viewportColumnCalculatorOverride, visible, this.wot.getSetting("stretchH"), function(stretchedWidth, column) {
        return _this3.wot.getSetting("onBeforeStretchingColumnWidth", stretchedWidth, column);
      });
    }
    /**
     * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and
     * cols should be rendered)
     *
     * @param fastDraw {Boolean} If `true`, will try to avoid full redraw and only update the border positions.
     *                           If `false` or `undefined`, will perform a full redraw
     * @returns fastDraw {Boolean} The fastDraw value, possibly modified
     */
  }, {
    key: "createRenderCalculators",
    value: function createRenderCalculators() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var runFastDraw = fastDraw;
      if (runFastDraw) {
        var proposedRowsVisibleCalculator = this.createRowsCalculator(true);
        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(true);
        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {
          runFastDraw = false;
        }
      }
      if (!runFastDraw) {
        this.rowsRenderCalculator = this.createRowsCalculator();
        this.columnsRenderCalculator = this.createColumnsCalculator();
      }
      this.rowsVisibleCalculator = null;
      this.columnsVisibleCalculator = null;
      return runFastDraw;
    }
    /**
     * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are
     * the actually visible rows and columns)
     */
  }, {
    key: "createVisibleCalculators",
    value: function createVisibleCalculators() {
      this.rowsVisibleCalculator = this.createRowsCalculator(true);
      this.columnsVisibleCalculator = this.createColumnsCalculator(true);
    }
    /**
     * Returns information whether proposedRowsVisibleCalculator viewport
     * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator)
     *
     * @param {Object} proposedRowsVisibleCalculator
     * @returns {Boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).
     *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed)
     */
  }, {
    key: "areAllProposedVisibleRowsAlreadyRendered",
    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {
      if (this.rowsVisibleCalculator) {
        if (proposedRowsVisibleCalculator.startRow < this.rowsRenderCalculator.startRow || proposedRowsVisibleCalculator.startRow === this.rowsRenderCalculator.startRow && proposedRowsVisibleCalculator.startRow > 0) {
          return false;
        } else if (proposedRowsVisibleCalculator.endRow > this.rowsRenderCalculator.endRow || proposedRowsVisibleCalculator.endRow === this.rowsRenderCalculator.endRow && proposedRowsVisibleCalculator.endRow < this.wot.getSetting("totalRows") - 1) {
          return false;
        }
        return true;
      }
      return false;
    }
    /**
     * Returns information whether proposedColumnsVisibleCalculator viewport
     * is contained inside column rendered in previous draw (cached in columnsRenderCalculator)
     *
     * @param {Object} proposedColumnsVisibleCalculator
     * @returns {Boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).
     *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed)
     */
  }, {
    key: "areAllProposedVisibleColumnsAlreadyRendered",
    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {
      if (this.columnsVisibleCalculator) {
        if (proposedColumnsVisibleCalculator.startColumn < this.columnsRenderCalculator.startColumn || proposedColumnsVisibleCalculator.startColumn === this.columnsRenderCalculator.startColumn && proposedColumnsVisibleCalculator.startColumn > 0) {
          return false;
        } else if (proposedColumnsVisibleCalculator.endColumn > this.columnsRenderCalculator.endColumn || proposedColumnsVisibleCalculator.endColumn === this.columnsRenderCalculator.endColumn && proposedColumnsVisibleCalculator.endColumn < this.wot.getSetting("totalColumns") - 1) {
          return false;
        }
        return true;
      }
      return false;
    }
    /**
     * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.
     */
  }, {
    key: "resetHasOversizedColumnHeadersMarked",
    value: function resetHasOversizedColumnHeadersMarked() {
      objectEach(this.hasOversizedColumnHeadersMarked, function(value, key, object) {
        object[key] = void 0;
      });
    }
  }]);
  return Viewport2;
}();
var viewport_default = Viewport;

// node_modules/handsontable/es/3rdparty/walkontable/src/core.js
function _classCallCheck16(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties16(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass16(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties16(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties16(Constructor, staticProps);
  return Constructor;
}
var Walkontable = function() {
  function Walkontable2(settings) {
    _classCallCheck16(this, Walkontable2);
    var originalHeaders = [];
    this.guid = "wt_".concat(randomString());
    if (settings.cloneSource) {
      this.cloneSource = settings.cloneSource;
      this.cloneOverlay = settings.cloneOverlay;
      this.wtSettings = settings.cloneSource.wtSettings;
      this.wtTable = new table_default(this, settings.table, settings.wtRootElement);
      this.wtScroll = new scroll_default(this);
      this.wtViewport = settings.cloneSource.wtViewport;
      this.wtEvent = new event_default(this);
      this.selections = this.cloneSource.selections;
    } else {
      this.wtSettings = new settings_default(this, settings);
      this.wtTable = new table_default(this, settings.table);
      this.wtScroll = new scroll_default(this);
      this.wtViewport = new viewport_default(this);
      this.wtEvent = new event_default(this);
      this.selections = this.getSetting("selections");
      this.wtOverlays = new overlays_default(this);
      this.exportSettingsAsClassNames();
    }
    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
      for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {
        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);
      }
      if (!this.getSetting("columnHeaders").length) {
        this.update("columnHeaders", [function(column, TH) {
          fastInnerText(TH, originalHeaders[column]);
        }]);
      }
    }
    this.drawn = false;
    this.drawInterrupted = false;
  }
  _createClass16(Walkontable2, [{
    key: "draw",
    value: function draw() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.drawInterrupted = false;
      if (!fastDraw && !isVisible(this.wtTable.TABLE)) {
        this.drawInterrupted = true;
      } else {
        this.wtTable.draw(fastDraw);
      }
      return this;
    }
    /**
     * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,
     * if not set or set to false, returns TD from the master table.
     *
     * @param {CellCoords} coords
     * @param {Boolean} [topmost=false]
     * @returns {Object}
     */
  }, {
    key: "getCell",
    value: function getCell(coords) {
      var topmost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!topmost) {
        return this.wtTable.getCell(coords);
      }
      var totalRows = this.wtSettings.getSetting("totalRows");
      var fixedRowsTop = this.wtSettings.getSetting("fixedRowsTop");
      var fixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
      var fixedColumns = this.wtSettings.getSetting("fixedColumnsLeft");
      if (coords.row < fixedRowsTop && coords.col < fixedColumns) {
        return this.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell(coords);
      } else if (coords.row < fixedRowsTop) {
        return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);
      } else if (coords.col < fixedColumns && coords.row >= totalRows - fixedRowsBottom) {
        if (this.wtOverlays.bottomLeftCornerOverlay && this.wtOverlays.bottomLeftCornerOverlay.clone) {
          return this.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell(coords);
        }
      } else if (coords.col < fixedColumns) {
        return this.wtOverlays.leftOverlay.clone.wtTable.getCell(coords);
      } else if (coords.row < totalRows && coords.row > totalRows - fixedRowsBottom) {
        if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {
          return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);
        }
      }
      return this.wtTable.getCell(coords);
    }
    /**
     * @param {Object} settings
     * @param {*} value
     * @returns {Walkontable}
     */
  }, {
    key: "update",
    value: function update(settings, value) {
      return this.wtSettings.update(settings, value);
    }
    /**
     * Scrolls the viewport to a cell (rerenders if needed).
     *
     * @param {CellCoords} coords
     * @param {Boolean} [snapToTop]
     * @param {Boolean} [snapToRight]
     * @param {Boolean} [snapToBottom]
     * @param {Boolean} [snapToLeft]
     * @returns {Boolean}
     */
  }, {
    key: "scrollViewport",
    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
      return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
    /**
     * Scrolls the viewport to a column (rerenders if needed).
     *
     * @param {Number} column Visual column index.
     * @param {Boolean} [snapToRight]
     * @param {Boolean} [snapToLeft]
     * @returns {Boolean}
     */
  }, {
    key: "scrollViewportHorizontally",
    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {
      return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);
    }
    /**
     * Scrolls the viewport to a row (rerenders if needed).
     *
     * @param {Number} row Visual row index.
     * @param {Boolean} [snapToTop]
     * @param {Boolean} [snapToBottom]
     * @returns {Boolean}
     */
  }, {
    key: "scrollViewportVertically",
    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {
      return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);
    }
    /**
     * @returns {Array}
     */
  }, {
    key: "getViewport",
    value: function getViewport() {
      return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];
    }
    /**
     * Get overlay name
     *
     * @returns {String}
     */
  }, {
    key: "getOverlayName",
    value: function getOverlayName() {
      return this.cloneOverlay ? this.cloneOverlay.type : "master";
    }
    /**
     * Check overlay type of this Walkontable instance.
     *
     * @param {String} name Clone type @see {Overlay.CLONE_TYPES}.
     * @returns {Boolean}
     */
  }, {
    key: "isOverlayName",
    value: function isOverlayName(name) {
      if (this.cloneOverlay) {
        return this.cloneOverlay.type === name;
      }
      return false;
    }
    /**
     * Export settings as class names added to the parent element of the table.
     */
  }, {
    key: "exportSettingsAsClassNames",
    value: function exportSettingsAsClassNames() {
      var _this = this;
      var toExport = {
        rowHeaders: ["array"],
        columnHeaders: ["array"]
      };
      var allClassNames = [];
      var newClassNames = [];
      objectEach(toExport, function(optionType, key) {
        if (optionType.indexOf("array") > -1 && _this.getSetting(key).length) {
          newClassNames.push("ht".concat(toUpperCaseFirst(key)));
        }
        allClassNames.push("ht".concat(toUpperCaseFirst(key)));
      });
      removeClass(this.wtTable.wtRootElement.parentNode, allClassNames);
      addClass(this.wtTable.wtRootElement.parentNode, newClassNames);
    }
    /**
     * Get/Set Walkontable instance setting
     *
     * @param {String} key
     * @param {*} [param1]
     * @param {*} [param2]
     * @param {*} [param3]
     * @param {*} [param4]
     * @returns {*}
     */
  }, {
    key: "getSetting",
    value: function getSetting(key, param1, param2, param3, param4) {
      return this.wtSettings.getSetting(key, param1, param2, param3, param4);
    }
    /**
     * Checks if setting exists
     *
     * @param {String} key
     * @returns {Boolean}
     */
  }, {
    key: "hasSetting",
    value: function hasSetting(key) {
      return this.wtSettings.has(key);
    }
    /**
     * Destroy instance
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.wtOverlays.destroy();
      this.wtEvent.destroy();
    }
  }]);
  return Walkontable2;
}();
var core_default = Walkontable;

// node_modules/handsontable/es/3rdparty/walkontable/src/overlay/_base.js
function _classCallCheck17(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties17(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass17(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties17(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties17(Constructor, staticProps);
  return Constructor;
}
var registeredOverlays = {};
var Overlay = function() {
  _createClass17(Overlay2, null, [{
    key: "registerOverlay",
    /**
     * Register overlay class.
     *
     * @param {String} type Overlay type, one of the CLONE_TYPES value
     * @param {Overlay} overlayClass Overlay class extended from base overlay class {@link Overlay}
     */
    value: function registerOverlay(type, overlayClass) {
      if (Overlay2.CLONE_TYPES.indexOf(type) === -1) {
        throw new Error("Unsupported overlay (".concat(type, ")."));
      }
      registeredOverlays[type] = overlayClass;
    }
    /**
     * Create new instance of overlay type.
     *
     * @param {String} type Overlay type, one of the CLONE_TYPES value
     * @param {Walkontable} wot Walkontable instance
     */
  }, {
    key: "createOverlay",
    value: function createOverlay(type, wot) {
      return new registeredOverlays[type](wot);
    }
    /**
     * Check if specified overlay was registered.
     *
     * @param {String} type Overlay type, one of the CLONE_TYPES value
     * @returns {Boolean}
     */
  }, {
    key: "hasOverlay",
    value: function hasOverlay(type) {
      return registeredOverlays[type] !== void 0;
    }
    /**
     * Checks if overlay object (`overlay`) is instance of overlay type (`type`).
     *
     * @param {Overlay} overlay Overlay object
     * @param {String} type Overlay type, one of the CLONE_TYPES value
     * @returns {Boolean}
     */
  }, {
    key: "isOverlayTypeOf",
    value: function isOverlayTypeOf(overlay, type) {
      if (!overlay || !registeredOverlays[type]) {
        return false;
      }
      return overlay instanceof registeredOverlays[type];
    }
    /**
     * @param {Walkontable} wotInstance
     */
  }, {
    key: "CLONE_TOP",
    /**
     * @type {String}
     */
    get: function get5() {
      return "top";
    }
    /**
     * @type {String}
     */
  }, {
    key: "CLONE_BOTTOM",
    get: function get5() {
      return "bottom";
    }
    /**
     * @type {String}
     */
  }, {
    key: "CLONE_LEFT",
    get: function get5() {
      return "left";
    }
    /**
     * @type {String}
     */
  }, {
    key: "CLONE_TOP_LEFT_CORNER",
    get: function get5() {
      return "top_left_corner";
    }
    /**
     * @type {String}
     */
  }, {
    key: "CLONE_BOTTOM_LEFT_CORNER",
    get: function get5() {
      return "bottom_left_corner";
    }
    /**
     * @type {String}
     */
  }, {
    key: "CLONE_DEBUG",
    get: function get5() {
      return "debug";
    }
    /**
     * List of all availables clone types
     *
     * @type {Array}
     */
  }, {
    key: "CLONE_TYPES",
    get: function get5() {
      return [Overlay2.CLONE_TOP, Overlay2.CLONE_BOTTOM, Overlay2.CLONE_LEFT, Overlay2.CLONE_TOP_LEFT_CORNER, Overlay2.CLONE_BOTTOM_LEFT_CORNER, Overlay2.CLONE_DEBUG];
    }
  }]);
  function Overlay2(wotInstance) {
    _classCallCheck17(this, Overlay2);
    defineGetter(this, "wot", wotInstance, {
      writable: false
    });
    this.instance = this.wot;
    this.type = "";
    this.mainTableScrollableElement = null;
    this.TABLE = this.wot.wtTable.TABLE;
    this.hider = this.wot.wtTable.hider;
    this.spreader = this.wot.wtTable.spreader;
    this.holder = this.wot.wtTable.holder;
    this.wtRootElement = this.wot.wtTable.wtRootElement;
    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
    this.areElementSizesAdjusted = false;
    this.updateStateOfRendering();
  }
  _createClass17(Overlay2, [{
    key: "updateStateOfRendering",
    value: function updateStateOfRendering() {
      var previousState = this.needFullRender;
      this.needFullRender = this.shouldBeRendered();
      var changed = previousState !== this.needFullRender;
      if (changed && !this.needFullRender) {
        this.reset();
      }
      return changed;
    }
    /**
     * Checks if overlay should be fully rendered
     *
     * @returns {Boolean}
     */
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return true;
    }
    /**
     * Update the trimming container.
     */
  }, {
    key: "updateTrimmingContainer",
    value: function updateTrimmingContainer() {
      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
    }
    /**
     * Update the main scrollable element.
     */
  }, {
    key: "updateMainScrollableElement",
    value: function updateMainScrollableElement() {
      this.mainTableScrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
    }
    /**
     * Make a clone of table for overlay
     *
     * @param {String} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,
     *                           `Overlay.CLONE_TOP_LEFT_CORNER`, `Overlay.CLONE_DEBUG`
     * @returns {Walkontable}
     */
  }, {
    key: "makeClone",
    value: function makeClone(direction) {
      if (Overlay2.CLONE_TYPES.indexOf(direction) === -1) {
        throw new Error('Clone type "'.concat(direction, '" is not supported.'));
      }
      var clone5 = document.createElement("DIV");
      var clonedTable = document.createElement("TABLE");
      clone5.className = "ht_clone_".concat(direction, " handsontable");
      clone5.style.position = "absolute";
      clone5.style.top = 0;
      clone5.style.left = 0;
      clone5.style.overflow = "hidden";
      clonedTable.className = this.wot.wtTable.TABLE.className;
      clone5.appendChild(clonedTable);
      this.type = direction;
      this.wot.wtTable.wtRootElement.parentNode.appendChild(clone5);
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (preventOverflow === true || preventOverflow === "horizontal" && this.type === Overlay2.CLONE_TOP || preventOverflow === "vertical" && this.type === Overlay2.CLONE_LEFT) {
        this.mainTableScrollableElement = window;
      } else {
        this.mainTableScrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
      }
      return new core_default({
        cloneSource: this.wot,
        cloneOverlay: this,
        table: clonedTable
      });
    }
    /**
     * Refresh/Redraw overlay
     *
     * @param {Boolean} [fastDraw=false]
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var nextCycleRenderFlag = this.shouldBeRendered();
      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {
        this.clone.draw(fastDraw);
      }
      this.needFullRender = nextCycleRenderFlag;
    }
    /**
     * Reset overlay styles to initial values.
     */
  }, {
    key: "reset",
    value: function reset() {
      if (!this.clone) {
        return;
      }
      var holder2 = this.clone.wtTable.holder;
      var hider = this.clone.wtTable.hider;
      var holderStyle = holder2.style;
      var hidderStyle = hider.style;
      var rootStyle = holder2.parentNode.style;
      arrayEach([holderStyle, hidderStyle, rootStyle], function(style) {
        style.width = "";
        style.height = "";
      });
    }
    /**
     * Destroy overlay instance
     */
  }, {
    key: "destroy",
    value: function destroy() {
      new eventManager_default(this.clone).destroy();
    }
  }]);
  return Overlay2;
}();
var base_default = Overlay;

// node_modules/handsontable/es/3rdparty/walkontable/src/overlay/debug.js
function _typeof6(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof6 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof6 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof6(obj);
}
function _classCallCheck18(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof6(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
var DebugOverlay = function(_Overlay) {
  _inherits(DebugOverlay2, _Overlay);
  function DebugOverlay2(wotInstance) {
    var _this;
    _classCallCheck18(this, DebugOverlay2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(DebugOverlay2).call(this, wotInstance));
    _this.clone = _this.makeClone(base_default.CLONE_DEBUG);
    _this.clone.wtTable.holder.style.opacity = 0.4;
    _this.clone.wtTable.holder.style.textShadow = "0 0 2px #ff0000";
    addClass(_this.clone.wtTable.holder.parentNode, "wtDebugVisible");
    return _this;
  }
  return DebugOverlay2;
}(base_default);
base_default.registerOverlay(base_default.CLONE_DEBUG, DebugOverlay);

// node_modules/handsontable/es/3rdparty/walkontable/src/overlay/left.js
function _typeof7(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof7 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof7 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof7(obj);
}
function _classCallCheck19(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties18(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass18(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties18(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties18(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn2(self2, call) {
  if (call && (_typeof7(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized2(self2);
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf2(o) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf2(o);
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
var LeftOverlay = function(_Overlay) {
  _inherits2(LeftOverlay2, _Overlay);
  function LeftOverlay2(wotInstance) {
    var _this;
    _classCallCheck19(this, LeftOverlay2);
    _this = _possibleConstructorReturn2(this, _getPrototypeOf2(LeftOverlay2).call(this, wotInstance));
    _this.clone = _this.makeClone(base_default.CLONE_LEFT);
    return _this;
  }
  _createClass18(LeftOverlay2, [{
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return !!(this.wot.getSetting("fixedColumnsLeft") || this.wot.getSetting("rowHeaders").length);
    }
    /**
     * Updates the left overlay position.
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var headerPosition = 0;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer === window && (!preventOverflow || preventOverflow !== "horizontal")) {
        var box = this.wot.wtTable.hider.getBoundingClientRect();
        var left2 = Math.ceil(box.left);
        var right2 = Math.ceil(box.right);
        var finalLeft;
        var finalTop;
        finalTop = this.wot.wtTable.hider.style.top;
        finalTop = finalTop === "" ? 0 : finalTop;
        if (left2 < 0 && right2 - overlayRoot.offsetWidth > 0) {
          finalLeft = -left2;
        } else {
          finalLeft = 0;
        }
        headerPosition = finalLeft;
        finalLeft += "px";
        setOverlayPosition(overlayRoot, finalLeft, finalTop);
      } else {
        headerPosition = this.getScrollPosition();
        resetCssTransform(overlayRoot);
      }
      this.adjustHeaderBordersPosition(headerPosition);
      this.adjustElementsSize();
    }
    /**
     * Sets the main overlay's horizontal scroll position.
     *
     * @param {Number} pos
     * @returns {Boolean}
     */
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(pos) {
      var result = false;
      if (this.mainTableScrollableElement === window && window.scrollX !== pos) {
        window.scrollTo(pos, getWindowScrollTop());
        result = true;
      } else if (this.mainTableScrollableElement.scrollLeft !== pos) {
        this.mainTableScrollableElement.scrollLeft = pos;
        result = true;
      }
      return result;
    }
    /**
     * Triggers onScroll hook callback.
     */
  }, {
    key: "onScroll",
    value: function onScroll() {
      this.wot.getSetting("onScrollVertically");
    }
    /**
     * Calculates total sum cells width.
     *
     * @param {Number} from Column index which calculates started from.
     * @param {Number} to Column index where calculation is finished.
     * @returns {Number} Width sum.
     */
  }, {
    key: "sumCellSizes",
    value: function sumCellSizes(from3, to3) {
      var defaultColumnWidth = this.wot.wtSettings.defaultColumnWidth;
      var column = from3;
      var sum = 0;
      while (column < to3) {
        sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;
        column += 1;
      }
      return sum;
    }
    /**
     * Adjust overlay root element, childs and master table element sizes (width, height).
     *
     * @param {Boolean} [force=false]
     */
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.updateTrimmingContainer();
      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildrenSize();
        if (!force) {
          this.areElementSizesAdjusted = true;
        }
      }
    }
    /**
     * Adjust overlay root element size (width and height).
     */
  }, {
    key: "adjustRootElementSize",
    value: function adjustRootElementSize() {
      var masterHolder = this.wot.wtTable.holder;
      var scrollbarHeight = masterHolder.clientHeight === masterHolder.offsetHeight ? 0 : getScrollbarWidth();
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer !== window || preventOverflow === "vertical") {
        var height = this.wot.wtViewport.getWorkspaceHeight() - scrollbarHeight;
        height = Math.min(height, innerHeight(this.wot.wtTable.wtRootElement));
        overlayRootStyle.height = "".concat(height, "px");
      } else {
        overlayRootStyle.height = "";
      }
      this.clone.wtTable.holder.style.height = overlayRootStyle.height;
      var tableWidth = outerWidth(this.clone.wtTable.TABLE);
      overlayRootStyle.width = "".concat(tableWidth === 0 ? tableWidth : tableWidth + 4, "px");
    }
    /**
     * Adjust overlay root childs size.
     */
  }, {
    key: "adjustRootChildrenSize",
    value: function adjustRootChildrenSize() {
      var scrollbarWidth = getScrollbarWidth();
      this.clone.wtTable.hider.style.height = this.hider.style.height;
      this.clone.wtTable.holder.style.height = this.clone.wtTable.holder.parentNode.style.height;
      if (scrollbarWidth === 0) {
        scrollbarWidth = 30;
      }
      this.clone.wtTable.holder.style.width = "".concat(parseInt(this.clone.wtTable.holder.parentNode.style.width, 10) + scrollbarWidth, "px");
    }
    /**
     * Adjust the overlay dimensions and position.
     */
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var total = this.wot.getSetting("totalColumns");
      if (!this.areElementSizesAdjusted) {
        this.adjustElementsSize();
      }
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
        this.spreader.style.left = "".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, "px");
      } else if (total === 0) {
        this.spreader.style.left = "0";
      } else {
        throw new Error("Incorrect value of the columnsRenderCalculator");
      }
      this.spreader.style.right = "";
      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }
    /**
     * Synchronize calculated top position to an element.
     */
  }, {
    key: "syncOverlayOffset",
    value: function syncOverlayOffset() {
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
        this.clone.wtTable.spreader.style.top = "".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, "px");
      } else {
        this.clone.wtTable.spreader.style.top = "";
      }
    }
    /**
     * Scrolls horizontally to a column at the left edge of the viewport.
     *
     * @param {Number} sourceCol  Column index which you want to scroll to.
     * @param {Boolean} [beyondRendered]  if `true`, scrolls according to the bottom edge (top edge is by default).
     * @returns {Boolean}
     */
  }, {
    key: "scrollTo",
    value: function scrollTo(sourceCol, beyondRendered) {
      var newX = this.getTableParentOffset();
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var scrollbarCompensation = 0;
      if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {
        scrollbarCompensation = getScrollbarWidth();
      }
      if (beyondRendered) {
        newX += this.sumCellSizes(0, sourceCol + 1);
        newX -= this.wot.wtViewport.getViewportWidth();
      } else {
        newX += this.sumCellSizes(this.wot.getSetting("fixedColumnsLeft"), sourceCol);
      }
      newX += scrollbarCompensation;
      return this.setScrollPosition(newX);
    }
    /**
     * Gets table parent left position.
     *
     * @returns {Number}
     */
  }, {
    key: "getTableParentOffset",
    value: function getTableParentOffset() {
      var preventOverflow = this.wot.getSetting("preventOverflow");
      var offset4 = 0;
      if (!preventOverflow && this.trimmingContainer === window) {
        offset4 = this.wot.wtTable.holderOffset.left;
      }
      return offset4;
    }
    /**
     * Gets the main overlay's horizontal scroll position.
     *
     * @returns {Number} Main table's vertical scroll position.
     */
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return getScrollLeft(this.mainTableScrollableElement);
    }
    /**
     * Adds css classes to hide the header border's header (cell-selection border hiding issue).
     *
     * @param {Number} position Header X position if trimming container is window or scroll top if not.
     */
  }, {
    key: "adjustHeaderBordersPosition",
    value: function adjustHeaderBordersPosition(position) {
      var masterParent = this.wot.wtTable.holder.parentNode;
      var rowHeaders = this.wot.getSetting("rowHeaders");
      var fixedColumnsLeft = this.wot.getSetting("fixedColumnsLeft");
      var totalRows = this.wot.getSetting("totalRows");
      if (totalRows) {
        removeClass(masterParent, "emptyRows");
      } else {
        addClass(masterParent, "emptyRows");
      }
      if (fixedColumnsLeft && !rowHeaders.length) {
        addClass(masterParent, "innerBorderLeft");
      } else if (!fixedColumnsLeft && rowHeaders.length) {
        var previousState = hasClass(masterParent, "innerBorderLeft");
        if (position) {
          addClass(masterParent, "innerBorderLeft");
        } else {
          removeClass(masterParent, "innerBorderLeft");
        }
        if (!previousState && position || previousState && !position) {
          this.wot.wtOverlays.adjustElementsSize();
        }
      }
    }
  }]);
  return LeftOverlay2;
}(base_default);
base_default.registerOverlay(base_default.CLONE_LEFT, LeftOverlay);

// node_modules/handsontable/es/3rdparty/walkontable/src/overlay/top.js
function _typeof8(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof8 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof8 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof8(obj);
}
function _classCallCheck20(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties19(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass19(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties19(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties19(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn3(self2, call) {
  if (call && (_typeof8(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized3(self2);
}
function _assertThisInitialized3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf3(o) {
  _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf3(o);
}
function _inherits3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf3(subClass, superClass);
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
var TopOverlay = function(_Overlay) {
  _inherits3(TopOverlay2, _Overlay);
  function TopOverlay2(wotInstance) {
    var _this;
    _classCallCheck20(this, TopOverlay2);
    _this = _possibleConstructorReturn3(this, _getPrototypeOf3(TopOverlay2).call(this, wotInstance));
    _this.clone = _this.makeClone(base_default.CLONE_TOP);
    return _this;
  }
  _createClass19(TopOverlay2, [{
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return !!(this.wot.getSetting("fixedRowsTop") || this.wot.getSetting("columnHeaders").length);
    }
    /**
     * Updates the top overlay position.
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var headerPosition = 0;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer === window && (!preventOverflow || preventOverflow !== "vertical")) {
        var box = this.wot.wtTable.hider.getBoundingClientRect();
        var top2 = Math.ceil(box.top);
        var bottom2 = Math.ceil(box.bottom);
        var finalLeft;
        var finalTop;
        finalLeft = this.wot.wtTable.hider.style.left;
        finalLeft = finalLeft === "" ? 0 : finalLeft;
        if (top2 < 0 && bottom2 - overlayRoot.offsetHeight > 0) {
          finalTop = -top2;
        } else {
          finalTop = 0;
        }
        headerPosition = finalTop;
        finalTop += "px";
        setOverlayPosition(overlayRoot, finalLeft, finalTop);
      } else {
        headerPosition = this.getScrollPosition();
        resetCssTransform(overlayRoot);
      }
      this.adjustHeaderBordersPosition(headerPosition);
      this.adjustElementsSize();
    }
    /**
     * Sets the main overlay's vertical scroll position.
     *
     * @param {Number} pos
     * @returns {Boolean}
     */
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(pos) {
      var result = false;
      if (this.mainTableScrollableElement === window && window.scrollY !== pos) {
        window.scrollTo(getWindowScrollLeft(), pos);
        result = true;
      } else if (this.mainTableScrollableElement.scrollTop !== pos) {
        this.mainTableScrollableElement.scrollTop = pos;
        result = true;
      }
      return result;
    }
    /**
     * Triggers onScroll hook callback.
     */
  }, {
    key: "onScroll",
    value: function onScroll() {
      this.wot.getSetting("onScrollHorizontally");
    }
    /**
     * Calculates total sum cells height.
     *
     * @param {Number} from Row index which calculates started from.
     * @param {Number} to Row index where calculation is finished.
     * @returns {Number} Height sum.
     */
  }, {
    key: "sumCellSizes",
    value: function sumCellSizes(from3, to3) {
      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
      var row = from3;
      var sum = 0;
      while (row < to3) {
        var height = this.wot.wtTable.getRowHeight(row);
        sum += height === void 0 ? defaultRowHeight : height;
        row += 1;
      }
      return sum;
    }
    /**
     * Adjust overlay root element, childs and master table element sizes (width, height).
     *
     * @param {Boolean} [force=false]
     */
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.updateTrimmingContainer();
      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildrenSize();
        if (!force) {
          this.areElementSizesAdjusted = true;
        }
      }
    }
    /**
     * Adjust overlay root element size (width and height).
     */
  }, {
    key: "adjustRootElementSize",
    value: function adjustRootElementSize() {
      var masterHolder = this.wot.wtTable.holder;
      var scrollbarWidth = masterHolder.clientWidth === masterHolder.offsetWidth ? 0 : getScrollbarWidth();
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer !== window || preventOverflow === "horizontal") {
        var width = this.wot.wtViewport.getWorkspaceWidth() - scrollbarWidth;
        width = Math.min(width, innerWidth(this.wot.wtTable.wtRootElement));
        overlayRootStyle.width = "".concat(width, "px");
      } else {
        overlayRootStyle.width = "";
      }
      this.clone.wtTable.holder.style.width = overlayRootStyle.width;
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      overlayRootStyle.height = "".concat(tableHeight === 0 ? tableHeight : tableHeight + 4, "px");
    }
    /**
     * Adjust overlay root childs size.
     */
  }, {
    key: "adjustRootChildrenSize",
    value: function adjustRootChildrenSize() {
      var scrollbarWidth = getScrollbarWidth();
      this.clone.wtTable.hider.style.width = this.hider.style.width;
      this.clone.wtTable.holder.style.width = this.clone.wtTable.holder.parentNode.style.width;
      if (scrollbarWidth === 0) {
        scrollbarWidth = 30;
      }
      this.clone.wtTable.holder.style.height = "".concat(parseInt(this.clone.wtTable.holder.parentNode.style.height, 10) + scrollbarWidth, "px");
    }
    /**
     * Adjust the overlay dimensions and position.
     */
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var total = this.wot.getSetting("totalRows");
      if (!this.areElementSizesAdjusted) {
        this.adjustElementsSize();
      }
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
        this.spreader.style.top = "".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, "px");
      } else if (total === 0) {
        this.spreader.style.top = "0";
      } else {
        throw new Error("Incorrect value of the rowsRenderCalculator");
      }
      this.spreader.style.bottom = "";
      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }
    /**
     * Synchronize calculated left position to an element.
     */
  }, {
    key: "syncOverlayOffset",
    value: function syncOverlayOffset() {
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
        this.clone.wtTable.spreader.style.left = "".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, "px");
      } else {
        this.clone.wtTable.spreader.style.left = "";
      }
    }
    /**
     * Scrolls vertically to a row.
     *
     * @param {Number} sourceRow Row index which you want to scroll to.
     * @param {Boolean} [bottomEdge] if `true`, scrolls according to the bottom edge (top edge is by default).
     * @returns {Boolean}
     */
  }, {
    key: "scrollTo",
    value: function scrollTo(sourceRow, bottomEdge) {
      var newY = this.getTableParentOffset();
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var scrollbarCompensation = 0;
      if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
        scrollbarCompensation = getScrollbarWidth();
      }
      if (bottomEdge) {
        var fixedRowsBottom = this.wot.getSetting("fixedRowsBottom");
        var totalRows = this.wot.getSetting("totalRows");
        newY += this.sumCellSizes(0, sourceRow + 1);
        newY -= this.wot.wtViewport.getViewportHeight() - this.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
        newY += 1;
      } else {
        newY += this.sumCellSizes(this.wot.getSetting("fixedRowsTop"), sourceRow);
      }
      newY += scrollbarCompensation;
      return this.setScrollPosition(newY);
    }
    /**
     * Gets table parent top position.
     *
     * @returns {Number}
     */
  }, {
    key: "getTableParentOffset",
    value: function getTableParentOffset() {
      if (this.mainTableScrollableElement === window) {
        return this.wot.wtTable.holderOffset.top;
      }
      return 0;
    }
    /**
     * Gets the main overlay's vertical scroll position.
     *
     * @returns {Number} Main table's vertical scroll position.
     */
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return getScrollTop(this.mainTableScrollableElement);
    }
    /**
     * Redraw borders of selection.
     *
     * @param {WalkontableSelection} selection Selection for redraw.
     */
  }, {
    key: "redrawSelectionBorders",
    value: function redrawSelectionBorders(selection) {
      if (selection && selection.cellRange) {
        var border = selection.getBorder(this.wot);
        var corners = selection.getCorners();
        border.disappear();
        border.appear(corners);
      }
    }
    /**
     * Redrawing borders of all selections.
     */
  }, {
    key: "redrawAllSelectionsBorders",
    value: function redrawAllSelectionsBorders() {
      var _this2 = this;
      var selections = this.wot.selections;
      this.redrawSelectionBorders(selections.getCell());
      arrayEach(selections.getAreas(), function(area) {
        _this2.redrawSelectionBorders(area);
      });
      this.redrawSelectionBorders(selections.getFill());
      this.wot.wtTable.wot.wtOverlays.leftOverlay.refresh();
    }
    /**
     * Adds css classes to hide the header border's header (cell-selection border hiding issue).
     *
     * @param {Number} position Header Y position if trimming container is window or scroll top if not.
     */
  }, {
    key: "adjustHeaderBordersPosition",
    value: function adjustHeaderBordersPosition(position) {
      var masterParent = this.wot.wtTable.holder.parentNode;
      var totalColumns = this.wot.getSetting("totalColumns");
      if (totalColumns) {
        removeClass(masterParent, "emptyColumns");
      } else {
        addClass(masterParent, "emptyColumns");
      }
      if (this.wot.getSetting("fixedRowsTop") === 0 && this.wot.getSetting("columnHeaders").length > 0) {
        var previousState = hasClass(masterParent, "innerBorderTop");
        if (position || this.wot.getSetting("totalRows") === 0) {
          addClass(masterParent, "innerBorderTop");
        } else {
          removeClass(masterParent, "innerBorderTop");
        }
        if (!previousState && position || previousState && !position) {
          this.wot.wtOverlays.adjustElementsSize();
          this.redrawAllSelectionsBorders();
        }
      }
      if (this.wot.getSetting("rowHeaders").length === 0) {
        var secondHeaderCell = this.clone.wtTable.THEAD.querySelectorAll("th:nth-of-type(2)");
        if (secondHeaderCell) {
          for (var i = 0; i < secondHeaderCell.length; i++) {
            secondHeaderCell[i].style["border-left-width"] = 0;
          }
        }
      }
    }
  }]);
  return TopOverlay2;
}(base_default);
base_default.registerOverlay(base_default.CLONE_TOP, TopOverlay);

// node_modules/handsontable/es/3rdparty/walkontable/src/overlay/topLeftCorner.js
function _typeof9(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof9 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof9 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof9(obj);
}
function _classCallCheck21(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties20(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass20(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties20(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties20(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn4(self2, call) {
  if (call && (_typeof9(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized4(self2);
}
function _assertThisInitialized4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf4(o) {
  _getPrototypeOf4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf4(o);
}
function _inherits4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf4(subClass, superClass);
}
function _setPrototypeOf4(o, p) {
  _setPrototypeOf4 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf4(o, p);
}
var TopLeftCornerOverlay = function(_Overlay) {
  _inherits4(TopLeftCornerOverlay2, _Overlay);
  function TopLeftCornerOverlay2(wotInstance) {
    var _this;
    _classCallCheck21(this, TopLeftCornerOverlay2);
    _this = _possibleConstructorReturn4(this, _getPrototypeOf4(TopLeftCornerOverlay2).call(this, wotInstance));
    _this.clone = _this.makeClone(base_default.CLONE_TOP_LEFT_CORNER);
    return _this;
  }
  _createClass20(TopLeftCornerOverlay2, [{
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return !!((this.wot.getSetting("fixedRowsTop") || this.wot.getSetting("columnHeaders").length) && (this.wot.getSetting("fixedColumnsLeft") || this.wot.getSetting("rowHeaders").length));
    }
    /**
     * Updates the corner overlay position
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      this.updateTrimmingContainer();
      if (!this.wot.wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      var tableWidth = outerWidth(this.clone.wtTable.TABLE);
      var preventOverflow = this.wot.getSetting("preventOverflow");
      if (this.trimmingContainer === window) {
        var box = this.wot.wtTable.hider.getBoundingClientRect();
        var top2 = Math.ceil(box.top);
        var left2 = Math.ceil(box.left);
        var bottom2 = Math.ceil(box.bottom);
        var right2 = Math.ceil(box.right);
        var finalLeft = "0";
        var finalTop = "0";
        if (!preventOverflow || preventOverflow === "vertical") {
          if (left2 < 0 && right2 - overlayRoot.offsetWidth > 0) {
            finalLeft = "".concat(-left2, "px");
          }
        }
        if (!preventOverflow || preventOverflow === "horizontal") {
          if (top2 < 0 && bottom2 - overlayRoot.offsetHeight > 0) {
            finalTop = "".concat(-top2, "px");
          }
        }
        setOverlayPosition(overlayRoot, finalLeft, finalTop);
      } else {
        resetCssTransform(overlayRoot);
      }
      overlayRoot.style.height = "".concat(tableHeight === 0 ? tableHeight : tableHeight + 4, "px");
      overlayRoot.style.width = "".concat(tableWidth === 0 ? tableWidth : tableWidth + 4, "px");
    }
  }]);
  return TopLeftCornerOverlay2;
}(base_default);
base_default.registerOverlay(base_default.CLONE_TOP_LEFT_CORNER, TopLeftCornerOverlay);

// node_modules/handsontable/es/3rdparty/walkontable/src/overlay/bottom.js
function _typeof10(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof10 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof10 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof10(obj);
}
function _classCallCheck22(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties21(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass21(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties21(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties21(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn5(self2, call) {
  if (call && (_typeof10(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized5(self2);
}
function _assertThisInitialized5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf5(o) {
  _getPrototypeOf5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf5(o);
}
function _inherits5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf5(subClass, superClass);
}
function _setPrototypeOf5(o, p) {
  _setPrototypeOf5 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf5(o, p);
}
var BottomOverlay = function(_Overlay) {
  _inherits5(BottomOverlay2, _Overlay);
  function BottomOverlay2(wotInstance) {
    var _this;
    _classCallCheck22(this, BottomOverlay2);
    _this = _possibleConstructorReturn5(this, _getPrototypeOf5(BottomOverlay2).call(this, wotInstance));
    _this.clone = _this.makeClone(base_default.CLONE_BOTTOM);
    return _this;
  }
  _createClass21(BottomOverlay2, [{
    key: "repositionOverlay",
    value: function repositionOverlay() {
      var scrollbarWidth = getScrollbarWidth();
      var cloneRoot = this.clone.wtTable.holder.parentNode;
      if (this.wot.wtTable.holder.clientHeight === this.wot.wtTable.holder.offsetHeight) {
        scrollbarWidth = 0;
      }
      cloneRoot.style.top = "";
      cloneRoot.style.bottom = "".concat(scrollbarWidth, "px");
    }
    /**
     * Checks if overlay should be fully rendered
     *
     * @returns {Boolean}
     */
  }, {
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wot.getSetting("fixedRowsBottom") ? true : false;
    }
    /**
     * Updates the top overlay position
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var headerPosition = 0;
      overlayRoot.style.top = "";
      if (this.wot.wtOverlays.leftOverlay.trimmingContainer === window) {
        var box = this.wot.wtTable.hider.getBoundingClientRect();
        var bottom2 = Math.ceil(box.bottom);
        var finalLeft;
        var finalBottom;
        var bodyHeight = document.body.offsetHeight;
        finalLeft = this.wot.wtTable.hider.style.left;
        finalLeft = finalLeft === "" ? 0 : finalLeft;
        if (bottom2 > bodyHeight) {
          finalBottom = bottom2 - bodyHeight;
        } else {
          finalBottom = 0;
        }
        headerPosition = finalBottom;
        finalBottom += "px";
        overlayRoot.style.top = "";
        overlayRoot.style.left = finalLeft;
        overlayRoot.style.bottom = finalBottom;
      } else {
        headerPosition = this.getScrollPosition();
        resetCssTransform(overlayRoot);
        this.repositionOverlay();
      }
      this.adjustHeaderBordersPosition(headerPosition);
    }
    /**
     * Sets the main overlay's vertical scroll position
     *
     * @param {Number} pos
     */
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(pos) {
      if (this.mainTableScrollableElement === window) {
        window.scrollTo(getWindowScrollLeft(), pos);
      } else {
        this.mainTableScrollableElement.scrollTop = pos;
      }
    }
    /**
     * Triggers onScroll hook callback
     */
  }, {
    key: "onScroll",
    value: function onScroll() {
      this.wot.getSetting("onScrollVertically");
    }
    /**
     * Calculates total sum cells height
     *
     * @param {Number} from Row index which calculates started from
     * @param {Number} to Row index where calculation is finished
     * @returns {Number} Height sum
     */
  }, {
    key: "sumCellSizes",
    value: function sumCellSizes(from3, to3) {
      var row = from3;
      var sum = 0;
      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
      while (row < to3) {
        var height = this.wot.wtTable.getRowHeight(row);
        sum += height === void 0 ? defaultRowHeight : height;
        row += 1;
      }
      return sum;
    }
    /**
     * Adjust overlay root element, childs and master table element sizes (width, height).
     *
     * @param {Boolean} [force=false]
     */
  }, {
    key: "adjustElementsSize",
    value: function adjustElementsSize() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.updateTrimmingContainer();
      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildrenSize();
        if (!force) {
          this.areElementSizesAdjusted = true;
        }
      }
    }
    /**
     * Adjust overlay root element size (width and height).
     */
  }, {
    key: "adjustRootElementSize",
    value: function adjustRootElementSize() {
      var masterHolder = this.wot.wtTable.holder;
      var scrollbarWidth = masterHolder.clientWidth === masterHolder.offsetWidth ? 0 : getScrollbarWidth();
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      if (this.trimmingContainer === window) {
        overlayRootStyle.width = "";
      } else {
        overlayRootStyle.width = "".concat(this.wot.wtViewport.getWorkspaceWidth() - scrollbarWidth, "px");
      }
      this.clone.wtTable.holder.style.width = overlayRootStyle.width;
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      overlayRootStyle.height = "".concat(tableHeight === 0 ? tableHeight : tableHeight, "px");
    }
    /**
     * Adjust overlay root childs size
     */
  }, {
    key: "adjustRootChildrenSize",
    value: function adjustRootChildrenSize() {
      var scrollbarWidth = getScrollbarWidth();
      this.clone.wtTable.hider.style.width = this.hider.style.width;
      this.clone.wtTable.holder.style.width = this.clone.wtTable.holder.parentNode.style.width;
      if (scrollbarWidth === 0) {
        scrollbarWidth = 30;
      }
      this.clone.wtTable.holder.style.height = "".concat(parseInt(this.clone.wtTable.holder.parentNode.style.height, 10) + scrollbarWidth, "px");
    }
    /**
     * Adjust the overlay dimensions and position
     */
  }, {
    key: "applyToDOM",
    value: function applyToDOM() {
      var total = this.wot.getSetting("totalRows");
      if (!this.areElementSizesAdjusted) {
        this.adjustElementsSize();
      }
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
        this.spreader.style.top = "".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, "px");
      } else if (total === 0) {
        this.spreader.style.top = "0";
      } else {
        throw new Error("Incorrect value of the rowsRenderCalculator");
      }
      this.spreader.style.bottom = "";
      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }
    /**
     * Synchronize calculated left position to an element
     */
  }, {
    key: "syncOverlayOffset",
    value: function syncOverlayOffset() {
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
        this.clone.wtTable.spreader.style.left = "".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, "px");
      } else {
        this.clone.wtTable.spreader.style.left = "";
      }
    }
    /**
     * Scrolls vertically to a row
     *
     * @param sourceRow {Number} Row index which you want to scroll to
     * @param [bottomEdge=false] {Boolean} if `true`, scrolls according to the bottom edge (top edge is by default)
     */
  }, {
    key: "scrollTo",
    value: function scrollTo(sourceRow, bottomEdge) {
      var newY = this.getTableParentOffset();
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var scrollbarCompensation = 0;
      if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
        scrollbarCompensation = getScrollbarWidth();
      }
      if (bottomEdge) {
        newY += this.sumCellSizes(0, sourceRow + 1);
        newY -= this.wot.wtViewport.getViewportHeight();
        newY += 1;
      } else {
        newY += this.sumCellSizes(this.wot.getSetting("fixedRowsBottom"), sourceRow);
      }
      newY += scrollbarCompensation;
      this.setScrollPosition(newY);
    }
    /**
     * Gets table parent top position
     *
     * @returns {Number}
     */
  }, {
    key: "getTableParentOffset",
    value: function getTableParentOffset() {
      if (this.mainTableScrollableElement === window) {
        return this.wot.wtTable.holderOffset.top;
      }
      return 0;
    }
    /**
     * Gets the main overlay's vertical scroll position
     *
     * @returns {Number} Main table's vertical scroll position
     */
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return getScrollTop(this.mainTableScrollableElement);
    }
    /**
     * Adds css classes to hide the header border's header (cell-selection border hiding issue)
     *
     * @param {Number} position Header Y position if trimming container is window or scroll top if not
     */
  }, {
    key: "adjustHeaderBordersPosition",
    value: function adjustHeaderBordersPosition(position) {
      if (this.wot.getSetting("fixedRowsBottom") === 0 && this.wot.getSetting("columnHeaders").length > 0) {
        var masterParent = this.wot.wtTable.holder.parentNode;
        var previousState = hasClass(masterParent, "innerBorderTop");
        if (position) {
          addClass(masterParent, "innerBorderTop");
        } else {
          removeClass(masterParent, "innerBorderTop");
        }
        if (!previousState && position || previousState && !position) {
          this.wot.wtOverlays.adjustElementsSize();
        }
      }
      if (this.wot.getSetting("rowHeaders").length === 0) {
        var secondHeaderCell = this.clone.wtTable.THEAD.querySelector("th:nth-of-type(2)");
        if (secondHeaderCell) {
          secondHeaderCell.style["border-left-width"] = 0;
        }
      }
    }
  }]);
  return BottomOverlay2;
}(base_default);
base_default.registerOverlay(base_default.CLONE_BOTTOM, BottomOverlay);

// node_modules/handsontable/es/3rdparty/walkontable/src/overlay/bottomLeftCorner.js
function _typeof11(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof11 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof11 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof11(obj);
}
function _classCallCheck23(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties22(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass22(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties22(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties22(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn6(self2, call) {
  if (call && (_typeof11(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized6(self2);
}
function _assertThisInitialized6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf6(o) {
  _getPrototypeOf6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf6(o);
}
function _inherits6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf6(subClass, superClass);
}
function _setPrototypeOf6(o, p) {
  _setPrototypeOf6 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf6(o, p);
}
var BottomLeftCornerOverlay = function(_Overlay) {
  _inherits6(BottomLeftCornerOverlay2, _Overlay);
  function BottomLeftCornerOverlay2(wotInstance) {
    var _this;
    _classCallCheck23(this, BottomLeftCornerOverlay2);
    _this = _possibleConstructorReturn6(this, _getPrototypeOf6(BottomLeftCornerOverlay2).call(this, wotInstance));
    _this.clone = _this.makeClone(base_default.CLONE_BOTTOM_LEFT_CORNER);
    return _this;
  }
  _createClass22(BottomLeftCornerOverlay2, [{
    key: "shouldBeRendered",
    value: function shouldBeRendered() {
      return this.wot.getSetting("fixedRowsBottom") && (this.wot.getSetting("fixedColumnsLeft") || this.wot.getSetting("rowHeaders").length) ? true : false;
    }
    /**
     * Reposition the overlay.
     */
  }, {
    key: "repositionOverlay",
    value: function repositionOverlay() {
      var scrollbarWidth = getScrollbarWidth();
      var cloneRoot = this.clone.wtTable.holder.parentNode;
      if (this.wot.wtTable.holder.clientHeight === this.wot.wtTable.holder.offsetHeight) {
        scrollbarWidth = 0;
      }
      cloneRoot.style.top = "";
      cloneRoot.style.bottom = "".concat(scrollbarWidth, "px");
    }
    /**
     * Updates the corner overlay position
     */
  }, {
    key: "resetFixedPosition",
    value: function resetFixedPosition() {
      this.updateTrimmingContainer();
      if (!this.wot.wtTable.holder.parentNode) {
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var tableHeight = outerHeight(this.clone.wtTable.TABLE);
      var tableWidth = outerWidth(this.clone.wtTable.TABLE);
      overlayRoot.style.top = "";
      if (this.trimmingContainer === window) {
        var box = this.wot.wtTable.hider.getBoundingClientRect();
        var bottom2 = Math.ceil(box.bottom);
        var left2 = Math.ceil(box.left);
        var finalLeft;
        var finalBottom;
        var bodyHeight = document.body.offsetHeight;
        if (left2 < 0) {
          finalLeft = -left2;
        } else {
          finalLeft = 0;
        }
        if (bottom2 > bodyHeight) {
          finalBottom = bottom2 - bodyHeight;
        } else {
          finalBottom = 0;
        }
        finalBottom += "px";
        finalLeft += "px";
        overlayRoot.style.top = "";
        overlayRoot.style.left = finalLeft;
        overlayRoot.style.bottom = finalBottom;
      } else {
        resetCssTransform(overlayRoot);
        this.repositionOverlay();
      }
      overlayRoot.style.height = "".concat(tableHeight === 0 ? tableHeight : tableHeight, "px");
      overlayRoot.style.width = "".concat(tableWidth === 0 ? tableWidth : tableWidth, "px");
    }
  }]);
  return BottomLeftCornerOverlay2;
}(base_default);
base_default.registerOverlay(base_default.CLONE_BOTTOM_LEFT_CORNER, BottomLeftCornerOverlay);

// node_modules/handsontable/es/3rdparty/walkontable/src/border.js
function _slicedToArray2(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit2(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr)) return arr;
}
function _classCallCheck24(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties23(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass23(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties23(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties23(Constructor, staticProps);
  return Constructor;
}
var Border = function() {
  function Border2(wotInstance, settings) {
    _classCallCheck24(this, Border2);
    if (!settings) {
      return;
    }
    this.eventManager = new eventManager_default(wotInstance);
    this.instance = wotInstance;
    this.wot = wotInstance;
    this.settings = settings;
    this.mouseDown = false;
    this.main = null;
    this.top = null;
    this.left = null;
    this.bottom = null;
    this.right = null;
    this.topStyle = null;
    this.leftStyle = null;
    this.bottomStyle = null;
    this.rightStyle = null;
    this.cornerDefaultStyle = {
      width: "6px",
      height: "6px",
      borderWidth: "1px",
      borderStyle: "solid",
      borderColor: "#FFF"
    };
    this.corner = null;
    this.cornerStyle = null;
    this.createBorders(settings);
    this.registerListeners();
  }
  _createClass23(Border2, [{
    key: "registerListeners",
    value: function registerListeners() {
      var _this2 = this;
      this.eventManager.addEventListener(document.body, "mousedown", function() {
        return _this2.onMouseDown();
      });
      this.eventManager.addEventListener(document.body, "mouseup", function() {
        return _this2.onMouseUp();
      });
      var _loop = function _loop2(c2, len2) {
        _this2.eventManager.addEventListener(_this2.main.childNodes[c2], "mouseenter", function(event2) {
          return _this2.onMouseEnter(event2, _this2.main.childNodes[c2]);
        });
      };
      for (var c = 0, len = this.main.childNodes.length; c < len; c++) {
        _loop(c, len);
      }
    }
    /**
     * Mouse down listener
     *
     * @private
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown() {
      this.mouseDown = true;
    }
    /**
     * Mouse up listener
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      this.mouseDown = false;
    }
    /**
     * Mouse enter listener for fragment selection functionality.
     *
     * @private
     * @param {Event} event Dom event
     * @param {HTMLElement} parentElement Part of border element.
     */
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(event2, parentElement) {
      if (!this.mouseDown || !this.wot.getSetting("hideBorderOnMouseDownOver")) {
        return;
      }
      event2.preventDefault();
      stopImmediatePropagation(event2);
      var _this = this;
      var bounds = parentElement.getBoundingClientRect();
      parentElement.style.display = "none";
      function isOutside(mouseEvent) {
        if (mouseEvent.clientY < Math.floor(bounds.top)) {
          return true;
        }
        if (mouseEvent.clientY > Math.ceil(bounds.top + bounds.height)) {
          return true;
        }
        if (mouseEvent.clientX < Math.floor(bounds.left)) {
          return true;
        }
        if (mouseEvent.clientX > Math.ceil(bounds.left + bounds.width)) {
          return true;
        }
      }
      function handler(handlerEvent) {
        if (isOutside(handlerEvent)) {
          _this.eventManager.removeEventListener(document.body, "mousemove", handler);
          parentElement.style.display = "block";
        }
      }
      this.eventManager.addEventListener(document.body, "mousemove", handler);
    }
    /**
     * Create border elements
     *
     * @param {Object} settings
     */
  }, {
    key: "createBorders",
    value: function createBorders(settings) {
      this.main = document.createElement("div");
      var borderDivs = ["top", "left", "bottom", "right", "corner"];
      var style = this.main.style;
      style.position = "absolute";
      style.top = 0;
      style.left = 0;
      for (var i = 0; i < 5; i++) {
        var position = borderDivs[i];
        var div = document.createElement("div");
        div.className = "wtBorder ".concat(this.settings.className || "");
        if (this.settings[position] && this.settings[position].hide) {
          div.className += " hidden";
        }
        style = div.style;
        style.backgroundColor = this.settings[position] && this.settings[position].color ? this.settings[position].color : settings.border.color;
        style.height = this.settings[position] && this.settings[position].width ? "".concat(this.settings[position].width, "px") : "".concat(settings.border.width, "px");
        style.width = this.settings[position] && this.settings[position].width ? "".concat(this.settings[position].width, "px") : "".concat(settings.border.width, "px");
        this.main.appendChild(div);
      }
      this.top = this.main.childNodes[0];
      this.left = this.main.childNodes[1];
      this.bottom = this.main.childNodes[2];
      this.right = this.main.childNodes[3];
      this.topStyle = this.top.style;
      this.leftStyle = this.left.style;
      this.bottomStyle = this.bottom.style;
      this.rightStyle = this.right.style;
      this.corner = this.main.childNodes[4];
      this.corner.className += " corner";
      this.cornerStyle = this.corner.style;
      this.cornerStyle.width = this.cornerDefaultStyle.width;
      this.cornerStyle.height = this.cornerDefaultStyle.height;
      this.cornerStyle.border = [this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(" ");
      if (isMobileBrowser()) {
        this.createMultipleSelectorHandles();
      }
      this.disappear();
      var bordersHolder = this.wot.wtTable.bordersHolder;
      if (!bordersHolder) {
        bordersHolder = document.createElement("div");
        bordersHolder.className = "htBorders";
        this.wot.wtTable.bordersHolder = bordersHolder;
        this.wot.wtTable.spreader.appendChild(bordersHolder);
      }
      bordersHolder.appendChild(this.main);
    }
    /**
     * Create multiple selector handler for mobile devices
     */
  }, {
    key: "createMultipleSelectorHandles",
    value: function createMultipleSelectorHandles() {
      var _this3 = this;
      this.selectionHandles = {
        topLeft: document.createElement("DIV"),
        topLeftHitArea: document.createElement("DIV"),
        bottomRight: document.createElement("DIV"),
        bottomRightHitArea: document.createElement("DIV")
      };
      var width = 10;
      var hitAreaWidth = 40;
      this.selectionHandles.topLeft.className = "topLeftSelectionHandle";
      this.selectionHandles.topLeftHitArea.className = "topLeftSelectionHandle-HitArea";
      this.selectionHandles.bottomRight.className = "bottomRightSelectionHandle";
      this.selectionHandles.bottomRightHitArea.className = "bottomRightSelectionHandle-HitArea";
      this.selectionHandles.styles = {
        topLeft: this.selectionHandles.topLeft.style,
        topLeftHitArea: this.selectionHandles.topLeftHitArea.style,
        bottomRight: this.selectionHandles.bottomRight.style,
        bottomRightHitArea: this.selectionHandles.bottomRightHitArea.style
      };
      var hitAreaStyle = {
        position: "absolute",
        height: "".concat(hitAreaWidth, "px"),
        width: "".concat(hitAreaWidth, "px"),
        "border-radius": "".concat(parseInt(hitAreaWidth / 1.5, 10), "px")
      };
      objectEach(hitAreaStyle, function(value, key) {
        _this3.selectionHandles.styles.bottomRightHitArea[key] = value;
        _this3.selectionHandles.styles.topLeftHitArea[key] = value;
      });
      var handleStyle = {
        position: "absolute",
        height: "".concat(width, "px"),
        width: "".concat(width, "px"),
        "border-radius": "".concat(parseInt(width / 1.5, 10), "px"),
        background: "#F5F5FF",
        border: "1px solid #4285c8"
      };
      objectEach(handleStyle, function(value, key) {
        _this3.selectionHandles.styles.bottomRight[key] = value;
        _this3.selectionHandles.styles.topLeft[key] = value;
      });
      this.main.appendChild(this.selectionHandles.topLeft);
      this.main.appendChild(this.selectionHandles.bottomRight);
      this.main.appendChild(this.selectionHandles.topLeftHitArea);
      this.main.appendChild(this.selectionHandles.bottomRightHitArea);
    }
  }, {
    key: "isPartRange",
    value: function isPartRange(row, col) {
      var areaSelection = this.wot.selections.createOrGetArea();
      if (areaSelection.cellRange) {
        if (row !== areaSelection.cellRange.to.row || col !== areaSelection.cellRange.to.col) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "updateMultipleSelectionHandlesPosition",
    value: function updateMultipleSelectionHandlesPosition(row, col, top2, left2, width, height) {
      var handleWidth = parseInt(this.selectionHandles.styles.topLeft.width, 10);
      var hitAreaWidth = parseInt(this.selectionHandles.styles.topLeftHitArea.width, 10);
      this.selectionHandles.styles.topLeft.top = "".concat(parseInt(top2 - handleWidth, 10), "px");
      this.selectionHandles.styles.topLeft.left = "".concat(parseInt(left2 - handleWidth, 10), "px");
      this.selectionHandles.styles.topLeftHitArea.top = "".concat(parseInt(top2 - hitAreaWidth / 4 * 3, 10), "px");
      this.selectionHandles.styles.topLeftHitArea.left = "".concat(parseInt(left2 - hitAreaWidth / 4 * 3, 10), "px");
      this.selectionHandles.styles.bottomRight.top = "".concat(parseInt(top2 + height, 10), "px");
      this.selectionHandles.styles.bottomRight.left = "".concat(parseInt(left2 + width, 10), "px");
      this.selectionHandles.styles.bottomRightHitArea.top = "".concat(parseInt(top2 + height - hitAreaWidth / 4, 10), "px");
      this.selectionHandles.styles.bottomRightHitArea.left = "".concat(parseInt(left2 + width - hitAreaWidth / 4, 10), "px");
      if (this.settings.border.cornerVisible && this.settings.border.cornerVisible()) {
        this.selectionHandles.styles.topLeft.display = "block";
        this.selectionHandles.styles.topLeftHitArea.display = "block";
        if (this.isPartRange(row, col)) {
          this.selectionHandles.styles.bottomRight.display = "none";
          this.selectionHandles.styles.bottomRightHitArea.display = "none";
        } else {
          this.selectionHandles.styles.bottomRight.display = "block";
          this.selectionHandles.styles.bottomRightHitArea.display = "block";
        }
      } else {
        this.selectionHandles.styles.topLeft.display = "none";
        this.selectionHandles.styles.bottomRight.display = "none";
        this.selectionHandles.styles.topLeftHitArea.display = "none";
        this.selectionHandles.styles.bottomRightHitArea.display = "none";
      }
      if (row === this.wot.wtSettings.getSetting("fixedRowsTop") || col === this.wot.wtSettings.getSetting("fixedColumnsLeft")) {
        this.selectionHandles.styles.topLeft.zIndex = "9999";
        this.selectionHandles.styles.topLeftHitArea.zIndex = "9999";
      } else {
        this.selectionHandles.styles.topLeft.zIndex = "";
        this.selectionHandles.styles.topLeftHitArea.zIndex = "";
      }
    }
    /**
     * Show border around one or many cells
     *
     * @param {Array} corners
     */
  }, {
    key: "appear",
    value: function appear(corners) {
      if (this.disabled) {
        return;
      }
      var fromRow;
      var toRow;
      var fromColumn;
      var toColumn;
      var rowsCount = this.wot.wtTable.getRenderedRowsCount();
      for (var i = 0; i < rowsCount; i += 1) {
        var s = this.wot.wtTable.rowFilter.renderedToSource(i);
        if (s >= corners[0] && s <= corners[2]) {
          fromRow = s;
          break;
        }
      }
      for (var _i = rowsCount - 1; _i >= 0; _i -= 1) {
        var _s = this.wot.wtTable.rowFilter.renderedToSource(_i);
        if (_s >= corners[0] && _s <= corners[2]) {
          toRow = _s;
          break;
        }
      }
      var columnsCount = this.wot.wtTable.getRenderedColumnsCount();
      for (var _i2 = 0; _i2 < columnsCount; _i2 += 1) {
        var _s2 = this.wot.wtTable.columnFilter.renderedToSource(_i2);
        if (_s2 >= corners[1] && _s2 <= corners[3]) {
          fromColumn = _s2;
          break;
        }
      }
      for (var _i3 = columnsCount - 1; _i3 >= 0; _i3 -= 1) {
        var _s3 = this.wot.wtTable.columnFilter.renderedToSource(_i3);
        if (_s3 >= corners[1] && _s3 <= corners[3]) {
          toColumn = _s3;
          break;
        }
      }
      if (fromRow === void 0 || fromColumn === void 0) {
        this.disappear();
        return;
      }
      var fromTD = this.wot.wtTable.getCell(new coords_default(fromRow, fromColumn));
      var isMultiple = fromRow !== toRow || fromColumn !== toColumn;
      var toTD = isMultiple ? this.wot.wtTable.getCell(new coords_default(toRow, toColumn)) : fromTD;
      var fromOffset = offset(fromTD);
      var toOffset = isMultiple ? offset(toTD) : fromOffset;
      var containerOffset = offset(this.wot.wtTable.TABLE);
      var minTop = fromOffset.top;
      var minLeft = fromOffset.left;
      var left2 = minLeft - containerOffset.left - 1;
      var width = toOffset.left + outerWidth(toTD) - minLeft;
      if (this.isEntireColumnSelected(fromRow, toRow)) {
        var modifiedValues = this.getDimensionsFromHeader("columns", fromColumn, toColumn, containerOffset);
        var fromTH = null;
        if (modifiedValues) {
          var _modifiedValues = _slicedToArray2(modifiedValues, 3);
          fromTH = _modifiedValues[0];
          left2 = _modifiedValues[1];
          width = _modifiedValues[2];
        }
        if (fromTH) {
          fromTD = fromTH;
        }
      }
      var top2 = minTop - containerOffset.top - 1;
      var height = toOffset.top + outerHeight(toTD) - minTop;
      if (this.isEntireRowSelected(fromColumn, toColumn)) {
        var _modifiedValues2 = this.getDimensionsFromHeader("rows", fromRow, toRow, containerOffset);
        var _fromTH = null;
        if (_modifiedValues2) {
          var _modifiedValues3 = _slicedToArray2(_modifiedValues2, 3);
          _fromTH = _modifiedValues3[0];
          top2 = _modifiedValues3[1];
          height = _modifiedValues3[2];
        }
        if (_fromTH) {
          fromTD = _fromTH;
        }
      }
      var style = getComputedStyle2(fromTD);
      if (parseInt(style.borderTopWidth, 10) > 0) {
        top2 += 1;
        height = height > 0 ? height - 1 : 0;
      }
      if (parseInt(style.borderLeftWidth, 10) > 0) {
        left2 += 1;
        width = width > 0 ? width - 1 : 0;
      }
      this.topStyle.top = "".concat(top2, "px");
      this.topStyle.left = "".concat(left2, "px");
      this.topStyle.width = "".concat(width, "px");
      this.topStyle.display = "block";
      this.leftStyle.top = "".concat(top2, "px");
      this.leftStyle.left = "".concat(left2, "px");
      this.leftStyle.height = "".concat(height, "px");
      this.leftStyle.display = "block";
      var delta = Math.floor(this.settings.border.width / 2);
      this.bottomStyle.top = "".concat(top2 + height - delta, "px");
      this.bottomStyle.left = "".concat(left2, "px");
      this.bottomStyle.width = "".concat(width, "px");
      this.bottomStyle.display = "block";
      this.rightStyle.top = "".concat(top2, "px");
      this.rightStyle.left = "".concat(left2 + width - delta, "px");
      this.rightStyle.height = "".concat(height + 1, "px");
      this.rightStyle.display = "block";
      var cornerVisibleSetting = this.settings.border.cornerVisible;
      cornerVisibleSetting = typeof cornerVisibleSetting === "function" ? cornerVisibleSetting(this.settings.layerLevel) : cornerVisibleSetting;
      var hookResult = this.wot.getSetting("onModifyGetCellCoords", toRow, toColumn);
      var checkRow = toRow, checkCol = toColumn;
      if (hookResult && Array.isArray(hookResult)) {
        var _hookResult = _slicedToArray2(hookResult, 4);
        checkRow = _hookResult[2];
        checkCol = _hookResult[3];
      }
      if (isMobileBrowser() || !cornerVisibleSetting || this.isPartRange(checkRow, checkCol)) {
        this.cornerStyle.display = "none";
      } else {
        this.cornerStyle.top = "".concat(top2 + height - 4, "px");
        this.cornerStyle.left = "".concat(left2 + width - 4, "px");
        this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;
        this.cornerStyle.width = this.cornerDefaultStyle.width;
        this.cornerStyle.display = "none";
        var trimmingContainer = getTrimmingContainer(this.wot.wtTable.TABLE);
        var trimToWindow = trimmingContainer === window;
        if (trimToWindow) {
          trimmingContainer = document.documentElement;
        }
        if (toColumn === this.wot.getSetting("totalColumns") - 1) {
          var toTdOffsetLeft = trimToWindow ? toTD.getBoundingClientRect().left : toTD.offsetLeft;
          var cornerRightEdge = toTdOffsetLeft + outerWidth(toTD) + parseInt(this.cornerDefaultStyle.width, 10) / 2;
          var cornerOverlappingContainer = cornerRightEdge >= innerWidth(trimmingContainer);
          if (cornerOverlappingContainer) {
            this.cornerStyle.left = "".concat(Math.floor(left2 + width - 3 - parseInt(this.cornerDefaultStyle.width, 10) / 2), "px");
            this.cornerStyle.borderRightWidth = 0;
          }
        }
        if (toRow === this.wot.getSetting("totalRows") - 1) {
          var toTdOffsetTop = trimToWindow ? toTD.getBoundingClientRect().top : toTD.offsetTop;
          var cornerBottomEdge = toTdOffsetTop + outerHeight(toTD) + parseInt(this.cornerDefaultStyle.height, 10) / 2;
          var _cornerOverlappingContainer = cornerBottomEdge >= innerHeight(trimmingContainer);
          if (_cornerOverlappingContainer) {
            this.cornerStyle.top = "".concat(Math.floor(top2 + height - 3 - parseInt(this.cornerDefaultStyle.height, 10) / 2), "px");
            this.cornerStyle.borderBottomWidth = 0;
          }
        }
        this.cornerStyle.display = "block";
      }
      if (isMobileBrowser()) {
        this.updateMultipleSelectionHandlesPosition(toRow, toColumn, top2, left2, width, height);
      }
    }
    /**
     * Check whether an entire column of cells is selected.
     *
     * @private
     * @param {Number} startRowIndex Start row index.
     * @param {Number} endRowIndex End row index.
     */
  }, {
    key: "isEntireColumnSelected",
    value: function isEntireColumnSelected(startRowIndex, endRowIndex) {
      return startRowIndex === this.wot.wtTable.getFirstRenderedRow() && endRowIndex === this.wot.wtTable.getLastRenderedRow();
    }
    /**
     * Check whether an entire row of cells is selected.
     *
     * @private
     * @param {Number} startColumnIndex Start column index.
     * @param {Number} endColumnIndex End column index.
     */
  }, {
    key: "isEntireRowSelected",
    value: function isEntireRowSelected(startColumnIndex, endColumnIndex) {
      return startColumnIndex === this.wot.wtTable.getFirstRenderedColumn() && endColumnIndex === this.wot.wtTable.getLastRenderedColumn();
    }
    /**
     * Get left/top index and width/height depending on the `direction` provided.
     *
     * @private
     * @param {String} direction `rows` or `columns`, defines if an entire column or row is selected.
     * @param {Number} fromIndex Start index of the selection.
     * @param {Number} toIndex End index of the selection.
     * @param {Number} containerOffset offset of the container.
     * @return {Array|Boolean} Returns an array of [headerElement, left, width] or [headerElement, top, height], depending on `direction` (`false` in case of an error getting the headers).
     */
  }, {
    key: "getDimensionsFromHeader",
    value: function getDimensionsFromHeader(direction, fromIndex, toIndex, containerOffset) {
      var _this4 = this;
      var rootHotElement = this.wot.wtTable.wtRootElement.parentNode;
      var getHeaderFn = null;
      var dimensionFn = null;
      var entireSelectionClassname = null;
      var index2 = null;
      var dimension = null;
      var dimensionProperty = null;
      var startHeader = null;
      var endHeader = null;
      switch (direction) {
        case "rows":
          getHeaderFn = function getHeaderFn2() {
            var _this4$wot$wtTable;
            return (_this4$wot$wtTable = _this4.wot.wtTable).getRowHeader.apply(_this4$wot$wtTable, arguments);
          };
          dimensionFn = function dimensionFn2() {
            return outerHeight.apply(void 0, arguments);
          };
          entireSelectionClassname = "ht__selection--rows";
          dimensionProperty = "top";
          break;
        case "columns":
          getHeaderFn = function getHeaderFn2() {
            var _this4$wot$wtTable2;
            return (_this4$wot$wtTable2 = _this4.wot.wtTable).getColumnHeader.apply(_this4$wot$wtTable2, arguments);
          };
          dimensionFn = function dimensionFn2() {
            return outerWidth.apply(void 0, arguments);
          };
          entireSelectionClassname = "ht__selection--columns";
          dimensionProperty = "left";
          break;
        default:
      }
      if (rootHotElement.className.includes(entireSelectionClassname)) {
        var columnHeaderLevelCount = this.wot.getSetting("columnHeaders").length;
        startHeader = getHeaderFn(fromIndex, columnHeaderLevelCount - 1);
        endHeader = getHeaderFn(toIndex, columnHeaderLevelCount - 1);
        if (!startHeader || !endHeader) {
          return false;
        }
        var startHeaderOffset = offset(startHeader);
        var endOffset = offset(endHeader);
        if (startHeader && endHeader) {
          index2 = startHeaderOffset[dimensionProperty] - containerOffset[dimensionProperty] - 1;
          dimension = endOffset[dimensionProperty] + dimensionFn(endHeader) - startHeaderOffset[dimensionProperty];
        }
        return [startHeader, index2, dimension];
      }
      return false;
    }
    /**
     * Change border style.
     *
     * @private
     * @param {String} borderElement Coordinate where add/remove border: top, right, bottom, left.
     */
  }, {
    key: "changeBorderStyle",
    value: function changeBorderStyle(borderElement, border) {
      var style = this[borderElement].style;
      var borderStyle = border[borderElement];
      if (!borderStyle || borderStyle.hide) {
        addClass(this[borderElement], "hidden");
      } else {
        if (hasClass(this[borderElement], "hidden")) {
          removeClass(this[borderElement], "hidden");
        }
        style.backgroundColor = borderStyle.color;
        if (borderElement === "top" || borderElement === "bottom") {
          style.height = "".concat(borderStyle.width, "px");
        }
        if (borderElement === "right" || borderElement === "left") {
          style.width = "".concat(borderStyle.width, "px");
        }
      }
    }
    /**
     * Change border style to default.
     *
     * @private
     * @param {HTMLElement} position
     */
  }, {
    key: "changeBorderToDefaultStyle",
    value: function changeBorderToDefaultStyle(position) {
      var defaultBorder = {
        width: 1,
        color: "#000"
      };
      var style = this[position].style;
      style.backgroundColor = defaultBorder.color;
      style.width = "".concat(defaultBorder.width, "px");
      style.height = "".concat(defaultBorder.width, "px");
    }
    /**
     * Toggle class 'hidden' to element.
     *
     * @private
     * @param {String} borderElement Coordinate where add/remove border: top, right, bottom, left.
     * @return {Boolean}
     */
  }, {
    key: "toggleHiddenClass",
    value: function toggleHiddenClass(borderElement, remove) {
      this.changeBorderToDefaultStyle(borderElement);
      if (remove) {
        addClass(this[borderElement], "hidden");
      } else {
        removeClass(this[borderElement], "hidden");
      }
    }
    /**
     * Hide border
     */
  }, {
    key: "disappear",
    value: function disappear() {
      this.topStyle.display = "none";
      this.leftStyle.display = "none";
      this.bottomStyle.display = "none";
      this.rightStyle.display = "none";
      this.cornerStyle.display = "none";
      if (isMobileBrowser()) {
        this.selectionHandles.styles.topLeft.display = "none";
        this.selectionHandles.styles.bottomRight.display = "none";
      }
    }
  }]);
  return Border2;
}();
var border_default = Border;

// node_modules/handsontable/es/3rdparty/walkontable/src/selection.js
function _slicedToArray3(arr, i) {
  return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i) || _nonIterableRest3();
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit3(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles3(arr) {
  if (Array.isArray(arr)) return arr;
}
function _typeof12(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof12 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof12 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof12(obj);
}
function _classCallCheck25(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties24(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass24(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties24(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties24(Constructor, staticProps);
  return Constructor;
}
var Selection = function() {
  function Selection3(settings, cellRange) {
    _classCallCheck25(this, Selection3);
    this.settings = settings;
    this.cellRange = cellRange || null;
    this.instanceBorders = {};
    this.classNames = [this.settings.className];
    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);
  }
  _createClass24(Selection3, [{
    key: "getBorder",
    value: function getBorder(wotInstance) {
      if (!this.instanceBorders[wotInstance.guid]) {
        this.instanceBorders[wotInstance.guid] = new border_default(wotInstance, this.settings);
      }
      return this.instanceBorders[wotInstance.guid];
    }
    /**
     * Checks if selection is empty
     *
     * @returns {Boolean}
     */
  }, {
    key: "isEmpty",
    value: function isEmpty2() {
      return this.cellRange === null;
    }
    /**
     * Adds a cell coords to the selection
     *
     * @param {CellCoords} coords
     */
  }, {
    key: "add",
    value: function add5(coords) {
      if (this.isEmpty()) {
        this.cellRange = new range_default(coords);
      } else {
        this.cellRange.expand(coords);
      }
      return this;
    }
    /**
     * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean
     * information about success
     *
     * @param {CellCoords} oldCoords
     * @param {CellCoords} newCoords
     * @returns {Boolean}
     */
  }, {
    key: "replace",
    value: function replace(oldCoords, newCoords) {
      if (!this.isEmpty()) {
        if (this.cellRange.from.isEqual(oldCoords)) {
          this.cellRange.from = newCoords;
          return true;
        }
        if (this.cellRange.to.isEqual(oldCoords)) {
          this.cellRange.to = newCoords;
          return true;
        }
      }
      return false;
    }
    /**
     * Clears selection
     *
     * @returns {Selection}
     */
  }, {
    key: "clear",
    value: function clear() {
      this.cellRange = null;
      return this;
    }
    /**
     * Returns the top left (TL) and bottom right (BR) selection coordinates
     *
     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`
     */
  }, {
    key: "getCorners",
    value: function getCorners() {
      var topLeft = this.cellRange.getTopLeftCorner();
      var bottomRight = this.cellRange.getBottomRightCorner();
      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];
    }
    /**
     * Adds class name to cell element at given coords
     *
     * @param {Walkontable} wotInstance Walkontable instance
     * @param {Number} sourceRow Cell row coord
     * @param {Number} sourceColumn Cell column coord
     * @param {String} className Class name
     * @param {Boolean} [markIntersections=false] If `true`, linear className generator will be used to add CSS classes
     *                                            in a continuous way.
     * @returns {Selection}
     */
  }, {
    key: "addClassAtCoords",
    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {
      var markIntersections = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      var TD = wotInstance.wtTable.getCell(new coords_default(sourceRow, sourceColumn));
      if (_typeof12(TD) === "object") {
        var cellClassName = className;
        if (markIntersections) {
          cellClassName = this.classNameGenerator(TD);
          if (!this.classNames.includes(cellClassName)) {
            this.classNames.push(cellClassName);
          }
        }
        addClass(TD, cellClassName);
      }
      return this;
    }
    /**
     * Generate helper for calculating classNames based on previously added base className.
     * The generated className is always generated as a continuation of the previous className. For example, when
     * the currently checked element has 'area-2' className the generated new className will be 'area-3'. When
     * the element doesn't have any classNames than the base className will be returned ('area');
     *
     * @param {String} baseClassName Base className to be used.
     * @param {Number} layerLevelOwner Layer level which the instance of the Selection belongs to.
     * @return {Function}
     */
  }, {
    key: "linearClassNameGenerator",
    value: function linearClassNameGenerator(baseClassName, layerLevelOwner) {
      return function calcClassName(element) {
        var previousIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
        if (layerLevelOwner === 0 || previousIndex === 0) {
          return baseClassName;
        }
        var index2 = previousIndex >= 0 ? previousIndex : layerLevelOwner;
        var className = baseClassName;
        index2 -= 1;
        var previousClassName = index2 === 0 ? baseClassName : "".concat(baseClassName, "-").concat(index2);
        if (hasClass(element, previousClassName)) {
          var currentLayer = index2 + 1;
          className = "".concat(baseClassName, "-").concat(currentLayer);
        } else {
          className = calcClassName(element, index2);
        }
        return className;
      };
    }
    /**
     * @param wotInstance
     */
  }, {
    key: "draw",
    value: function draw(wotInstance) {
      if (this.isEmpty()) {
        if (this.settings.border) {
          this.getBorder(wotInstance).disappear();
        }
        return;
      }
      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();
      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();
      var corners = this.getCorners();
      var _corners = _slicedToArray3(corners, 4), topRow = _corners[0], topColumn = _corners[1], bottomRow = _corners[2], bottomColumn = _corners[3];
      for (var column = 0; column < renderedColumns; column += 1) {
        var sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);
        if (sourceCol >= topColumn && sourceCol <= bottomColumn) {
          var TH = wotInstance.wtTable.getColumnHeader(sourceCol);
          if (TH) {
            var newClasses = [];
            if (this.settings.highlightHeaderClassName) {
              newClasses.push(this.settings.highlightHeaderClassName);
            }
            if (this.settings.highlightColumnClassName) {
              newClasses.push(this.settings.highlightColumnClassName);
            }
            addClass(TH, newClasses);
          }
        }
      }
      for (var row = 0; row < renderedRows; row += 1) {
        var sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);
        if (sourceRow >= topRow && sourceRow <= bottomRow) {
          var _TH = wotInstance.wtTable.getRowHeader(sourceRow);
          if (_TH) {
            var _newClasses = [];
            if (this.settings.highlightHeaderClassName) {
              _newClasses.push(this.settings.highlightHeaderClassName);
            }
            if (this.settings.highlightRowClassName) {
              _newClasses.push(this.settings.highlightRowClassName);
            }
            addClass(_TH, _newClasses);
          }
        }
        for (var _column = 0; _column < renderedColumns; _column += 1) {
          var _sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(_column);
          if (sourceRow >= topRow && sourceRow <= bottomRow && _sourceCol >= topColumn && _sourceCol <= bottomColumn) {
            if (this.settings.className) {
              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.className, this.settings.markIntersections);
            }
          } else if (sourceRow >= topRow && sourceRow <= bottomRow) {
            if (this.settings.highlightRowClassName) {
              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightRowClassName);
            }
          } else if (_sourceCol >= topColumn && _sourceCol <= bottomColumn) {
            if (this.settings.highlightColumnClassName) {
              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightColumnClassName);
            }
          }
          var additionalSelectionClass = wotInstance.getSetting("onAfterDrawSelection", sourceRow, _sourceCol, corners, this.settings.layerLevel);
          if (typeof additionalSelectionClass === "string") {
            this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, additionalSelectionClass);
          }
        }
      }
      wotInstance.getSetting("onBeforeDrawBorders", corners, this.settings.className);
      if (this.settings.border) {
        this.getBorder(wotInstance).appear(corners);
      }
    }
  }]);
  return Selection3;
}();
var selection_default = Selection;

// node_modules/handsontable/es/editors/_baseEditor.js
var EditorState = {
  VIRGIN: "STATE_VIRGIN",
  // before editing
  EDITING: "STATE_EDITING",
  WAITING: "STATE_WAITING",
  // waiting for async validation
  FINISHED: "STATE_FINISHED"
};
function BaseEditor(instance) {
  this.instance = instance;
  this.state = EditorState.VIRGIN;
  this._opened = false;
  this._fullEditMode = false;
  this._closeCallback = null;
  this.init();
}
BaseEditor.prototype._fireCallbacks = function(result) {
  if (this._closeCallback) {
    this._closeCallback(result);
    this._closeCallback = null;
  }
};
BaseEditor.prototype.init = function() {
};
BaseEditor.prototype.getValue = function() {
  throw Error("Editor getValue() method unimplemented");
};
BaseEditor.prototype.setValue = function() {
  throw Error("Editor setValue() method unimplemented");
};
BaseEditor.prototype.open = function() {
  throw Error("Editor open() method unimplemented");
};
BaseEditor.prototype.close = function() {
  throw Error("Editor close() method unimplemented");
};
BaseEditor.prototype.prepare = function(row, col, prop, td, originalValue, cellProperties) {
  this.TD = td;
  this.row = row;
  this.col = col;
  this.prop = prop;
  this.originalValue = originalValue;
  this.cellProperties = cellProperties;
  this.state = EditorState.VIRGIN;
};
BaseEditor.prototype.extend = function() {
  var baseClass = this.constructor;
  function Editor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    baseClass.apply(this, args);
  }
  function inherit2(Child, Parent) {
    function Bridge() {
    }
    Bridge.prototype = Parent.prototype;
    Child.prototype = new Bridge();
    Child.prototype.constructor = Child;
    return Child;
  }
  return inherit2(Editor, baseClass);
};
BaseEditor.prototype.saveValue = function(value, ctrlDown) {
  var selection;
  var tmp;
  if (ctrlDown) {
    selection = this.instance.getSelectedLast();
    if (selection[0] > selection[2]) {
      tmp = selection[0];
      selection[0] = selection[2];
      selection[2] = tmp;
    }
    if (selection[1] > selection[3]) {
      tmp = selection[1];
      selection[1] = selection[3];
      selection[3] = tmp;
    }
  } else {
    selection = [this.row, this.col, null, null];
  }
  this.instance.populateFromArray(selection[0], selection[1], value, selection[2], selection[3], "edit");
};
BaseEditor.prototype.beginEditing = function(newInitialValue, event2) {
  if (this.state !== EditorState.VIRGIN) {
    return;
  }
  this.instance.view.scrollViewport(new coords_default(this.row, this.col));
  this.state = EditorState.EDITING;
  if (this.isInFullEditMode()) {
    var stringifiedInitialValue = typeof newInitialValue === "string" ? newInitialValue : stringify(this.originalValue);
    this.setValue(stringifiedInitialValue);
  }
  this.open(event2);
  this._opened = true;
  this.focus();
  this.instance.view.render();
  this.instance.runHooks("afterBeginEditing", this.row, this.col);
};
BaseEditor.prototype.finishEditing = function(restoreOriginalValue, ctrlDown, callback) {
  var _this = this;
  var val;
  if (callback) {
    var previousCloseCallback = this._closeCallback;
    this._closeCallback = function(result) {
      if (previousCloseCallback) {
        previousCloseCallback(result);
      }
      callback(result);
      _this.instance.view.render();
    };
  }
  if (this.isWaiting()) {
    return;
  }
  if (this.state === EditorState.VIRGIN) {
    this.instance._registerTimeout(function() {
      _this._fireCallbacks(true);
    });
    return;
  }
  if (this.state === EditorState.EDITING) {
    if (restoreOriginalValue) {
      this.cancelChanges();
      this.instance.view.render();
      return;
    }
    var value = this.getValue();
    if (this.instance.getSettings().trimWhitespace) {
      val = [[typeof value === "string" ? String.prototype.trim.call(value || "") : value]];
    } else {
      val = [[value]];
    }
    this.state = EditorState.WAITING;
    this.saveValue(val, ctrlDown);
    if (this.instance.getCellValidator(this.cellProperties)) {
      this.instance.addHookOnce("postAfterValidate", function(result) {
        _this.state = EditorState.FINISHED;
        _this.discardEditor(result);
      });
    } else {
      this.state = EditorState.FINISHED;
      this.discardEditor(true);
    }
  }
};
BaseEditor.prototype.cancelChanges = function() {
  this.state = EditorState.FINISHED;
  this.discardEditor();
};
BaseEditor.prototype.discardEditor = function(result) {
  if (this.state !== EditorState.FINISHED) {
    return;
  }
  if (result === false && this.cellProperties.allowInvalid !== true) {
    this.instance.selectCell(this.row, this.col);
    this.focus();
    this.state = EditorState.EDITING;
    this._fireCallbacks(false);
  } else {
    this.close();
    this._opened = false;
    this._fullEditMode = false;
    this.state = EditorState.VIRGIN;
    this._fireCallbacks(true);
  }
};
BaseEditor.prototype.enableFullEditMode = function() {
  this._fullEditMode = true;
};
BaseEditor.prototype.isInFullEditMode = function() {
  return this._fullEditMode;
};
BaseEditor.prototype.isOpened = function() {
  return this._opened;
};
BaseEditor.prototype.isWaiting = function() {
  return this.state === EditorState.WAITING;
};
BaseEditor.prototype.checkEditorSection = function() {
  var totalRows = this.instance.countRows();
  var section = "";
  if (this.row < this.instance.getSettings().fixedRowsTop) {
    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
      section = "top-left-corner";
    } else {
      section = "top";
    }
  } else if (this.instance.getSettings().fixedRowsBottom && this.row >= totalRows - this.instance.getSettings().fixedRowsBottom) {
    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
      section = "bottom-left-corner";
    } else {
      section = "bottom";
    }
  } else if (this.col < this.instance.getSettings().fixedColumnsLeft) {
    section = "left";
  }
  return section;
};
var baseEditor_default = BaseEditor;

// node_modules/handsontable/es/editors/textEditor.js
var import_autoResize = __toESM(require_autoResize());
var TextEditor = baseEditor_default.prototype.extend();
TextEditor.prototype.init = function() {
  var that = this;
  this.createElements();
  this.eventManager = new eventManager_default(this);
  this.bindEvents();
  this.autoResize = (0, import_autoResize.default)();
  this.holderZIndex = -1;
  this.instance.addHook("afterDestroy", function() {
    that.destroy();
  });
};
TextEditor.prototype.prepare = function(row, col, prop, td, originalValue, cellProperties) {
  var _this = this;
  var previousState = this.state;
  for (var _len = arguments.length, args = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
    args[_key - 6] = arguments[_key];
  }
  baseEditor_default.prototype.prepare.apply(this, [row, col, prop, td, originalValue, cellProperties].concat(args));
  if (!cellProperties.readOnly) {
    this.refreshDimensions(true);
    var allowInvalid = cellProperties.allowInvalid, fragmentSelection = cellProperties.fragmentSelection;
    if (allowInvalid) {
      this.TEXTAREA.value = "";
    }
    if (previousState !== EditorState.FINISHED) {
      this.hideEditableElement();
    }
    var restoreFocus = !fragmentSelection;
    if (restoreFocus && !isMobileBrowser()) {
      this.instance._registerImmediate(function() {
        return _this.focus();
      });
    }
  }
};
TextEditor.prototype.hideEditableElement = function() {
  this.textareaParentStyle.top = "-9999px";
  this.textareaParentStyle.left = "-9999px";
  this.textareaParentStyle.zIndex = "-1";
  this.textareaParentStyle.position = "fixed";
};
TextEditor.prototype.showEditableElement = function() {
  this.textareaParentStyle.zIndex = this.holderZIndex >= 0 ? this.holderZIndex : "";
  this.textareaParentStyle.position = "";
};
TextEditor.prototype.getValue = function() {
  return this.TEXTAREA.value;
};
TextEditor.prototype.setValue = function(newValue) {
  this.TEXTAREA.value = newValue;
};
TextEditor.prototype.beginEditing = function() {
  if (this.state !== EditorState.VIRGIN) {
    return;
  }
  this.TEXTAREA.value = "";
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  baseEditor_default.prototype.beginEditing.apply(this, args);
};
var onBeforeKeyDown = function onBeforeKeyDown2(event2) {
  var instance = this;
  var that = instance.getActiveEditor();
  var ctrlDown = (event2.ctrlKey || event2.metaKey) && !event2.altKey;
  if (event2.target !== that.TEXTAREA || isImmediatePropagationStopped(event2)) {
    return;
  }
  switch (event2.keyCode) {
    case KEY_CODES.ARROW_RIGHT:
      if (that.isInFullEditMode()) {
        if (!that.isWaiting() && !that.allowKeyEventPropagation || !that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event2.keyCode)) {
          stopImmediatePropagation(event2);
        }
      }
      break;
    case KEY_CODES.ARROW_LEFT:
      if (that.isInFullEditMode()) {
        if (!that.isWaiting() && !that.allowKeyEventPropagation || !that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event2.keyCode)) {
          stopImmediatePropagation(event2);
        }
      }
      break;
    case KEY_CODES.ARROW_UP:
    case KEY_CODES.ARROW_DOWN:
      if (that.isInFullEditMode()) {
        if (!that.isWaiting() && !that.allowKeyEventPropagation || !that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event2.keyCode)) {
          stopImmediatePropagation(event2);
        }
      }
      break;
    case KEY_CODES.ENTER: {
      var isMultipleSelection = this.selection.isMultiple();
      if (ctrlDown && !isMultipleSelection || event2.altKey) {
        if (that.isOpened()) {
          var caretPosition = getCaretPosition(that.TEXTAREA);
          var value = that.getValue();
          var newValue = "".concat(value.slice(0, caretPosition), "\n").concat(value.slice(caretPosition));
          that.setValue(newValue);
          setCaretPosition(that.TEXTAREA, caretPosition + 1);
        } else {
          that.beginEditing("".concat(that.originalValue, "\n"));
        }
        stopImmediatePropagation(event2);
      }
      event2.preventDefault();
      break;
    }
    case KEY_CODES.BACKSPACE:
    case KEY_CODES.DELETE:
    case KEY_CODES.HOME:
    case KEY_CODES.END:
      stopImmediatePropagation(event2);
      break;
    default:
      break;
  }
  if ([KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_LEFT].indexOf(event2.keyCode) === -1) {
    that.autoResize.resize(String.fromCharCode(event2.keyCode));
  }
};
TextEditor.prototype.open = function() {
  this.refreshDimensions();
  this.showEditableElement();
  this.instance.addHook("beforeKeyDown", onBeforeKeyDown);
};
TextEditor.prototype.close = function() {
  this.autoResize.unObserve();
  if (document.activeElement === this.TEXTAREA) {
    this.instance.listen();
  }
  this.hideEditableElement();
  this.instance.removeHook("beforeKeyDown", onBeforeKeyDown);
};
TextEditor.prototype.focus = function() {
  this.TEXTAREA.select();
  setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
};
TextEditor.prototype.createElements = function() {
  this.TEXTAREA = document.createElement("TEXTAREA");
  this.TEXTAREA.tabIndex = -1;
  addClass(this.TEXTAREA, "handsontableInput");
  this.textareaStyle = this.TEXTAREA.style;
  this.textareaStyle.width = 0;
  this.textareaStyle.height = 0;
  this.TEXTAREA_PARENT = document.createElement("DIV");
  addClass(this.TEXTAREA_PARENT, "handsontableInputHolder");
  this.textareaParentStyle = this.TEXTAREA_PARENT.style;
  this.textareaParentStyle.zIndex = "-1";
  this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
  this.instance.rootElement.appendChild(this.TEXTAREA_PARENT);
};
TextEditor.prototype.getEditedCell = function() {
  var editorSection = this.checkEditorSection();
  var editedCell;
  switch (editorSection) {
    case "top":
      editedCell = this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.holderZIndex = 101;
      break;
    case "top-left-corner":
      editedCell = this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.holderZIndex = 103;
      break;
    case "bottom-left-corner":
      editedCell = this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.holderZIndex = 103;
      break;
    case "left":
      editedCell = this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.holderZIndex = 102;
      break;
    case "bottom":
      editedCell = this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.holderZIndex = 102;
      break;
    default:
      editedCell = this.instance.getCell(this.row, this.col);
      this.holderZIndex = -1;
      break;
  }
  return editedCell !== -1 && editedCell !== -2 ? editedCell : void 0;
};
TextEditor.prototype.refreshValue = function() {
  var physicalRow = this.instance.toPhysicalRow(this.row);
  var sourceData = this.instance.getSourceDataAtCell(physicalRow, this.col);
  this.originalValue = sourceData;
  this.setValue(sourceData);
  this.refreshDimensions();
};
TextEditor.prototype.refreshDimensions = function() {
  var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  if (this.state !== EditorState.EDITING && !force) {
    return;
  }
  this.TD = this.getEditedCell();
  if (!this.TD) {
    if (!force) {
      this.close(true);
    }
    return;
  }
  var currentOffset = offset(this.TD);
  var containerOffset = offset(this.instance.rootElement);
  var scrollableContainerTop = this.instance.view.wt.wtOverlays.topOverlay.mainTableScrollableElement;
  var scrollableContainerLeft = this.instance.view.wt.wtOverlays.leftOverlay.mainTableScrollableElement;
  var totalRowsCount = this.instance.countRows();
  var containerScrollTop = scrollableContainerTop !== window ? scrollableContainerTop.scrollTop : 0;
  var containerScrollLeft = scrollableContainerLeft !== window ? scrollableContainerLeft.scrollLeft : 0;
  var editorSection = this.checkEditorSection();
  var scrollTop = ["", "left"].includes(editorSection) ? containerScrollTop : 0;
  var scrollLeft = ["", "top", "bottom"].includes(editorSection) ? containerScrollLeft : 0;
  var editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;
  var settings = this.instance.getSettings();
  var colHeadersCount = this.instance.hasColHeaders();
  var backgroundColor = this.TD.style.backgroundColor;
  var editTop = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;
  var editLeft = currentOffset.left - containerOffset.left - 1 - scrollLeft;
  var cssTransformOffset;
  switch (editorSection) {
    case "top":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
      break;
    case "left":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
      break;
    case "top-left-corner":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
      break;
    case "bottom-left-corner":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
      break;
    case "bottom":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
      break;
    default:
      break;
  }
  if (colHeadersCount && this.instance.getSelectedLast()[0] === 0 || settings.fixedRowsBottom && this.instance.getSelectedLast()[0] === totalRowsCount - settings.fixedRowsBottom) {
    editTop += 1;
  }
  if (this.instance.getSelectedLast()[1] === 0) {
    editLeft += 1;
  }
  if (cssTransformOffset && cssTransformOffset !== -1) {
    this.textareaParentStyle[cssTransformOffset[0]] = cssTransformOffset[1];
  } else {
    resetCssTransform(this.TEXTAREA_PARENT);
  }
  this.textareaParentStyle.top = "".concat(editTop, "px");
  this.textareaParentStyle.left = "".concat(editLeft, "px");
  this.showEditableElement();
  var firstRowOffset = this.instance.view.wt.wtViewport.rowsRenderCalculator.startPosition;
  var firstColumnOffset = this.instance.view.wt.wtViewport.columnsRenderCalculator.startPosition;
  var horizontalScrollPosition = this.instance.view.wt.wtOverlays.leftOverlay.getScrollPosition();
  var verticalScrollPosition = this.instance.view.wt.wtOverlays.topOverlay.getScrollPosition();
  var scrollbarWidth = getScrollbarWidth();
  var cellTopOffset = this.TD.offsetTop + firstRowOffset - verticalScrollPosition;
  var cellLeftOffset = this.TD.offsetLeft + firstColumnOffset - horizontalScrollPosition;
  var width = innerWidth(this.TD) - 8;
  var actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;
  var actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;
  var maxWidth = this.instance.view.maximumVisibleElementWidth(cellLeftOffset) - 9 - actualVerticalScrollbarWidth;
  var height = this.TD.scrollHeight + 1;
  var maxHeight = Math.max(this.instance.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth, 23);
  var cellComputedStyle = getComputedStyle2(this.TD);
  this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;
  this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;
  this.TEXTAREA.style.backgroundColor = backgroundColor;
  this.autoResize.init(this.TEXTAREA, {
    minHeight: Math.min(height, maxHeight),
    maxHeight,
    // TEXTAREA should never be higher than visible part of the viewport (should not cover the scrollbar)
    minWidth: Math.min(width, maxWidth),
    maxWidth
    // TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
  }, true);
};
TextEditor.prototype.bindEvents = function() {
  var editor = this;
  this.eventManager.addEventListener(this.TEXTAREA, "cut", function(event2) {
    stopPropagation(event2);
  });
  this.eventManager.addEventListener(this.TEXTAREA, "paste", function(event2) {
    stopPropagation(event2);
  });
  this.instance.addHook("afterScrollHorizontally", function() {
    editor.refreshDimensions();
  });
  this.instance.addHook("afterScrollVertically", function() {
    editor.refreshDimensions();
  });
  this.instance.addHook("afterColumnResize", function() {
    editor.refreshDimensions();
    editor.focus();
  });
  this.instance.addHook("afterRowResize", function() {
    editor.refreshDimensions();
    editor.focus();
  });
  this.instance.addHook("afterDestroy", function() {
    editor.eventManager.destroy();
  });
};
TextEditor.prototype.destroy = function() {
  this.eventManager.destroy();
};
var textEditor_default = TextEditor;

// node_modules/handsontable/es/editors/handsontableEditor.js
var HandsontableEditor = textEditor_default.prototype.extend();
HandsontableEditor.prototype.createElements = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  textEditor_default.prototype.createElements.apply(this, args);
  var DIV = document.createElement("DIV");
  DIV.className = "handsontableEditor";
  this.TEXTAREA_PARENT.appendChild(DIV);
  this.htContainer = DIV;
  this.assignHooks();
};
HandsontableEditor.prototype.prepare = function(td, row, col, prop, value, cellProperties) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 6 ? _len2 - 6 : 0), _key2 = 6; _key2 < _len2; _key2++) {
    args[_key2 - 6] = arguments[_key2];
  }
  textEditor_default.prototype.prepare.apply(this, [td, row, col, prop, value, cellProperties].concat(args));
  var parent = this;
  var options = {
    startRows: 0,
    startCols: 0,
    minRows: 0,
    minCols: 0,
    className: "listbox",
    copyPaste: false,
    autoColumnSize: false,
    autoRowSize: false,
    readOnly: true,
    fillHandle: false,
    autoWrapCol: false,
    autoWrapRow: false,
    afterOnCellMouseDown: function afterOnCellMouseDown(_, coords) {
      var sourceValue = this.getSourceData(coords.row, coords.col);
      if (sourceValue !== void 0) {
        parent.setValue(sourceValue);
      }
      parent.instance.destroyEditor();
    }
  };
  if (this.cellProperties.handsontable) {
    extend(options, cellProperties.handsontable);
  }
  this.htOptions = options;
};
var onBeforeKeyDown3 = function onBeforeKeyDown4(event2) {
  if (isImmediatePropagationStopped(event2)) {
    return;
  }
  var editor = this.getActiveEditor();
  var innerHOT = editor.htEditor.getInstance();
  var rowToSelect;
  var selectedRow;
  if (event2.keyCode === KEY_CODES.ARROW_DOWN) {
    if (!innerHOT.getSelectedLast() && !innerHOT.flipped) {
      rowToSelect = 0;
    } else if (innerHOT.getSelectedLast()) {
      if (innerHOT.flipped) {
        rowToSelect = innerHOT.getSelectedLast()[0] + 1;
      } else if (!innerHOT.flipped) {
        var lastRow = innerHOT.countRows() - 1;
        selectedRow = innerHOT.getSelectedLast()[0];
        rowToSelect = Math.min(lastRow, selectedRow + 1);
      }
    }
  } else if (event2.keyCode === KEY_CODES.ARROW_UP) {
    if (!innerHOT.getSelectedLast() && innerHOT.flipped) {
      rowToSelect = innerHOT.countRows() - 1;
    } else if (innerHOT.getSelectedLast()) {
      if (innerHOT.flipped) {
        selectedRow = innerHOT.getSelectedLast()[0];
        rowToSelect = Math.max(0, selectedRow - 1);
      } else {
        selectedRow = innerHOT.getSelectedLast()[0];
        rowToSelect = selectedRow - 1;
      }
    }
  }
  if (rowToSelect !== void 0) {
    if (rowToSelect < 0 || innerHOT.flipped && rowToSelect > innerHOT.countRows() - 1) {
      innerHOT.deselectCell();
    } else {
      innerHOT.selectCell(rowToSelect, 0);
    }
    if (innerHOT.getData().length) {
      event2.preventDefault();
      stopImmediatePropagation(event2);
      editor.instance.listen();
      editor.TEXTAREA.focus();
    }
  }
};
HandsontableEditor.prototype.open = function() {
  this.instance.addHook("beforeKeyDown", onBeforeKeyDown3);
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  textEditor_default.prototype.open.apply(this, args);
  if (this.htEditor) {
    this.htEditor.destroy();
  }
  if (this.htContainer.style.display === "none") {
    this.htContainer.style.display = "";
  }
  this.htEditor = new this.instance.constructor(this.htContainer, this.htOptions);
  this.htEditor.init();
  this.htEditor.rootElement.style.display = "";
  if (this.cellProperties.strict) {
    this.htEditor.selectCell(0, 0);
  } else {
    this.htEditor.deselectCell();
  }
  setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);
};
HandsontableEditor.prototype.close = function() {
  this.htEditor.rootElement.style.display = "none";
  this.instance.removeHook("beforeKeyDown", onBeforeKeyDown3);
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }
  textEditor_default.prototype.close.apply(this, args);
};
HandsontableEditor.prototype.focus = function() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }
  textEditor_default.prototype.focus.apply(this, args);
};
HandsontableEditor.prototype.beginEditing = function() {
  var onBeginEditing = this.instance.getSettings().onBeginEditing;
  if (onBeginEditing && onBeginEditing() === false) {
    return;
  }
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  textEditor_default.prototype.beginEditing.apply(this, args);
};
HandsontableEditor.prototype.finishEditing = function() {
  if (this.htEditor && this.htEditor.isListening()) {
    this.instance.listen();
  }
  if (this.htEditor && this.htEditor.getSelectedLast()) {
    var value = this.htEditor.getInstance().getValue();
    if (value !== void 0) {
      this.setValue(value);
    }
  }
  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }
  return textEditor_default.prototype.finishEditing.apply(this, args);
};
HandsontableEditor.prototype.assignHooks = function() {
  var _this = this;
  this.instance.addHook("afterDestroy", function() {
    if (_this.htEditor) {
      _this.htEditor.destroy();
    }
  });
};
var handsontableEditor_default = HandsontableEditor;

// node_modules/handsontable/es/editors/autocompleteEditor.js
var AutocompleteEditor = handsontableEditor_default.prototype.extend();
AutocompleteEditor.prototype.init = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  handsontableEditor_default.prototype.init.apply(this, args);
  this.query = null;
  this.strippedChoices = [];
  this.rawChoices = [];
};
AutocompleteEditor.prototype.getValue = function() {
  var _this2 = this;
  var selectedValue = this.rawChoices.find(function(value) {
    var strippedValue = _this2.stripValueIfNeeded(value);
    return strippedValue === _this2.TEXTAREA.value;
  });
  if (isDefined(selectedValue)) {
    return selectedValue;
  }
  return this.TEXTAREA.value;
};
AutocompleteEditor.prototype.createElements = function() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  handsontableEditor_default.prototype.createElements.apply(this, args);
  addClass(this.htContainer, "autocompleteEditor");
  addClass(this.htContainer, window.navigator.platform.indexOf("Mac") === -1 ? "" : "htMacScroll");
};
var skipOne = false;
function onBeforeKeyDown5(event2) {
  skipOne = false;
  var editor = this.getActiveEditor();
  if (isPrintableChar(event2.keyCode) || event2.keyCode === KEY_CODES.BACKSPACE || event2.keyCode === KEY_CODES.DELETE || event2.keyCode === KEY_CODES.INSERT) {
    var timeOffset = 0;
    if (event2.keyCode === KEY_CODES.C && (event2.ctrlKey || event2.metaKey)) {
      return;
    }
    if (!editor.isOpened()) {
      timeOffset += 10;
    }
    if (editor.htEditor) {
      editor.instance._registerTimeout(function() {
        editor.queryChoices(editor.TEXTAREA.value);
        skipOne = true;
      }, timeOffset);
    }
  }
}
AutocompleteEditor.prototype.prepare = function() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  handsontableEditor_default.prototype.prepare.apply(this, args);
};
AutocompleteEditor.prototype.open = function() {
  this.instance.addHook("beforeKeyDown", onBeforeKeyDown5);
  this.TEXTAREA_PARENT.style.overflow = "auto";
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }
  handsontableEditor_default.prototype.open.apply(this, args);
  this.TEXTAREA_PARENT.style.overflow = "";
  var choicesListHot = this.htEditor.getInstance();
  var _this = this;
  var trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;
  this.showEditableElement();
  this.focus();
  choicesListHot.updateSettings({
    colWidths: trimDropdown ? [outerWidth(this.TEXTAREA) - 2] : void 0,
    width: trimDropdown ? outerWidth(this.TEXTAREA) + getScrollbarWidth() + 2 : void 0,
    afterRenderer: function afterRenderer(TD, row, col, prop, value) {
      var _this$cellProperties = _this.cellProperties, filteringCaseSensitive = _this$cellProperties.filteringCaseSensitive, allowHtml = _this$cellProperties.allowHtml;
      var cellValue = stringify(value);
      var indexOfMatch;
      var match;
      if (cellValue && !allowHtml) {
        indexOfMatch = filteringCaseSensitive === true ? cellValue.indexOf(this.query) : cellValue.toLowerCase().indexOf(_this.query.toLowerCase());
        if (indexOfMatch !== -1) {
          match = cellValue.substr(indexOfMatch, _this.query.length);
          cellValue = cellValue.replace(match, "<strong>".concat(match, "</strong>"));
        }
      }
      TD.innerHTML = cellValue;
    },
    autoColumnSize: true,
    modifyColWidth: function modifyColWidth(width, col) {
      var autoWidths = this.getPlugin("autoColumnSize").widths;
      var columnWidth = width;
      if (autoWidths[col]) {
        columnWidth = autoWidths[col];
      }
      return trimDropdown ? columnWidth : columnWidth + 15;
    }
  });
  this.htEditor.view.wt.wtTable.holder.parentNode.style["padding-right"] = "".concat(getScrollbarWidth() + 2, "px");
  if (skipOne) {
    skipOne = false;
  }
  _this.instance._registerTimeout(function() {
    _this.queryChoices(_this.TEXTAREA.value);
  });
};
AutocompleteEditor.prototype.queryChoices = function(query) {
  var _this3 = this;
  this.query = query;
  var source = this.cellProperties.source;
  if (typeof source === "function") {
    source.call(this.cellProperties, query, function(choices) {
      _this3.rawChoices = choices;
      _this3.updateChoicesList(_this3.stripValuesIfNeeded(choices));
    });
  } else if (Array.isArray(source)) {
    this.rawChoices = source;
    this.updateChoicesList(this.stripValuesIfNeeded(source));
  } else {
    this.updateChoicesList([]);
  }
};
AutocompleteEditor.prototype.updateChoicesList = function(choicesList) {
  var pos = getCaretPosition(this.TEXTAREA);
  var endPos = getSelectionEndPosition(this.TEXTAREA);
  var sortByRelevanceSetting = this.cellProperties.sortByRelevance;
  var filterSetting = this.cellProperties.filter;
  var orderByRelevance = null;
  var highlightIndex = null;
  var choices = choicesList;
  if (sortByRelevanceSetting) {
    orderByRelevance = AutocompleteEditor.sortByRelevance(this.stripValueIfNeeded(this.getValue()), choices, this.cellProperties.filteringCaseSensitive);
  }
  var orderByRelevanceLength = Array.isArray(orderByRelevance) ? orderByRelevance.length : 0;
  if (filterSetting === false) {
    if (orderByRelevanceLength) {
      highlightIndex = orderByRelevance[0];
    }
  } else {
    var sorted = [];
    for (var i = 0, choicesCount = choices.length; i < choicesCount; i++) {
      if (sortByRelevanceSetting && orderByRelevanceLength <= i) {
        break;
      }
      if (orderByRelevanceLength) {
        sorted.push(choices[orderByRelevance[i]]);
      } else {
        sorted.push(choices[i]);
      }
    }
    highlightIndex = 0;
    choices = sorted;
  }
  this.strippedChoices = choices;
  this.htEditor.loadData(pivot([choices]));
  this.updateDropdownHeight();
  this.flipDropdownIfNeeded();
  if (this.cellProperties.strict === true) {
    this.highlightBestMatchingChoice(highlightIndex);
  }
  this.instance.listen(false);
  setCaretPosition(this.TEXTAREA, pos, pos === endPos ? void 0 : endPos);
};
AutocompleteEditor.prototype.flipDropdownIfNeeded = function() {
  var textareaOffset = offset(this.TEXTAREA);
  var textareaHeight = outerHeight(this.TEXTAREA);
  var dropdownHeight = this.getDropdownHeight();
  var trimmingContainer = getTrimmingContainer(this.instance.view.wt.wtTable.TABLE);
  var trimmingContainerScrollTop = trimmingContainer.scrollTop;
  var headersHeight = outerHeight(this.instance.view.wt.wtTable.THEAD);
  var containerOffset = {
    row: 0,
    col: 0
  };
  if (trimmingContainer !== window) {
    containerOffset = offset(trimmingContainer);
  }
  var spaceAbove = textareaOffset.top - containerOffset.top - headersHeight + trimmingContainerScrollTop;
  var spaceBelow = trimmingContainer.scrollHeight - spaceAbove - headersHeight - textareaHeight;
  var flipNeeded = dropdownHeight > spaceBelow && spaceAbove > spaceBelow;
  if (flipNeeded) {
    this.flipDropdown(dropdownHeight);
  } else {
    this.unflipDropdown();
  }
  this.limitDropdownIfNeeded(flipNeeded ? spaceAbove : spaceBelow, dropdownHeight);
  return flipNeeded;
};
AutocompleteEditor.prototype.limitDropdownIfNeeded = function(spaceAvailable, dropdownHeight) {
  if (dropdownHeight > spaceAvailable) {
    var tempHeight = 0;
    var i = 0;
    var lastRowHeight = 0;
    var height = null;
    do {
      lastRowHeight = this.htEditor.getRowHeight(i) || this.htEditor.view.wt.wtSettings.settings.defaultRowHeight;
      tempHeight += lastRowHeight;
      i += 1;
    } while (tempHeight < spaceAvailable);
    height = tempHeight - lastRowHeight;
    if (this.htEditor.flipped) {
      this.htEditor.rootElement.style.top = "".concat(parseInt(this.htEditor.rootElement.style.top, 10) + dropdownHeight - height, "px");
    }
    this.setDropdownHeight(tempHeight - lastRowHeight);
  }
};
AutocompleteEditor.prototype.flipDropdown = function(dropdownHeight) {
  var dropdownStyle = this.htEditor.rootElement.style;
  dropdownStyle.position = "absolute";
  dropdownStyle.top = "".concat(-dropdownHeight, "px");
  this.htEditor.flipped = true;
};
AutocompleteEditor.prototype.unflipDropdown = function() {
  var dropdownStyle = this.htEditor.rootElement.style;
  if (dropdownStyle.position === "absolute") {
    dropdownStyle.position = "";
    dropdownStyle.top = "";
  }
  this.htEditor.flipped = void 0;
};
AutocompleteEditor.prototype.updateDropdownHeight = function() {
  var currentDropdownWidth = this.htEditor.getColWidth(0) + getScrollbarWidth() + 2;
  var trimDropdown = this.cellProperties.trimDropdown;
  this.htEditor.updateSettings({
    height: this.getDropdownHeight(),
    width: trimDropdown ? void 0 : currentDropdownWidth
  });
  this.htEditor.view.wt.wtTable.alignOverlaysWithTrimmingContainer();
};
AutocompleteEditor.prototype.setDropdownHeight = function(height) {
  this.htEditor.updateSettings({
    height
  });
};
AutocompleteEditor.prototype.finishEditing = function(restoreOriginalValue) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  handsontableEditor_default.prototype.finishEditing.apply(this, [restoreOriginalValue].concat(args));
};
AutocompleteEditor.prototype.highlightBestMatchingChoice = function(index2) {
  if (typeof index2 === "number") {
    this.htEditor.selectCell(index2, 0, void 0, void 0, void 0, false);
  } else {
    this.htEditor.deselectCell();
  }
};
AutocompleteEditor.sortByRelevance = function(value, choices, caseSensitive) {
  var choicesRelevance = [];
  var currentItem;
  var valueLength = value.length;
  var valueIndex;
  var charsLeft;
  var result = [];
  var i;
  var choicesCount = choices.length;
  if (valueLength === 0) {
    for (i = 0; i < choicesCount; i++) {
      result.push(i);
    }
    return result;
  }
  for (i = 0; i < choicesCount; i++) {
    currentItem = stripTags(stringify(choices[i]));
    if (caseSensitive) {
      valueIndex = currentItem.indexOf(value);
    } else {
      valueIndex = currentItem.toLowerCase().indexOf(value.toLowerCase());
    }
    if (valueIndex !== -1) {
      charsLeft = currentItem.length - valueIndex - valueLength;
      choicesRelevance.push({
        baseIndex: i,
        index: valueIndex,
        charsLeft,
        value: currentItem
      });
    }
  }
  choicesRelevance.sort(function(a, b) {
    if (b.index === -1) {
      return -1;
    }
    if (a.index === -1) {
      return 1;
    }
    if (a.index < b.index) {
      return -1;
    } else if (b.index < a.index) {
      return 1;
    } else if (a.index === b.index) {
      if (a.charsLeft < b.charsLeft) {
        return -1;
      } else if (a.charsLeft > b.charsLeft) {
        return 1;
      }
    }
    return 0;
  });
  for (i = 0, choicesCount = choicesRelevance.length; i < choicesCount; i++) {
    result.push(choicesRelevance[i].baseIndex);
  }
  return result;
};
AutocompleteEditor.prototype.getDropdownHeight = function() {
  var firstRowHeight = this.htEditor.getInstance().getRowHeight(0) || 23;
  var visibleRows = this.cellProperties.visibleRows;
  return this.strippedChoices.length >= visibleRows ? visibleRows * firstRowHeight : this.strippedChoices.length * firstRowHeight + 8;
};
AutocompleteEditor.prototype.stripValueIfNeeded = function(value) {
  return this.stripValuesIfNeeded([value])[0];
};
AutocompleteEditor.prototype.stripValuesIfNeeded = function(values) {
  var allowHtml = this.cellProperties.allowHtml;
  var stringifiedValues = arrayMap(values, function(value) {
    return stringify(value);
  });
  var strippedValues = arrayMap(stringifiedValues, function(value) {
    return allowHtml ? value : stripTags(value);
  });
  return strippedValues;
};
AutocompleteEditor.prototype.allowKeyEventPropagation = function(keyCode) {
  var selectedRange = this.htEditor.getSelectedRangeLast();
  var selected = {
    row: selectedRange ? selectedRange.from.row : -1
  };
  var allowed = false;
  if (keyCode === KEY_CODES.ARROW_DOWN && selected.row > 0 && selected.row < this.htEditor.countRows() - 1) {
    allowed = true;
  }
  if (keyCode === KEY_CODES.ARROW_UP && selected.row > -1) {
    allowed = true;
  }
  return allowed;
};
AutocompleteEditor.prototype.close = function() {
  this.instance.removeHook("beforeKeyDown", onBeforeKeyDown5);
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  handsontableEditor_default.prototype.close.apply(this, args);
};
AutocompleteEditor.prototype.discardEditor = function() {
  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }
  handsontableEditor_default.prototype.discardEditor.apply(this, args);
  this.instance.view.render();
};
var autocompleteEditor_default = AutocompleteEditor;

// node_modules/handsontable/es/editors/checkboxEditor.js
function _typeof13(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof13 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof13 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof13(obj);
}
function _classCallCheck26(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties25(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass25(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties25(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties25(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn7(self2, call) {
  if (call && (_typeof13(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized7(self2);
}
function _assertThisInitialized7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf7(o) {
  _getPrototypeOf7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf7(o);
}
function _inherits7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf7(subClass, superClass);
}
function _setPrototypeOf7(o, p) {
  _setPrototypeOf7 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf7(o, p);
}
var CheckboxEditor = function(_BaseEditor) {
  _inherits7(CheckboxEditor2, _BaseEditor);
  function CheckboxEditor2() {
    _classCallCheck26(this, CheckboxEditor2);
    return _possibleConstructorReturn7(this, _getPrototypeOf7(CheckboxEditor2).apply(this, arguments));
  }
  _createClass25(CheckboxEditor2, [{
    key: "beginEditing",
    value: function beginEditing(initialValue, event2) {
      if (event2 && event2.type === "mouseup") {
        var checkbox = this.TD.querySelector('input[type="checkbox"]');
        if (!hasClass(checkbox, "htBadValue")) {
          checkbox.click();
        }
      }
    }
  }, {
    key: "finishEditing",
    value: function finishEditing() {
    }
  }, {
    key: "init",
    value: function init2() {
    }
  }, {
    key: "open",
    value: function open() {
    }
  }, {
    key: "close",
    value: function close() {
    }
  }, {
    key: "getValue",
    value: function getValue() {
    }
  }, {
    key: "setValue",
    value: function setValue() {
    }
  }, {
    key: "focus",
    value: function focus() {
    }
  }]);
  return CheckboxEditor2;
}(baseEditor_default);
var checkboxEditor_default = CheckboxEditor;

// node_modules/handsontable/es/editors/dateEditor.js
var import_pikaday = __toESM(require_pikaday());
function _typeof14(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof14 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof14 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof14(obj);
}
function _classCallCheck27(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties26(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass26(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties26(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties26(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn8(self2, call) {
  if (call && (_typeof14(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized8(self2);
}
function _assertThisInitialized8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get28(target2, property2, receiver2) {
      var base = _superPropBase(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property, receiver || target);
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf8(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf8(o) {
  _getPrototypeOf8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf8(o);
}
function _inherits8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf8(subClass, superClass);
}
function _setPrototypeOf8(o, p) {
  _setPrototypeOf8 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf8(o, p);
}
var DateEditor = function(_TextEditor) {
  _inherits8(DateEditor2, _TextEditor);
  function DateEditor2(hotInstance) {
    var _this;
    _classCallCheck27(this, DateEditor2);
    _this = _possibleConstructorReturn8(this, _getPrototypeOf8(DateEditor2).call(this, hotInstance));
    _this.defaultDateFormat = "DD/MM/YYYY";
    _this.isCellEdited = false;
    _this.parentDestroyed = false;
    return _this;
  }
  _createClass26(DateEditor2, [{
    key: "init",
    value: function init2() {
      var _this2 = this;
      if (typeof moment_default !== "function") {
        throw new Error("You need to include moment.js to your project.");
      }
      if (typeof import_pikaday.default !== "function") {
        throw new Error("You need to include Pikaday to your project.");
      }
      _get(_getPrototypeOf8(DateEditor2.prototype), "init", this).call(this);
      this.instance.addHook("afterDestroy", function() {
        _this2.parentDestroyed = true;
        _this2.destroyElements();
      });
    }
    /**
     * Create data picker instance
     */
  }, {
    key: "createElements",
    value: function createElements() {
      _get(_getPrototypeOf8(DateEditor2.prototype), "createElements", this).call(this);
      this.datePicker = document.createElement("DIV");
      this.datePickerStyle = this.datePicker.style;
      this.datePickerStyle.position = "absolute";
      this.datePickerStyle.top = 0;
      this.datePickerStyle.left = 0;
      this.datePickerStyle.zIndex = 9999;
      addClass(this.datePicker, "htDatepickerHolder");
      document.body.appendChild(this.datePicker);
      this.$datePicker = new import_pikaday.default(this.getDatePickerConfig());
      var eventManager2 = new eventManager_default(this);
      eventManager2.addEventListener(this.datePicker, "mousedown", function(event2) {
        return stopPropagation(event2);
      });
      this.hideDatepicker();
    }
    /**
     * Destroy data picker instance
     */
  }, {
    key: "destroyElements",
    value: function destroyElements() {
      this.$datePicker.destroy();
    }
    /**
     * Prepare editor to appear
     *
     * @param {Number} row Row index
     * @param {Number} col Column index
     * @param {String} prop Property name (passed when datasource is an array of objects)
     * @param {HTMLTableCellElement} td Table cell element
     * @param {*} originalValue Original value
     * @param {Object} cellProperties Object with cell properties ({@see Core#getCellMeta})
     */
  }, {
    key: "prepare",
    value: function prepare(row, col, prop, td, originalValue, cellProperties) {
      _get(_getPrototypeOf8(DateEditor2.prototype), "prepare", this).call(this, row, col, prop, td, originalValue, cellProperties);
    }
    /**
     * Open editor
     *
     * @param {Event} [event=null]
     */
  }, {
    key: "open",
    value: function open() {
      var event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      _get(_getPrototypeOf8(DateEditor2.prototype), "open", this).call(this);
      this.showDatepicker(event2);
    }
    /**
     * Close editor
     */
  }, {
    key: "close",
    value: function close() {
      var _this3 = this;
      this._opened = false;
      this.instance._registerTimeout(function() {
        _this3.instance._refreshBorders();
      });
      _get(_getPrototypeOf8(DateEditor2.prototype), "close", this).call(this);
    }
    /**
     * @param {Boolean} [isCancelled=false]
     * @param {Boolean} [ctrlDown=false]
     */
  }, {
    key: "finishEditing",
    value: function finishEditing() {
      var isCancelled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var ctrlDown = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (isCancelled) {
        var value = this.originalValue;
        if (value !== void 0) {
          this.setValue(value);
        }
      }
      this.hideDatepicker();
      _get(_getPrototypeOf8(DateEditor2.prototype), "finishEditing", this).call(this, isCancelled, ctrlDown);
    }
    /**
     * Show data picker
     *
     * @param {Event} event
     */
  }, {
    key: "showDatepicker",
    value: function showDatepicker(event2) {
      this.$datePicker.config(this.getDatePickerConfig());
      var offset4 = this.TD.getBoundingClientRect();
      var dateFormat = this.cellProperties.dateFormat || this.defaultDateFormat;
      var datePickerConfig = this.$datePicker.config();
      var dateStr;
      var isMouseDown = this.instance.view.isMouseDown();
      var isMeta = event2 ? isMetaKey(event2.keyCode) : false;
      this.datePickerStyle.top = "".concat(window.pageYOffset + offset4.top + outerHeight(this.TD), "px");
      this.datePickerStyle.left = "".concat(window.pageXOffset + offset4.left, "px");
      this.$datePicker._onInputFocus = function() {
      };
      datePickerConfig.format = dateFormat;
      if (this.originalValue) {
        dateStr = this.originalValue;
        if (moment_default(dateStr, dateFormat, true).isValid()) {
          this.$datePicker.setMoment(moment_default(dateStr, dateFormat), true);
        }
        if (this.getValue() !== this.originalValue) {
          this.setValue(this.originalValue);
        }
        if (!isMeta && !isMouseDown) {
          this.setValue("");
        }
      } else if (this.cellProperties.defaultDate) {
        dateStr = this.cellProperties.defaultDate;
        datePickerConfig.defaultDate = dateStr;
        if (moment_default(dateStr, dateFormat, true).isValid()) {
          this.$datePicker.setMoment(moment_default(dateStr, dateFormat), true);
        }
        if (!isMeta && !isMouseDown) {
          this.setValue("");
        }
      } else {
        this.$datePicker.gotoToday();
      }
      this.datePickerStyle.display = "block";
      this.$datePicker.show();
    }
    /**
     * Hide data picker
     */
  }, {
    key: "hideDatepicker",
    value: function hideDatepicker() {
      this.datePickerStyle.display = "none";
      this.$datePicker.hide();
    }
    /**
     * Get date picker options.
     *
     * @returns {Object}
     */
  }, {
    key: "getDatePickerConfig",
    value: function getDatePickerConfig() {
      var _this4 = this;
      var htInput = this.TEXTAREA;
      var options = {};
      if (this.cellProperties && this.cellProperties.datePickerConfig) {
        deepExtend(options, this.cellProperties.datePickerConfig);
      }
      var origOnSelect = options.onSelect;
      var origOnClose = options.onClose;
      options.field = htInput;
      options.trigger = htInput;
      options.container = this.datePicker;
      options.bound = false;
      options.format = options.format || this.defaultDateFormat;
      options.reposition = options.reposition || false;
      options.onSelect = function(value) {
        var dateStr = value;
        if (!isNaN(dateStr.getTime())) {
          dateStr = moment_default(dateStr).format(_this4.cellProperties.dateFormat || _this4.defaultDateFormat);
        }
        _this4.setValue(dateStr);
        _this4.hideDatepicker();
        if (origOnSelect) {
          origOnSelect();
        }
      };
      options.onClose = function() {
        if (!_this4.parentDestroyed) {
          _this4.finishEditing(false);
        }
        if (origOnClose) {
          origOnClose();
        }
      };
      return options;
    }
  }]);
  return DateEditor2;
}(textEditor_default);
var dateEditor_default = DateEditor;

// node_modules/handsontable/es/editors/dropdownEditor.js
function _typeof15(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof15 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof15 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof15(obj);
}
function _classCallCheck28(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties27(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass27(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties27(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties27(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn9(self2, call) {
  if (call && (_typeof15(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized9(self2);
}
function _assertThisInitialized9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get2(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get2 = Reflect.get;
  } else {
    _get2 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase2(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get2(target, property, receiver || target);
}
function _superPropBase2(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf9(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf9(o) {
  _getPrototypeOf9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf9(o);
}
function _inherits9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf9(subClass, superClass);
}
function _setPrototypeOf9(o, p) {
  _setPrototypeOf9 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf9(o, p);
}
var DropdownEditor = function(_AutocompleteEditor) {
  _inherits9(DropdownEditor2, _AutocompleteEditor);
  function DropdownEditor2() {
    _classCallCheck28(this, DropdownEditor2);
    return _possibleConstructorReturn9(this, _getPrototypeOf9(DropdownEditor2).apply(this, arguments));
  }
  _createClass27(DropdownEditor2, [{
    key: "prepare",
    value: function prepare(row, col, prop, td, originalValue, cellProperties) {
      _get2(_getPrototypeOf9(DropdownEditor2.prototype), "prepare", this).call(this, row, col, prop, td, originalValue, cellProperties);
      this.cellProperties.filter = false;
      this.cellProperties.strict = true;
    }
  }]);
  return DropdownEditor2;
}(autocompleteEditor_default);
pluginHooks_default.getSingleton().add("beforeValidate", function(value, row, col) {
  var cellMeta = this.getCellMeta(row, this.propToCol(col));
  if (cellMeta.editor === DropdownEditor) {
    if (cellMeta.strict === void 0) {
      cellMeta.filter = false;
      cellMeta.strict = true;
    }
  }
});
var dropdownEditor_default = DropdownEditor;

// node_modules/handsontable/es/editors/numericEditor.js
function _typeof16(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof16 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof16 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof16(obj);
}
function _classCallCheck29(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn10(self2, call) {
  if (call && (_typeof16(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized10(self2);
}
function _assertThisInitialized10(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf10(o) {
  _getPrototypeOf10 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf10(o);
}
function _inherits10(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf10(subClass, superClass);
}
function _setPrototypeOf10(o, p) {
  _setPrototypeOf10 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf10(o, p);
}
var NumericEditor = function(_TextEditor) {
  _inherits10(NumericEditor2, _TextEditor);
  function NumericEditor2() {
    _classCallCheck29(this, NumericEditor2);
    return _possibleConstructorReturn10(this, _getPrototypeOf10(NumericEditor2).apply(this, arguments));
  }
  return NumericEditor2;
}(textEditor_default);
var numericEditor_default = NumericEditor;

// node_modules/handsontable/es/editors/passwordEditor.js
function _typeof17(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof17 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof17 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof17(obj);
}
function _classCallCheck30(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties28(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass28(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties28(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties28(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn11(self2, call) {
  if (call && (_typeof17(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized11(self2);
}
function _assertThisInitialized11(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get3(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get3 = Reflect.get;
  } else {
    _get3 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase3(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get3(target, property, receiver || target);
}
function _superPropBase3(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf11(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf11(o) {
  _getPrototypeOf11 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf11(o);
}
function _inherits11(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf11(subClass, superClass);
}
function _setPrototypeOf11(o, p) {
  _setPrototypeOf11 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf11(o, p);
}
var PasswordEditor = function(_TextEditor) {
  _inherits11(PasswordEditor2, _TextEditor);
  function PasswordEditor2() {
    _classCallCheck30(this, PasswordEditor2);
    return _possibleConstructorReturn11(this, _getPrototypeOf11(PasswordEditor2).apply(this, arguments));
  }
  _createClass28(PasswordEditor2, [{
    key: "createElements",
    value: function createElements() {
      _get3(_getPrototypeOf11(PasswordEditor2.prototype), "createElements", this).call(this);
      this.TEXTAREA = document.createElement("input");
      this.TEXTAREA.setAttribute("type", "password");
      this.TEXTAREA.className = "handsontableInput";
      this.textareaStyle = this.TEXTAREA.style;
      this.textareaStyle.width = 0;
      this.textareaStyle.height = 0;
      empty(this.TEXTAREA_PARENT);
      this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
    }
  }]);
  return PasswordEditor2;
}(textEditor_default);
var passwordEditor_default = PasswordEditor;

// node_modules/handsontable/es/editors/selectEditor.js
function _typeof18(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof18 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof18 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof18(obj);
}
var SelectEditor = baseEditor_default.prototype.extend();
SelectEditor.prototype.init = function() {
  this.select = document.createElement("SELECT");
  addClass(this.select, "htSelectEditor");
  this.select.style.display = "none";
  this.instance.rootElement.appendChild(this.select);
  this.registerHooks();
};
SelectEditor.prototype.registerHooks = function() {
  var _this = this;
  this.instance.addHook("afterScrollHorizontally", function() {
    return _this.refreshDimensions();
  });
  this.instance.addHook("afterScrollVertically", function() {
    return _this.refreshDimensions();
  });
  this.instance.addHook("afterColumnResize", function() {
    return _this.refreshDimensions();
  });
  this.instance.addHook("afterRowResize", function() {
    return _this.refreshDimensions();
  });
};
SelectEditor.prototype.prepare = function() {
  var _this2 = this;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  baseEditor_default.prototype.prepare.apply(this, args);
  var selectOptions = this.cellProperties.selectOptions;
  var options;
  if (typeof selectOptions === "function") {
    options = this.prepareOptions(selectOptions(this.row, this.col, this.prop));
  } else {
    options = this.prepareOptions(selectOptions);
  }
  empty(this.select);
  objectEach(options, function(value, key) {
    var optionElement = document.createElement("OPTION");
    optionElement.value = key;
    fastInnerHTML(optionElement, value);
    _this2.select.appendChild(optionElement);
  });
};
SelectEditor.prototype.prepareOptions = function(optionsToPrepare) {
  var preparedOptions = {};
  if (Array.isArray(optionsToPrepare)) {
    for (var i = 0, len = optionsToPrepare.length; i < len; i++) {
      preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
    }
  } else if (_typeof18(optionsToPrepare) === "object") {
    preparedOptions = optionsToPrepare;
  }
  return preparedOptions;
};
SelectEditor.prototype.getValue = function() {
  return this.select.value;
};
SelectEditor.prototype.setValue = function(value) {
  this.select.value = value;
};
var onBeforeKeyDown6 = function onBeforeKeyDown7(event2) {
  var instance = this;
  var editor = instance.getActiveEditor();
  var previousOptionIndex = editor.select.selectedIndex - 1;
  var nextOptionIndex = editor.select.selectedIndex + 1;
  switch (event2.keyCode) {
    case KEY_CODES.ARROW_UP:
      if (previousOptionIndex >= 0) {
        editor.select[previousOptionIndex].selected = true;
      }
      stopImmediatePropagation(event2);
      event2.preventDefault();
      break;
    case KEY_CODES.ARROW_DOWN:
      if (nextOptionIndex <= editor.select.length - 1) {
        editor.select[nextOptionIndex].selected = true;
      }
      stopImmediatePropagation(event2);
      event2.preventDefault();
      break;
    default:
      break;
  }
};
SelectEditor.prototype.open = function() {
  this._opened = true;
  this.refreshDimensions();
  this.select.style.display = "";
  this.instance.addHook("beforeKeyDown", onBeforeKeyDown6);
};
SelectEditor.prototype.close = function() {
  this._opened = false;
  this.select.style.display = "none";
  this.instance.removeHook("beforeKeyDown", onBeforeKeyDown6);
};
SelectEditor.prototype.focus = function() {
  this.select.focus();
};
SelectEditor.prototype.refreshValue = function() {
  var sourceData = this.instance.getSourceDataAtCell(this.row, this.prop);
  this.originalValue = sourceData;
  this.setValue(sourceData);
  this.refreshDimensions();
};
SelectEditor.prototype.refreshDimensions = function() {
  if (this.state !== EditorState.EDITING) {
    return;
  }
  this.TD = this.getEditedCell();
  if (!this.TD) {
    this.close();
    return;
  }
  var currentOffset = offset(this.TD);
  var containerOffset = offset(this.instance.rootElement);
  var scrollableContainer = getScrollableElement(this.TD);
  var editorSection = this.checkEditorSection();
  var width = outerWidth(this.TD) + 1;
  var height = outerHeight(this.TD) + 1;
  var editTop = currentOffset.top - containerOffset.top - 1 - (scrollableContainer.scrollTop || 0);
  var editLeft = currentOffset.left - containerOffset.left - 1 - (scrollableContainer.scrollLeft || 0);
  var cssTransformOffset;
  switch (editorSection) {
    case "top":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
      break;
    case "left":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
      break;
    case "top-left-corner":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
      break;
    case "bottom-left-corner":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
      break;
    case "bottom":
      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
      break;
    default:
      break;
  }
  if (this.instance.getSelectedLast()[0] === 0) {
    editTop += 1;
  }
  if (this.instance.getSelectedLast()[1] === 0) {
    editLeft += 1;
  }
  var selectStyle = this.select.style;
  if (cssTransformOffset && cssTransformOffset !== -1) {
    selectStyle[cssTransformOffset[0]] = cssTransformOffset[1];
  } else {
    resetCssTransform(this.select);
  }
  var cellComputedStyle = getComputedStyle2(this.TD);
  if (parseInt(cellComputedStyle.borderTopWidth, 10) > 0) {
    height -= 1;
  }
  if (parseInt(cellComputedStyle.borderLeftWidth, 10) > 0) {
    width -= 1;
  }
  selectStyle.height = "".concat(height, "px");
  selectStyle.minWidth = "".concat(width, "px");
  selectStyle.top = "".concat(editTop, "px");
  selectStyle.left = "".concat(editLeft, "px");
  selectStyle.margin = "0px";
};
SelectEditor.prototype.getEditedCell = function() {
  var editorSection = this.checkEditorSection();
  var editedCell;
  switch (editorSection) {
    case "top":
      editedCell = this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.select.style.zIndex = 101;
      break;
    case "corner":
      editedCell = this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.select.style.zIndex = 103;
      break;
    case "left":
      editedCell = this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.select.style.zIndex = 102;
      break;
    default:
      editedCell = this.instance.getCell(this.row, this.col);
      this.select.style.zIndex = "";
      break;
  }
  return editedCell !== -1 && editedCell !== -2 ? editedCell : void 0;
};
var selectEditor_default = SelectEditor;

// node_modules/handsontable/es/editors/index.js
var registeredEditorClasses = /* @__PURE__ */ new WeakMap();
var _staticRegister = staticRegister("editors");
var register = _staticRegister.register;
var getItem = _staticRegister.getItem;
var hasItem = _staticRegister.hasItem;
var getNames = _staticRegister.getNames;
var getValues = _staticRegister.getValues;
_register("base", baseEditor_default);
_register("autocomplete", autocompleteEditor_default);
_register("checkbox", checkboxEditor_default);
_register("date", dateEditor_default);
_register("dropdown", dropdownEditor_default);
_register("handsontable", handsontableEditor_default);
_register("numeric", numericEditor_default);
_register("password", passwordEditor_default);
_register("select", selectEditor_default);
_register("text", textEditor_default);
function RegisteredEditor(editorClass) {
  var instances2 = {};
  var Clazz = editorClass;
  this.getConstructor = function() {
    return editorClass;
  };
  this.getInstance = function(hotInstance) {
    if (!(hotInstance.guid in instances2)) {
      instances2[hotInstance.guid] = new Clazz(hotInstance);
    }
    return instances2[hotInstance.guid];
  };
  pluginHooks_default.getSingleton().add("afterDestroy", function() {
    instances2[this.guid] = null;
  });
}
function _getEditorInstance(name, hotInstance) {
  var editor;
  if (typeof name === "function") {
    if (!registeredEditorClasses.get(name)) {
      _register(null, name);
    }
    editor = registeredEditorClasses.get(name);
  } else if (typeof name === "string") {
    editor = getItem(name);
  } else {
    throw Error('Only strings and functions can be passed as "editor" parameter');
  }
  if (!editor) {
    throw Error('No editor registered under name "'.concat(name, '"'));
  }
  return editor.getInstance(hotInstance);
}
function _getItem(name) {
  if (!hasItem(name)) {
    throw Error('No registered editor found under "'.concat(name, '" name'));
  }
  return getItem(name).getConstructor();
}
function _register(name, editorClass) {
  var editorWrapper = new RegisteredEditor(editorClass);
  if (typeof name === "string") {
    register(name, editorWrapper);
  }
  registeredEditorClasses.set(editorClass, editorWrapper);
}

// node_modules/handsontable/es/renderers/_cellDecorator.js
function cellDecorator(instance, TD, row, col, prop, value, cellProperties) {
  var classesToAdd = [];
  var classesToRemove = [];
  if (cellProperties.className) {
    if (TD.className) {
      TD.className = "".concat(TD.className, " ").concat(cellProperties.className);
    } else {
      TD.className = cellProperties.className;
    }
  }
  if (cellProperties.readOnly) {
    classesToAdd.push(cellProperties.readOnlyCellClassName);
  }
  if (cellProperties.valid === false && cellProperties.invalidCellClassName) {
    classesToAdd.push(cellProperties.invalidCellClassName);
  } else {
    classesToRemove.push(cellProperties.invalidCellClassName);
  }
  if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {
    classesToAdd.push(cellProperties.noWordWrapClassName);
  }
  if (!value && cellProperties.placeholder) {
    classesToAdd.push(cellProperties.placeholderCellClassName);
  }
  removeClass(TD, classesToRemove);
  addClass(TD, classesToAdd);
}
var cellDecorator_default = cellDecorator;

// node_modules/handsontable/es/renderers/autocompleteRenderer.js
var clonableWRAPPER = document.createElement("DIV");
clonableWRAPPER.className = "htAutocompleteWrapper";
var clonableARROW = document.createElement("DIV");
clonableARROW.className = "htAutocompleteArrow";
clonableARROW.appendChild(document.createTextNode(String.fromCharCode(9660)));
function autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var rendererType = cellProperties.allowHtml ? "html" : "text";
  var ARROW = clonableARROW.cloneNode(true);
  for (var _len = arguments.length, args = new Array(_len > 7 ? _len - 7 : 0), _key = 7; _key < _len; _key++) {
    args[_key - 7] = arguments[_key];
  }
  _getItem2(rendererType).apply(this, [instance, TD, row, col, prop, value, cellProperties].concat(args));
  if (!TD.firstChild) {
    TD.appendChild(document.createTextNode(String.fromCharCode(160)));
  }
  TD.insertBefore(ARROW, TD.firstChild);
  addClass(TD, "htAutocomplete");
  if (!instance.acArrowListener) {
    var eventManager2 = new eventManager_default(instance);
    instance.acArrowListener = function(event2) {
      if (hasClass(event2.target, "htAutocompleteArrow")) {
        instance.view.wt.getSetting("onCellDblClick", null, new coords_default(row, col), TD);
      }
    };
    eventManager2.addEventListener(instance.rootElement, "mousedown", instance.acArrowListener);
    instance.addHookOnce("afterDestroy", function() {
      eventManager2.destroy();
    });
  }
}
var autocompleteRenderer_default = autocompleteRenderer;

// node_modules/handsontable/es/renderers/checkboxRenderer.js
var isListeningKeyDownEvent = /* @__PURE__ */ new WeakMap();
var isCheckboxListenerAdded = /* @__PURE__ */ new WeakMap();
var BAD_VALUE_CLASS = "htBadValue";
function checkboxRenderer(instance, TD, row, col, prop, value, cellProperties) {
  for (var _len = arguments.length, args = new Array(_len > 7 ? _len - 7 : 0), _key = 7; _key < _len; _key++) {
    args[_key - 7] = arguments[_key];
  }
  _getItem2("base").apply(this, [instance, TD, row, col, prop, value, cellProperties].concat(args));
  registerEvents(instance);
  var input = createInput();
  var labelOptions = cellProperties.label;
  var badValue = false;
  if (typeof cellProperties.checkedTemplate === "undefined") {
    cellProperties.checkedTemplate = true;
  }
  if (typeof cellProperties.uncheckedTemplate === "undefined") {
    cellProperties.uncheckedTemplate = false;
  }
  empty(TD);
  if (value === cellProperties.checkedTemplate || equalsIgnoreCase(value, cellProperties.checkedTemplate)) {
    input.checked = true;
  } else if (value === cellProperties.uncheckedTemplate || equalsIgnoreCase(value, cellProperties.uncheckedTemplate)) {
    input.checked = false;
  } else if (value === null) {
    addClass(input, "noValue");
  } else {
    input.style.display = "none";
    addClass(input, BAD_VALUE_CLASS);
    badValue = true;
  }
  input.setAttribute("data-row", row);
  input.setAttribute("data-col", col);
  if (!badValue && labelOptions) {
    var labelText = "";
    if (labelOptions.value) {
      labelText = typeof labelOptions.value === "function" ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;
    } else if (labelOptions.property) {
      labelText = instance.getDataAtRowProp(row, labelOptions.property);
    }
    var label = createLabel(labelText);
    if (labelOptions.position === "before") {
      label.appendChild(input);
    } else {
      label.insertBefore(input, label.firstChild);
    }
    input = label;
  }
  TD.appendChild(input);
  if (badValue) {
    TD.appendChild(document.createTextNode("#bad-value#"));
  }
  if (!isListeningKeyDownEvent.has(instance)) {
    isListeningKeyDownEvent.set(instance, true);
    instance.addHook("beforeKeyDown", onBeforeKeyDown9);
  }
  function onBeforeKeyDown9(event2) {
    var toggleKeys = "SPACE|ENTER";
    var switchOffKeys = "DELETE|BACKSPACE";
    var isKeyCode = partial(isKey, event2.keyCode);
    if (!instance.getSettings().enterBeginsEditing && isKeyCode("ENTER")) {
      return;
    }
    if (isKeyCode("".concat(toggleKeys, "|").concat(switchOffKeys)) && !isImmediatePropagationStopped(event2)) {
      eachSelectedCheckboxCell(function() {
        stopImmediatePropagation(event2);
        event2.preventDefault();
      });
    }
    if (isKeyCode(toggleKeys)) {
      changeSelectedCheckboxesState();
    }
    if (isKeyCode(switchOffKeys)) {
      changeSelectedCheckboxesState(true);
    }
  }
  function changeSelectedCheckboxesState() {
    var uncheckCheckbox = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var selRange = instance.getSelectedRangeLast();
    if (!selRange) {
      return;
    }
    var _selRange$getTopLeftC = selRange.getTopLeftCorner(), startRow = _selRange$getTopLeftC.row, startColumn = _selRange$getTopLeftC.col;
    var _selRange$getBottomRi = selRange.getBottomRightCorner(), endRow = _selRange$getBottomRi.row, endColumn = _selRange$getBottomRi.col;
    var changes = [];
    for (var visualRow = startRow; visualRow <= endRow; visualRow += 1) {
      for (var visualColumn = startColumn; visualColumn <= endColumn; visualColumn += 1) {
        var cachedCellProperties = instance.getCellMeta(visualRow, visualColumn);
        if (cachedCellProperties.type !== "checkbox") {
          return;
        }
        if (cachedCellProperties.readOnly === true) {
          continue;
        }
        if (typeof cachedCellProperties.checkedTemplate === "undefined") {
          cachedCellProperties.checkedTemplate = true;
        }
        if (typeof cachedCellProperties.uncheckedTemplate === "undefined") {
          cachedCellProperties.uncheckedTemplate = false;
        }
        var dataAtCell = instance.getDataAtCell(visualRow, visualColumn);
        if (uncheckCheckbox === false) {
          if ([cachedCellProperties.checkedTemplate, cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {
            changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
          } else if ([cachedCellProperties.uncheckedTemplate, cachedCellProperties.uncheckedTemplate.toString(), null, void 0].includes(dataAtCell)) {
            changes.push([visualRow, visualColumn, cachedCellProperties.checkedTemplate]);
          }
        } else {
          changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
        }
      }
    }
    if (changes.length > 0) {
      instance.setDataAtCell(changes);
    }
  }
  function eachSelectedCheckboxCell(callback) {
    var selRange = instance.getSelectedRangeLast();
    if (!selRange) {
      return;
    }
    var topLeft = selRange.getTopLeftCorner();
    var bottomRight = selRange.getBottomRightCorner();
    for (var visualRow = topLeft.row; visualRow <= bottomRight.row; visualRow++) {
      for (var visualColumn = topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {
        var cachedCellProperties = instance.getCellMeta(visualRow, visualColumn);
        if (cachedCellProperties.type !== "checkbox") {
          return;
        }
        var cell = instance.getCell(visualRow, visualColumn);
        if (cell === null || cell === void 0) {
          callback(visualRow, visualColumn, cachedCellProperties);
        } else {
          var checkboxes = cell.querySelectorAll("input[type=checkbox]");
          if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {
            callback(checkboxes);
          }
        }
      }
    }
  }
}
function registerEvents(instance) {
  var eventManager2 = isCheckboxListenerAdded.get(instance);
  if (!eventManager2) {
    eventManager2 = new eventManager_default(instance);
    eventManager2.addEventListener(instance.rootElement, "click", function(event2) {
      return onClick(event2, instance);
    });
    eventManager2.addEventListener(instance.rootElement, "mouseup", function(event2) {
      return onMouseUp(event2, instance);
    });
    eventManager2.addEventListener(instance.rootElement, "change", function(event2) {
      return onChange(event2, instance);
    });
    isCheckboxListenerAdded.set(instance, eventManager2);
  }
  return eventManager2;
}
function createInput() {
  var input = document.createElement("input");
  input.className = "htCheckboxRendererInput";
  input.type = "checkbox";
  input.setAttribute("autocomplete", "off");
  input.setAttribute("tabindex", "-1");
  return input.cloneNode(false);
}
function createLabel(text) {
  var label = document.createElement("label");
  label.className = "htCheckboxRendererLabel";
  label.appendChild(document.createTextNode(text));
  return label.cloneNode(true);
}
function onMouseUp(event2, instance) {
  if (!isCheckboxInput(event2.target)) {
    return;
  }
  setTimeout(instance.listen, 10);
}
function onClick(event2, instance) {
  if (!isCheckboxInput(event2.target)) {
    return false;
  }
  var row = parseInt(event2.target.getAttribute("data-row"), 10);
  var col = parseInt(event2.target.getAttribute("data-col"), 10);
  var cellProperties = instance.getCellMeta(row, col);
  if (cellProperties.readOnly) {
    event2.preventDefault();
  }
}
function onChange(event2, instance) {
  if (!isCheckboxInput(event2.target)) {
    return false;
  }
  var row = parseInt(event2.target.getAttribute("data-row"), 10);
  var col = parseInt(event2.target.getAttribute("data-col"), 10);
  var cellProperties = instance.getCellMeta(row, col);
  if (!cellProperties.readOnly) {
    var newCheckboxValue = null;
    if (event2.target.checked) {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? true : cellProperties.checkedTemplate;
    } else {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? false : cellProperties.uncheckedTemplate;
    }
    instance.setDataAtCell(row, col, newCheckboxValue);
  }
}
function isCheckboxInput(element) {
  return element.tagName === "INPUT" && element.getAttribute("type") === "checkbox";
}
var checkboxRenderer_default = checkboxRenderer;

// node_modules/handsontable/es/renderers/htmlRenderer.js
function htmlRenderer(instance, TD, row, col, prop, value) {
  for (var _len = arguments.length, args = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
    args[_key - 6] = arguments[_key];
  }
  _getItem2("base").apply(this, [instance, TD, row, col, prop, value].concat(args));
  fastInnerHTML(TD, value === null || value === void 0 ? "" : value);
}
var htmlRenderer_default = htmlRenderer;

// node_modules/numbro/dist/es/numbro.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var enUS;
var hasRequiredEnUS;
function requireEnUS() {
  if (hasRequiredEnUS) return enUS;
  hasRequiredEnUS = 1;
  enUS = {
    languageTag: "en-US",
    delimiters: {
      thousands: ",",
      decimal: "."
    },
    abbreviations: {
      thousand: "k",
      million: "m",
      billion: "b",
      trillion: "t"
    },
    spaceSeparated: false,
    ordinal: function(number) {
      let b = number % 10;
      return ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    },
    bytes: {
      binarySuffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"],
      decimalSuffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    },
    currency: {
      symbol: "$",
      position: "prefix",
      code: "USD"
    },
    currencyFormat: {
      thousandSeparated: true,
      totalLength: 4,
      spaceSeparated: true,
      spaceSeparatedCurrency: true
    },
    formats: {
      fourDigits: {
        totalLength: 4,
        spaceSeparated: true
      },
      fullWithTwoDecimals: {
        output: "currency",
        thousandSeparated: true,
        mantissa: 2
      },
      fullWithTwoDecimalsNoCurrency: {
        thousandSeparated: true,
        mantissa: 2
      },
      fullWithNoDecimals: {
        output: "currency",
        thousandSeparated: true,
        mantissa: 0
      }
    }
  };
  return enUS;
}
var unformatting;
var hasRequiredUnformatting;
function requireUnformatting() {
  if (hasRequiredUnformatting) return unformatting;
  hasRequiredUnformatting = 1;
  const allSuffixes = [
    { key: "ZiB", factor: Math.pow(1024, 7) },
    { key: "ZB", factor: Math.pow(1e3, 7) },
    { key: "YiB", factor: Math.pow(1024, 8) },
    { key: "YB", factor: Math.pow(1e3, 8) },
    { key: "TiB", factor: Math.pow(1024, 4) },
    { key: "TB", factor: Math.pow(1e3, 4) },
    { key: "PiB", factor: Math.pow(1024, 5) },
    { key: "PB", factor: Math.pow(1e3, 5) },
    { key: "MiB", factor: Math.pow(1024, 2) },
    { key: "MB", factor: Math.pow(1e3, 2) },
    { key: "KiB", factor: Math.pow(1024, 1) },
    { key: "KB", factor: Math.pow(1e3, 1) },
    { key: "GiB", factor: Math.pow(1024, 3) },
    { key: "GB", factor: Math.pow(1e3, 3) },
    { key: "EiB", factor: Math.pow(1024, 6) },
    { key: "EB", factor: Math.pow(1e3, 6) },
    { key: "B", factor: 1 }
  ];
  function escapeRegExp(s) {
    return s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function computeUnformattedValue(inputString, delimiters, currencySymbol, ordinal3, zeroFormat, abbreviations, format4) {
    if (!isNaN(+inputString)) {
      return +inputString;
    }
    let stripped = "";
    let newInput = inputString.replace(/(^[^(]*)\((.*)\)([^)]*$)/, "$1$2$3");
    if (newInput !== inputString) {
      return -1 * computeUnformattedValue(newInput, delimiters, currencySymbol, ordinal3, zeroFormat, abbreviations);
    }
    for (let i = 0; i < allSuffixes.length; i++) {
      let suffix = allSuffixes[i];
      stripped = inputString.replace(RegExp(`([0-9 ])(${suffix.key})$`), "$1");
      if (stripped !== inputString) {
        return computeUnformattedValue(stripped, delimiters, currencySymbol, ordinal3, zeroFormat, abbreviations) * suffix.factor;
      }
    }
    stripped = inputString.replace("%", "");
    if (stripped !== inputString) {
      return computeUnformattedValue(stripped, delimiters, currencySymbol, ordinal3, zeroFormat, abbreviations) / 100;
    }
    let possibleOrdinalValue = parseFloat(inputString);
    if (isNaN(possibleOrdinalValue)) {
      return void 0;
    }
    let ordinalString = ordinal3(possibleOrdinalValue);
    if (ordinalString && ordinalString !== ".") {
      stripped = inputString.replace(new RegExp(`${escapeRegExp(ordinalString)}$`), "");
      if (stripped !== inputString) {
        return computeUnformattedValue(stripped, delimiters, currencySymbol, ordinal3, zeroFormat, abbreviations);
      }
    }
    let inversedAbbreviations = {};
    Object.keys(abbreviations).forEach((key) => {
      inversedAbbreviations[abbreviations[key]] = key;
    });
    let abbreviationValues = Object.keys(inversedAbbreviations).sort().reverse();
    let numberOfAbbreviations = abbreviationValues.length;
    for (let i = 0; i < numberOfAbbreviations; i++) {
      let value = abbreviationValues[i];
      let key = inversedAbbreviations[value];
      stripped = inputString.replace(value, "");
      if (stripped !== inputString) {
        let factor = void 0;
        switch (key) {
          case "thousand":
            factor = Math.pow(10, 3);
            break;
          case "million":
            factor = Math.pow(10, 6);
            break;
          case "billion":
            factor = Math.pow(10, 9);
            break;
          case "trillion":
            factor = Math.pow(10, 12);
            break;
        }
        return computeUnformattedValue(stripped, delimiters, currencySymbol, ordinal3, zeroFormat, abbreviations) * factor;
      }
    }
    return void 0;
  }
  function removeFormattingSymbols(inputString, delimiters, currencySymbol) {
    let stripped = inputString.replace(currencySymbol, "");
    stripped = stripped.replace(new RegExp(`([0-9])${escapeRegExp(delimiters.thousands)}([0-9])`, "g"), "$1$2");
    stripped = stripped.replace(delimiters.decimal, ".");
    return stripped;
  }
  function unformatValue(inputString, delimiters, currencySymbol = "", ordinal3, zeroFormat, abbreviations, format4) {
    if (inputString === "") {
      return void 0;
    }
    if (inputString === zeroFormat) {
      return 0;
    }
    let value = removeFormattingSymbols(inputString, delimiters, currencySymbol);
    return computeUnformattedValue(value, delimiters, currencySymbol, ordinal3, zeroFormat, abbreviations);
  }
  function matchesTime(inputString, delimiters) {
    let separators = inputString.indexOf(":") && delimiters.thousands !== ":";
    if (!separators) {
      return false;
    }
    let segments = inputString.split(":");
    if (segments.length !== 3) {
      return false;
    }
    let hours3 = +segments[0];
    let minutes3 = +segments[1];
    let seconds3 = +segments[2];
    return !isNaN(hours3) && !isNaN(minutes3) && !isNaN(seconds3);
  }
  function unformatTime(inputString) {
    let segments = inputString.split(":");
    let hours3 = +segments[0];
    let minutes3 = +segments[1];
    let seconds3 = +segments[2];
    return seconds3 + 60 * minutes3 + 3600 * hours3;
  }
  function unformat(inputString, format4) {
    const globalState2 = requireGlobalState();
    let delimiters = globalState2.currentDelimiters();
    let currencySymbol = globalState2.currentCurrency().symbol;
    let ordinal3 = globalState2.currentOrdinal();
    let zeroFormat = globalState2.getZeroFormat();
    let abbreviations = globalState2.currentAbbreviations();
    let value = void 0;
    if (typeof inputString === "string") {
      if (matchesTime(inputString, delimiters)) {
        value = unformatTime(inputString);
      } else {
        value = unformatValue(inputString, delimiters, currencySymbol, ordinal3, zeroFormat, abbreviations);
      }
    } else if (typeof inputString === "number") {
      value = inputString;
    } else {
      return void 0;
    }
    if (value === void 0) {
      return void 0;
    }
    return value;
  }
  unformatting = {
    unformat
  };
  return unformatting;
}
var validating$1;
var hasRequiredValidating;
function requireValidating() {
  if (hasRequiredValidating) return validating$1;
  hasRequiredValidating = 1;
  let unformatter2 = requireUnformatting();
  const bcp47RegExp = /^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/;
  const validOutputValues = [
    "currency",
    "percent",
    "byte",
    "time",
    "ordinal",
    "number"
  ];
  const validForceAverageValues = [
    "trillion",
    "billion",
    "million",
    "thousand"
  ];
  const validCurrencyPosition = [
    "prefix",
    "infix",
    "postfix"
  ];
  const validNegativeValues = [
    "sign",
    "parenthesis"
  ];
  const validMandatoryAbbreviations = {
    type: "object",
    children: {
      thousand: {
        type: "string",
        mandatory: true
      },
      million: {
        type: "string",
        mandatory: true
      },
      billion: {
        type: "string",
        mandatory: true
      },
      trillion: {
        type: "string",
        mandatory: true
      }
    },
    mandatory: true
  };
  const validAbbreviations = {
    type: "object",
    children: {
      thousand: "string",
      million: "string",
      billion: "string",
      trillion: "string"
    }
  };
  const validBaseValues = [
    "decimal",
    "binary",
    "general"
  ];
  const validFormat = {
    output: {
      type: "string",
      validValues: validOutputValues
    },
    base: {
      type: "string",
      validValues: validBaseValues,
      restriction: (number, format4) => format4.output === "byte",
      message: "`base` must be provided only when the output is `byte`",
      mandatory: (format4) => format4.output === "byte"
    },
    characteristic: {
      type: "number",
      restriction: (number) => number >= 0,
      message: "value must be positive"
    },
    prefix: "string",
    postfix: "string",
    forceAverage: {
      type: "string",
      validValues: validForceAverageValues
    },
    average: "boolean",
    lowPrecision: {
      type: "boolean",
      restriction: (number, format4) => format4.average === true,
      message: "`lowPrecision` must be provided only when the option `average` is set"
    },
    currencyPosition: {
      type: "string",
      validValues: validCurrencyPosition
    },
    currencySymbol: "string",
    totalLength: {
      type: "number",
      restrictions: [
        {
          restriction: (number) => number >= 0,
          message: "value must be positive"
        },
        {
          restriction: (number, format4) => !format4.exponential,
          message: "`totalLength` is incompatible with `exponential`"
        }
      ]
    },
    mantissa: {
      type: "number",
      restriction: (number) => number >= 0,
      message: "value must be positive"
    },
    optionalMantissa: "boolean",
    trimMantissa: "boolean",
    roundingFunction: "function",
    optionalCharacteristic: "boolean",
    thousandSeparated: "boolean",
    spaceSeparated: "boolean",
    spaceSeparatedCurrency: "boolean",
    spaceSeparatedAbbreviation: "boolean",
    abbreviations: validAbbreviations,
    negative: {
      type: "string",
      validValues: validNegativeValues
    },
    forceSign: "boolean",
    exponential: {
      type: "boolean"
    },
    prefixSymbol: {
      type: "boolean",
      restriction: (number, format4) => format4.output === "percent",
      message: "`prefixSymbol` can be provided only when the output is `percent`"
    }
  };
  const validLanguage = {
    languageTag: {
      type: "string",
      mandatory: true,
      restriction: (tag) => {
        return tag.match(bcp47RegExp);
      },
      message: "the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)"
    },
    delimiters: {
      type: "object",
      children: {
        thousands: "string",
        decimal: "string",
        thousandsSize: "number"
      },
      mandatory: true
    },
    abbreviations: validMandatoryAbbreviations,
    spaceSeparated: "boolean",
    spaceSeparatedCurrency: "boolean",
    ordinal: {
      type: "function",
      mandatory: true
    },
    bytes: {
      type: "object",
      children: {
        binarySuffixes: "object",
        decimalSuffixes: "object"
      }
    },
    currency: {
      type: "object",
      children: {
        symbol: "string",
        position: "string",
        code: "string"
      },
      mandatory: true
    },
    defaults: "format",
    ordinalFormat: "format",
    byteFormat: "format",
    percentageFormat: "format",
    currencyFormat: "format",
    timeDefaults: "format",
    formats: {
      type: "object",
      children: {
        fourDigits: {
          type: "format",
          mandatory: true
        },
        fullWithTwoDecimals: {
          type: "format",
          mandatory: true
        },
        fullWithTwoDecimalsNoCurrency: {
          type: "format",
          mandatory: true
        },
        fullWithNoDecimals: {
          type: "format",
          mandatory: true
        }
      }
    }
  };
  function validate(input, format4) {
    let validInput = validateInput(input);
    let isFormatValid = validateFormat(format4);
    return validInput && isFormatValid;
  }
  function validateInput(input) {
    let value = unformatter2.unformat(input);
    return value !== void 0;
  }
  function validateSpec(toValidate, spec, prefix, skipMandatoryCheck = false) {
    let results = Object.keys(toValidate).map((key) => {
      if (!spec[key]) {
        console.error(`${prefix} Invalid key: ${key}`);
        return false;
      }
      let value = toValidate[key];
      let data = spec[key];
      if (typeof data === "string") {
        data = { type: data };
      }
      if (data.type === "format") {
        let valid = validateSpec(value, validFormat, `[Validate ${key}]`, true);
        if (!valid) {
          return false;
        }
      } else if (typeof value !== data.type) {
        console.error(`${prefix} ${key} type mismatched: "${data.type}" expected, "${typeof value}" provided`);
        return false;
      }
      if (data.restrictions && data.restrictions.length) {
        let length = data.restrictions.length;
        for (let i = 0; i < length; i++) {
          let { restriction, message } = data.restrictions[i];
          if (!restriction(value, toValidate)) {
            console.error(`${prefix} ${key} invalid value: ${message}`);
            return false;
          }
        }
      }
      if (data.restriction && !data.restriction(value, toValidate)) {
        console.error(`${prefix} ${key} invalid value: ${data.message}`);
        return false;
      }
      if (data.validValues && data.validValues.indexOf(value) === -1) {
        console.error(`${prefix} ${key} invalid value: must be among ${JSON.stringify(data.validValues)}, "${value}" provided`);
        return false;
      }
      if (data.children) {
        let valid = validateSpec(value, data.children, `[Validate ${key}]`);
        if (!valid) {
          return false;
        }
      }
      return true;
    });
    if (!skipMandatoryCheck) {
      results.push(...Object.keys(spec).map((key) => {
        let data = spec[key];
        if (typeof data === "string") {
          data = { type: data };
        }
        if (data.mandatory) {
          let mandatory = data.mandatory;
          if (typeof mandatory === "function") {
            mandatory = mandatory(toValidate);
          }
          if (mandatory && toValidate[key] === void 0) {
            console.error(`${prefix} Missing mandatory key "${key}"`);
            return false;
          }
        }
        return true;
      }));
    }
    return results.reduce((acc, current) => {
      return acc && current;
    }, true);
  }
  function validateFormat(format4) {
    return validateSpec(format4, validFormat, "[Validate format]");
  }
  function validateLanguage(language) {
    return validateSpec(language, validLanguage, "[Validate language]");
  }
  validating$1 = {
    validate,
    validateFormat,
    validateInput,
    validateLanguage
  };
  return validating$1;
}
function parsePrefix(string, result) {
  let match = string.match(/^{([^}]*)}/);
  if (match) {
    result.prefix = match[1];
    return string.slice(match[0].length);
  }
  return string;
}
function parsePostfix(string, result) {
  let match = string.match(/{([^}]*)}$/);
  if (match) {
    result.postfix = match[1];
    return string.slice(0, -match[0].length);
  }
  return string;
}
function parseOutput(string, result) {
  if (string.indexOf("$") !== -1) {
    result.output = "currency";
    return;
  }
  if (string.indexOf("%") !== -1) {
    result.output = "percent";
    return;
  }
  if (string.indexOf("bd") !== -1) {
    result.output = "byte";
    result.base = "general";
    return;
  }
  if (string.indexOf("b") !== -1) {
    result.output = "byte";
    result.base = "binary";
    return;
  }
  if (string.indexOf("d") !== -1) {
    result.output = "byte";
    result.base = "decimal";
    return;
  }
  if (string.indexOf(":") !== -1) {
    result.output = "time";
    return;
  }
  if (string.indexOf("o") !== -1) {
    result.output = "ordinal";
  }
}
function parseThousandSeparated(string, result) {
  if (string.indexOf(",") !== -1) {
    result.thousandSeparated = true;
  }
}
function parseSpaceSeparated(string, result) {
  if (string.indexOf(" ") !== -1) {
    result.spaceSeparated = true;
    result.spaceSeparatedCurrency = true;
    if (result.average || result.forceAverage) {
      result.spaceSeparatedAbbreviation = true;
    }
  }
}
function parseTotalLength(string, result) {
  let match = string.match(/[1-9]+[0-9]*/);
  if (match) {
    result.totalLength = +match[0];
  }
}
function parseCharacteristic(string, result) {
  let characteristic = string.split(".")[0];
  let match = characteristic.match(/0+/);
  if (match) {
    result.characteristic = match[0].length;
  }
}
function parseMantissa(string, result) {
  let mantissa = string.split(".")[1];
  if (mantissa) {
    let match = mantissa.match(/0+/);
    if (match) {
      result.mantissa = match[0].length;
    }
  }
}
function parseTrimMantissa(string, result) {
  const mantissa = string.split(".")[1];
  if (mantissa) {
    result.trimMantissa = mantissa.indexOf("[") !== -1;
  }
}
function parseAverage(string, result) {
  if (string.indexOf("a") !== -1) {
    result.average = true;
  }
}
function parseForceAverage(string, result) {
  if (string.indexOf("K") !== -1) {
    result.forceAverage = "thousand";
  } else if (string.indexOf("M") !== -1) {
    result.forceAverage = "million";
  } else if (string.indexOf("B") !== -1) {
    result.forceAverage = "billion";
  } else if (string.indexOf("T") !== -1) {
    result.forceAverage = "trillion";
  }
}
function parseOptionalMantissa(string, result) {
  if (string.match(/\[\.]/)) {
    result.optionalMantissa = true;
  } else if (string.match(/\./)) {
    result.optionalMantissa = false;
  }
}
function parseOptionalCharacteristic(string, result) {
  if (string.indexOf(".") !== -1) {
    let characteristic = string.split(".")[0];
    result.optionalCharacteristic = characteristic.indexOf("0") === -1;
  }
}
function parseNegative(string, result) {
  if (string.match(/^\+?\([^)]*\)$/)) {
    result.negative = "parenthesis";
  }
  if (string.match(/^\+?-/)) {
    result.negative = "sign";
  }
}
function parseForceSign(string, result) {
  if (string.match(/^\+/)) {
    result.forceSign = true;
  }
}
function parseFormat(string, result = {}) {
  if (typeof string !== "string") {
    return string;
  }
  string = parsePrefix(string, result);
  string = parsePostfix(string, result);
  parseOutput(string, result);
  parseTotalLength(string, result);
  parseCharacteristic(string, result);
  parseOptionalCharacteristic(string, result);
  parseAverage(string, result);
  parseForceAverage(string, result);
  parseMantissa(string, result);
  parseOptionalMantissa(string, result);
  parseTrimMantissa(string, result);
  parseThousandSeparated(string, result);
  parseSpaceSeparated(string, result);
  parseNegative(string, result);
  parseForceSign(string, result);
  return result;
}
var parsing$2 = {
  parseFormat
};
var globalState$2;
var hasRequiredGlobalState;
function requireGlobalState() {
  if (hasRequiredGlobalState) return globalState$2;
  hasRequiredGlobalState = 1;
  const enUS2 = requireEnUS();
  const validating2 = requireValidating();
  const parsing2 = parsing$2;
  let state = {};
  let currentLanguageTag = void 0;
  let languages = {};
  let zeroFormat = null;
  let globalDefaults = {};
  function chooseLanguage(tag) {
    currentLanguageTag = tag;
  }
  function currentLanguageData() {
    return languages[currentLanguageTag];
  }
  state.languages = () => Object.assign({}, languages);
  state.currentLanguage = () => currentLanguageTag;
  state.currentBytes = () => currentLanguageData().bytes || {};
  state.currentCurrency = () => currentLanguageData().currency;
  state.currentAbbreviations = () => currentLanguageData().abbreviations;
  state.currentDelimiters = () => currentLanguageData().delimiters;
  state.currentOrdinal = () => currentLanguageData().ordinal;
  state.currentDefaults = () => Object.assign({}, currentLanguageData().defaults, globalDefaults);
  state.currentOrdinalDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().ordinalFormat);
  state.currentByteDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().byteFormat);
  state.currentPercentageDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().percentageFormat);
  state.currentCurrencyDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().currencyFormat);
  state.currentTimeDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().timeFormat);
  state.setDefaults = (format4) => {
    format4 = parsing2.parseFormat(format4);
    if (validating2.validateFormat(format4)) {
      globalDefaults = format4;
    }
  };
  state.getZeroFormat = () => zeroFormat;
  state.setZeroFormat = (string) => zeroFormat = typeof string === "string" ? string : null;
  state.hasZeroFormat = () => zeroFormat !== null;
  state.languageData = (tag) => {
    if (tag) {
      if (languages[tag]) {
        return languages[tag];
      }
      throw new Error(`Unknown tag "${tag}"`);
    }
    return currentLanguageData();
  };
  state.registerLanguage = (data, useLanguage = false) => {
    if (!validating2.validateLanguage(data)) {
      throw new Error("Invalid language data");
    }
    languages[data.languageTag] = data;
    if (useLanguage) {
      chooseLanguage(data.languageTag);
    }
  };
  state.setLanguage = (tag, fallbackTag = enUS2.languageTag) => {
    if (!languages[tag]) {
      let suffix = tag.split("-")[0];
      let matchingLanguageTag = Object.keys(languages).find((each) => {
        return each.split("-")[0] === suffix;
      });
      if (!languages[matchingLanguageTag]) {
        chooseLanguage(fallbackTag);
        return;
      }
      chooseLanguage(matchingLanguageTag);
      return;
    }
    chooseLanguage(tag);
  };
  state.registerLanguage(enUS2);
  currentLanguageTag = enUS2.languageTag;
  globalState$2 = state;
  return globalState$2;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
function loadLanguagesInNode(tags, numbro2) {
  tags.forEach((tag) => {
    let data = void 0;
    try {
      data = commonjsRequire(`../languages/${tag}`);
    } catch (e) {
      console.error(`Unable to load "${tag}". No matching language file found.`);
    }
    if (data) {
      numbro2.registerLanguage(data);
    }
  });
}
var loading = (numbro2) => ({
  loadLanguagesInNode: (tags) => loadLanguagesInNode(tags, numbro2)
});
var bignumber = { exports: {} };
(function(module2) {
  (function(globalObject) {
    var BigNumber2, isNumeric2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone5(configObject) {
      var div, convertBase, parseNumeric, P = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: " ",
        // non-breaking space
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber3(v, b) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber3)) return new BigNumber3(v, b);
        if (b == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (v.e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v; i >= 10; i /= 10, e++) ;
              if (e > MAX_EXP) {
                x.c = x.e = null;
              } else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric2.test(str = String(v))) return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0) e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          if (b == 10 && alphabetHasNormalDecimalDigits) {
            x = new BigNumber3(v);
            return round3(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet = ALPHABET.slice(0, b);
          e = i = 0;
          for (len = str.length; i < len; i++) {
            if (alphabet.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x, String(v), isNum, b);
            }
          }
          isNum = false;
          str = convertBase(str, b, 10, x.s);
          if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
          else e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++) ;
        for (len = str.length; str.charCodeAt(--len) === 48; ) ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber3.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x.c = x.e = null;
          } else if (e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0) i += LOG_BASE;
            if (i < len) {
              if (i) x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE; i < len; ) {
                x.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (; i--; str += "0") ;
            x.c.push(+str);
          }
        } else {
          x.c = [x.e = 0];
        }
      }
      BigNumber3.clone = clone5;
      BigNumber3.ROUND_UP = 0;
      BigNumber3.ROUND_DOWN = 1;
      BigNumber3.ROUND_CEIL = 2;
      BigNumber3.ROUND_FLOOR = 3;
      BigNumber3.ROUND_HALF_UP = 4;
      BigNumber3.ROUND_HALF_DOWN = 5;
      BigNumber3.ROUND_HALF_EVEN = 6;
      BigNumber3.ROUND_HALF_CEIL = 7;
      BigNumber3.ROUND_HALF_FLOOR = 8;
      BigNumber3.EUCLID = 9;
      BigNumber3.config = BigNumber3.set = function(obj) {
        var p, v;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              DECIMAL_PLACES = v;
            }
            if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
              v = obj[p];
              intCheck(v, 0, 8, p);
              ROUNDING_MODE = v;
            }
            if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p);
                intCheck(v[1], 0, MAX, p);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj.hasOwnProperty(p = "RANGE")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p);
                intCheck(v[1], 1, MAX, p);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p + " cannot be zero: " + v);
                }
              }
            }
            if (obj.hasOwnProperty(p = "CRYPTO")) {
              v = obj[p];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p + " not true or false: " + v);
              }
            }
            if (obj.hasOwnProperty(p = "MODULO_MODE")) {
              v = obj[p];
              intCheck(v, 0, 9, p);
              MODULO_MODE = v;
            }
            if (obj.hasOwnProperty(p = "POW_PRECISION")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              POW_PRECISION = v;
            }
            if (obj.hasOwnProperty(p = "FORMAT")) {
              v = obj[p];
              if (typeof v == "object") FORMAT = v;
              else throw Error(bignumberError + p + " not an object: " + v);
            }
            if (obj.hasOwnProperty(p = "ALPHABET")) {
              v = obj[p];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                ALPHABET = v;
              } else {
                throw Error(bignumberError + p + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber3.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true) return false;
        if (!BigNumber3.DEBUG) return true;
        var i, n, c = v.c, e = v.e, s = v.s;
        out: if ({}.toString.call(c) == "[object Array]") {
          if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
            if (c[0] === 0) {
              if (e === 0 && c.length === 1) return true;
              break out;
            }
            i = (e + 1) % LOG_BASE;
            if (i < 1) i += LOG_BASE;
            if (String(c[0]).length == i) {
              for (i = 0; i < c.length; i++) {
                n = c[i];
                if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
              }
              if (n !== 0) return true;
            }
          }
        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
          return true;
        }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber3.maximum = BigNumber3.max = function() {
        return maxOrMin(arguments, -1);
      };
      BigNumber3.minimum = BigNumber3.min = function() {
        return maxOrMin(arguments, 1);
      };
      BigNumber3.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b, e, k, v, i = 0, c = [], rand = new BigNumber3(ONE);
          if (dp == null) dp = DECIMAL_PLACES;
          else intCheck(dp, 0, MAX);
          k = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k *= 2));
              for (; i < k; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9e15) {
                  b = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b[0];
                  a[i + 1] = b[1];
                } else {
                  c.push(v % 1e14);
                  i += 2;
                }
              }
              i = k / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k *= 7);
              for (; i < k; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9e15) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v % 1e14);
                  i += 7;
                }
              }
              i = k / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i < k; ) {
              v = random53bitInt();
              if (v < 9e15) c[i++] = v % 1e14;
            }
          }
          k = c[--i];
          dp %= LOG_BASE;
          if (k && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k / v) * v;
          }
          for (; c[i] === 0; c.pop(), i--) ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
            for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
            if (i < LOG_BASE) e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber3.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber3(args[0]);
        for (; i < args.length; ) sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = /* @__PURE__ */ function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet) {
          var j, arr = [0], arrL, i = 0, len = str.length;
          for (; i < len; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
            arr[0] += alphabet.indexOf(str.charAt(i++));
            for (j = 0; j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] == null) arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign3, callerIsToString) {
          var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y = new BigNumber3(baseIn);
            x = y.pow(str.length - i);
            POW_PRECISION = k;
            y.c = toBaseOut(
              toFixedPoint(coeffToString(x.c), x.e, "0"),
              10,
              baseOut,
              decimal
            );
            y.e = y.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
          e = k = xc.length;
          for (; xc[--k] == 0; xc.pop()) ;
          if (!xc[0]) return alphabet.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign3;
            x = div(x, y, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
          } else {
            xc.length = d;
            if (r) {
              for (--baseOut; ++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k = xc.length; !xc[--k]; ) ;
            for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
            str = toFixedPoint(str, e, alphabet.charAt(0));
          }
          return str;
        };
      }();
      div = /* @__PURE__ */ function() {
        function multiply2(x, k, base) {
          var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
          for (x = x.slice(); i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m = khi * xlo + xhi * klo;
            temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base;
          }
          if (carry) x = [carry].concat(x);
          return x;
        }
        function compare2(a, b, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                cmp = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract5(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
        }
        return function(x, y, dp, rm, base) {
          var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber3(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                xc && xc[0] == 0 || !yc ? s * 0 : s / 0
              )
            );
          }
          q = new BigNumber3(s);
          qc = q.c = [];
          e = x.e - y.e;
          s = dp + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
            s = s / LOG_BASE | 0;
          }
          for (i = 0; yc[i] == (xc[i] || 0); i++) ;
          if (yc[i] > (xc[i] || 0)) e--;
          if (s < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s += 2;
            n = mathfloor(base / (yc[0] + 1));
            if (n > 1) {
              yc = multiply2(yc, n, base);
              xc = multiply2(xc, n, base);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0) ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base / 2) yc0++;
            do {
              n = 0;
              cmp = compare2(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base) n = base - 1;
                  prod = multiply2(yc, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare2(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract5(prod, yL < prodL ? yz : yc, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL) prod = [0].concat(prod);
                subtract5(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare2(yc, rem, yL, remL) < 1) {
                    n++;
                    subtract5(rem, yL < remL ? yz : yc, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s--);
            more = rem[0] != null;
            if (!qc[0]) qc.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
            round3(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format4(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        if (!n.c) return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round3(new BigNumber3(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (; len < i; str += "0", len++) ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0) for (str += "."; i--; str += "0") ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len) str += ".";
                for (; i--; str += "0") ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, n) {
        var k, y, i = 1, x = new BigNumber3(args[0]);
        for (; i < args.length; i++) {
          y = new BigNumber3(args[i]);
          if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
            x = y;
          }
        }
        return x;
      }
      function normalise(n, c, e) {
        var i = 1, j = c.length;
        for (; !c[--j]; c.pop()) ;
        for (j = c[0]; j >= 10; j /= 10, i++) ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = /* @__PURE__ */ function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
          var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s)) {
            x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s = s.replace(basePrefix, function(m, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b || b == base ? p1 : m;
              });
              if (b) {
                base = b;
                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s) return new BigNumber3(s, base);
            }
            if (BigNumber3.DEBUG) {
              throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
            }
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round3(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
            i = sd - d;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              n = xc[ni = 0];
              rd = mathfloor(n / pows10[d - j - 1] % 10);
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r) {
                  for (; xc.length <= ni; xc.push(0)) ;
                  n = rd = 0;
                  d = 1;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k = xc[ni];
                for (d = 1; k >= 10; k /= 10, d++) ;
                i %= LOG_BASE;
                j = i - LOG_BASE + d;
                rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
              }
            }
            r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
            r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r) {
                sd -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x.e = -sd || 0;
              } else {
                xc[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k = pows10[LOG_BASE - i];
              xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
            }
            if (r) {
              for (; ; ) {
                if (ni == 0) {
                  for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                  j = xc[0] += k;
                  for (k = 1; j >= 10; j /= 10, k++) ;
                  if (i != k) {
                    x.e++;
                    if (xc[0] == BASE) xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k;
                  if (xc[ni] != BASE) break;
                  xc[ni--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xc.length; xc[--i] === 0; xc.pop()) ;
          }
          if (x.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (x.e < MIN_EXP) {
            x.c = [x.e = 0];
          }
        }
        return x;
      }
      function valueOf4(n) {
        var str, e = n.e;
        if (e === null) return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P.absoluteValue = P.abs = function() {
        var x = new BigNumber3(this);
        if (x.s < 0) x.s = 1;
        return x;
      };
      P.comparedTo = function(y, b) {
        return compare(this, new BigNumber3(y, b));
      };
      P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round3(new BigNumber3(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c)) return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
        if (n < 0) n = 0;
        return n;
      };
      P.dividedBy = P.div = function(y, b) {
        return div(this, new BigNumber3(y, b), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P.dividedToIntegerBy = P.idiv = function(y, b) {
        return div(this, new BigNumber3(y, b), 0, 1);
      };
      P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
        n = new BigNumber3(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf4(n));
        }
        if (m != null) m = new BigNumber3(m);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y = new BigNumber3(Math.pow(+valueOf4(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf4(n)));
          return m ? y.mod(m) : y;
        }
        nIsNeg = n.s < 0;
        if (m) {
          if (m.c ? !m.c[0] : !m.s) return new BigNumber3(NaN);
          isModExp = !nIsNeg && x.isInteger() && m.isInteger();
          if (isModExp) x = x.mod(m);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
          k = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1) k = 1 / k;
          return new BigNumber3(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
          k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber3(0.5);
          if (nIsNeg) n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf4(n));
          nIsOdd = i % 2;
        }
        y = new BigNumber3(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y = y.times(x);
            if (!y.c) break;
            if (k) {
              if (y.c.length > k) y.c.length = k;
            } else if (isModExp) {
              y = y.mod(m);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0) break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round3(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf4(n);
              if (i === 0) break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k) {
            if (x.c && x.c.length > k) x.c.length = k;
          } else if (isModExp) {
            x = x.mod(m);
          }
        }
        if (isModExp) return y;
        if (nIsNeg) y = ONE.div(y);
        return m ? y.mod(m) : k ? round3(y, POW_PRECISION, ROUNDING_MODE, more) : y;
      };
      P.integerValue = function(rm) {
        var n = new BigNumber3(this);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        return round3(n, n.e + 1, rm);
      };
      P.isEqualTo = P.eq = function(y, b) {
        return compare(this, new BigNumber3(y, b)) === 0;
      };
      P.isFinite = function() {
        return !!this.c;
      };
      P.isGreaterThan = P.gt = function(y, b) {
        return compare(this, new BigNumber3(y, b)) > 0;
      };
      P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
        return (b = compare(this, new BigNumber3(y, b))) === 1 || b === 0;
      };
      P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P.isLessThan = P.lt = function(y, b) {
        return compare(this, new BigNumber3(y, b)) < 0;
      };
      P.isLessThanOrEqualTo = P.lte = function(y, b) {
        return (b = compare(this, new BigNumber3(y, b))) === -1 || b === 0;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = function() {
        return this.s < 0;
      };
      P.isPositive = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P.minus = function(y, b) {
        var i, j, t, xLTy, x = this, a = x.s;
        y = new BigNumber3(y, b);
        b = y.s;
        if (!a || !b) return new BigNumber3(NaN);
        if (a != b) {
          y.s = -b;
          return x.plus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber3(yc ? x : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y.s = -b, y) : new BigNumber3(xc[0] ? x : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              ROUNDING_MODE == 3 ? -0 : 0
            ));
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b = a; b--; t.push(0)) ;
          t.reverse();
        } else {
          j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
          for (a = b = 0; b < j; b++) {
            if (xc[b] != yc[b]) {
              xLTy = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xLTy) {
          t = xc;
          xc = yc;
          yc = t;
          y.s = -y.s;
        }
        b = (j = yc.length) - (i = xc.length);
        if (b > 0) for (; b--; xc[i++] = 0) ;
        b = BASE - 1;
        for (; j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j; i && !xc[--i]; xc[i] = b) ;
            --xc[i];
            xc[j] += BASE;
          }
          xc[j] -= yc[j];
        }
        for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
        if (!xc[0]) {
          y.s = ROUNDING_MODE == 3 ? -1 : 1;
          y.c = [y.e = 0];
          return y;
        }
        return normalise(y, xc, ye);
      };
      P.modulo = P.mod = function(y, b) {
        var q, s, x = this;
        y = new BigNumber3(y, b);
        if (!x.c || !y.s || y.c && !y.c[0]) {
          return new BigNumber3(NaN);
        } else if (!y.c || x.c && !x.c[0]) {
          return new BigNumber3(x);
        }
        if (MODULO_MODE == 9) {
          s = y.s;
          y.s = 1;
          q = div(x, y, 0, 3);
          y.s = s;
          q.s *= s;
        } else {
          q = div(x, y, 0, MODULO_MODE);
        }
        y = x.minus(q.times(y));
        if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
        return y;
      };
      P.multipliedBy = P.times = function(y, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber3(y, b)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y.c = y.e = y.s = null;
          } else {
            y.s *= x.s;
            if (!xc || !yc) {
              y.c = y.e = null;
            } else {
              y.c = [0];
              y.e = 0;
            }
          }
          return y;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
        y.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL) {
          zc = xc;
          xc = yc;
          yc = zc;
          i = xcL;
          xcL = ycL;
          ycL = i;
        }
        for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL; --i >= 0; ) {
          c = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k = xcL, j = i + k; j > i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
            c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
            zc[j--] = xlo % base;
          }
          zc[j] = c;
        }
        if (c) {
          ++e;
        } else {
          zc.splice(0, 1);
        }
        return normalise(y, zc, e);
      };
      P.negated = function() {
        var x = new BigNumber3(this);
        x.s = -x.s || null;
        return x;
      };
      P.plus = function(y, b) {
        var t, x = this, a = x.s;
        y = new BigNumber3(y, b);
        b = y.s;
        if (!a || !b) return new BigNumber3(NaN);
        if (a != b) {
          y.s = -b;
          return x.minus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc) return new BigNumber3(a / 0);
          if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber3(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t = yc;
          } else {
            a = -a;
            t = xc;
          }
          t.reverse();
          for (; a--; t.push(0)) ;
          t.reverse();
        }
        a = xc.length;
        b = yc.length;
        if (a - b < 0) {
          t = yc;
          yc = xc;
          xc = t;
          b = a;
        }
        for (a = 0; b; ) {
          a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
          xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y, xc, ye);
      };
      P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round3(new BigNumber3(x), sd, rm);
        }
        if (!(c = x.c)) return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (; v % 10 == 0; v /= 10, n--) ;
          for (v = c[0]; v >= 10; v /= 10, n++) ;
        }
        if (sd && x.e + 1 > n) n = x.e + 1;
        return n;
      };
      P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
        if (s !== 1 || !c || !c[0]) {
          return new BigNumber3(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        s = Math.sqrt(+valueOf4(x));
        if (s == 0 || s == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0) n += "0";
          s = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber3(n);
        } else {
          r = new BigNumber3(s + "");
        }
        if (r.c[0]) {
          e = r.e;
          s = e + dp;
          if (s < 3) s = 0;
          for (; ; ) {
            t = r;
            r = half.times(t.plus(div(x, t, dp, 1)));
            if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
              if (r.e < e) --s;
              n = n.slice(s - 3, s + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round3(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x)) {
                    r = t;
                    break;
                  }
                }
                dp += 4;
                s += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round3(r, r.e + DECIMAL_PLACES + 2, 1);
                  m = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
        }
        return round3(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
      };
      P.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format4(this, dp, rm, 1);
      };
      P.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format4(this, dp, rm);
      };
      P.toFormat = function(dp, rm, format5) {
        var str, x = this;
        if (format5 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format5 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format5 = dp;
            dp = rm = null;
          } else {
            format5 = FORMAT;
          }
        } else if (typeof format5 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format5);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format5.groupSize, g2 = +format5.secondaryGroupSize, groupSeparator = format5.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2) {
            i = g1;
            g1 = g2;
            g2 = i;
            len -= i;
          }
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
            if (isNeg) intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format5.decimalSeparator || "") + ((g2 = +format5.fractionGroupSize) ? fractionPart.replace(
            new RegExp("\\d{" + g2 + "}\\B", "g"),
            "$&" + (format5.fractionGroupSeparator || "")
          ) : fractionPart) : intPart;
        }
        return (format5.prefix || "") + str + (format5.suffix || "");
      };
      P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
        if (md != null) {
          n = new BigNumber3(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf4(n));
          }
        }
        if (!xc) return new BigNumber3(x);
        d = new BigNumber3(ONE);
        n1 = d0 = new BigNumber3(ONE);
        d1 = n0 = new BigNumber3(ONE);
        s = coeffToString(xc);
        e = d.e = s.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber3(s);
        n0.c[0] = 0;
        for (; ; ) {
          q = div(n, d, 0, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.comparedTo(md) == 1) break;
          d0 = d1;
          d1 = d2;
          n1 = n0.plus(q.times(d2 = n1));
          n0 = d2;
          d = n.minus(q.times(d2 = d));
          n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
        ) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r;
      };
      P.toNumber = function() {
        return +valueOf4(this);
      };
      P.toPrecision = function(sd, rm) {
        if (sd != null) intCheck(sd, 1, MAX);
        return format4(this, sd, rm, 2);
      };
      P.toString = function(b) {
        var str, n = this, s = n.s, e = n.e;
        if (e === null) {
          if (s) {
            str = "Infinity";
            if (s < 0) str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b === 10 && alphabetHasNormalDecimalDigits) {
            n = round3(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
          }
          if (s < 0 && n.c[0]) str = "-" + str;
        }
        return str;
      };
      P.valueOf = P.toJSON = function() {
        return valueOf4(this);
      };
      P._isBigNumber = true;
      if (configObject != null) BigNumber3.set(configObject);
      return BigNumber3;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s, z, i = 1, j = a.length, r = a[0] + "";
      for (; i < j; ) {
        s = a[i++] + "";
        z = LOG_BASE - s.length;
        for (; z--; s = "0" + s) ;
        r += s;
      }
      for (j = r.length; r.charCodeAt(--j) === 48; ) ;
      return r.slice(0, j + 1 || 1);
    }
    function compare(x, y) {
      var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
      if (!i || !j) return null;
      a = xc && !xc[0];
      b = yc && !yc[0];
      if (a || b) return a ? b ? 0 : -j : i;
      if (i != j) return i;
      a = i < 0;
      b = k == l;
      if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
      if (!b) return k > l ^ a ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
      return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    function intCheck(n, min3, max3, name) {
      if (n < min3 || n > max3 || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min3 || n > max3 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z) {
      var len, zs;
      if (e < 0) {
        for (zs = z + "."; ++e; zs += z) ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z, e -= len; --e; zs += z) ;
          str += zs;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber2 = clone5();
    BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
    if (module2.exports) {
      module2.exports = BigNumber2;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber2;
    }
  })(commonjsGlobal);
})(bignumber);
var bignumberExports = bignumber.exports;
var globalState$1 = requireGlobalState();
var validating = requireValidating();
var parsing$1 = parsing$2;
var BigNumber$1 = bignumberExports;
var powers = {
  trillion: Math.pow(10, 12),
  billion: Math.pow(10, 9),
  million: Math.pow(10, 6),
  thousand: Math.pow(10, 3)
};
var defaultOptions = {
  totalLength: 0,
  characteristic: 0,
  forceAverage: false,
  average: false,
  mantissa: -1,
  optionalMantissa: true,
  thousandSeparated: false,
  spaceSeparated: false,
  negative: "sign",
  forceSign: false,
  roundingFunction: Math.round,
  spaceSeparatedAbbreviation: false
};
var { binarySuffixes, decimalSuffixes } = globalState$1.currentBytes();
var bytes = {
  general: { scale: 1024, suffixes: decimalSuffixes, marker: "bd" },
  binary: { scale: 1024, suffixes: binarySuffixes, marker: "b" },
  decimal: { scale: 1e3, suffixes: decimalSuffixes, marker: "d" }
};
function format3(instance, providedFormat = {}, numbro2) {
  if (typeof providedFormat === "string") {
    providedFormat = parsing$1.parseFormat(providedFormat);
  }
  let valid = validating.validateFormat(providedFormat);
  if (!valid) {
    return "ERROR: invalid format";
  }
  let prefix = providedFormat.prefix || "";
  let postfix = providedFormat.postfix || "";
  let output = formatNumbro(instance, providedFormat, numbro2);
  output = insertPrefix(output, prefix);
  output = insertPostfix(output, postfix);
  return output;
}
function formatNumbro(instance, providedFormat, numbro2) {
  switch (providedFormat.output) {
    case "currency": {
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentCurrencyDefaultFormat());
      return formatCurrency(instance, providedFormat, globalState$1);
    }
    case "percent": {
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentPercentageDefaultFormat());
      return formatPercentage(instance, providedFormat, globalState$1, numbro2);
    }
    case "byte":
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentByteDefaultFormat());
      return formatByte(instance, providedFormat, globalState$1, numbro2);
    case "time":
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentTimeDefaultFormat());
      return formatTime(instance);
    case "ordinal":
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentOrdinalDefaultFormat());
      return formatOrdinal(instance, providedFormat, globalState$1);
    case "number":
    default:
      return formatNumber({
        instance,
        providedFormat,
        numbro: numbro2
      });
  }
}
function getDecimalByteUnit(instance) {
  let data = bytes.decimal;
  return getFormatByteUnits(instance._value, data.suffixes, data.scale).suffix;
}
function getBinaryByteUnit(instance) {
  let data = bytes.binary;
  return getFormatByteUnits(instance._value, data.suffixes, data.scale).suffix;
}
function getByteUnit(instance) {
  let data = bytes.general;
  return getFormatByteUnits(instance._value, data.suffixes, data.scale).suffix;
}
function getFormatByteUnits(value, suffixes, scale) {
  let suffix = suffixes[0];
  let abs4 = Math.abs(value);
  if (abs4 >= scale) {
    for (let power = 1; power < suffixes.length; ++power) {
      let min3 = Math.pow(scale, power);
      let max3 = Math.pow(scale, power + 1);
      if (abs4 >= min3 && abs4 < max3) {
        suffix = suffixes[power];
        value = value / min3;
        break;
      }
    }
    if (suffix === suffixes[0]) {
      value = value / Math.pow(scale, suffixes.length - 1);
      suffix = suffixes[suffixes.length - 1];
    }
  }
  return { value, suffix };
}
function formatByte(instance, providedFormat, state, numbro2) {
  let base = providedFormat.base || "binary";
  let options = Object.assign({}, defaultOptions, providedFormat);
  const { binarySuffixes: localBinarySuffixes, decimalSuffixes: localDecimalSuffixes } = state.currentBytes();
  const localBytes = {
    general: { scale: 1024, suffixes: localDecimalSuffixes || decimalSuffixes, marker: "bd" },
    binary: { scale: 1024, suffixes: localBinarySuffixes || binarySuffixes, marker: "b" },
    decimal: { scale: 1e3, suffixes: localDecimalSuffixes || decimalSuffixes, marker: "d" }
  };
  let baseInfo = localBytes[base];
  let { value, suffix } = getFormatByteUnits(instance._value, baseInfo.suffixes, baseInfo.scale);
  let output = formatNumber({
    instance: numbro2(value),
    providedFormat,
    state,
    defaults: state.currentByteDefaultFormat()
  });
  return `${output}${options.spaceSeparated ? " " : ""}${suffix}`;
}
function formatOrdinal(instance, providedFormat, state) {
  let ordinalFn = state.currentOrdinal();
  let options = Object.assign({}, defaultOptions, providedFormat);
  let output = formatNumber({
    instance,
    providedFormat,
    state
  });
  let ordinal3 = ordinalFn(instance._value);
  return `${output}${options.spaceSeparated ? " " : ""}${ordinal3}`;
}
function formatTime(instance) {
  let hours3 = Math.floor(instance._value / 60 / 60);
  let minutes3 = Math.floor((instance._value - hours3 * 60 * 60) / 60);
  let seconds3 = Math.round(instance._value - hours3 * 60 * 60 - minutes3 * 60);
  return `${hours3}:${minutes3 < 10 ? "0" : ""}${minutes3}:${seconds3 < 10 ? "0" : ""}${seconds3}`;
}
function formatPercentage(instance, providedFormat, state, numbro2) {
  let prefixSymbol = providedFormat.prefixSymbol;
  let output = formatNumber({
    instance: numbro2(instance._value * 100),
    providedFormat,
    state
  });
  let options = Object.assign({}, defaultOptions, providedFormat);
  if (prefixSymbol) {
    return `%${options.spaceSeparated ? " " : ""}${output}`;
  }
  return `${output}${options.spaceSeparated ? " " : ""}%`;
}
function formatCurrency(instance, providedFormat, state) {
  const currentCurrency = state.currentCurrency();
  let clonedFormat = Object.assign({}, providedFormat);
  let options = Object.assign({}, defaultOptions, clonedFormat);
  let decimalSeparator = void 0;
  let space = "";
  let average = !!options.totalLength || !!options.forceAverage || options.average;
  let position = clonedFormat.currencyPosition || currentCurrency.position;
  let symbol = clonedFormat.currencySymbol || currentCurrency.symbol;
  const spaceSeparatedCurrency = options.spaceSeparatedCurrency !== void 0 ? options.spaceSeparatedCurrency : options.spaceSeparated;
  if (clonedFormat.lowPrecision === void 0) {
    clonedFormat.lowPrecision = false;
  }
  if (spaceSeparatedCurrency) {
    space = " ";
  }
  if (position === "infix") {
    decimalSeparator = space + symbol + space;
  }
  let output = formatNumber({
    instance,
    providedFormat: clonedFormat,
    state,
    decimalSeparator
  });
  if (position === "prefix") {
    if (instance._value < 0 && options.negative === "sign") {
      output = `-${space}${symbol}${output.slice(1)}`;
    } else if (instance._value > 0 && options.forceSign) {
      output = `+${space}${symbol}${output.slice(1)}`;
    } else {
      output = symbol + space + output;
    }
  }
  if (!position || position === "postfix") {
    space = !options.spaceSeparatedAbbreviation && average ? "" : space;
    output = output + space + symbol;
  }
  return output;
}
function computeAverage({ value, forceAverage, lowPrecision = true, abbreviations, spaceSeparated = false, totalLength = 0, roundingFunction = Math.round }) {
  let abbreviation = "";
  let abs4 = Math.abs(value);
  let mantissaPrecision = -1;
  if (forceAverage && abbreviations[forceAverage] && powers[forceAverage]) {
    abbreviation = abbreviations[forceAverage];
    value = value / powers[forceAverage];
  } else {
    if (abs4 >= powers.trillion || lowPrecision && roundingFunction(abs4 / powers.trillion) === 1) {
      abbreviation = abbreviations.trillion;
      value = value / powers.trillion;
    } else if (abs4 < powers.trillion && abs4 >= powers.billion || lowPrecision && roundingFunction(abs4 / powers.billion) === 1) {
      abbreviation = abbreviations.billion;
      value = value / powers.billion;
    } else if (abs4 < powers.billion && abs4 >= powers.million || lowPrecision && roundingFunction(abs4 / powers.million) === 1) {
      abbreviation = abbreviations.million;
      value = value / powers.million;
    } else if (abs4 < powers.million && abs4 >= powers.thousand || lowPrecision && roundingFunction(abs4 / powers.thousand) === 1) {
      abbreviation = abbreviations.thousand;
      value = value / powers.thousand;
    }
  }
  let optionalSpace = spaceSeparated ? " " : "";
  if (abbreviation) {
    abbreviation = optionalSpace + abbreviation;
  }
  if (totalLength) {
    let isNegative = value < 0;
    let characteristic = value.toString().split(".")[0];
    let characteristicLength = isNegative ? characteristic.length - 1 : characteristic.length;
    mantissaPrecision = Math.max(totalLength - characteristicLength, 0);
  }
  return { value, abbreviation, mantissaPrecision };
}
function computeExponential({ value, characteristicPrecision }) {
  let [numberString, exponential] = value.toExponential().split("e");
  let number = +numberString;
  if (!characteristicPrecision) {
    return {
      value: number,
      abbreviation: `e${exponential}`
    };
  }
  let characteristicLength = 1;
  if (characteristicLength < characteristicPrecision) {
    number = number * Math.pow(10, characteristicPrecision - characteristicLength);
    exponential = +exponential - (characteristicPrecision - characteristicLength);
    exponential = exponential >= 0 ? `+${exponential}` : exponential;
  }
  return {
    value: number,
    abbreviation: `e${exponential}`
  };
}
function zeroes(number) {
  let result = "";
  for (let i = 0; i < number; i++) {
    result += "0";
  }
  return result;
}
function toFixedLarge(value, precision) {
  let result = value.toString();
  let [base, exp] = result.split("e");
  let [characteristic, mantissa = ""] = base.split(".");
  if (+exp > 0) {
    result = characteristic + mantissa + zeroes(exp - mantissa.length);
  } else {
    let prefix = ".";
    if (+characteristic < 0) {
      prefix = `-0${prefix}`;
    } else {
      prefix = `0${prefix}`;
    }
    let suffix = (zeroes(-exp - 1) + Math.abs(characteristic) + mantissa).substr(0, precision);
    if (suffix.length < precision) {
      suffix += zeroes(precision - suffix.length);
    }
    result = prefix + suffix;
  }
  if (+exp > 0 && precision > 0) {
    result += `.${zeroes(precision)}`;
  }
  return result;
}
function toFixed(value, precision, roundingFunction = Math.round) {
  if (value.toString().indexOf("e") !== -1) {
    return toFixedLarge(value, precision);
  }
  const n = new BigNumber$1(roundingFunction(+`${value}e+${precision}`) / Math.pow(10, precision));
  return n.toFixed(precision);
}
function setMantissaPrecision(output, value, optionalMantissa, precision, trim, roundingFunction) {
  if (precision === -1) {
    return output;
  }
  let result = toFixed(value, precision, roundingFunction);
  let [currentCharacteristic, currentMantissa = ""] = result.toString().split(".");
  if (currentMantissa.match(/^0+$/) && (optionalMantissa || trim)) {
    return currentCharacteristic;
  }
  let hasTrailingZeroes = currentMantissa.match(/0+$/);
  if (trim && hasTrailingZeroes) {
    return `${currentCharacteristic}.${currentMantissa.toString().slice(0, hasTrailingZeroes.index)}`;
  }
  return result.toString();
}
function setCharacteristicPrecision(output, value, optionalCharacteristic, precision) {
  let result = output;
  let [currentCharacteristic, currentMantissa] = result.toString().split(".");
  if (currentCharacteristic.match(/^-?0$/) && optionalCharacteristic) {
    if (!currentMantissa) {
      return currentCharacteristic.replace("0", "");
    }
    return `${currentCharacteristic.replace("0", "")}.${currentMantissa}`;
  }
  const hasNegativeSign = value < 0 && currentCharacteristic.indexOf("-") === 0;
  if (hasNegativeSign) {
    currentCharacteristic = currentCharacteristic.slice(1);
    result = result.slice(1);
  }
  if (currentCharacteristic.length < precision) {
    let missingZeros = precision - currentCharacteristic.length;
    for (let i = 0; i < missingZeros; i++) {
      result = `0${result}`;
    }
  }
  if (hasNegativeSign) {
    result = `-${result}`;
  }
  return result.toString();
}
function indexesOfGroupSpaces(totalLength, groupSize) {
  let result = [];
  let counter = 0;
  for (let i = totalLength; i > 0; i--) {
    if (counter === groupSize) {
      result.unshift(i);
      counter = 0;
    }
    counter++;
  }
  return result;
}
function replaceDelimiters(output, value, thousandSeparated, state, decimalSeparator) {
  let delimiters = state.currentDelimiters();
  let thousandSeparator = delimiters.thousands;
  decimalSeparator = decimalSeparator || delimiters.decimal;
  let thousandsSize = delimiters.thousandsSize || 3;
  let result = output.toString();
  let characteristic = result.split(".")[0];
  let mantissa = result.split(".")[1];
  const hasNegativeSign = value < 0 && characteristic.indexOf("-") === 0;
  if (thousandSeparated) {
    if (hasNegativeSign) {
      characteristic = characteristic.slice(1);
    }
    let indexesToInsertThousandDelimiters = indexesOfGroupSpaces(characteristic.length, thousandsSize);
    indexesToInsertThousandDelimiters.forEach((position, index2) => {
      characteristic = characteristic.slice(0, position + index2) + thousandSeparator + characteristic.slice(position + index2);
    });
    if (hasNegativeSign) {
      characteristic = `-${characteristic}`;
    }
  }
  if (!mantissa) {
    result = characteristic;
  } else {
    result = characteristic + decimalSeparator + mantissa;
  }
  return result;
}
function insertAbbreviation(output, abbreviation) {
  return output + abbreviation;
}
function insertSign(output, value, negative) {
  if (value === 0) {
    return output;
  }
  if (+output === 0) {
    return output.replace("-", "");
  }
  if (value > 0) {
    return `+${output}`;
  }
  if (negative === "sign") {
    return output;
  }
  return `(${output.replace("-", "")})`;
}
function insertPrefix(output, prefix) {
  return prefix + output;
}
function insertPostfix(output, postfix) {
  return output + postfix;
}
function formatNumber({ instance, providedFormat, state = globalState$1, decimalSeparator, defaults: defaults3 = state.currentDefaults() }) {
  let value = instance._value;
  if (value === 0 && state.hasZeroFormat()) {
    return state.getZeroFormat();
  }
  if (!isFinite(value)) {
    return value.toString();
  }
  let options = Object.assign({}, defaultOptions, defaults3, providedFormat);
  let totalLength = options.totalLength;
  let characteristicPrecision = totalLength ? 0 : options.characteristic;
  let optionalCharacteristic = options.optionalCharacteristic;
  let forceAverage = options.forceAverage;
  let lowPrecision = options.lowPrecision;
  let average = !!totalLength || !!forceAverage || options.average;
  let mantissaPrecision = totalLength ? -1 : average && providedFormat.mantissa === void 0 ? 0 : options.mantissa;
  let optionalMantissa = totalLength ? false : providedFormat.optionalMantissa === void 0 ? mantissaPrecision === -1 : options.optionalMantissa;
  let trimMantissa = options.trimMantissa;
  let thousandSeparated = options.thousandSeparated;
  let spaceSeparated = options.spaceSeparated;
  let negative = options.negative;
  let forceSign = options.forceSign;
  let exponential = options.exponential;
  let roundingFunction = options.roundingFunction;
  let abbreviation = "";
  if (average) {
    let data = computeAverage({
      value,
      forceAverage,
      lowPrecision,
      abbreviations: state.currentAbbreviations(),
      spaceSeparated,
      roundingFunction,
      totalLength
    });
    value = data.value;
    abbreviation += data.abbreviation;
    if (totalLength) {
      mantissaPrecision = data.mantissaPrecision;
    }
  }
  if (exponential) {
    let data = computeExponential({
      value,
      characteristicPrecision
    });
    value = data.value;
    abbreviation = data.abbreviation + abbreviation;
  }
  let output = setMantissaPrecision(value.toString(), value, optionalMantissa, mantissaPrecision, trimMantissa, roundingFunction);
  output = setCharacteristicPrecision(output, value, optionalCharacteristic, characteristicPrecision);
  output = replaceDelimiters(output, value, thousandSeparated, state, decimalSeparator);
  if (average || exponential) {
    output = insertAbbreviation(output, abbreviation);
  }
  if (forceSign || value < 0) {
    output = insertSign(output, value, negative);
  }
  return output;
}
function formatOrDefault(providedFormat, defaultFormat) {
  if (!providedFormat) {
    return defaultFormat;
  }
  let keys3 = Object.keys(providedFormat);
  if (keys3.length === 1 && keys3[0] === "output") {
    return defaultFormat;
  }
  return providedFormat;
}
var formatting = (numbro2) => ({
  format: (...args) => format3(...args, numbro2),
  getByteUnit: (...args) => getByteUnit(...args, numbro2),
  getBinaryByteUnit: (...args) => getBinaryByteUnit(...args, numbro2),
  getDecimalByteUnit: (...args) => getDecimalByteUnit(...args, numbro2),
  formatOrDefault
});
var BigNumber = bignumberExports;
function add4(n, other, numbro2) {
  let value = new BigNumber(n._value);
  let otherValue = other;
  if (numbro2.isNumbro(other)) {
    otherValue = other._value;
  }
  otherValue = new BigNumber(otherValue);
  n._value = value.plus(otherValue).toNumber();
  return n;
}
function subtract4(n, other, numbro2) {
  let value = new BigNumber(n._value);
  let otherValue = other;
  if (numbro2.isNumbro(other)) {
    otherValue = other._value;
  }
  otherValue = new BigNumber(otherValue);
  n._value = value.minus(otherValue).toNumber();
  return n;
}
function multiply(n, other, numbro2) {
  let value = new BigNumber(n._value);
  let otherValue = other;
  if (numbro2.isNumbro(other)) {
    otherValue = other._value;
  }
  otherValue = new BigNumber(otherValue);
  n._value = value.times(otherValue).toNumber();
  return n;
}
function divide(n, other, numbro2) {
  let value = new BigNumber(n._value);
  let otherValue = other;
  if (numbro2.isNumbro(other)) {
    otherValue = other._value;
  }
  otherValue = new BigNumber(otherValue);
  n._value = value.dividedBy(otherValue).toNumber();
  return n;
}
function set4(n, other, numbro2) {
  let value = other;
  if (numbro2.isNumbro(other)) {
    value = other._value;
  }
  n._value = value;
  return n;
}
function difference(n, other, numbro2) {
  let clone5 = numbro2(n._value);
  subtract4(clone5, other, numbro2);
  return Math.abs(clone5._value);
}
var manipulating = (numbro2) => ({
  add: (n, other) => add4(n, other, numbro2),
  subtract: (n, other) => subtract4(n, other, numbro2),
  multiply: (n, other) => multiply(n, other, numbro2),
  divide: (n, other) => divide(n, other, numbro2),
  set: (n, other) => set4(n, other, numbro2),
  difference: (n, other) => difference(n, other, numbro2),
  BigNumber
});
var VERSION = "2.5.0";
var globalState = requireGlobalState();
var validator = requireValidating();
var loader = loading(numbro);
var unformatter = requireUnformatting();
var formatter = formatting(numbro);
var manipulate = manipulating(numbro);
var parsing = parsing$2;
var Numbro = class {
  constructor(number) {
    this._value = number;
  }
  clone() {
    return numbro(this._value);
  }
  format(format4 = {}) {
    return formatter.format(this, format4);
  }
  formatCurrency(format4) {
    if (typeof format4 === "string") {
      format4 = parsing.parseFormat(format4);
    }
    format4 = formatter.formatOrDefault(format4, globalState.currentCurrencyDefaultFormat());
    format4.output = "currency";
    return formatter.format(this, format4);
  }
  formatTime(format4 = {}) {
    format4.output = "time";
    return formatter.format(this, format4);
  }
  binaryByteUnits() {
    return formatter.getBinaryByteUnit(this);
  }
  decimalByteUnits() {
    return formatter.getDecimalByteUnit(this);
  }
  byteUnits() {
    return formatter.getByteUnit(this);
  }
  difference(other) {
    return manipulate.difference(this, other);
  }
  add(other) {
    return manipulate.add(this, other);
  }
  subtract(other) {
    return manipulate.subtract(this, other);
  }
  multiply(other) {
    return manipulate.multiply(this, other);
  }
  divide(other) {
    return manipulate.divide(this, other);
  }
  set(input) {
    return manipulate.set(this, normalizeInput(input));
  }
  value() {
    return this._value;
  }
  valueOf() {
    return this._value;
  }
};
function normalizeInput(input) {
  let result = input;
  if (numbro.isNumbro(input)) {
    result = input._value;
  } else if (typeof input === "string") {
    result = numbro.unformat(input);
  } else if (isNaN(input)) {
    result = NaN;
  }
  return result;
}
function numbro(input) {
  return new Numbro(normalizeInput(input));
}
numbro.version = VERSION;
numbro.isNumbro = function(object) {
  return object instanceof Numbro;
};
numbro.language = globalState.currentLanguage;
numbro.registerLanguage = globalState.registerLanguage;
numbro.setLanguage = globalState.setLanguage;
numbro.languages = globalState.languages;
numbro.languageData = globalState.languageData;
numbro.zeroFormat = globalState.setZeroFormat;
numbro.defaultFormat = globalState.currentDefaults;
numbro.setDefaults = globalState.setDefaults;
numbro.defaultCurrencyFormat = globalState.currentCurrencyDefaultFormat;
numbro.validate = validator.validate;
numbro.loadLanguagesInNode = loader.loadLanguagesInNode;
numbro.unformat = unformatter.unformat;
numbro.BigNumber = manipulate.BigNumber;
var numbro_1 = numbro;
var numbro$1 = getDefaultExportFromCjs(numbro_1);

// node_modules/handsontable/es/renderers/numericRenderer.js
function numericRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var newValue = value;
  if (isNumeric(newValue)) {
    var numericFormat = cellProperties.numericFormat;
    var cellCulture = numericFormat && numericFormat.culture || "-";
    var cellFormatPattern = numericFormat && numericFormat.pattern;
    var className = cellProperties.className || "";
    var classArr = className.length ? className.split(" ") : [];
    if (typeof cellCulture !== "undefined" && !numbro$1.languages()[cellCulture]) {
      var shortTag = cellCulture.replace("-", "");
      var langData = numbro$1.allLanguages ? numbro$1.allLanguages[cellCulture] : numbro$1[shortTag];
      if (langData) {
        numbro$1.registerLanguage(langData);
      }
    }
    numbro$1.setLanguage(cellCulture);
    newValue = numbro$1(newValue).format(cellFormatPattern || "0");
    if (classArr.indexOf("htLeft") < 0 && classArr.indexOf("htCenter") < 0 && classArr.indexOf("htRight") < 0 && classArr.indexOf("htJustify") < 0) {
      classArr.push("htRight");
    }
    if (classArr.indexOf("htNumeric") < 0) {
      classArr.push("htNumeric");
    }
    cellProperties.className = classArr.join(" ");
  }
  _getItem2("text")(instance, TD, row, col, prop, newValue, cellProperties);
}
var numericRenderer_default = numericRenderer;

// node_modules/handsontable/es/renderers/passwordRenderer.js
function passwordRenderer(instance, TD, row, col, prop, value, cellProperties) {
  for (var _len = arguments.length, args = new Array(_len > 7 ? _len - 7 : 0), _key = 7; _key < _len; _key++) {
    args[_key - 7] = arguments[_key];
  }
  _getItem2("text").apply(this, [instance, TD, row, col, prop, value, cellProperties].concat(args));
  var hashLength = cellProperties.hashLength || TD.innerHTML.length;
  var hashSymbol = cellProperties.hashSymbol || "*";
  var hash = "";
  rangeEach(hashLength - 1, function() {
    hash += hashSymbol;
  });
  fastInnerHTML(TD, hash);
}
var passwordRenderer_default = passwordRenderer;

// node_modules/handsontable/es/renderers/textRenderer.js
function textRenderer(instance, TD, row, col, prop, value, cellProperties) {
  for (var _len = arguments.length, args = new Array(_len > 7 ? _len - 7 : 0), _key = 7; _key < _len; _key++) {
    args[_key - 7] = arguments[_key];
  }
  _getItem2("base").apply(this, [instance, TD, row, col, prop, value, cellProperties].concat(args));
  var escaped = value;
  if (!escaped && cellProperties.placeholder) {
    escaped = cellProperties.placeholder;
  }
  escaped = stringify(escaped);
  if (!instance.getSettings().trimWhitespace) {
    escaped = escaped.replace(/ /g, String.fromCharCode(160));
  }
  if (cellProperties.rendererTemplate) {
    empty(TD);
    var TEMPLATE = document.createElement("TEMPLATE");
    TEMPLATE.setAttribute("bind", "{{}}");
    TEMPLATE.innerHTML = cellProperties.rendererTemplate;
    HTMLTemplateElement.decorate(TEMPLATE);
    TEMPLATE.model = instance.getSourceDataAtRow(row);
    TD.appendChild(TEMPLATE);
  } else {
    fastInnerText(TD, escaped);
  }
}
var textRenderer_default = textRenderer;

// node_modules/handsontable/es/renderers/index.js
var _staticRegister2 = staticRegister("renderers");
var register2 = _staticRegister2.register;
var getItem2 = _staticRegister2.getItem;
var hasItem2 = _staticRegister2.hasItem;
var getNames2 = _staticRegister2.getNames;
var getValues2 = _staticRegister2.getValues;
register2("base", cellDecorator_default);
register2("autocomplete", autocompleteRenderer_default);
register2("checkbox", checkboxRenderer_default);
register2("html", htmlRenderer_default);
register2("numeric", numericRenderer_default);
register2("password", passwordRenderer_default);
register2("text", textRenderer_default);
function _getItem2(name) {
  if (typeof name === "function") {
    return name;
  }
  if (!hasItem2(name)) {
    throw Error('No registered renderer found under "'.concat(name, '" name'));
  }
  return getItem2(name);
}

// node_modules/handsontable/es/validators/autocompleteValidator.js
function autocompleteValidator(value, callback) {
  var valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
    return;
  }
  if (this.strict && this.source) {
    if (typeof this.source === "function") {
      this.source(valueToValidate, process(valueToValidate, callback));
    } else {
      process(valueToValidate, callback)(this.source);
    }
  } else {
    callback(true);
  }
}
function process(value, callback) {
  var originalVal = value;
  return function(source) {
    var found = false;
    for (var s = 0, slen = source.length; s < slen; s++) {
      if (originalVal === source[s]) {
        found = true;
        break;
      }
    }
    callback(found);
  };
}

// node_modules/handsontable/es/helpers/date.js
var date_exports = {};
__export(date_exports, {
  getNormalizedDate: () => getNormalizedDate
});
function getNormalizedDate(dateString) {
  var nativeDate = new Date(dateString);
  if (!isNaN(new Date("".concat(dateString, "T00:00")).getDate())) {
    return new Date(nativeDate.getTime() + nativeDate.getTimezoneOffset() * 6e4);
  }
  return nativeDate;
}

// node_modules/handsontable/es/validators/dateValidator.js
function dateValidator(value, callback) {
  var dateEditor = _getEditorInstance("date", this.instance);
  var valueToValidate = value;
  var valid = true;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  var isValidDate = moment_default(new Date(valueToValidate)).isValid() || moment_default(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();
  var isValidFormat = moment_default(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();
  if (this.allowEmpty && valueToValidate === "") {
    isValidDate = true;
    isValidFormat = true;
  }
  if (!isValidDate) {
    valid = false;
  }
  if (!isValidDate && isValidFormat) {
    valid = true;
  }
  if (isValidDate && !isValidFormat) {
    if (this.correctFormat === true) {
      var correctedValue = correctFormat(valueToValidate, this.dateFormat);
      var row = this.instance.runHooks("unmodifyRow", this.row);
      var column = this.instance.runHooks("unmodifyCol", this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "dateValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
function correctFormat(value, dateFormat) {
  var dateFromDate = moment_default(getNormalizedDate(value));
  var dateFromMoment = moment_default(value, dateFormat);
  var isAlphanumeric = value.search(/[A-z]/g) > -1;
  var date;
  if (dateFromDate.isValid() && dateFromDate.format("x") === dateFromMoment.format("x") || !dateFromMoment.isValid() || isAlphanumeric) {
    date = dateFromDate;
  } else {
    date = dateFromMoment;
  }
  return date.format(dateFormat);
}

// node_modules/handsontable/es/validators/numericValidator.js
function numericValidator(value, callback) {
  var valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
  } else if (valueToValidate === "") {
    callback(false);
  } else {
    callback(isNumeric(value));
  }
}

// node_modules/handsontable/es/validators/timeValidator.js
var STRICT_FORMATS = [
  "YYYY-MM-DDTHH:mm:ss.SSSZ",
  "X",
  // Unix timestamp
  "x"
  // Unix ms timestamp
];
function timeValidator(value, callback) {
  var timeFormat = this.timeFormat || "h:mm:ss a";
  var valid = true;
  var valueToValidate = value;
  if (valueToValidate === null) {
    valueToValidate = "";
  }
  valueToValidate = /^\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;
  var twoDigitValue = /^\d{1,2}$/.test(valueToValidate);
  if (twoDigitValue) {
    valueToValidate += ":00";
  }
  var date = moment_default(valueToValidate, STRICT_FORMATS, true).isValid() ? moment_default(valueToValidate) : moment_default(valueToValidate, timeFormat);
  var isValidTime = date.isValid();
  var isValidFormat = moment_default(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;
  if (this.allowEmpty && valueToValidate === "") {
    isValidTime = true;
    isValidFormat = true;
  }
  if (!isValidTime) {
    valid = false;
  }
  if (!isValidTime && isValidFormat) {
    valid = true;
  }
  if (isValidTime && !isValidFormat) {
    if (this.correctFormat === true) {
      var correctedValue = date.format(timeFormat);
      var row = this.instance.runHooks("unmodifyRow", this.row);
      var column = this.instance.runHooks("unmodifyCol", this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "timeValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}

// node_modules/handsontable/es/validators/index.js
var _staticRegister3 = staticRegister("validators");
var register3 = _staticRegister3.register;
var getItem3 = _staticRegister3.getItem;
var hasItem3 = _staticRegister3.hasItem;
var getNames3 = _staticRegister3.getNames;
var getValues3 = _staticRegister3.getValues;
register3("autocomplete", autocompleteValidator);
register3("date", dateValidator);
register3("numeric", numericValidator);
register3("time", timeValidator);
function _getItem3(name) {
  if (typeof name === "function") {
    return name;
  }
  if (!hasItem3(name)) {
    throw Error('No registered validator found under "'.concat(name, '" name'));
  }
  return getItem3(name);
}

// node_modules/handsontable/es/cellTypes/autocompleteType.js
var CELL_TYPE = "autocomplete";
var autocompleteType_default = {
  editor: _getItem(CELL_TYPE),
  renderer: _getItem2(CELL_TYPE),
  validator: _getItem3(CELL_TYPE)
};

// node_modules/handsontable/es/cellTypes/checkboxType.js
var CELL_TYPE2 = "checkbox";
var checkboxType_default = {
  editor: _getItem(CELL_TYPE2),
  renderer: _getItem2(CELL_TYPE2)
};

// node_modules/handsontable/es/cellTypes/dateType.js
var CELL_TYPE3 = "date";
var dateType_default = {
  editor: _getItem(CELL_TYPE3),
  // displays small gray arrow on right side of the cell
  renderer: _getItem2("autocomplete"),
  validator: _getItem3(CELL_TYPE3)
};

// node_modules/handsontable/es/cellTypes/dropdownType.js
var CELL_TYPE4 = "dropdown";
var dropdownType_default = {
  editor: _getItem(CELL_TYPE4),
  // displays small gray arrow on right side of the cell
  renderer: _getItem2("autocomplete"),
  validator: _getItem3("autocomplete")
};

// node_modules/handsontable/es/cellTypes/handsontableType.js
var CELL_TYPE5 = "handsontable";
var handsontableType_default = {
  editor: _getItem(CELL_TYPE5),
  // displays small gray arrow on right side of the cell
  renderer: _getItem2("autocomplete")
};

// node_modules/handsontable/es/cellTypes/numericType.js
var CELL_TYPE6 = "numeric";
var numericType_default = {
  editor: _getItem(CELL_TYPE6),
  renderer: _getItem2(CELL_TYPE6),
  validator: _getItem3(CELL_TYPE6),
  dataType: "number"
};

// node_modules/handsontable/es/cellTypes/passwordType.js
var CELL_TYPE7 = "password";
var passwordType_default = {
  editor: _getItem(CELL_TYPE7),
  renderer: _getItem2(CELL_TYPE7),
  copyable: false
};

// node_modules/handsontable/es/cellTypes/textType.js
var CELL_TYPE8 = "text";
var textType_default = {
  editor: _getItem(CELL_TYPE8),
  renderer: _getItem2(CELL_TYPE8)
};

// node_modules/handsontable/es/cellTypes/timeType.js
var CELL_TYPE9 = "time";
var timeType_default = {
  editor: _getItem("text"),
  // displays small gray arrow on right side of the cell
  renderer: _getItem2("text"),
  validator: _getItem3(CELL_TYPE9)
};

// node_modules/handsontable/es/cellTypes/index.js
var _staticRegister4 = staticRegister("cellTypes");
var register4 = _staticRegister4.register;
var getItem4 = _staticRegister4.getItem;
var hasItem4 = _staticRegister4.hasItem;
var getNames4 = _staticRegister4.getNames;
var getValues4 = _staticRegister4.getValues;
_register2("autocomplete", autocompleteType_default);
_register2("checkbox", checkboxType_default);
_register2("date", dateType_default);
_register2("dropdown", dropdownType_default);
_register2("handsontable", handsontableType_default);
_register2("numeric", numericType_default);
_register2("password", passwordType_default);
_register2("text", textType_default);
_register2("time", timeType_default);
function _getItem4(name) {
  if (!hasItem4(name)) {
    throw Error('You declared cell type "'.concat(name, '" as a string that is not mapped to a known object.\n                 Cell type must be an object or a string mapped to an object registered by "Handsontable.cellTypes.registerCellType" method'));
  }
  return getItem4(name);
}
function _register2(name, type) {
  var editor = type.editor, renderer = type.renderer, validator2 = type.validator;
  if (editor) {
    _register(name, editor);
  }
  if (renderer) {
    register2(name, renderer);
  }
  if (validator2) {
    register3(name, validator2);
  }
  register4(name, type);
}

// node_modules/handsontable/es/helpers/setting.js
var setting_exports = {};
__export(setting_exports, {
  columnFactory: () => columnFactory
});
function columnFactory(GridSettings, conflictList) {
  function ColumnSettings() {
  }
  inherit(ColumnSettings, GridSettings);
  for (var i = 0, len = conflictList.length; i < len; i++) {
    ColumnSettings.prototype[conflictList[i]] = void 0;
  }
  return ColumnSettings;
}

// node_modules/handsontable/es/dataMap.js
var import_SheetClip = __toESM(require_SheetClip());

// node_modules/handsontable/es/helpers/data.js
var data_exports = {};
__export(data_exports, {
  cellMethodLookupFactory: () => cellMethodLookupFactory,
  createEmptySpreadsheetData: () => createEmptySpreadsheetData,
  createSpreadsheetData: () => createSpreadsheetData,
  createSpreadsheetObjectData: () => createSpreadsheetObjectData,
  spreadsheetColumnIndex: () => spreadsheetColumnIndex,
  spreadsheetColumnLabel: () => spreadsheetColumnLabel,
  translateRowsToColumns: () => translateRowsToColumns
});
var COLUMN_LABEL_BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;
function spreadsheetColumnLabel(index2) {
  var dividend = index2 + 1;
  var columnLabel = "";
  var modulo;
  while (dividend > 0) {
    modulo = (dividend - 1) % COLUMN_LABEL_BASE_LENGTH;
    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
    dividend = parseInt((dividend - modulo) / COLUMN_LABEL_BASE_LENGTH, 10);
  }
  return columnLabel;
}
function spreadsheetColumnIndex(label) {
  var result = 0;
  if (label) {
    for (var i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {
      result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j) * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);
    }
  }
  result -= 1;
  return result;
}
function createSpreadsheetData() {
  var rows = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
  var columns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
  var _rows = [];
  var i;
  var j;
  for (i = 0; i < rows; i++) {
    var row = [];
    for (j = 0; j < columns; j++) {
      row.push(spreadsheetColumnLabel(j) + (i + 1));
    }
    _rows.push(row);
  }
  return _rows;
}
function createSpreadsheetObjectData() {
  var rows = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
  var colCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
  var _rows = [];
  var i;
  var j;
  for (i = 0; i < rows; i++) {
    var row = {};
    for (j = 0; j < colCount; j++) {
      row["prop".concat(j)] = spreadsheetColumnLabel(j) + (i + 1);
    }
    _rows.push(row);
  }
  return _rows;
}
function createEmptySpreadsheetData(rows, columns) {
  var data = [];
  var row;
  for (var i = 0; i < rows; i++) {
    row = [];
    for (var j = 0; j < columns; j++) {
      row.push("");
    }
    data.push(row);
  }
  return data;
}
function translateRowsToColumns(input) {
  var output = [];
  var i;
  var ilen;
  var j;
  var jlen;
  var olen = 0;
  for (i = 0, ilen = input.length; i < ilen; i++) {
    for (j = 0, jlen = input[i].length; j < jlen; j++) {
      if (j === olen) {
        output.push([]);
        olen += 1;
      }
      output[j].push(input[i][j]);
    }
  }
  return output;
}
function cellMethodLookupFactory(methodName, allowUndefined) {
  var isUndefinedAllowed = typeof allowUndefined === "undefined" ? true : allowUndefined;
  return function cellMethodLookup(row, col) {
    return function getMethodFromProperties(properties) {
      if (!properties) {
        return;
      } else if (hasOwnProperty(properties, methodName) && properties[methodName] !== void 0) {
        return properties[methodName];
      } else if (hasOwnProperty(properties, "type") && properties.type) {
        if (typeof properties.type !== "string") {
          throw new Error("Cell type must be a string ");
        }
        var type = _getItem4(properties.type);
        if (hasOwnProperty(type, methodName)) {
          return type[methodName];
        } else if (isUndefinedAllowed) {
          return;
        }
      }
      return getMethodFromProperties(Object.getPrototypeOf(properties));
    }(typeof row === "number" ? this.getCellMeta(row, col) : row);
  };
}

// node_modules/handsontable/es/utils/interval.js
function _classCallCheck31(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties29(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass29(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties29(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties29(Constructor, staticProps);
  return Constructor;
}
var Interval = function() {
  _createClass29(Interval2, null, [{
    key: "create",
    value: function create(func, delay) {
      return new Interval2(func, delay);
    }
  }]);
  function Interval2(func, delay) {
    var _this = this;
    _classCallCheck31(this, Interval2);
    this.timer = null;
    this.func = func;
    this.delay = parseDelay(delay);
    this.stopped = true;
    this._then = null;
    this._callback = function() {
      return _this.__callback();
    };
  }
  _createClass29(Interval2, [{
    key: "start",
    value: function start() {
      if (this.stopped) {
        this._then = Date.now();
        this.stopped = false;
        this.timer = requestAnimationFrame(this._callback);
      }
      return this;
    }
    /**
     * Stop looping.
     *
     * @returns {Interval}
     */
  }, {
    key: "stop",
    value: function stop() {
      if (!this.stopped) {
        this.stopped = true;
        cancelAnimationFrame(this.timer);
        this.timer = null;
      }
      return this;
    }
    /**
     * Loop callback, fired on every animation frame.
     *
     * @private
     */
  }, {
    key: "__callback",
    value: function __callback() {
      this.timer = requestAnimationFrame(this._callback);
      if (this.delay) {
        var now3 = Date.now();
        var elapsed = now3 - this._then;
        if (elapsed > this.delay) {
          this._then = now3 - elapsed % this.delay;
          this.func();
        }
      } else {
        this.func();
      }
    }
  }]);
  return Interval2;
}();
var interval_default = Interval;
function parseDelay(delay) {
  var result = delay;
  if (typeof result === "string" && /fps$/.test(result)) {
    result = 1e3 / parseInt(result.replace("fps", "") || 0, 10);
  }
  return result;
}

// node_modules/handsontable/es/multiMap.js
function _typeof19(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof19 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof19 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof19(obj);
}
function MultiMap() {
  var map3 = {
    arrayMap: [],
    weakMap: /* @__PURE__ */ new WeakMap()
  };
  return {
    get: function get5(key) {
      if (canBeAnArrayMapKey(key)) {
        return map3.arrayMap[key];
      } else if (canBeAWeakMapKey(key)) {
        return map3.weakMap.get(key);
      }
    },
    set: function set5(key, value) {
      if (canBeAnArrayMapKey(key)) {
        map3.arrayMap[key] = value;
      } else if (canBeAWeakMapKey(key)) {
        map3.weakMap.set(key, value);
      } else {
        throw new Error("Invalid key type");
      }
    },
    delete: function _delete(key) {
      if (canBeAnArrayMapKey(key)) {
        delete map3.arrayMap[key];
      } else if (canBeAWeakMapKey(key)) {
        map3.weakMap.delete(key);
      }
    }
  };
  function canBeAnArrayMapKey(obj) {
    return obj !== null && !isNaNSymbol(obj) && (typeof obj === "string" || typeof obj === "number");
  }
  function canBeAWeakMapKey(obj) {
    return obj !== null && (_typeof19(obj) === "object" || typeof obj === "function");
  }
  function isNaNSymbol(obj) {
    return obj !== obj;
  }
}
var multiMap_default = MultiMap;

// node_modules/handsontable/es/dataMap.js
function _typeof20(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof20 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof20 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof20(obj);
}
function DataMap(instance, priv, GridSettings) {
  var _this = this;
  this.instance = instance;
  this.priv = priv;
  this.GridSettings = GridSettings;
  this.dataSource = this.instance.getSettings().data;
  this.cachedLength = null;
  this.skipCache = false;
  this.latestSourceRowsCount = 0;
  if (this.dataSource && this.dataSource[0]) {
    this.duckSchema = this.recursiveDuckSchema(this.dataSource[0]);
  } else {
    this.duckSchema = {};
  }
  this.createMap();
  this.interval = interval_default.create(function() {
    return _this.clearLengthCache();
  }, "15fps");
  this.instance.addHook("skipLengthCache", function(delay) {
    return _this.onSkipLengthCache(delay);
  });
  this.onSkipLengthCache(500);
}
DataMap.prototype.DESTINATION_RENDERER = 1;
DataMap.prototype.DESTINATION_CLIPBOARD_GENERATOR = 2;
DataMap.prototype.recursiveDuckSchema = function(object) {
  return duckSchema(object);
};
DataMap.prototype.recursiveDuckColumns = function(schema, lastCol, parent) {
  var _this2 = this;
  var lastColumn = lastCol;
  var propertyParent = parent;
  var prop;
  if (typeof lastColumn === "undefined") {
    lastColumn = 0;
    propertyParent = "";
  }
  if (_typeof20(schema) === "object" && !Array.isArray(schema)) {
    objectEach(schema, function(value, key) {
      if (value === null) {
        prop = propertyParent + key;
        _this2.colToPropCache.push(prop);
        _this2.propToColCache.set(prop, lastColumn);
        lastColumn += 1;
      } else {
        lastColumn = _this2.recursiveDuckColumns(value, lastColumn, "".concat(key, "."));
      }
    });
  }
  return lastColumn;
};
DataMap.prototype.createMap = function() {
  var i;
  var schema = this.getSchema();
  if (typeof schema === "undefined") {
    throw new Error("trying to create `columns` definition but you didn't provide `schema` nor `data`");
  }
  this.colToPropCache = [];
  this.propToColCache = new multiMap_default();
  var columns = this.instance.getSettings().columns;
  if (columns) {
    var maxCols = this.instance.getSettings().maxCols;
    var columnsLen = Math.min(maxCols, columns.length);
    var filteredIndex = 0;
    var columnsAsFunc = false;
    var schemaLen = deepObjectSize(schema);
    if (typeof columns === "function") {
      columnsLen = schemaLen > 0 ? schemaLen : this.instance.countSourceCols();
      columnsAsFunc = true;
    }
    for (i = 0; i < columnsLen; i++) {
      var column = columnsAsFunc ? columns(i) : columns[i];
      if (isObject(column)) {
        if (typeof column.data !== "undefined") {
          var index2 = columnsAsFunc ? filteredIndex : i;
          this.colToPropCache[index2] = column.data;
          this.propToColCache.set(column.data, index2);
        }
        filteredIndex += 1;
      }
    }
  } else {
    this.recursiveDuckColumns(schema);
  }
};
DataMap.prototype.colToProp = function(col) {
  var physicalColumn = this.instance.runHooks("modifyCol", col);
  if (!isNaN(physicalColumn) && this.colToPropCache && typeof this.colToPropCache[physicalColumn] !== "undefined") {
    return this.colToPropCache[physicalColumn];
  }
  return physicalColumn;
};
DataMap.prototype.propToCol = function(prop) {
  var col;
  if (typeof this.propToColCache.get(prop) === "undefined") {
    col = prop;
  } else {
    col = this.propToColCache.get(prop);
  }
  col = this.instance.runHooks("unmodifyCol", col);
  return col;
};
DataMap.prototype.getSchema = function() {
  var schema = this.instance.getSettings().dataSchema;
  if (schema) {
    if (typeof schema === "function") {
      return schema();
    }
    return schema;
  }
  return this.duckSchema;
};
DataMap.prototype.createRow = function(index2) {
  var _this3 = this;
  var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var source = arguments.length > 2 ? arguments[2] : void 0;
  var numberOfCreatedRows = 0;
  var rowIndex = index2;
  if (typeof rowIndex !== "number" || rowIndex >= this.instance.countSourceRows()) {
    rowIndex = this.instance.countSourceRows();
  }
  var continueProcess = this.instance.runHooks("beforeCreateRow", rowIndex, amount, source);
  if (continueProcess === false) {
    return 0;
  }
  var maxRows = this.instance.getSettings().maxRows;
  var columnCount = this.instance.countCols();
  var _loop = function _loop2() {
    var row = null;
    if (_this3.instance.dataType === "array") {
      if (_this3.instance.getSettings().dataSchema) {
        row = deepClone(_this3.getSchema());
      } else {
        row = [];
        rangeEach(columnCount - 1, function() {
          return row.push(null);
        });
      }
    } else if (_this3.instance.dataType === "function") {
      row = _this3.instance.getSettings().dataSchema(rowIndex);
    } else {
      row = {};
      deepExtend(row, _this3.getSchema());
    }
    if (rowIndex === _this3.instance.countSourceRows()) {
      _this3.dataSource.push(row);
    } else {
      _this3.spliceData(rowIndex, 0, row);
    }
    numberOfCreatedRows += 1;
  };
  while (numberOfCreatedRows < amount && this.instance.countSourceRows() < maxRows) {
    _loop();
  }
  this.instance.runHooks("afterCreateRow", rowIndex, numberOfCreatedRows, source);
  this.instance.forceFullRender = true;
  return numberOfCreatedRows;
};
DataMap.prototype.createCol = function(index2) {
  var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var source = arguments.length > 2 ? arguments[2] : void 0;
  if (!this.instance.isColumnModificationAllowed()) {
    throw new Error("Cannot create new column. When data source in an object, you can only have as much columns as defined in first data row, data schema or in the 'columns' setting.If you want to be able to add new columns, you have to use array datasource.");
  }
  var rlen = this.instance.countSourceRows();
  var data = this.dataSource;
  var countColumns = this.instance.countCols();
  var columnIndex = typeof index2 !== "number" || index2 >= countColumns ? countColumns : index2;
  var constructor;
  var numberOfCreatedCols = 0;
  var currentIndex;
  this.instance.runHooks("beforeCreateCol", columnIndex, amount, source);
  currentIndex = columnIndex;
  var maxCols = this.instance.getSettings().maxCols;
  while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {
    constructor = columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);
    if (typeof columnIndex !== "number" || columnIndex >= this.instance.countCols()) {
      if (rlen > 0) {
        for (var r = 0; r < rlen; r++) {
          if (typeof data[r] === "undefined") {
            data[r] = [];
          }
          data[r].push(null);
        }
      } else {
        data.push([null]);
      }
      this.priv.columnSettings.push(constructor);
    } else {
      for (var row = 0; row < rlen; row++) {
        data[row].splice(currentIndex, 0, null);
      }
      this.priv.columnSettings.splice(currentIndex, 0, constructor);
    }
    numberOfCreatedCols += 1;
    currentIndex += 1;
  }
  this.instance.runHooks("afterCreateCol", columnIndex, numberOfCreatedCols, source);
  this.instance.forceFullRender = true;
  return numberOfCreatedCols;
};
DataMap.prototype.removeRow = function(index2) {
  var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var source = arguments.length > 2 ? arguments[2] : void 0;
  var rowIndex = typeof index2 !== "number" ? -amount : index2;
  var rowsAmount = this.instance.runHooks("modifyRemovedAmount", amount, rowIndex);
  rowIndex = (this.instance.countSourceRows() + rowIndex) % this.instance.countSourceRows();
  var logicRows = this.visualRowsToPhysical(rowIndex, rowsAmount);
  var actionWasNotCancelled = this.instance.runHooks("beforeRemoveRow", rowIndex, rowsAmount, logicRows, source);
  if (actionWasNotCancelled === false) {
    return;
  }
  var data = this.dataSource;
  var newData = this.filterData(rowIndex, rowsAmount);
  if (newData) {
    data.length = 0;
    Array.prototype.push.apply(data, newData);
  }
  this.instance.runHooks("afterRemoveRow", rowIndex, rowsAmount, logicRows, source);
  this.instance.forceFullRender = true;
};
DataMap.prototype.removeCol = function(index2) {
  var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var source = arguments.length > 2 ? arguments[2] : void 0;
  if (this.instance.dataType === "object" || this.instance.getSettings().columns) {
    throw new Error("cannot remove column with object data source or columns option specified");
  }
  var columnIndex = typeof index2 !== "number" ? -amount : index2;
  columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();
  var logicColumns = this.visualColumnsToPhysical(columnIndex, amount);
  var descendingLogicColumns = logicColumns.slice(0).sort(function(a, b) {
    return b - a;
  });
  var actionWasNotCancelled = this.instance.runHooks("beforeRemoveCol", columnIndex, amount, logicColumns, source);
  if (actionWasNotCancelled === false) {
    return;
  }
  var isTableUniform = true;
  var removedColumnsCount = descendingLogicColumns.length;
  var data = this.dataSource;
  for (var c = 0; c < removedColumnsCount; c++) {
    if (isTableUniform && logicColumns[0] !== logicColumns[c] - c) {
      isTableUniform = false;
    }
  }
  if (isTableUniform) {
    for (var r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {
      data[r].splice(logicColumns[0], amount);
    }
  } else {
    for (var _r = 0, _rlen = this.instance.countSourceRows(); _r < _rlen; _r++) {
      for (var _c = 0; _c < removedColumnsCount; _c++) {
        data[_r].splice(descendingLogicColumns[_c], 1);
      }
    }
    for (var _c2 = 0; _c2 < removedColumnsCount; _c2++) {
      this.priv.columnSettings.splice(logicColumns[_c2], 1);
    }
  }
  this.instance.runHooks("afterRemoveCol", columnIndex, amount, logicColumns, source);
  this.instance.forceFullRender = true;
};
DataMap.prototype.spliceCol = function(col, index2, amount) {
  var colData = this.instance.getDataAtCol(col);
  var removed = colData.slice(index2, index2 + amount);
  var after = colData.slice(index2 + amount);
  for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    elements[_key - 3] = arguments[_key];
  }
  extendArray(elements, after);
  var i = 0;
  while (i < amount) {
    elements.push(null);
    i += 1;
  }
  to2dArray(elements);
  this.instance.populateFromArray(index2, col, elements, null, null, "spliceCol");
  return removed;
};
DataMap.prototype.spliceRow = function(row, index2, amount) {
  var rowData = this.instance.getSourceDataAtRow(row);
  var removed = rowData.slice(index2, index2 + amount);
  var after = rowData.slice(index2 + amount);
  for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    elements[_key2 - 3] = arguments[_key2];
  }
  extendArray(elements, after);
  var i = 0;
  while (i < amount) {
    elements.push(null);
    i += 1;
  }
  this.instance.populateFromArray(row, index2, [elements], null, null, "spliceRow");
  return removed;
};
DataMap.prototype.spliceData = function(index2, amount, element) {
  var continueSplicing = this.instance.runHooks("beforeDataSplice", index2, amount, element);
  if (continueSplicing !== false) {
    this.dataSource.splice(index2, amount, element);
  }
};
DataMap.prototype.filterData = function(index2, amount) {
  var physicalRows = this.visualRowsToPhysical(index2, amount);
  var continueSplicing = this.instance.runHooks("beforeDataFilter", index2, amount, physicalRows);
  if (continueSplicing !== false) {
    var newData = this.dataSource.filter(function(row, rowIndex) {
      return physicalRows.indexOf(rowIndex) === -1;
    });
    return newData;
  }
};
DataMap.prototype.get = function(row, prop) {
  var physicalRow = this.instance.runHooks("modifyRow", row);
  var dataRow = this.dataSource[physicalRow];
  var modifiedRowData = this.instance.runHooks("modifyRowData", physicalRow);
  dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
  var value = null;
  if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {
    value = dataRow[prop];
  } else if (typeof prop === "string" && prop.indexOf(".") > -1) {
    var sliced = prop.split(".");
    var out = dataRow;
    if (!out) {
      return null;
    }
    for (var i = 0, ilen = sliced.length; i < ilen; i++) {
      out = out[sliced[i]];
      if (typeof out === "undefined") {
        return null;
      }
    }
    value = out;
  } else if (typeof prop === "function") {
    value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);
  }
  if (this.instance.hasHook("modifyData")) {
    var valueHolder = createObjectPropListener(value);
    this.instance.runHooks("modifyData", physicalRow, this.propToCol(prop), valueHolder, "get");
    if (valueHolder.isTouched()) {
      value = valueHolder.value;
    }
  }
  return value;
};
var copyableLookup = cellMethodLookupFactory("copyable", false);
DataMap.prototype.getCopyable = function(row, prop) {
  if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {
    return this.get(row, prop);
  }
  return "";
};
DataMap.prototype.set = function(row, prop, value, source) {
  var physicalRow = this.instance.runHooks("modifyRow", row, source || "datamapGet");
  var newValue = value;
  var dataRow = this.dataSource[physicalRow];
  var modifiedRowData = this.instance.runHooks("modifyRowData", physicalRow);
  dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
  if (this.instance.hasHook("modifyData")) {
    var valueHolder = createObjectPropListener(newValue);
    this.instance.runHooks("modifyData", physicalRow, this.propToCol(prop), valueHolder, "set");
    if (valueHolder.isTouched()) {
      newValue = valueHolder.value;
    }
  }
  if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {
    dataRow[prop] = newValue;
  } else if (typeof prop === "string" && prop.indexOf(".") > -1) {
    var sliced = prop.split(".");
    var out = dataRow;
    var i = 0;
    var ilen;
    for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {
      if (typeof out[sliced[i]] === "undefined") {
        out[sliced[i]] = {};
      }
      out = out[sliced[i]];
    }
    out[sliced[i]] = newValue;
  } else if (typeof prop === "function") {
    prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);
  } else {
    dataRow[prop] = newValue;
  }
};
DataMap.prototype.visualRowsToPhysical = function(index2, amount) {
  var totalRows = this.instance.countSourceRows();
  var logicRows = [];
  var physicRow = (totalRows + index2) % totalRows;
  var rowsToRemove = amount;
  var row;
  while (physicRow < totalRows && rowsToRemove) {
    row = this.instance.runHooks("modifyRow", physicRow);
    logicRows.push(row);
    rowsToRemove -= 1;
    physicRow += 1;
  }
  return logicRows;
};
DataMap.prototype.visualColumnsToPhysical = function(index2, amount) {
  var totalCols = this.instance.countCols();
  var physicalCol = (totalCols + index2) % totalCols;
  var visualCols = [];
  var colsToRemove = amount;
  while (physicalCol < totalCols && colsToRemove) {
    var col = this.instance.runHooks("modifyCol", physicalCol);
    visualCols.push(col);
    colsToRemove -= 1;
    physicalCol += 1;
  }
  return visualCols;
};
DataMap.prototype.clear = function() {
  for (var r = 0; r < this.instance.countSourceRows(); r++) {
    for (var c = 0; c < this.instance.countCols(); c++) {
      this.set(r, this.colToProp(c), "");
    }
  }
};
DataMap.prototype.clearLengthCache = function() {
  this.cachedLength = null;
};
DataMap.prototype.getLength = function() {
  var _this4 = this;
  var maxRowsFromSettings = this.instance.getSettings().maxRows;
  var maxRows;
  if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {
    maxRows = 0;
  } else {
    maxRows = maxRowsFromSettings || Infinity;
  }
  var length = this.instance.countSourceRows();
  if (this.instance.hasHook("modifyRow")) {
    var reValidate = this.skipCache;
    this.interval.start();
    if (length !== this.latestSourceRowsCount) {
      reValidate = true;
    }
    this.latestSourceRowsCount = length;
    if (this.cachedLength === null || reValidate) {
      rangeEach(length - 1, function(row) {
        var physicalRow = _this4.instance.runHooks("modifyRow", row);
        if (physicalRow === null) {
          length -= 1;
        }
      });
      this.cachedLength = length;
    } else {
      length = this.cachedLength;
    }
  } else {
    this.interval.stop();
  }
  return Math.min(length, maxRows);
};
DataMap.prototype.getAll = function() {
  var start = {
    row: 0,
    col: 0
  };
  var end = {
    row: Math.max(this.instance.countSourceRows() - 1, 0),
    col: Math.max(this.instance.countCols() - 1, 0)
  };
  if (start.row - end.row === 0 && !this.instance.countSourceRows()) {
    return [];
  }
  return this.getRange(start, end, DataMap.prototype.DESTINATION_RENDERER);
};
DataMap.prototype.getRange = function(start, end, destination) {
  var output = [];
  var r;
  var c;
  var row;
  var maxRows = this.instance.getSettings().maxRows;
  var maxCols = this.instance.getSettings().maxCols;
  if (maxRows === 0 || maxCols === 0) {
    return [];
  }
  var getFn = destination === this.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;
  var rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));
  var clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));
  for (r = Math.min(start.row, end.row); r <= rlen; r++) {
    row = [];
    var physicalRow = this.instance.runHooks("modifyRow", r);
    for (c = Math.min(start.col, end.col); c <= clen; c++) {
      if (physicalRow === null) {
        break;
      }
      row.push(getFn.call(this, r, this.colToProp(c)));
    }
    if (physicalRow !== null) {
      output.push(row);
    }
  }
  return output;
};
DataMap.prototype.getText = function(start, end) {
  return import_SheetClip.default.stringify(this.getRange(start, end, this.DESTINATION_RENDERER));
};
DataMap.prototype.getCopyableText = function(start, end) {
  return import_SheetClip.default.stringify(this.getRange(start, end, this.DESTINATION_CLIPBOARD_GENERATOR));
};
DataMap.prototype.onSkipLengthCache = function(delay) {
  var _this5 = this;
  this.skipCache = true;
  setTimeout(function() {
    _this5.skipCache = false;
  }, delay);
};
DataMap.prototype.destroy = function() {
  this.interval.stop();
  this.interval = null;
  this.instance = null;
  this.priv = null;
  this.GridSettings = null;
  this.dataSource = null;
  this.cachedLength = null;
  this.duckSchema = null;
};
var dataMap_default = DataMap;

// node_modules/handsontable/es/editorManager.js
function EditorManager(instance, priv, selection) {
  var _this = this;
  var eventManager2 = new eventManager_default(instance);
  var destroyed = false;
  var lock = false;
  var activeEditor;
  function moveSelectionAfterEnter(shiftKey) {
    var enterMoves = typeof priv.settings.enterMoves === "function" ? priv.settings.enterMoves(event) : priv.settings.enterMoves;
    if (shiftKey) {
      selection.transformStart(-enterMoves.row, -enterMoves.col);
    } else {
      selection.transformStart(enterMoves.row, enterMoves.col, true);
    }
  }
  function moveSelectionUp(shiftKey) {
    if (shiftKey) {
      selection.transformEnd(-1, 0);
    } else {
      selection.transformStart(-1, 0);
    }
  }
  function moveSelectionDown(shiftKey) {
    if (shiftKey) {
      selection.transformEnd(1, 0);
    } else {
      selection.transformStart(1, 0);
    }
  }
  function moveSelectionRight(shiftKey) {
    if (shiftKey) {
      selection.transformEnd(0, 1);
    } else {
      selection.transformStart(0, 1);
    }
  }
  function moveSelectionLeft(shiftKey) {
    if (shiftKey) {
      selection.transformEnd(0, -1);
    } else {
      selection.transformStart(0, -1);
    }
  }
  function onKeyDown(event2) {
    if (!instance.isListening()) {
      return;
    }
    instance.runHooks("beforeKeyDown", event2);
    if (destroyed || event2.keyCode === 229) {
      return;
    }
    if (isImmediatePropagationStopped(event2)) {
      return;
    }
    priv.lastKeyCode = event2.keyCode;
    if (!selection.isSelected()) {
      return;
    }
    var ctrlDown = (event2.ctrlKey || event2.metaKey) && !event2.altKey;
    if (activeEditor && !activeEditor.isWaiting()) {
      if (!isMetaKey(event2.keyCode) && !isCtrlMetaKey(event2.keyCode) && !ctrlDown && !_this.isEditorOpened()) {
        _this.openEditor("", event2);
        return;
      }
    }
    var rangeModifier = event2.shiftKey ? selection.setRangeEnd : selection.setRangeStart;
    var tabMoves;
    switch (event2.keyCode) {
      case KEY_CODES.A:
        if (!_this.isEditorOpened() && ctrlDown) {
          instance.selectAll();
          event2.preventDefault();
          stopPropagation(event2);
        }
        break;
      case KEY_CODES.ARROW_UP:
        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
          _this.closeEditorAndSaveChanges(ctrlDown);
        }
        moveSelectionUp(event2.shiftKey);
        event2.preventDefault();
        stopPropagation(event2);
        break;
      case KEY_CODES.ARROW_DOWN:
        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
          _this.closeEditorAndSaveChanges(ctrlDown);
        }
        moveSelectionDown(event2.shiftKey);
        event2.preventDefault();
        stopPropagation(event2);
        break;
      case KEY_CODES.ARROW_RIGHT:
        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
          _this.closeEditorAndSaveChanges(ctrlDown);
        }
        moveSelectionRight(event2.shiftKey);
        event2.preventDefault();
        stopPropagation(event2);
        break;
      case KEY_CODES.ARROW_LEFT:
        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
          _this.closeEditorAndSaveChanges(ctrlDown);
        }
        moveSelectionLeft(event2.shiftKey);
        event2.preventDefault();
        stopPropagation(event2);
        break;
      case KEY_CODES.TAB:
        tabMoves = typeof priv.settings.tabMoves === "function" ? priv.settings.tabMoves(event2) : priv.settings.tabMoves;
        if (event2.shiftKey) {
          selection.transformStart(-tabMoves.row, -tabMoves.col);
        } else {
          selection.transformStart(tabMoves.row, tabMoves.col, true);
        }
        event2.preventDefault();
        stopPropagation(event2);
        break;
      case KEY_CODES.BACKSPACE:
      case KEY_CODES.DELETE:
        instance.emptySelectedCells();
        _this.prepareEditor();
        event2.preventDefault();
        break;
      case KEY_CODES.F2:
        if (activeEditor) {
          activeEditor.enableFullEditMode();
        }
        _this.openEditor(null, event2);
        event2.preventDefault();
        break;
      case KEY_CODES.ENTER:
        if (_this.isEditorOpened()) {
          if (activeEditor && activeEditor.state !== EditorState.WAITING) {
            _this.closeEditorAndSaveChanges(ctrlDown);
          }
          moveSelectionAfterEnter(event2.shiftKey);
        } else if (instance.getSettings().enterBeginsEditing) {
          if (activeEditor) {
            activeEditor.enableFullEditMode();
          }
          _this.openEditor(null, event2);
        } else {
          moveSelectionAfterEnter(event2.shiftKey);
        }
        event2.preventDefault();
        stopImmediatePropagation(event2);
        break;
      case KEY_CODES.ESCAPE:
        if (_this.isEditorOpened()) {
          _this.closeEditorAndRestoreOriginalValue(ctrlDown);
          activeEditor.focus();
        }
        event2.preventDefault();
        break;
      case KEY_CODES.HOME:
        if (event2.ctrlKey || event2.metaKey) {
          rangeModifier.call(selection, new coords_default(0, selection.selectedRange.current().from.col));
        } else {
          rangeModifier.call(selection, new coords_default(selection.selectedRange.current().from.row, 0));
        }
        event2.preventDefault();
        stopPropagation(event2);
        break;
      case KEY_CODES.END:
        if (event2.ctrlKey || event2.metaKey) {
          rangeModifier.call(selection, new coords_default(instance.countRows() - 1, selection.selectedRange.current().from.col));
        } else {
          rangeModifier.call(selection, new coords_default(selection.selectedRange.current().from.row, instance.countCols() - 1));
        }
        event2.preventDefault();
        stopPropagation(event2);
        break;
      case KEY_CODES.PAGE_UP:
        selection.transformStart(-instance.countVisibleRows(), 0);
        event2.preventDefault();
        stopPropagation(event2);
        break;
      case KEY_CODES.PAGE_DOWN:
        selection.transformStart(instance.countVisibleRows(), 0);
        event2.preventDefault();
        stopPropagation(event2);
        break;
      default:
        break;
    }
  }
  function init2() {
    instance.addHook("afterDocumentKeyDown", onKeyDown);
    eventManager2.addEventListener(document.documentElement, "keydown", function(event2) {
      if (!destroyed) {
        instance.runHooks("afterDocumentKeyDown", event2);
      }
    });
    eventManager2.addEventListener(document.documentElement, "compositionstart", function(event2) {
      if (!destroyed && activeEditor && !activeEditor.isOpened() && instance.isListening()) {
        _this.openEditor("", event2);
      }
    });
    function onDblClick(event2, coords, elem) {
      if (elem.nodeName === "TD") {
        if (activeEditor) {
          activeEditor.enableFullEditMode();
        }
        _this.openEditor(null, event2);
      }
    }
    instance.view.wt.update("onCellDblClick", onDblClick);
  }
  this.lockEditor = function() {
    lock = true;
  };
  this.unlockEditor = function() {
    lock = false;
  };
  this.destroyEditor = function(revertOriginal) {
    if (!lock) {
      this.closeEditor(revertOriginal);
    }
  };
  this.getActiveEditor = function() {
    return activeEditor;
  };
  this.prepareEditor = function() {
    if (lock) {
      return;
    }
    if (activeEditor && activeEditor.isWaiting()) {
      this.closeEditor(false, false, function(dataSaved) {
        if (dataSaved) {
          _this.prepareEditor();
        }
      });
      return;
    }
    var row = instance.selection.selectedRange.current().highlight.row;
    var col = instance.selection.selectedRange.current().highlight.col;
    var prop = instance.colToProp(col);
    var td = instance.getCell(row, col);
    var originalValue = instance.getSourceDataAtCell(instance.runHooks("modifyRow", row), col);
    var cellProperties = instance.getCellMeta(row, col);
    var editorClass = instance.getCellEditor(cellProperties);
    if (editorClass) {
      activeEditor = _getEditorInstance(editorClass, instance);
      activeEditor.prepare(row, col, prop, td, originalValue, cellProperties);
    } else {
      activeEditor = void 0;
    }
  };
  this.isEditorOpened = function() {
    return activeEditor && activeEditor.isOpened();
  };
  this.openEditor = function(newInitialValue, event2) {
    if (!activeEditor) {
      return;
    }
    var readOnly = activeEditor.cellProperties.readOnly;
    if (readOnly) {
      if (event2 && event2.keyCode === KEY_CODES.ENTER) {
        moveSelectionAfterEnter();
      }
    } else {
      activeEditor.beginEditing(newInitialValue, event2);
    }
  };
  this.closeEditor = function(restoreOriginalValue, ctrlDown, callback) {
    if (activeEditor) {
      activeEditor.finishEditing(restoreOriginalValue, ctrlDown, callback);
    } else if (callback) {
      callback(false);
    }
  };
  this.closeEditorAndSaveChanges = function(ctrlDown) {
    return this.closeEditor(false, ctrlDown);
  };
  this.closeEditorAndRestoreOriginalValue = function(ctrlDown) {
    return this.closeEditor(true, ctrlDown);
  };
  this.destroy = function() {
    destroyed = true;
  };
  init2();
}
var instances = /* @__PURE__ */ new WeakMap();
EditorManager.getInstance = function(hotInstance, hotSettings, selection, datamap) {
  var editorManager = instances.get(hotInstance);
  if (!editorManager) {
    editorManager = new EditorManager(hotInstance, hotSettings, selection, datamap);
    instances.set(hotInstance, editorManager);
  }
  return editorManager;
};
var editorManager_default = EditorManager;

// node_modules/handsontable/es/plugins.js
var registeredPlugins = /* @__PURE__ */ new WeakMap();
function registerPlugin(pluginName, PluginClass) {
  var correctedPluginName = toUpperCaseFirst(pluginName);
  pluginHooks_default.getSingleton().add("construct", function() {
    if (!registeredPlugins.has(this)) {
      registeredPlugins.set(this, {});
    }
    var holder2 = registeredPlugins.get(this);
    if (!holder2[correctedPluginName]) {
      holder2[correctedPluginName] = new PluginClass(this);
    }
  });
  pluginHooks_default.getSingleton().add("afterDestroy", function() {
    if (registeredPlugins.has(this)) {
      var pluginsHolder = registeredPlugins.get(this);
      objectEach(pluginsHolder, function(plugin) {
        return plugin.destroy();
      });
      registeredPlugins.delete(this);
    }
  });
}
function getPlugin(instance, pluginName) {
  if (typeof pluginName !== "string") {
    throw Error('Only strings can be passed as "plugin" parameter');
  }
  var _pluginName = toUpperCaseFirst(pluginName);
  if (!registeredPlugins.has(instance) || !registeredPlugins.get(instance)[_pluginName]) {
    return void 0;
  }
  return registeredPlugins.get(instance)[_pluginName];
}
function getRegistredPluginNames(hotInstance) {
  return registeredPlugins.has(hotInstance) ? Object.keys(registeredPlugins.get(hotInstance)) : [];
}
function getPluginName(hotInstance, plugin) {
  var pluginName = null;
  if (registeredPlugins.has(hotInstance)) {
    objectEach(registeredPlugins.get(hotInstance), function(pluginInstance, name) {
      if (pluginInstance === plugin) {
        pluginName = name;
      }
    });
  }
  return pluginName;
}

// node_modules/handsontable/es/selection/mouseEventHandler.js
function mouseDown(_ref) {
  var isShiftKey = _ref.isShiftKey, isLeftClick2 = _ref.isLeftClick, isRightClick2 = _ref.isRightClick, coords = _ref.coords, selection = _ref.selection, controller = _ref.controller;
  var currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;
  var selectedCorner = selection.isSelectedByCorner();
  var selectedRow = selection.isSelectedByRowHeader();
  if (isShiftKey && currentSelection) {
    if (coords.row >= 0 && coords.col >= 0 && !controller.cells) {
      selection.setRangeEnd(coords);
    } else if ((selectedCorner || selectedRow) && coords.row >= 0 && coords.col >= 0 && !controller.cells) {
      selection.setRangeEnd(new coords_default(coords.row, coords.col));
    } else if (selectedCorner && coords.row < 0 && !controller.column) {
      selection.setRangeEnd(new coords_default(currentSelection.to.row, coords.col));
    } else if (selectedRow && coords.col < 0 && !controller.row) {
      selection.setRangeEnd(new coords_default(coords.row, currentSelection.to.col));
    } else if ((!selectedCorner && !selectedRow && coords.col < 0 || selectedCorner && coords.col < 0) && !controller.row) {
      selection.selectRows(currentSelection.from.row, coords.row);
    } else if ((!selectedCorner && !selectedRow && coords.row < 0 || selectedRow && coords.row < 0) && !controller.column) {
      selection.selectColumns(currentSelection.from.col, coords.col);
    }
  } else {
    var newCoord = new coords_default(coords.row, coords.col);
    if (newCoord.row < 0) {
      newCoord.row = 0;
    }
    if (newCoord.col < 0) {
      newCoord.col = 0;
    }
    var allowRightClickSelection = !selection.inInSelection(newCoord);
    var performSelection = isLeftClick2 || isRightClick2 && allowRightClickSelection;
    if (coords.row < 0 && coords.col >= 0 && !controller.column) {
      if (performSelection) {
        selection.selectColumns(coords.col);
      }
    } else if (coords.col < 0 && coords.row >= 0 && !controller.row) {
      if (performSelection) {
        selection.selectRows(coords.row);
      }
    } else if (coords.col >= 0 && coords.row >= 0 && !controller.cells) {
      if (performSelection) {
        selection.setRangeStart(coords);
      }
    } else if (coords.col < 0 && coords.row < 0) {
      selection.setRangeStart(coords);
    }
  }
}
function mouseOver(_ref2) {
  var isLeftClick2 = _ref2.isLeftClick, coords = _ref2.coords, selection = _ref2.selection, controller = _ref2.controller;
  if (!isLeftClick2) {
    return;
  }
  var selectedRow = selection.isSelectedByRowHeader();
  var selectedColumn = selection.isSelectedByColumnHeader();
  var countCols = selection.tableProps.countCols();
  var countRows = selection.tableProps.countRows();
  if (selectedColumn && !controller.column) {
    selection.setRangeEnd(new coords_default(countRows - 1, coords.col));
  } else if (selectedRow && !controller.row) {
    selection.setRangeEnd(new coords_default(coords.row, countCols - 1));
  } else if (!controller.cell) {
    selection.setRangeEnd(coords);
  }
}
var handlers = /* @__PURE__ */ new Map([["mousedown", mouseDown], ["mouseover", mouseOver], ["touchstart", mouseDown]]);
function handleMouseEvent(event2, _ref3) {
  var coords = _ref3.coords, selection = _ref3.selection, controller = _ref3.controller;
  handlers.get(event2.type)({
    coords,
    selection,
    controller,
    isShiftKey: event2.shiftKey,
    isLeftClick: isLeftClick(event2) || event2.type === "touchstart",
    isRightClick: isRightClick(event2)
  });
}

// node_modules/handsontable/es/tableView.js
function _slicedToArray4(arr, i) {
  return _arrayWithHoles4(arr) || _iterableToArrayLimit4(arr, i) || _nonIterableRest4();
}
function _nonIterableRest4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit4(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles4(arr) {
  if (Array.isArray(arr)) return arr;
}
var clearTextSelection = function clearTextSelection2() {
  if (window.getSelection) {
    if (window.getSelection().empty) {
      window.getSelection().empty();
    } else if (window.getSelection().removeAllRanges) {
      window.getSelection().removeAllRanges();
    }
  } else if (document.selection) {
    document.selection.empty();
  }
};
function TableView(instance) {
  var _this = this;
  var that = this;
  this.eventManager = new eventManager_default(instance);
  this.instance = instance;
  this.settings = instance.getSettings();
  this.selectionMouseDown = false;
  var originalStyle = instance.rootElement.getAttribute("style");
  if (originalStyle) {
    instance.rootElement.setAttribute("data-originalstyle", originalStyle);
  }
  addClass(instance.rootElement, "handsontable");
  var table = document.createElement("TABLE");
  addClass(table, "htCore");
  if (instance.getSettings().tableClassName) {
    addClass(table, instance.getSettings().tableClassName);
  }
  this.THEAD = document.createElement("THEAD");
  table.appendChild(this.THEAD);
  this.TBODY = document.createElement("TBODY");
  table.appendChild(this.TBODY);
  instance.table = table;
  instance.container.insertBefore(table, instance.container.firstChild);
  this.eventManager.addEventListener(instance.rootElement, "mousedown", function(event2) {
    _this.selectionMouseDown = true;
    if (!that.isTextSelectionAllowed(event2.target)) {
      clearTextSelection();
      event2.preventDefault();
      window.focus();
    }
  });
  this.eventManager.addEventListener(instance.rootElement, "mouseup", function() {
    _this.selectionMouseDown = false;
  });
  this.eventManager.addEventListener(instance.rootElement, "mousemove", function(event2) {
    if (_this.selectionMouseDown && !that.isTextSelectionAllowed(event2.target)) {
      if (_this.settings.fragmentSelection) {
        clearTextSelection();
      }
      event2.preventDefault();
    }
  });
  this.eventManager.addEventListener(document.documentElement, "keyup", function(event2) {
    if (instance.selection.isInProgress() && !event2.shiftKey) {
      instance.selection.finish();
    }
  });
  var isMouseDown;
  this.isMouseDown = function() {
    return isMouseDown;
  };
  this.eventManager.addEventListener(document.documentElement, "mouseup", function(event2) {
    if (instance.selection.isInProgress() && isLeftClick(event2)) {
      instance.selection.finish();
    }
    isMouseDown = false;
    if (isOutsideInput(document.activeElement) || !instance.selection.isSelected() && !isRightClick(event2)) {
      instance.unlisten();
    }
  });
  this.eventManager.addEventListener(document.documentElement, "contextmenu", function(event2) {
    if (instance.selection.isInProgress() && isRightClick(event2)) {
      instance.selection.finish();
      isMouseDown = false;
    }
  });
  this.eventManager.addEventListener(document.documentElement, "touchend", function() {
    if (instance.selection.isInProgress()) {
      instance.selection.finish();
    }
    isMouseDown = false;
  });
  this.eventManager.addEventListener(document.documentElement, "mousedown", function(event2) {
    var originalTarget = event2.target;
    var eventX = event2.x || event2.clientX;
    var eventY = event2.y || event2.clientY;
    var next = event2.target;
    if (isMouseDown || !instance.rootElement) {
      return;
    }
    if (next === instance.view.wt.wtTable.holder) {
      var scrollbarWidth = getScrollbarWidth();
      if (document.elementFromPoint(eventX + scrollbarWidth, eventY) !== instance.view.wt.wtTable.holder || document.elementFromPoint(eventX, eventY + scrollbarWidth) !== instance.view.wt.wtTable.holder) {
        return;
      }
    } else {
      while (next !== document.documentElement) {
        if (next === null) {
          if (event2.isTargetWebComponent) {
            break;
          }
          return;
        }
        if (next === instance.rootElement) {
          return;
        }
        next = next.parentNode;
      }
    }
    var outsideClickDeselects = typeof that.settings.outsideClickDeselects === "function" ? that.settings.outsideClickDeselects(originalTarget) : that.settings.outsideClickDeselects;
    if (outsideClickDeselects) {
      instance.deselectCell();
    } else {
      instance.destroyEditor(false, false);
    }
  });
  this.eventManager.addEventListener(table, "selectstart", function(event2) {
    if (that.settings.fragmentSelection || isInput(event2.target)) {
      return;
    }
    event2.preventDefault();
  });
  var walkontableConfig = {
    debug: function debug() {
      return that.settings.debug;
    },
    externalRowCalculator: this.instance.getPlugin("autoRowSize") && this.instance.getPlugin("autoRowSize").isEnabled(),
    table,
    preventOverflow: function preventOverflow() {
      return _this.settings.preventOverflow;
    },
    stretchH: function stretchH() {
      return that.settings.stretchH;
    },
    data: instance.getDataAtCell,
    totalRows: function totalRows() {
      return instance.countRows();
    },
    totalColumns: function totalColumns() {
      return instance.countCols();
    },
    fixedColumnsLeft: function fixedColumnsLeft() {
      return that.settings.fixedColumnsLeft;
    },
    fixedRowsTop: function fixedRowsTop() {
      return that.settings.fixedRowsTop;
    },
    fixedRowsBottom: function fixedRowsBottom() {
      return that.settings.fixedRowsBottom;
    },
    minSpareRows: function minSpareRows() {
      return that.settings.minSpareRows;
    },
    renderAllRows: that.settings.renderAllRows,
    rowHeaders: function rowHeaders() {
      var headerRenderers = [];
      if (instance.hasRowHeaders()) {
        headerRenderers.push(function(row, TH) {
          return that.appendRowHeader(row, TH);
        });
      }
      instance.runHooks("afterGetRowHeaderRenderers", headerRenderers);
      return headerRenderers;
    },
    columnHeaders: function columnHeaders() {
      var headerRenderers = [];
      if (instance.hasColHeaders()) {
        headerRenderers.push(function(column, TH) {
          that.appendColHeader(column, TH);
        });
      }
      instance.runHooks("afterGetColumnHeaderRenderers", headerRenderers);
      return headerRenderers;
    },
    columnWidth: instance.getColWidth,
    rowHeight: instance.getRowHeight,
    cellRenderer: function cellRenderer(row, col, TD) {
      var cellProperties = that.instance.getCellMeta(row, col);
      var prop = that.instance.colToProp(col);
      var value = that.instance.getDataAtRowProp(row, prop);
      if (that.instance.hasHook("beforeValueRender")) {
        value = that.instance.runHooks("beforeValueRender", value, cellProperties);
      }
      that.instance.runHooks("beforeRenderer", TD, row, col, prop, value, cellProperties);
      that.instance.getCellRenderer(cellProperties)(that.instance, TD, row, col, prop, value, cellProperties);
      that.instance.runHooks("afterRenderer", TD, row, col, prop, value, cellProperties);
    },
    selections: that.instance.selection.highlight,
    hideBorderOnMouseDownOver: function hideBorderOnMouseDownOver() {
      return that.settings.fragmentSelection;
    },
    onCellMouseDown: function onCellMouseDown(event2, coords, TD, wt) {
      var blockCalculations = {
        row: false,
        column: false,
        cell: false
      };
      instance.listen();
      that.activeWt = wt;
      isMouseDown = true;
      instance.runHooks("beforeOnCellMouseDown", event2, coords, TD, blockCalculations);
      if (isImmediatePropagationStopped(event2)) {
        return;
      }
      handleMouseEvent(event2, {
        coords,
        selection: instance.selection,
        controller: blockCalculations
      });
      instance.runHooks("afterOnCellMouseDown", event2, coords, TD);
      that.activeWt = that.wt;
    },
    onCellContextMenu: function onCellContextMenu(event2, coords, TD, wt) {
      that.activeWt = wt;
      isMouseDown = false;
      if (instance.selection.isInProgress()) {
        instance.selection.finish();
      }
      instance.runHooks("beforeOnCellContextMenu", event2, coords, TD);
      if (isImmediatePropagationStopped(event2)) {
        return;
      }
      instance.runHooks("afterOnCellContextMenu", event2, coords, TD);
      that.activeWt = that.wt;
    },
    onCellMouseOut: function onCellMouseOut(event2, coords, TD, wt) {
      that.activeWt = wt;
      instance.runHooks("beforeOnCellMouseOut", event2, coords, TD);
      if (isImmediatePropagationStopped(event2)) {
        return;
      }
      instance.runHooks("afterOnCellMouseOut", event2, coords, TD);
      that.activeWt = that.wt;
    },
    onCellMouseOver: function onCellMouseOver(event2, coords, TD, wt) {
      var blockCalculations = {
        row: false,
        column: false,
        cell: false
      };
      that.activeWt = wt;
      instance.runHooks("beforeOnCellMouseOver", event2, coords, TD, blockCalculations);
      if (isImmediatePropagationStopped(event2)) {
        return;
      }
      if (isMouseDown) {
        handleMouseEvent(event2, {
          coords,
          selection: instance.selection,
          controller: blockCalculations
        });
      }
      instance.runHooks("afterOnCellMouseOver", event2, coords, TD);
      that.activeWt = that.wt;
    },
    onCellMouseUp: function onCellMouseUp(event2, coords, TD, wt) {
      that.activeWt = wt;
      instance.runHooks("beforeOnCellMouseUp", event2, coords, TD);
      instance.runHooks("afterOnCellMouseUp", event2, coords, TD);
      that.activeWt = that.wt;
    },
    onCellCornerMouseDown: function onCellCornerMouseDown(event2) {
      event2.preventDefault();
      instance.runHooks("afterOnCellCornerMouseDown", event2);
    },
    onCellCornerDblClick: function onCellCornerDblClick(event2) {
      event2.preventDefault();
      instance.runHooks("afterOnCellCornerDblClick", event2);
    },
    beforeDraw: function beforeDraw(force, skipRender) {
      that.beforeRender(force, skipRender);
    },
    onDraw: function onDraw(force) {
      that.onDraw(force);
    },
    onScrollVertically: function onScrollVertically() {
      instance.runHooks("afterScrollVertically");
    },
    onScrollHorizontally: function onScrollHorizontally() {
      instance.runHooks("afterScrollHorizontally");
    },
    onBeforeRemoveCellClassNames: function onBeforeRemoveCellClassNames() {
      return instance.runHooks("beforeRemoveCellClassNames");
    },
    onAfterDrawSelection: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {
      return instance.runHooks("afterDrawSelection", currentRow, currentColumn, cornersOfSelection, layerLevel);
    },
    onBeforeDrawBorders: function onBeforeDrawBorders(corners, borderClassName) {
      instance.runHooks("beforeDrawBorders", corners, borderClassName);
    },
    onBeforeTouchScroll: function onBeforeTouchScroll() {
      instance.runHooks("beforeTouchScroll");
    },
    onAfterMomentumScroll: function onAfterMomentumScroll() {
      instance.runHooks("afterMomentumScroll");
    },
    onBeforeStretchingColumnWidth: function onBeforeStretchingColumnWidth(stretchedWidth, column) {
      return instance.runHooks("beforeStretchingColumnWidth", stretchedWidth, column);
    },
    onModifyRowHeaderWidth: function onModifyRowHeaderWidth(rowHeaderWidth) {
      return instance.runHooks("modifyRowHeaderWidth", rowHeaderWidth);
    },
    onModifyGetCellCoords: function onModifyGetCellCoords(row, column, topmost) {
      return instance.runHooks("modifyGetCellCoords", row, column, topmost);
    },
    viewportRowCalculatorOverride: function viewportRowCalculatorOverride(calc) {
      var rows = instance.countRows();
      var viewportOffset = that.settings.viewportRowRenderingOffset;
      if (viewportOffset === "auto" && that.settings.fixedRowsTop) {
        viewportOffset = 10;
      }
      if (typeof viewportOffset === "number") {
        calc.startRow = Math.max(calc.startRow - viewportOffset, 0);
        calc.endRow = Math.min(calc.endRow + viewportOffset, rows - 1);
      }
      if (viewportOffset === "auto") {
        var center = calc.startRow + calc.endRow - calc.startRow;
        var offset4 = Math.ceil(center / rows * 12);
        calc.startRow = Math.max(calc.startRow - offset4, 0);
        calc.endRow = Math.min(calc.endRow + offset4, rows - 1);
      }
      instance.runHooks("afterViewportRowCalculatorOverride", calc);
    },
    viewportColumnCalculatorOverride: function viewportColumnCalculatorOverride(calc) {
      var cols = instance.countCols();
      var viewportOffset = that.settings.viewportColumnRenderingOffset;
      if (viewportOffset === "auto" && that.settings.fixedColumnsLeft) {
        viewportOffset = 10;
      }
      if (typeof viewportOffset === "number") {
        calc.startColumn = Math.max(calc.startColumn - viewportOffset, 0);
        calc.endColumn = Math.min(calc.endColumn + viewportOffset, cols - 1);
      }
      if (viewportOffset === "auto") {
        var center = calc.startColumn + calc.endColumn - calc.startColumn;
        var offset4 = Math.ceil(center / cols * 12);
        calc.startRow = Math.max(calc.startColumn - offset4, 0);
        calc.endColumn = Math.min(calc.endColumn + offset4, cols - 1);
      }
      instance.runHooks("afterViewportColumnCalculatorOverride", calc);
    },
    rowHeaderWidth: function rowHeaderWidth() {
      return that.settings.rowHeaderWidth;
    },
    columnHeaderHeight: function columnHeaderHeight() {
      var columnHeaderHeight2 = instance.runHooks("modifyColumnHeaderHeight");
      return that.settings.columnHeaderHeight || columnHeaderHeight2;
    }
  };
  instance.runHooks("beforeInitWalkontable", walkontableConfig);
  this.wt = new core_default(walkontableConfig);
  this.activeWt = this.wt;
  this.eventManager.addEventListener(that.wt.wtTable.spreader, "mousedown", function(event2) {
    if (event2.target === that.wt.wtTable.spreader && event2.which === 3) {
      stopPropagation(event2);
    }
  });
  this.eventManager.addEventListener(that.wt.wtTable.spreader, "contextmenu", function(event2) {
    if (event2.target === that.wt.wtTable.spreader && event2.which === 3) {
      stopPropagation(event2);
    }
  });
  this.eventManager.addEventListener(document.documentElement, "click", function() {
    if (that.settings.observeDOMVisibility) {
      if (that.wt.drawInterrupted) {
        that.instance.forceFullRender = true;
        that.render();
      }
    }
  });
}
TableView.prototype.isTextSelectionAllowed = function(el) {
  if (isInput(el)) {
    return true;
  }
  var isChildOfTableBody = isChildOf(el, this.instance.view.wt.wtTable.spreader);
  if (this.settings.fragmentSelection === true && isChildOfTableBody) {
    return true;
  }
  if (this.settings.fragmentSelection === "cell" && this.isSelectedOnlyCell() && isChildOfTableBody) {
    return true;
  }
  if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {
    return true;
  }
  return false;
};
TableView.prototype.isSelectedOnlyCell = function() {
  var _ref = this.instance.getSelectedLast() || [], _ref2 = _slicedToArray4(_ref, 4), row = _ref2[0], col = _ref2[1], rowEnd = _ref2[2], colEnd = _ref2[3];
  return row !== void 0 && row === rowEnd && col === colEnd;
};
TableView.prototype.isCellEdited = function() {
  var activeEditor = this.instance.getActiveEditor();
  return activeEditor && activeEditor.isOpened();
};
TableView.prototype.beforeRender = function(force, skipRender) {
  if (force) {
    this.instance.runHooks("beforeRender", this.instance.forceFullRender, skipRender);
  }
};
TableView.prototype.onDraw = function(force) {
  if (force) {
    this.instance.runHooks("afterRender", this.instance.forceFullRender);
  }
};
TableView.prototype.render = function() {
  this.wt.draw(!this.instance.forceFullRender);
  this.instance.forceFullRender = false;
  this.instance.renderCall = false;
};
TableView.prototype.getCellAtCoords = function(coords, topmost) {
  var td = this.wt.getCell(coords, topmost);
  if (td < 0) {
    return null;
  }
  return td;
};
TableView.prototype.scrollViewport = function(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
  return this.wt.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
};
TableView.prototype.scrollViewportHorizontally = function(column, snapToRight, snapToLeft) {
  return this.wt.scrollViewportHorizontally(column, snapToRight, snapToLeft);
};
TableView.prototype.scrollViewportVertically = function(row, snapToTop, snapToBottom) {
  return this.wt.scrollViewportVertically(row, snapToTop, snapToBottom);
};
TableView.prototype.appendRowHeader = function(row, TH) {
  if (TH.firstChild) {
    var container = TH.firstChild;
    if (!hasClass(container, "relative")) {
      empty(TH);
      this.appendRowHeader(row, TH);
      return;
    }
    this.updateCellHeader(container.querySelector(".rowHeader"), row, this.instance.getRowHeader);
  } else {
    var div = document.createElement("div");
    var span = document.createElement("span");
    div.className = "relative";
    span.className = "rowHeader";
    this.updateCellHeader(span, row, this.instance.getRowHeader);
    div.appendChild(span);
    TH.appendChild(div);
  }
  this.instance.runHooks("afterGetRowHeader", row, TH);
};
TableView.prototype.appendColHeader = function(col, TH) {
  if (TH.firstChild) {
    var container = TH.firstChild;
    if (hasClass(container, "relative")) {
      this.updateCellHeader(container.querySelector(".colHeader"), col, this.instance.getColHeader);
    } else {
      empty(TH);
      this.appendColHeader(col, TH);
    }
  } else {
    var div = document.createElement("div");
    var span = document.createElement("span");
    div.className = "relative";
    span.className = "colHeader";
    this.updateCellHeader(span, col, this.instance.getColHeader);
    div.appendChild(span);
    TH.appendChild(div);
  }
  this.instance.runHooks("afterGetColHeader", col, TH);
};
TableView.prototype.updateCellHeader = function(element, index2, content) {
  var renderedIndex = index2;
  var parentOverlay = this.wt.wtOverlays.getParentOverlay(element) || this.wt;
  if (element.parentNode) {
    if (hasClass(element, "colHeader")) {
      renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index2);
    } else if (hasClass(element, "rowHeader")) {
      renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index2);
    }
  }
  if (renderedIndex > -1) {
    fastInnerHTML(element, content(index2));
  } else {
    fastInnerText(element, String.fromCharCode(160));
    addClass(element, "cornerHeader");
  }
};
TableView.prototype.maximumVisibleElementWidth = function(leftOffset) {
  var workspaceWidth = this.wt.wtViewport.getWorkspaceWidth();
  var maxWidth = workspaceWidth - leftOffset;
  return maxWidth > 0 ? maxWidth : 0;
};
TableView.prototype.maximumVisibleElementHeight = function(topOffset) {
  var workspaceHeight = this.wt.wtViewport.getWorkspaceHeight();
  var maxHeight = workspaceHeight - topOffset;
  return maxHeight > 0 ? maxHeight : 0;
};
TableView.prototype.mainViewIsActive = function() {
  return this.wt === this.activeWt;
};
TableView.prototype.destroy = function() {
  this.wt.destroy();
  this.eventManager.destroy();
};
var tableView_default = TableView;

// node_modules/handsontable/es/dataSource.js
function _classCallCheck32(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties30(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass30(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties30(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties30(Constructor, staticProps);
  return Constructor;
}
var DataSource = function() {
  function DataSource2(hotInstance) {
    var dataSource = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    _classCallCheck32(this, DataSource2);
    this.hot = hotInstance;
    this.data = dataSource;
    this.dataType = "array";
    this.colToProp = function() {
    };
    this.propToCol = function() {
    };
  }
  _createClass30(DataSource2, [{
    key: "getData",
    value: function getData() {
      var toArray3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var result = this.data;
      if (toArray3) {
        result = this.getByRange({
          row: 0,
          col: 0
        }, {
          row: Math.max(this.countRows() - 1, 0),
          col: Math.max(this.countColumns() - 1, 0)
        }, true);
      }
      return result;
    }
    /**
     * Set new data source.
     *
     * @param data {Array}
     */
  }, {
    key: "setData",
    value: function setData(data) {
      this.data = data;
    }
    /**
     * Returns array of column values from the data source. `column` is the index of the row in the data source.
     *
     * @param {Number} column Visual column index.
     * @returns {Array}
     */
  }, {
    key: "getAtColumn",
    value: function getAtColumn(column) {
      var _this = this;
      var result = [];
      arrayEach(this.data, function(row) {
        var property = _this.colToProp(column);
        var value;
        if (typeof property === "string") {
          value = getProperty(row, property);
        } else if (typeof property === "function") {
          value = property(row);
        } else {
          value = row[property];
        }
        result.push(value);
      });
      return result;
    }
    /**
     * Returns a single row of the data (array or object, depending on what you have). `row` is the index of the row in the data source.
     *
     * @param {Number} row Physical row index.
     * @returns {Array|Object}
     */
  }, {
    key: "getAtRow",
    value: function getAtRow(row) {
      return this.data[row];
    }
    /**
     * Returns a single value from the data.
     *
     * @param {Number} row Physical row index.
     * @param {Number} column Visual column index.
     * @returns {*}
     */
  }, {
    key: "getAtCell",
    value: function getAtCell(row, column) {
      var result = null;
      var modifyRowData = this.hot.runHooks("modifyRowData", row);
      var dataRow = isNaN(modifyRowData) ? modifyRowData : this.data[row];
      if (dataRow) {
        var prop = this.colToProp(column);
        if (typeof prop === "string") {
          result = getProperty(dataRow, prop);
        } else if (typeof prop === "function") {
          result = prop(this.data.slice(row, row + 1)[0]);
        } else {
          result = dataRow[prop];
        }
      }
      return result;
    }
    /**
     * Returns source data by passed range.
     *
     * @param {Object} start Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).
     * @param {Object} end Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).
     * @param {Boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided
     *                                  in another format.
     * @returns {Array}
     */
  }, {
    key: "getByRange",
    value: function getByRange(start, end) {
      var _this2 = this;
      var toArray3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var startRow = Math.min(start.row, end.row);
      var startCol = Math.min(start.col, end.col);
      var endRow = Math.max(start.row, end.row);
      var endCol = Math.max(start.col, end.col);
      var result = [];
      rangeEach(startRow, endRow, function(currentRow) {
        var row = _this2.getAtRow(currentRow);
        var newRow;
        if (_this2.dataType === "array") {
          newRow = row.slice(startCol, endCol + 1);
        } else if (_this2.dataType === "object") {
          newRow = toArray3 ? [] : {};
          rangeEach(startCol, endCol, function(column) {
            var prop = _this2.colToProp(column);
            if (toArray3) {
              newRow.push(row[prop]);
            } else {
              newRow[prop] = row[prop];
            }
          });
        }
        result.push(newRow);
      });
      return result;
    }
    /**
     * Count number of rows.
     *
     * @returns {Number}
     */
  }, {
    key: "countRows",
    value: function countRows() {
      return Array.isArray(this.data) ? this.data.length : 0;
    }
    /**
     * Count number of columns.
     *
     * @returns {Number}
     */
  }, {
    key: "countColumns",
    value: function countColumns() {
      var result = 0;
      if (Array.isArray(this.data)) {
        if (this.dataType === "array") {
          result = this.data[0].length;
        } else if (this.dataType === "object") {
          result = Object.keys(this.data[0]).length;
        }
      }
      return result;
    }
    /**
     * Destroy instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.data = null;
      this.hot = null;
    }
  }]);
  return DataSource2;
}();
var dataSource_default = DataSource;

// node_modules/handsontable/es/utils/recordTranslator.js
function _classCallCheck33(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties31(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass31(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties31(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties31(Constructor, staticProps);
  return Constructor;
}
var RecordTranslator = function() {
  function RecordTranslator2(hot) {
    _classCallCheck33(this, RecordTranslator2);
    this.hot = hot;
  }
  _createClass31(RecordTranslator2, [{
    key: "toVisualRow",
    value: function toVisualRow(row) {
      return this.hot.runHooks("unmodifyRow", row);
    }
    /**
     * Translate physical column index into visual.
     *
     * @param {Number} column Physical column index.
     * @returns {Number} Returns visual column index.
     */
  }, {
    key: "toVisualColumn",
    value: function toVisualColumn(column) {
      return this.hot.runHooks("unmodifyCol", column);
    }
    /**
     * Translate physical coordinates into visual. Can be passed as separate 2 arguments (row, column) or as an object in first
     * argument with `row` and `column` keys.
     *
     * @param {Number|Object} row Physical coordinates or row index.
     * @param {Number} [column] Physical column index.
     * @returns {Object|Array} Returns an object with visual records or an array if coordinates passed as separate arguments.
     */
  }, {
    key: "toVisual",
    value: function toVisual(row, column) {
      var result;
      if (isObject(row)) {
        result = {
          row: this.toVisualRow(row.row),
          column: this.toVisualColumn(row.column)
        };
      } else {
        result = [this.toVisualRow(row), this.toVisualColumn(column)];
      }
      return result;
    }
    /**
     * Translate visual row index into physical.
     *
     * @param {Number} row Visual row index.
     * @returns {Number} Returns physical row index.
     */
  }, {
    key: "toPhysicalRow",
    value: function toPhysicalRow(row) {
      return this.hot.runHooks("modifyRow", row);
    }
    /**
     * Translate visual column index into physical.
     *
     * @param {Number} column Visual column index.
     * @returns {Number} Returns physical column index.
     */
  }, {
    key: "toPhysicalColumn",
    value: function toPhysicalColumn(column) {
      return this.hot.runHooks("modifyCol", column);
    }
    /**
     * Translate visual coordinates into physical. Can be passed as separate 2 arguments (row, column) or as an object in first
     * argument with `row` and `column` keys.
     *
     * @param {Number|Object} row Visual coordinates or row index.
     * @param {Number} [column] Visual column index.
     * @returns {Object|Array} Returns an object with physical records or an array if coordinates passed as separate arguments.
     */
  }, {
    key: "toPhysical",
    value: function toPhysical(row, column) {
      var result;
      if (isObject(row)) {
        result = {
          row: this.toPhysicalRow(row.row),
          column: this.toPhysicalColumn(row.column)
        };
      } else {
        result = [this.toPhysicalRow(row), this.toPhysicalColumn(column)];
      }
      return result;
    }
  }]);
  return RecordTranslator2;
}();
var identities = /* @__PURE__ */ new WeakMap();
var translatorSingletons = /* @__PURE__ */ new WeakMap();
function getTranslator(identity) {
  var instance = identity instanceof Core ? identity : getIdentity(identity);
  var singleton;
  if (translatorSingletons.has(instance)) {
    singleton = translatorSingletons.get(instance);
  } else {
    singleton = new RecordTranslator(instance);
    translatorSingletons.set(instance, singleton);
  }
  return singleton;
}
function getIdentity(identity) {
  if (!identities.has(identity)) {
    throw Error("Record translator was not registered for this object identity");
  }
  return identities.get(identity);
}

// node_modules/handsontable/es/utils/rootInstance.js
var holder = /* @__PURE__ */ new WeakMap();
var rootInstanceSymbol = Symbol("rootInstance");
function registerAsRootInstance(object) {
  holder.set(object, true);
}
function hasValidParameter(rootSymbol) {
  return rootSymbol === rootInstanceSymbol;
}

// node_modules/handsontable/es/defaultSettings.js
function _typeof21(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof21 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof21 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof21(obj);
}
function DefaultSettings() {
}
DefaultSettings.prototype = {
  /**
   * License key for commercial version of Handsontable.
   *
   * @pro
   * @type {String}
   * @default 'trial'
   * @example
   * ```js
   * licenseKey: '00000-00000-00000-00000-00000',
   * ```
   */
  licenseKey: "trial",
  /**
   * @description
   * Initial data source that will be bound to the data grid __by reference__ (editing data grid alters the data source).
   * Can be declared as an array of arrays, array of objects or a function.
   *
   * See [Understanding binding as reference](https://docs.handsontable.com/tutorial-data-binding.html#page-reference).
   *
   * @type {Array[]|Object[]|Function}
   * @default undefined
   * @example
   * ```js
   * // as an array of arrays
   * data: [
   *   ['A', 'B', 'C'],
   *   ['D', 'E', 'F'],
   *   ['G', 'H', 'J']
   * ]
   *
   * // as an array of objects
   * data: [
   *   {id: 1, name: 'Ted Right'},
   *   {id: 2, name: 'Frank Honest'},
   *   {id: 3, name: 'Joan Well'},
   *   {id: 4, name: 'Gail Polite'},
   *   {id: 5, name: 'Michael Fair'},
   * ]
   * ```
   */
  data: void 0,
  /**
   * @description
   * Defines the structure of a new row when data source is an array of objects.
   *
   * See [data-schema](https://docs.handsontable.com/tutorial-data-sources.html#page-data-schema) for more options.
   *
   * @type {Object}
   * @default undefined
   *
   * @example
   * ```
   * // with data schema we can start with an empty table
   * data: null,
   * dataSchema: {id: null, name: {first: null, last: null}, address: null},
   * colHeaders: ['ID', 'First Name', 'Last Name', 'Address'],
   * columns: [
   *   {data: 'id'},
   *   {data: 'name.first'},
   *   {data: 'name.last'},
   *   {data: 'address'}
   * ],
   * startRows: 5,
   * minSpareRows: 1
   * ```
   */
  dataSchema: void 0,
  /**
   * Width of the grid. Can be a value or a function that returns a value.
   *
   * @type {Number|Function}
   * @default undefined
   *
   * @example
   * ```
   * // as a number
   * width: 500,
   *
   * // as a function
   * width: function() {
   *   return 500;
   * },
   * ```
   */
  width: void 0,
  /**
   * Height of the grid. Can be a number or a function that returns a number.
   *
   * @type {Number|Function}
   * @default undefined
   *
   * @example
   * ```js
   * // as a number
   * height: 500,
   *
   * // as a function
   * height: function() {
   *   return 500;
   * },
   * ```
   */
  height: void 0,
  /**
   * @description
   * Initial number of rows.
   *
   * __Note:__ This option only has effect in Handsontable constructor and only if `data` option is not provided
   *
   * @type {Number}
   * @default 5
   *
   * @example
   * ```js
   * // start with 15 empty rows
   * startRows: 15,
   * ```
   */
  startRows: 5,
  /**
   * @description
   * Initial number of columns.
   *
   * __Note:__ This option only has effect in Handsontable constructor and only if `data` option is not provided
   *
   * @type {Number}
   * @default 5
   *
   * @example
   * ```js
   * // start with 15 empty columns
   * startCols: 15,
   * ```
   */
  startCols: 5,
  /**
   * Setting `true` or `false` will enable or disable the default row headers (1, 2, 3).
   * You can also define an array `['One', 'Two', 'Three', ...]` or a function to define the headers.
   * If a function is set the index of the row is passed as a parameter.
   *
   * @type {Boolean|String[]|Function}
   * @default undefined
   *
   * @example
   * ```js
   * // as a boolean
   * rowHeaders: true,
   *
   * // as an array
   * rowHeaders: ['1', '2', '3'],
   *
   * // as a function
   * rowHeaders: function(index) {
   *   return index + ': AB';
   * },
   * ```
   */
  rowHeaders: void 0,
  /**
   * Setting `true` or `false` will enable or disable the default column headers (A, B, C).
   * You can also define an array `['One', 'Two', 'Three', ...]` or a function to define the headers.
   * If a function is set, then the index of the column is passed as a parameter.
   *
   * @type {Boolean|String[]|Function}
   * @default null
   *
   * @example
   * ```js
   * // as a boolean
   * colHeaders: true,
   *
   * // as an array
   * colHeaders: ['A', 'B', 'C'],
   *
   * // as a function
   * colHeaders: function(index) {
   *   return index + ': AB';
   * },
   * ```
   */
  colHeaders: null,
  /**
   * Defines column widths in pixels. Accepts number, string (that will be converted to a number), array of numbers
   * (if you want to define column width separately for each column) or a function (if you want to set column width
   * dynamically on each render).
   *
   * @type {Number|Number[]|String|String[]|Function}
   * @default undefined
   *
   * @example
   * ```js
   * // as a number, for each column.
   * colWidths: 100,
   *
   * // as a string, for each column.
   * colWidths: '100px',
   *
   * // as an array, based on visual indexes. The rest of the columns have a default width.
   * colWidths: [100, 120, 90],
   *
   * // as a function, based on visual indexes.
   * colWidths: function(index) {
   *   return index * 10;
   * },
   * ```
   */
  colWidths: void 0,
  /**
   * Defines row heights in pixels. Accepts numbers, strings (that will be converted into a number), array of numbers
   * (if you want to define row height separately for each row) or a function (if you want to set row height dynamically
   * on each render).
   *
   * If the {@link ManualRowResize} or {@link AutoRowSize} plugins are enabled, this is also the minimum height that can
   * be set via either of those two plugins.
   *
   * Height should be equal or greater than 23px. Table is rendered incorrectly if height is less than 23px.
   *
   * @type {Number|Number[]|String|String[]|Function}
   * @default undefined
   *
   * @example
   * ```js
   * // as a number, the same for all rows
   * rowHeights: 100,
   *
   * // as a string, the same for all row
   * rowHeights: '100px',
   *
   * // as an array, based on visual indexes. The rest of the rows have a default height
   * rowHeights: [100, 120, 90],
   *
   * // as a function, based on visual indexes
   * rowHeights: function(index) {
   *   return index * 10;
   * },
   * ```
   */
  rowHeights: void 0,
  /**
   * @description
   * Defines the cell properties and data binding for certain columns.
   *
   * __Note:__ Using this option sets a fixed number of columns (options `startCols`, `minCols`, `maxCols` will be ignored).
   *
   * See [documentation -> datasources.html](https://docs.handsontable.com/tutorial-data-sources.html#page-nested) for examples.
   *
   * @type {Object[]|Function}
   * @default undefined
   *
   * @example
   * ```js
   * // as an array of objects
   * // order of the objects in array is representation of physical indexes.
   * columns: [
   *   {
   *     // column options for the first column
   *     type: 'numeric',
   *     numericFormat: {
   *       pattern: '0,0.00 $'
   *     }
   *   },
   *   {
   *     // column options for the second column
   *     type: 'text',
   *     readOnly: true
   *   }
   * ],
   *
   * // or as a function, based on physical indexes
   * columns: function(index) {
   *   return {
   *     type: index > 0 ? 'numeric' : 'text',
   *     readOnly: index < 1
   *   }
   * }
   * ```
   */
  columns: void 0,
  /**
   * @description
   * Defines the cell properties for given `row`, `col`, `prop` coordinates. Any constructor or column option may be
   * overwritten for a particular cell (row/column combination) using the `cells` property in the Handsontable constructor.
   *
   * __Note:__ Parameters `row` and `col` always represent __physical indexes__. Example below show how to execute
   * operations based on the __visual__ representation of Handsontable.
   *
   * Possible values of `prop`:
   * - property name for column's data source object, when dataset is an [array of objects](/tutorial-data-sources.html#page-object)
   * - the same number as `col`, when dataset is an [array of arrays](/tutorial-data-sources.html#page-array)
   *
   * @type {Function}
   * @default undefined
   *
   * @example
   * ```js
   * cells: function(row, column, prop) {
   *   const cellProperties = {};
   *   const visualRowIndex = this.instance.toVisualRow(row);
   *   const visualColIndex = this.instance.toVisualColumn(column);
   *
   *   if (visualRowIndex === 0 && visualColIndex === 0) {
   *     cellProperties.readOnly = true;
   *   }
   *
   *   return cellProperties;
   * },
   * ```
   */
  cells: void 0,
  /**
   * Any constructor or column option may be overwritten for a particular cell (row/column combination), using `cell`
   * array passed to the Handsontable constructor.
   *
   * @type {Array[]}
   * @default []
   *
   * @example
   * ```js
   * // make cell with coordinates (0, 0) read only
   * cell: [
   *   {
   *     row: 0,
   *     col: 0,
   *     readOnly: true
   *   }
   * ],
   * ```
   */
  cell: [],
  /**
   * @description
   * If `true`, enables the {@link Comments} plugin, which enables an option to apply cell comments through the context menu
   * (configurable with context menu keys `commentsAddEdit`, `commentsRemove`).
   *
   * To initialize Handsontable with predefined comments, provide cell coordinates and comment text values in a form of
   * an array.
   *
   * See [Comments](https://docs.handsontable.com/demo-comments_.html) demo for examples.
   *
   * @type {Boolean|Object[]}
   * @default false
   *
   * @example
   * ```js
   * // enable comments plugin
   * comments: true,
   *
   * // or
   * // enable comments plugin and add predefined comments
   * comments: [
   *   {
   *     row: 1,
   *     col: 1,
   *     comment: {
   *       value: "Test comment"
   *     }
   *   }
   * ],
   * ```
   */
  comments: false,
  /**
   * @description
   * If `true`, enables the {@link CustomBorders} plugin, which enables an option to apply custom borders through the context
   * menu (configurable with context menu key `borders`). To initialize Handsontable with predefined custom borders,
   * provide cell coordinates and border styles in a form of an array.
   *
   * See [Custom Borders](https://docs.handsontable.com/demo-custom-borders.html) demo for examples.
   *
   * @type {Boolean|Object[]}
   * @default false
   *
   * @example
   * ```js
   * // enable custom borders
   * customBorders: true,
   *
   * // or
   * // enable custom borders and start with predefined left border
   * customBorders: [
   *   {
   *     range: {
   *       from: {
   *         row: 1,
   *         col: 1
   *       },
   *       to: {
   *         row: 3,
   *         col: 4
   *       }
   *     },
   *     left: {
   *       width: 2,
   *       color: 'red'
   *     },
   *     right: {},
   *     top: {},
   *     bottom: {}
   *   }
   * ],
   *
   * // or
   * customBorders: [
   *   {
   *     row: 2,
   *     col: 2,
   *     left: {
   *       width: 2,
   *       color: 'red'
   *     },
   *     right: {
   *       width: 1,
   *       color: 'green'
   *     },
   *     top: '',
   *     bottom: ''
   *   }
   * ],
   * ```
   */
  customBorders: false,
  /**
   * Minimum number of rows. At least that number of rows will be created during initialization.
   *
   * @type {Number}
   * @default 0
   *
   * @example
   * ```js
   * // set minimum table size to 10 rows
   * minRows: 10,
   * ```
   */
  minRows: 0,
  /**
   * Minimum number of columns. At least that number of columns will be created during initialization.
   *
   * @type {Number}
   * @default 0
   *
   * @example
   * ```js
   * // set minimum table size to 10 columns
   * minCols: 10,
   * ```
   */
  minCols: 0,
  /**
   * Maximum number of rows. If set to a value lower than the initial row count, the data will be trimmed to the provided
   * value as the number of rows.
   *
   * @type {Number}
   * @default Infinity
   *
   * @example
   * ```js
   * // limit table size to maximum 300 rows
   * maxRows: 300,
   * ```
   */
  maxRows: Infinity,
  /**
   * Maximum number of cols. If set to a value lower than the initial col count, the data will be trimmed to the provided
   * value as the number of cols.
   *
   * @type {Number}
   * @default Infinity
   *
   * @example
   * ```js
   * // limit table size to maximum 300 columns
   * maxCols: 300,
   * ```
   */
  maxCols: Infinity,
  /**
   * When set to 1 (or more), Handsontable will add a new row at the end of grid if there are no more empty rows.
   * (unless the number of rows exceeds the one set in the `maxRows` property)
   *
   * @type {Number}
   * @default 0
   *
   * @example
   * ```js
   * // always add 3 empty rows at the table end
   * minSpareRows: 3,
   * ```
   */
  minSpareRows: 0,
  /**
   * When set to 1 (or more), Handsontable will add a new column at the end of grid if there are no more empty columns.
   * (unless the number of rows exceeds the one set in the `maxCols` property)
   *
   * @type {Number}
   * @default 0
   *
   * @example
   * ```js
   * // always add 3 empty columns at the table end
   * minSpareCols: 3,
   * ```
   */
  minSpareCols: 0,
  /**
   * If set to `false`, there won't be an option to insert new rows in the Context Menu.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // hide "Insert row above" and "Insert row below" options from the Context Menu
   * allowInsertRow: false,
   * ```
   */
  allowInsertRow: true,
  /**
   * If set to `false`, there won't be an option to insert new columns in the Context Menu.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // hide "Insert column left" and "Insert column right" options from the Context Menu
   * allowInsertColumn: false,
   * ```
   */
  allowInsertColumn: true,
  /**
   * If set to `false`, there won't be an option to remove rows in the Context Menu.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // hide "Remove row" option from the Context Menu
   * allowRemoveRow: false,
   * ```
   */
  allowRemoveRow: true,
  /**
   * If set to `false`, there won't be an option to remove columns in the Context Menu.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // hide "Remove column" option from the Context Menu
   * allowRemoveColumn: false,
   * ```
   */
  allowRemoveColumn: true,
  /**
   * @description
   * Defines how the table selection reacts. The selection support three different behaviors defined as:
   *  * `'single'` Only a single cell can be selected.
   *  * `'range'` Multiple cells within a single range can be selected.
   *  * `'multiple'` Multiple ranges of cells can be selected.
   *
   * To see how to interact with selection by getting selected data or change styles of the selected cells go to
   * [https://docs.handsontable.com/demo-selecting-ranges.html](https://docs.handsontable.com/demo-selecting-ranges.html).
   *
   * @type {String}
   * @default 'multiple'
   *
   * @example
   * ```js
   * // only one cell can be selected at a time
   * selectionMode: 'single',
   * ```
   */
  selectionMode: "multiple",
  /**
   * Enables the fill handle (drag-down and copy-down) functionality, which shows a small rectangle in bottom
   * right corner of the selected area, that let's you expand values to the adjacent cells.
   *
   * Setting to `true` enables the fillHandle plugin. Possible values: `true` (to enable in all directions),
   * `'vertical'` or `'horizontal'` (to enable in one direction), `false` (to disable completely), an object with
   * options: `autoInsertRow`, `direction`.
   *
   * If `autoInsertRow` option is `true`, fill-handler will create new rows till it reaches the last row.
   * It is enabled by default.
   *
   * @type {Boolean|String|Object}
   * @default true
   *
   * @example
   * ```js
   * // enable plugin in all directions and with autoInsertRow as true
   * fillHandle: true,
   *
   * // or
   * // enable plugin in vertical direction and with autoInsertRow as true
   * fillHandle: 'vertical',
   *
   * // or
   * fillHandle: {
   *   // enable plugin in both directions and with autoInsertRow as false
   *   autoInsertRow: false,
   * },
   *
   * // or
   * fillHandle: {
   *   // enable plugin in vertical direction and with autoInsertRow as false
   *   autoInsertRow: false,
   *   direction: 'vertical'
   * },
   * ```
   */
  fillHandle: {
    autoInsertRow: false
  },
  /**
   * Allows to specify the number of fixed (or *frozen*) rows at the top of the table.
   *
   * @type {Number}
   * @default 0
   *
   * @example
   * ```js
   * // freeze the first 3 rows of the table.
   * fixedRowsTop: 3,
   * ```
   */
  fixedRowsTop: 0,
  /**
   * Allows to specify the number of fixed (or *frozen*) rows at the bottom of the table.
   *
   * @type {Number}
   * @default 0
   *
   * @example
   * ```js
   * // freeze the last 3 rows of the table.
   * fixedRowsBottom: 3,
   * ```
   */
  fixedRowsBottom: 0,
  /**
   * Allows to specify the number of fixed (or *frozen*) columns on the left of the table.
   *
   * @type {Number}
   * @default 0
   *
   * @example
   * ```js
   * // freeze first 3 columns of the table.
   * fixedColumnsLeft: 3,
   * ```
   */
  fixedColumnsLeft: 0,
  /**
   * If `true`, mouse click outside the grid will deselect the current selection. Can be a function that takes the
   * click event target and returns a boolean.
   *
   * @type {Boolean|Function}
   * @default true
   *
   * @example
   * ```js
   * // don't clear current selection when mouse click was outside the grid
   * outsideClickDeselects: false,
   *
   * // or
   * outsideClickDeselects: function(event) {
   *   return false;
   * }
   * ```
   */
  outsideClickDeselects: true,
  /**
   * If `true`, <kbd>ENTER</kbd> begins editing mode (like in Google Docs). If `false`, <kbd>ENTER</kbd> moves to next
   * row (like Excel) and adds a new row if necessary. <kbd>TAB</kbd> adds new column if necessary.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * enterBeginsEditing: false,
   * ```
   */
  enterBeginsEditing: true,
  /**
   * Defines the cursor movement after <kbd>ENTER</kbd> was pressed (<kbd>SHIFT</kbd> + <kbd>ENTER</kbd> uses a negative vector). Can
   * be an object or a function that returns an object. The event argument passed to the function is a DOM Event object
   * received after the <kbd>ENTER</kbd> key has been pressed. This event object can be used to check whether user pressed
   * <kbd>ENTER</kbd> or <kbd>SHIFT</kbd> + <kbd>ENTER</kbd>.
   *
   * @type {Object|Function}
   * @default {row: 1, col: 0}
   *
   * @example
   * ```js
   * // move selection diagonal by 1 cell in x and y axis
   * enterMoves: {row: 1, col: 1},
   * // or as a function
   * enterMoves: function(event) {
   *   return {row: 1, col: 1};
   * },
   * ```
   */
  enterMoves: {
    row: 1,
    col: 0
  },
  /**
   * Defines the cursor movement after <kbd>TAB</kbd> is pressed (<kbd>SHIFT</kbd> + <kbd>TAB</kbd> uses a negative vector). Can
   * be an object or a function that returns an object. The event argument passed to the function is a DOM Event object
   * received after the <kbd>TAB</kbd> key has been pressed. This event object can be used to check whether user pressed
   * <kbd>TAB</kbd> or <kbd>SHIFT</kbd> + <kbd>TAB</kbd>.
   *
   * @type {Object|Function}
   * @default {row: 0, col: 1}
   *
   * @example
   * ```js
   * // move selection 2 cells away after TAB pressed.
   * tabMoves: {row: 2, col: 2},
   * // or as a function
   * tabMoves: function(event) {
   *   return {row: 2, col: 2};
   * },
   * ```
   */
  tabMoves: {
    row: 0,
    col: 1
  },
  /**
   * If `true`, pressing <kbd>TAB</kbd> or right arrow in the last column will move to first column in next row.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // stop TAB key navigation on the last column
   * autoWrapRow: false,
   * ```
   */
  autoWrapRow: true,
  /**
   * If `true`, pressing <kbd>ENTER</kbd> or down arrow in the last row will move to the first row in the next column.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // stop ENTER key navigation on the last row
   * autoWrapCol: false,
   * ```
   */
  autoWrapCol: true,
  /**
   * @description
   * Turns on saving the state of column sorting, column positions and column sizes in local storage.
   *
   * You can save any sort of data in local storage to preserve table state between page reloads.  In order to enable
   * data storage mechanism, `persistentState` option must be set to `true` (you can set it either during Handsontable
   * initialization or using the `updateSettings` method). When `persistentState` is enabled it exposes 3 hooks:
   *
   * __persistentStateSave__ (key: String, value: Mixed)
   *
   *   * Saves value under given key in browser local storage.
   *
   * __persistentStateLoad__ (key: String, valuePlaceholder: Object)
   *
   *   * Loads `value`, saved under given key, form browser local storage. The loaded `value` will be saved in
   *   `valuePlaceholder.value` (this is due to specific behaviour of `Hooks.run()` method). If no value have
   *   been saved under key `valuePlaceholder.value` will be `undefined`.
   *
   * __persistentStateReset__ (key: String)
   *
   *   * Clears the value saved under `key`. If no `key` is given, all values associated with table will be cleared.
   *
   * __Note:__ The main reason behind using `persistentState` hooks rather than regular LocalStorage API is that it
   * ensures separation of data stored by multiple Handsontable instances. In other words, if you have two (or more)
   * instances of Handsontable on one page, data saved by one instance won't be accessible by the second instance.
   * Those two instances can store data under the same key and no data would be overwritten.
   *
   * __Important:__ In order for the data separation to work properly, make sure that each instance of Handsontable has a unique `id`.
   *
   * @type {Boolean}
   * @default false
   *
   * @example
   * ```js
   * // enable the persistent state plugin
   * persistentState: true,
   * ```
   */
  persistentState: void 0,
  /**
   * Class name for all visible rows in the current selection.
   *
   * @type {String}
   * @default undefined
   *
   * @example
   * ```js
   * // This will add a 'currentRow' class name to appropriate table cells.
   * currentRowClassName: 'currentRow',
   * ```
   */
  currentRowClassName: void 0,
  /**
   * Class name for all visible columns in the current selection.
   *
   * @type {String}
   * @default undefined
   *
   * @example
   * ```js
   * // This will add a 'currentColumn' class name to appropriate table cells.
   * currentColClassName: 'currentColumn',
   * ```
   */
  currentColClassName: void 0,
  /**
   * Class name for all visible headers in current selection.
   *
   * @type {String}
   * @default 'ht__highlight'
   *
   * @example
   * ```js
   * // This will add a 'ht__highlight' class name to appropriate table headers.
   * currentHeaderClassName: 'ht__highlight',
   * ```
   */
  currentHeaderClassName: "ht__highlight",
  /**
   * Class name for all active headers in selections. The header will be marked with this class name
   * only when a whole column or row will be selected.
   *
   * @type {String}
   * @since 0.38.2
   * @default 'ht__active_highlight'
   *
   * @example
   * ```js
   * // this will add a 'ht__active_highlight' class name to appropriate table headers.
   * activeHeaderClassName: 'ht__active_highlight',
   * ```
   */
  activeHeaderClassName: "ht__active_highlight",
  /**
   * Class name for the Handsontable container element.
   *
   * @type {String|String[]}
   * @default undefined
   *
   * @example
   * ```js
   * // set custom class for table container
   * className: 'your__class--name',
   *
   * // or
   * className: ['first-class-name', 'second-class-name'],
   * ```
   */
  className: void 0,
  /**
   * Class name for all tables inside container element.
   *
   * @type {String|String[]}
   * @default undefined
   *
   * @example
   * ```js
   * // set custom class for table element
   * tableClassName: 'your__class--name',
   *
   * // or
   * tableClassName: ['first-class-name', 'second-class-name'],
   * ```
   */
  tableClassName: void 0,
  /**
   * @description
   * Defines how the columns react, when the declared table width is different than the calculated sum of all column widths.
   * [See more](https://docs.handsontable.com/demo-stretching.html) mode. Possible values:
   *  * `'none'` Disable stretching
   *  * `'last'` Stretch only the last column
   *  * `'all'` Stretch all the columns evenly
   *
   * @type {String}
   * @default 'none'
   *
   * @example
   * ```js
   * // fit table to the container
   * stretchH: 'all',
   * ```
   */
  stretchH: "none",
  /**
   * Overwrites the default `isEmptyRow` method, which checks if row at the provided index is empty.
   *
   * @type {Function}
   * @param {Number} row Visual row index.
   * @returns {Boolean}
   *
   * @example
   * ```js
   * // define custom checks for empty row
   * isEmptyRow: function(row) {
   *    ...
   * },
   * ```
   */
  isEmptyRow: function isEmptyRow(row) {
    var col;
    var colLen;
    var value;
    var meta;
    for (col = 0, colLen = this.countCols(); col < colLen; col++) {
      value = this.getDataAtCell(row, col);
      if (value !== "" && value !== null && isDefined(value)) {
        if (_typeof21(value) === "object") {
          meta = this.getCellMeta(row, col);
          return isObjectEqual(this.getSchema()[meta.prop], value);
        }
        return false;
      }
    }
    return true;
  },
  /**
   * Overwrites the default `isEmptyCol` method, which checks if column at the provided index is empty.
   *
   * @type {Function}
   * @param {Number} column Visual column index
   * @returns {Boolean}
   *
   * @example
   * ```js
   * // define custom checks for empty column
   * isEmptyCol: function(column) {
   *    return false;
   * },
   * ```
   */
  isEmptyCol: function isEmptyCol(col) {
    var row;
    var rowLen;
    var value;
    for (row = 0, rowLen = this.countRows(); row < rowLen; row++) {
      value = this.getDataAtCell(row, col);
      if (value !== "" && value !== null && isDefined(value)) {
        return false;
      }
    }
    return true;
  },
  /**
   * When set to `true`, the table is re-rendered when it is detected that it was made visible in DOM.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // don't rerender the table on visibility changes
   * observeDOMVisibility: false,
   * ```
   */
  observeDOMVisibility: true,
  /**
   * If set to `true`, Handsontable will accept values that were marked as invalid by the cell `validator`. It will
   * result with *invalid* cells being treated as *valid* (will save the *invalid* value into the Handsontable data source).
   * If set to `false`, Handsontable will *not* accept the invalid values and won't allow the user to close the editor.
   * This option will be particularly useful when used with the Autocomplete's `strict` mode.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // don't save the invalid values
   * allowInvalid: false,
   * ```
   */
  allowInvalid: true,
  /**
   * If set to `true`, Handsontable will accept values that are empty (`null`, `undefined` or `''`). If set to `false`,
   * Handsontable will *not* accept the empty values and mark cell as invalid.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // allow empty values for all cells (whole table)
   * allowEmpty: true,
   *
   * // or
   * columns: [
   *   {
   *     data: 'date',
   *     dateFormat: 'DD/MM/YYYY',
   *     // allow empty values only for the 'date' column
   *     allowEmpty: true
   *   }
   * ],
   * ```
   */
  allowEmpty: true,
  /**
   * CSS class name for cells that did not pass validation.
   *
   * @type {String}
   * @default 'htInvalid'
   *
   * @example
   * ```js
   * // set custom validation error class
   * invalidCellClassName: 'highlight--error',
   * ```
   */
  invalidCellClassName: "htInvalid",
  /**
   * When set to an non-empty string, displayed as the cell content for empty cells. If a value of a different type is provided,
   * it will be stringified and applied as a string.
   *
   * @type {String}
   * @default undefined
   *
   * @example
   * ```js
   * // add custom placeholder content to empty cells
   * placeholder: 'Empty Cell',
   * ```
   */
  placeholder: void 0,
  /**
   * CSS class name for cells that have a placeholder in use.
   *
   * @type {String}
   * @default 'htPlaceholder'
   *
   * @example
   * ```js
   * // set custom placeholder class
   * placeholderCellClassName: 'has-placeholder',
   * ```
   */
  placeholderCellClassName: "htPlaceholder",
  /**
   * CSS class name for read-only cells.
   *
   * @type {String}
   * @default 'htDimmed'
   *
   * @example
   * ```js
   * // set custom read-only class
   * readOnlyCellClassName: 'is-readOnly',
   * ```
   */
  readOnlyCellClassName: "htDimmed",
  /**
   * @description
   * If a string is provided, it may be one of the following predefined values:
   * * `autocomplete`,
   * * `checkbox`,
   * * `html`,
   * * `numeric`,
   * * `password`.
   * * `text`.
   *
   * Or you can [register](https://docs.handsontable.com/demo-custom-renderers.html) the custom renderer under specified name and use its name as an alias in your
   * configuration.
   *
   * If a function is provided, it will receive the following arguments:
   * ```js
   * function(instance, TD, row, col, prop, value, cellProperties) {}
   * ```
   *
   * You can read more about custom renderes [in the documentation](https://docs.handsontable.com/demo-custom-renderers.html).
   *
   * @type {String|Function}
   * @default undefined
   *
   * @example
   * ```js
   * // register custom renderer
   * Handsontable.renderers.registerRenderer('my.renderer', function(instance, TD, row, col, prop, value, cellProperties) {
   *   TD.innerHTML = value;
   * });
   *
   * // use it for selected column:
   * columns: [
   *   {
   *     // as a string with the name of build in renderer
   *     renderer: 'autocomplete',
   *     editor: 'select'
   *   },
   *   {
   *     // as an alias to custom renderer registered above
   *     renderer: 'my.renderer'
   *   },
   *   {
   *     // renderer as custom function
   *     renderer: function(hotInstance, TD, row, col, prop, value, cellProperties) {
   *       TD.style.color = 'blue';
   *       TD.innerHTML = value;
   *     }
   *   }
   * ],
   * ```
   */
  renderer: void 0,
  /**
   * CSS class name added to the commented cells.
   *
   * @type {String}
   * @default 'htCommentCell'
   *
   * @example
   * ```js
   * // set custom class for commented cells
   * commentedCellClassName: 'has-comment',
   * ```
   */
  commentedCellClassName: "htCommentCell",
  /**
   * If set to `true`, it enables the browser's native selection of a fragment of the text within a single cell, between
   * adjacent cells or in a whole table. If set to `'cell'`, it enables the possibility of selecting a fragment of the
   * text within a single cell's body.
   *
   * @type {Boolean|String}
   * @default false
   *
   * @example
   * ```js
   * // enable text selection within table
   * fragmentSelection: true,
   *
   * // or
   * // enable text selection within cells only
   * fragmentSelection: 'cell',
   * ```
   */
  fragmentSelection: false,
  /**
   * @description
   * Makes cell [read only](https://docs.handsontable.com/demo-read-only.html).
   *
   * @type {Boolean}
   * @default false
   *
   * @example
   * ```js
   * // set cell as read only
   * readOnly: true,
   * ```
   */
  readOnly: false,
  /**
   * @description
   * When added to a `column` property, it skips the column on paste and pastes the data on the next column to the right.
   *
   * @type {Boolean}
   * @default false
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     // don't paste data to this column
   *     skipColumnOnPaste: true
   *   }
   * ],
   * ```
   */
  skipColumnOnPaste: false,
  /**
   * @description
   * Setting to `true` enables the {@link Search} plugin (see [demo](https://docs.handsontable.com/demo-search-for-values.html)).
   *
   * @type {Boolean}
   * @default false
   *
   * @example
   * ```js
   * // enable search plugin
   * search: true,
   *
   * // or
   * // as an object with detailed configuration
   * search: {
   *   searchResultClass: 'customClass',
   *   queryMethod: function(queryStr, value) {
   *     ...
   *   },
   *   callback: function(instance, row, column, value, result) {
   *     ...
   *   }
   * }
   * ```
   */
  search: false,
  /**
   * @description
   * Shortcut to define the combination of the cell renderer, editor and validator for the column, cell or whole table.
   *
   * Possible values:
   *  * [autocomplete](https://docs.handsontable.com/demo-autocomplete.html)
   *  * [checkbox](https://docs.handsontable.com/demo-checkbox.html)
   *  * [date](https://docs.handsontable.com/demo-date.html)
   *  * [dropdown](https://docs.handsontable.com/demo-dropdown.html)
   *  * [handsontable](https://docs.handsontable.com/demo-handsontable.html)
   *  * [numeric](https://docs.handsontable.com/demo-numeric.html)
   *  * [password](https://docs.handsontable.com/demo-password.html)
   *  * text
   *  * [time](https://docs.handsontable.com/demo-time.html)
   *
   * Or you can register the custom cell type under specified name and use
   * its name as an alias in your configuration.
   *
   * @type {String}
   * @default 'text'
   *
   * @example
   * ```js
   * // register custom cell type:
   * Handsontable.cellTypes.registerCellType('my.type', {
   *   editor: MyEditorClass,
   *   renderer: function(hot, td, row, col, prop, value, cellProperties) {
   *     td.innerHTML = value;
   *   },
   *   validator: function(value, callback) {
   *     callback(value === 'foo' ? true : false);
   *   }
   * });
   *
   * // use it in column settings:
   * columns: [
   *   {
   *     type: 'text'
   *   },
   *   {
   *     // an alias to custom type
   *     type: 'my.type'
   *   },
   *   {
   *     type: 'checkbox'
   *   }
   * ],
   * ```
   */
  type: "text",
  /**
   * @description
   * Makes a cell copyable (pressing <kbd>CTRL</kbd> + <kbd>C</kbd> on your keyboard moves its value to system clipboard).
   *
   * __Note:__ this setting is `false` by default for cells with type `password`.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * cells: [
   *   {
   *     cell: 0,
   *     row: 0,
   *     // cell with coordinates (0, 0) can't be copied
   *     copyable: false,
   *   }
   * ],
   * ```
   */
  copyable: true,
  /**
   * Defines the editor for the table/column/cell.
   *
   * If a string is provided, it may be one of the following predefined values:
   *  * [autocomplete](https://docs.handsontable.com/demo-autocomplete.html)
   *  * [checkbox](https://docs.handsontable.com/demo-checkbox.html)
   *  * [date](https://docs.handsontable.com/demo-date.html)
   *  * [dropdown](https://docs.handsontable.com/demo-dropdown.html)
   *  * [handsontable](https://docs.handsontable.com/demo-handsontable.html)
   *  * [mobile](https://docs.handsontable.com/demo-mobiles-and-tablets.html)
   *  * [password](https://docs.handsontable.com/demo-password.html)
   *  * [select](https://docs.handsontable.com/demo-select.html)
   *  * text
   *
   * Or you can [register](https://docs.handsontable.com/tutorial-cell-editor.html#registering-an-editor) the custom editor under specified name and use its name as an alias in your
   * configuration.
   *
   * To disable cell editing completely set `editor` property to `false`.
   *
   * @type {String|Function|Boolean}
   * @default undefined
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     // set editor for the first column
   *     editor: 'select'
   *   },
   *   {
   *     // disable editor for the second column
   *     editor: false
   *   }
   * ],
   * ```
   */
  editor: void 0,
  /**
   * Control number of choices for the autocomplete (or dropdown) typed cells. After exceeding it, a scrollbar for the
   * dropdown list of choices will appear.
   *
   * @type {Number}
   * @default 10
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     type: 'autocomplete',
   *     // set autocomplete options list height
   *     visibleRows: 15,
   *   }
   * ],
   * ```
   */
  visibleRows: 10,
  /**
   * Makes autocomplete or dropdown width the same as the edited cell width. If `false` then editor will be scaled
   * according to its content.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     type: 'autocomplete',
   *     // don't trim dropdown width with column width
   *     trimDropdown: false,
   *   }
   * ],
   * ```
   */
  trimDropdown: true,
  /**
   * Setting to `true` enables the debug mode, currently used to test the correctness of the row and column
   * header fixed positioning on a layer above the master table.
   *
   * @type {Boolean}
   * @default false
   *
   * @example
   * ```js
   * // enable debug mode
   * debug: true,
   * ```
   */
  debug: false,
  /**
   * When set to `true`, the text of the cell content is wrapped if it does not fit in the fixed column width.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * colWidths: 100,
   * columns: [
   *   {
   *     // fixed column width is set but don't wrap the content
   *     wordWrap: false,
   *   }
   * ],
   * ```
   */
  wordWrap: true,
  /**
   * CSS class name added to cells with cell meta `wordWrap: false`.
   *
   * @type {String}
   * @default 'htNoWrap'
   *
   * @example
   * ```js
   * // set custom class for cells which content won't be wrapped
   * noWordWrapClassName: 'is-noWrapCell',
   * ```
   */
  noWordWrapClassName: "htNoWrap",
  /**
   * @description
   * Defines if the right-click context menu should be enabled. Context menu allows to create new row or column at any
   * place in the grid among [other features](https://docs.handsontable.com/demo-context-menu.html).
   * Possible values:
   * * `true` (to enable default options),
   * * `false` (to disable completely)
   * * an array of [predefined options](https://docs.handsontable.com/demo-context-menu.html#page-specific),
   * * an object [with defined structure](https://docs.handsontable.com/demo-context-menu.html#page-custom)
   *
   * See [the context menu demo](https://docs.handsontable.com/demo-context-menu.html) for examples.
   *
   * @type {Boolean|String[]|Object}
   * @default undefined
   *
   * @example
   * ```js
   * // as a boolean
   * contextMenu: true,
   *
   * // as an array
   * contextMenu: ['row_above', 'row_below', '--------', 'undo', 'redo'],
   *
   * // as an object (`name` attribute is required in the custom keys)
   * contextMenu: {
   *   items: {
   *     "option1": {
   *       name: "option1"
   *     },
   *     "option2": {
   *       name: "option2",
   *       submenu: {
   *         items: [
   *           {
   *             key: "option2:suboption1",
   *             name: "option2:suboption1",
   *             callback: function(key, options) {
   *               ...
   *             }
   *           },
   *           ...
   *         ]
   *       }
   *     }
   *   }
   * },
   * ```
   */
  contextMenu: void 0,
  /**
   * Disables or enables the copy/paste functionality.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // disable copy and paste
   * copyPaste: false,
   * ```
   */
  copyPaste: true,
  /**
   * If `true`, undo/redo functionality is enabled.
   *
   * @type {Boolean}
   * @default undefined
   *
   * @example
   * ```js
   * // enable undo and redo
   * undo: true,
   * ```
   */
  undo: void 0,
  /**
   * @description
   * Turns on [Column sorting](https://docs.handsontable.com/demo-sorting-data.html). Can be either a boolean (`true` / `false`) or an object with a declared sorting options:
   * * `initialConfig` - Object with predefined keys:
   *   * `column` - sorted column
   *   * `sortOrder` - order in which column will be sorted
   *     * `'asc'` = ascending
   *     * `'desc'` = descending
   * * `indicator` - display status for sorting order indicator (an arrow icon in the column header, specifying the sorting order).
   *   * `true` = show sort indicator for sorted columns
   *   * `false` = don't show sort indicator for sorted columns
   * * `headerAction` - allow to click on the headers to sort
   *   * `true` = turn on possibility to click on the headers to sort
   *   * `false` = turn off possibility to click on the headers to sort
   * * `sortEmptyCells` - how empty values should be handled
   *   * `true` = the table sorts empty cells
   *   * `false` = the table moves all empty cells to the end of the table
   * * `compareFunctionFactory` - curry function returning compare function; compare function should work in the same way as function which is handled by native `Array.sort` method); please take a look at below examples for more information.
   *
   * @type {Boolean|Object}
   * @default undefined
   *
   * @example
   * ```js
   * // as boolean
   * columnSorting: true
   *
   * // as an object with initial sort config (sort ascending for column at index 1)
   * columnSorting: {
   *   initialConfig: {
   *     column: 1,
   *     sortOrder: 'asc'
   *   }
   * }
   *
   * // as an object which define specific sorting options for all columns
   * columnSorting: {
   *   sortEmptyCells: true, // true = the table sorts empty cells, false = the table moves all empty cells to the end of the table
   *   indicator: true, // true = shows indicator for all columns, false = don't show indicator for columns
   *   headerAction: false, // true = allow to click on the headers to sort, false = turn off possibility to click on the headers to sort
   *   compareFunctionFactory: function(sortOrder, columnMeta) {
   *     return function(value, nextValue) {
   *       // Some value comparisons which will return -1, 0 or 1...
   *     }
   *   }
   * }```
   */
  columnSorting: void 0,
  /**
   * Turns on [Manual column move](https://docs.handsontable.com/demo-moving-rows-and-columns.html), if set to a boolean or define initial column order (as an array of column indexes).
   *
   * @type {Boolean|Number[]}
   * @default undefined
   *
   * @example
   * ```js
   * // as a boolean to enable column move
   * manualColumnMove: true,
   *
   * // as a array with initial order
   * // (move column index at 0 to 1 and move column index at 1 to 4)
   * manualColumnMove: [1, 4],
   * ```
   */
  manualColumnMove: void 0,
  /**
   * @description
   * Turns on [Manual column resize](https://docs.handsontable.com/demo-resizing.html), if set to a boolean or define initial column resized widths (an an array of widths).
   *
   * @type {Boolean|Number[]}
   * @default undefined
   *
   * @example
   * ```js
   * // as a boolean to enable column resize
   * manualColumnResize: true,
   *
   * // as a array with initial widths
   * // (column at 0 index has 40px and column at 1 index has 50px)
   * manualColumnResize: [40, 50],
   * ```
   */
  manualColumnResize: void 0,
  /**
   * @description
   * Turns on [Manual row move](https://docs.handsontable.com/demo-moving-rows-and-columns.html), if set to a boolean or define initial row order (as an array of row indexes).
   *
   * @type {Boolean|Number[]}
   * @default undefined
   *
   * @example
   * ```js
   * // as a boolean
   * manualRowMove: true,
   *
   * // as a array with initial order
   * // (move row index at 0 to 1 and move row index at 1 to 4)
   * manualRowMove: [1, 4],
   * ```
   */
  manualRowMove: void 0,
  /**
   * @description
   * Turns on [Manual row resize](https://docs.handsontable.com/demo-resizing.html), if set to a boolean or define initial row resized heights (as an array of heights).
   *
   * @type {Boolean|Number[]}
   * @default undefined
   *
   * @example
   * ```js
   * // as a boolean to enable row resize
   * manualRowResize: true,
   *
   * // as an array to set initial heights
   * // (row at 0 index has 40px and row at 1 index has 50px)
   * manualRowResize: [40, 50],
   * ```
   */
  manualRowResize: void 0,
  /**
   * @description
   * If set to `true`, it enables a possibility to merge cells. If set to an array of objects, it merges the cells provided
   * in the objects (see the example below). More information on [the demo page](https://docs.handsontable.com/demo-merge-cells.html).
   *
   * @type {Boolean|Object[]}
   * @default false
   *
   * @example
   * ```js
   * // enables the mergeCells plugin
   * margeCells: true,
   *
   * // declares a list of merged sections
   * mergeCells: [
   *   // rowspan and colspan properties declare the width and height of a merged section in cells
   *   {row: 1, col: 1, rowspan: 3, colspan: 3},
   *   {row: 3, col: 4, rowspan: 2, colspan: 2},
   *   {row: 5, col: 6, rowspan: 3, colspan: 3}
   * ],
   * ```
   */
  mergeCells: false,
  /**
   * @description
   * Turns on [Multi-column sorting](https://docs.handsontable.com/pro/demo-multicolumn-sorting.html). Can be either a boolean (`true` / `false`) or an object with a declared sorting options:
   * * `initialConfig` - Array containing objects, every with predefined keys:
   *   * `column` - sorted column
   *   * `sortOrder` - order in which column will be sorted
   *     * `'asc'` = ascending
   *     * `'desc'` = descending
   * * `indicator` - display status for sorting order indicator (an arrow icon in the column header, specifying the sorting order).
   *   * `true` = show sort indicator for sorted columns
   *   * `false` = don't show sort indicator for sorted columns
   * * `headerAction` - allow to click on the headers to sort
   *   * `true` = turn on possibility to click on the headers to sort
   *   * `false` = turn off possibility to click on the headers to sort
   * * `sortEmptyCells` - how empty values should be handled
   *   * `true` = the table sorts empty cells
   *   * `false` = the table moves all empty cells to the end of the table
   * * `compareFunctionFactory` - curry function returning compare function; compare function should work in the same way as function which is handled by native `Array.sort` method); please take a look at below examples for more information.
   *
   * @pro
   * @type {Boolean|Object}
   * @default undefined
   *
   * @example
   * ```js
   * // as boolean
   * multiColumnSorting: true
   *
   * // as an object with initial sort config (sort ascending for column at index 1 and then sort descending for column at index 0)
   * multiColumnSorting: {
   *   initialConfig: [{
   *     column: 1,
   *     sortOrder: 'asc'
   *   }, {
   *     column: 0,
   *     sortOrder: 'desc'
   *   }]
   * }
   *
   * // as an object which define specific sorting options for all columns
   * multiColumnSorting: {
   *   sortEmptyCells: true, // true = the table sorts empty cells, false = the table moves all empty cells to the end of the table
   *   indicator: true, // true = shows indicator for all columns, false = don't show indicator for columns
   *   headerAction: false, // true = allow to click on the headers to sort, false = turn off possibility to click on the headers to sort
   *   compareFunctionFactory: function(sortOrder, columnMeta) {
   *     return function(value, nextValue) {
   *       // Some value comparisons which will return -1, 0 or 1...
   *     }
   *   }
   * }```
   */
  multiColumnSorting: void 0,
  /**
   * @description
   * Number of rows to be rendered outside of the visible part of the table. By default, it's set to `'auto'`, which
   * makes Handsontable to attempt to calculate the best offset performance-wise.
   *
   * You may test out different values to find the best one that works for your specific implementation.
   *
   * @type {Number|String}
   * @default 'auto'
   *
   * @example
   * ```js
   * viewportRowRenderingOffset: 70,
   * ```
   */
  viewportRowRenderingOffset: "auto",
  /**
   * @description
   * Number of columns to be rendered outside of the visible part of the table. By default, it's set to `'auto'`, which
   * makes Handsontable try calculating the best offset performance-wise.
   *
   * You may experiment with the value to find the one that works best for your specific implementation.
   *
   * @type {Number|String}
   * @default 'auto'
   *
   * @example
   * ```js
   * viewportColumnRenderingOffset: 70,
   * ```
   */
  viewportColumnRenderingOffset: "auto",
  /**
   * @description
   * A function, regular expression or a string, which will be used in the process of cell validation. If a function is
   * used, be sure to execute the callback argument with either `true` (`callback(true)`) if the validation passed
   * or with `false` (`callback(false)`), if the validation failed.
   *
   * __Note__, that `this` in the function points to the `cellProperties` object.
   *
   * If a string is provided, it may be one of the following predefined values:
   * * `autocomplete`,
   * * `date`,
   * * `numeric`,
   * * `time`.
   *
   * Or you can [register](https://docs.handsontable.com/demo-data-validation.html) the validator function under specified name and use its name as an alias in your
   * configuration.
   *
   * See more [in the demo](https://docs.handsontable.com/demo-data-validation.html).
   *
   * @type {Function|RegExp|String}
   * @default undefined
   *
   * @example
   * ```js
   * columns: [
   *    {
   *      // as a function
   *      validator: function(value, callback) {
   *          ...
   *      }
   *    },
   *    {
   *      // regular expression
   *      validator: /^[0-9]$/
   *    },
   *    {
   *      // as a string
   *      validator: 'numeric'
   *    }
   * ],
   * ```
   */
  validator: void 0,
  /**
   * @description
   * Disables visual cells selection.
   *
   * Possible values:
   *  * `true` - Disables any type of visual selection (current and area selection),
   *  * `false` - Enables any type of visual selection. This is default value.
   *  * `'current'` - Disables the selection of a currently selected cell, the area selection is still present.
   *  * `'area'` - Disables the area selection, the currently selected cell selection is still present.
   *  * `'header'` - Disables the headers selection, the currently selected cell selection is still present.
   *
   * @type {Boolean|String|String[]}
   * @default false
   *
   * @example
   * ```js
   * // as a boolean
   * disableVisualSelection: true,
   *
   * // as a string ('current', 'area' or 'header')
   * disableVisualSelection: 'current',
   *
   * // as an array
   * disableVisualSelection: ['current', 'area'],
   * ```
   */
  disableVisualSelection: false,
  /**
   * Disables or enables {@link ManualColumnFreeze} plugin.
   *
   * @type {Boolean}
   * @default undefined
   *
   * @example
   * ```js
   * // enable fixed columns
   * manualColumnFreeze: true,
   * ```
   */
  manualColumnFreeze: void 0,
  /**
   * Defines whether Handsontable should trim the whitespace at the beginning and the end of the cell contents.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     // don't remove whitespace
   *     trimWhitespace: false
   *   }
   * ]
   * ```
   */
  trimWhitespace: true,
  /**
   * Defines data source for Autocomplete or Dropdown cell types.
   *
   * @type {Array|Function}
   * @default undefined
   *
   * @example
   * ```js
   * // source as a array
   * columns: [{
   *   type: 'autocomplete',
   *   source: ['A', 'B', 'C', 'D']
   * }],
   *
   * // source as a function
   * columns: [{
   *   type: 'autocomplete',
   *   source: function(query, callback) {
   *     fetch('https://example.com/query?q=' + query, function(response) {
   *       callback(response.items);
   *     })
   *   }
   * }],
   * ```
   */
  source: void 0,
  /**
   * @description
   * Defines the column header name.
   *
   * @type {String}
   * @default undefined
   *
   * @example
   * ```js
   * // set header names for every column
   * columns: [
   *   {
   *     title: 'First name',
   *     type: 'text',
   *   },
   *   {
   *     title: 'Last name',
   *     type: 'text',
   *   }
   * ],
   * ```
   */
  title: void 0,
  /**
   * Data template for `'checkbox'` type when checkbox is checked.
   *
   * @type {Boolean|String|Number}
   * @default true
   *
   * @example
   * ```js
   * checkedTemplate: 'good'
   *
   * // if a checkbox-typed cell is checked, then getDataAtCell(x, y),
   * // where x and y are the coordinates of the cell will return 'good'.
   * ```
   */
  checkedTemplate: void 0,
  /**
   * Data template for `'checkbox'` type when checkbox is unchecked.
   *
   * @type {Boolean|String|Number}
   * @default false
   *
   * @example
   * ```js
   * uncheckedTemplate: 'bad'
   *
   * // if a checkbox-typed cell is not checked, then getDataAtCell(x,y),
   * // where x and y are the coordinates of the cell will return 'bad'.
   * ```
   */
  uncheckedTemplate: void 0,
  /**
   * @description
   * Object which describes if renderer should create checkbox element with label element as a parent.
   *
   * __Note__, this option only works for [checkbox-typed](https://docs.handsontable.com/demo-checkbox.html) cells.
   *
   * By default the [checkbox](https://docs.handsontable.com/demo-checkbox.html) renderer renders the checkbox without a label.
   *
   * Possible object properties:
   *  * `property` - Defines the property name of the data object, which will to be used as a label.
   *  (eg. `label: {property: 'name.last'}`). This option works only if data was passed as an array of objects.
   *  * `position` - String which describes where to place the label text (before or after checkbox element).
   * Valid values are `'before'` and '`after`' (defaults to `'after'`).
   *  * `value` - String or a Function which will be used as label text.
   *
   * @type {Object}
   * @default undefined
   *
   * @example
   * ```js
   * columns: [{
   *   type: 'checkbox',
   *   // add "My label:" after the checkbox
   *   label: {position: 'after', value: 'My label: '}
   * }],
   * ```
   */
  label: void 0,
  /**
   * Display format for numeric typed renderers.
   *
   * __Note__, this option only works for [numeric-typed](https://docs.handsontable.com/demo-numeric.html) cells.
   *
   * Format is described by two properties:
   * * `pattern` - Handled by `numbro` for purpose of formatting numbers to desired pattern. List of supported patterns can be found [here](http://numbrojs.com/format.html#numbers).
   * * `culture` - Handled by `numbro` for purpose of formatting currencies. Examples showing how it works can be found [here](http://numbrojs.com/format.html#currency). List of supported cultures can be found [here](http://numbrojs.com/languages.html#supported-languages).
   *
   * __Note:__ Please keep in mind that this option is used only to format the displayed output! It has no effect on the input data provided for the cell. The numeric data can be entered to the table only as floats (separated by a dot or a comma) or integers, and are stored in the source dataset as JavaScript numbers.
   *
   * Handsontable uses [numbro](http://numbrojs.com/) as a main library for numbers formatting.
   *
   * @since 0.35.0
   * @type {Object}
   * @default undefined
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     type: 'numeric',
   *     // set desired format pattern and
   *     numericFormat: {
   *       pattern: '0,00',
   *       culture: 'en-US'
   *     }
   *   }
   * ],
   * ```
   */
  numericFormat: void 0,
  /**
   * Language for Handsontable translation. Possible language codes are [listed here](https://docs.handsontable.com/tutorial-internationalization.html#available-languages).
   *
   * @type {String}
   * @default 'en-US'
   *
   * @example
   * ```js
   * // set Polish language
   * language: 'pl-PL',
   * ```
   */
  language: "en-US",
  /**
   * Data source for [select-typed](https://docs.handsontable.com/demo-select.html) cells.
   *
   * __Note__, this option only works for [select-typed](https://docs.handsontable.com/demo-select.html) cells.
   *
   * @type {String[]}
   * @default undefined
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     editor: 'select',
   *     // add three select options to choose from
   *     selectOptions: ['A', 'B', 'C'],
   *   }
   * ],
   * ```
   */
  selectOptions: void 0,
  /**
   * Enables or disables the {@link AutoColumnSize} plugin. Default value is `undefined`, which has the same effect as `true`.
   * Disabling this plugin can increase performance, as no size-related calculations would be done.
   *
   * Column width calculations are divided into sync and async part. Each of those parts has their own advantages and
   * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous
   * operations don't block the browser UI.
   *
   * To configure the sync/async distribution, you can pass an absolute value (number of columns) or a percentage value.
   *
   * You can also use the `useHeaders` option to take the column headers width into calculation.
   *
   * @type {Object|Boolean}
   * @default {syncLimit: 50}
   *
   * @example
   * ```js
   * // as a number (300 columns in sync, rest async)
   * autoColumnSize: {syncLimit: 300},
   *
   * // as a string (percent)
   * autoColumnSize: {syncLimit: '40%'},
   *
   * // use headers width while calculating the column width
   * autoColumnSize: {useHeaders: true},
   * ```
   */
  autoColumnSize: void 0,
  /**
   * Enables or disables {@link AutoRowSize} plugin. Default value is `undefined`, which has the same effect as `false`
   * (disabled). Enabling this plugin can decrease performance, as size-related calculations would be performed.
   *
   * Row height calculations are divided into sync and async stages. Each of these stages has their own advantages and
   * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous
   * operations don't block the browser UI.
   *
   * To configure the sync/async distribution, you can pass an absolute value (number of columns) or a percentage value.
   *
   * @type {Object|Boolean}
   * @default {syncLimit: 500}
   *
   * @example
   * ```js
   * // as a number (300 columns in sync, rest async)
   * autoRowSize: {syncLimit: 300},
   *
   * // as a string (percent)
   * autoRowSize: {syncLimit: '40%'},
   * ```
   */
  autoRowSize: void 0,
  /**
   * Date validation format.
   *
   * __Note__, this option only works for [date-typed](https://docs.handsontable.com/demo-date.html) cells.
   *
   * @type {String}
   * @default 'DD/MM/YYYY'
   *
   * @example
   * ```js
   * columns: [{
   *   type: 'date',
   *   // localise date format
   *   dateFormat: 'MM/DD/YYYY'
   * }],
   * ```
   */
  dateFormat: "DD/MM/YYYY",
  /**
   * If `true` then dates will be automatically formatted to match the desired format.
   *
   * __Note__, this option only works for [date-typed](https://docs.handsontable.com/demo-date.html) cells.
   *
   * @type {Boolean}
   * @default false
   *
   * @example
   * ```js
   * columns: [{
   *   type: 'date',
   *   dateFormat: 'YYYY-MM-DD',
   *   // force selected date format
   *   correctFormat: true
   * }],
   * ```
   */
  correctFormat: false,
  /**
   * Definition of default value which will fill the empty cells.
   *
   * __Note__, this option only works for [date-typed](https://docs.handsontable.com/demo-date.html) cells.
   *
   * @type {String}
   * @default undefined
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     type: 'date',
   *     // always set this date for empty cells
   *     defaultDate: '2015-02-02'
   *   }
   * ],
   * ```
   */
  defaultDate: void 0,
  /**
   * If set to `true`, the value entered into the cell must match (case-sensitive) the autocomplete source.
   * Otherwise, cell won't pass the validation. When filtering the autocomplete source list, the editor will
   * be working in case-insensitive mode.
   *
   * __Note__, this option only works for [autocomplete-typed](https://docs.handsontable.com/demo-autocomplete.html) cells.
   *
   * @type {Boolean}
   * @default undefined
   *
   * @example
   * ```js
   * columns: [{
   *   type: 'autocomplete',
   *   source: ['A', 'B', 'C'],
   *   // force selected value to match the source list
   *   strict: true
   * }],
   * ```
   */
  strict: void 0,
  /**
   * If set to `true`, data defined in `source` of the autocomplete or dropdown cell will be treated as HTML.
   *
   * __Warning:__ Enabling this option can cause serious XSS vulnerabilities.
   *
   * __Note__, this option only works for [autocomplete-typed](https://docs.handsontable.com/demo-autocomplete.html) cells.
   *
   * @type {Boolean}
   * @default false
   *
   * @example
   * ```js
   * columns: [{
   *   type: 'autocomplete',
   *   // use HTML in the source list
   *   allowHtml: true,
   *   source: ['<strong>foo</strong>', '<strong>bar</strong>']
   * }],
   * ```
   */
  allowHtml: false,
  /**
   * If typed `true` then virtual rendering mechanism for handsontable will be disabled.
   *
   * @type {Boolean}
   * @default undefined
   *
   * @example
   * ```js
   * // disable virtual rows rendering
   * renderAllRows: true,
   * ```
   */
  renderAllRows: void 0,
  /**
   * Prevents table to overlap outside the parent element. If `'horizontal'` option is chosen then table will show
   * a horizontal scrollbar if parent's width is narrower then table's width.
   *
   * Possible values:
   *  * `false` - Disables functionality.
   *  * `horizontal` - Prevents horizontal overflow table.
   *  * `vertical` - Prevents vertical overflow table.
   *
   * @type {String|Boolean}
   * @default false
   *
   * @example
   * ```js
   * preventOverflow: 'horizontal',
   * ```
   */
  preventOverflow: false,
  /**
   * @description
   * Enables the functionality of the {@link BindRowsWithHeaders} plugin which allows binding the table rows with their headers.
   * If the plugin is enabled, the table row headers will "stick" to the rows, when they are hidden/moved. Basically,
   * if at the initialization row 0 has a header titled "A", it will have it no matter what you do with the table.
   *
   * @pro
   * @type {Boolean|String}
   * @default undefined
   *
   * @example
   * ```js
   * // keep row data and row headers in sync
   * bindRowsWithHeaders: true
   * ```
   */
  bindRowsWithHeaders: void 0,
  /**
   * @description
   * The {@link CollapsibleColumns} plugin allows collapsing of columns, covered by a header with the `colspan` property
   * defined.
   *
   * Clicking the "collapse/expand" button collapses (or expands) all "child" headers except the first one.
   *
   * Setting the `collapsibleColumns` property to `true` will display a "collapse/expand" button in every
   * header with a defined colspan` property.
   *
   * To limit this functionality to a smaller group of headers, define the `collapsibleColumns` property
   * as an array of objects, as in the example below.
   *
   * @pro
   * @type {Boolean|Object[]}
   * @default undefined
   *
   * @example
   * ```js
   * // enable collapsing for all headers
   * collapsibleColumns: true,
   *
   * // or
   * // enable collapsing for selected headers
   * collapsibleColumns: [
   *   {row: -4, col: 1, collapsible: true},
   *   {row: -3, col: 5, collapsible: true}
   * ],
   * ```
   */
  collapsibleColumns: void 0,
  /**
   * @description
   * Allows making pre-defined calculations on the cell values and display the results within Handsontable.
   *
   * Possible types:
   *  * `'sum'`
   *  * `'min'`
   *  * `'max'`
   *  * `'count'`
   *  * `'average'`
   *  * `'custom'` - add `customFunction`
   *
   * [See the demo for more information](https://docs.handsontable.com/pro/demo-summary-calculations.html).
   *
   * @pro
   * @type {Object[]|Function}
   * @default undefined
   *
   * @example
   * ```
   * columnSummary: [
   *   {
   *     destinationRow: 4,
   *     destinationColumn: 1,
   *     forceNumeric: true,
   *     reversedRowCoords: true,
   *     suppressDataTypeErrors: false,
   *     readOnly: true,
   *     roundFloat: false,
   *     type: 'custom',
   *     customFunction: function(endpoint) {
   *        return 100;
   *     }
   *   }
   * ],
   * ```
   */
  columnSummary: void 0,
  /**
   * This plugin allows adding a configurable dropdown menu to the table's column headers. The dropdown menu acts like
   * the {@link Options#contextMenu}, but is triggered by clicking the button in the header.
   *
   * @pro
   * @type {Boolean|Object|String[]}
   * @default undefined
   *
   * @example
   * ```js
   * // enable dropdown menu
   * dropdownMenu: true,
   *
   * // or
   * // enable and configure dropdown menu options
   * dropdownMenu: ['remove_col', '---------', 'make_read_only', 'alignment']
   * ```
   */
  dropdownMenu: void 0,
  /**
   * The {@link Filters} plugin allows filtering the table data either by the built-in component or with the API.
   *
   * @pro
   * @type {Boolean}
   * @default undefined
   *
   * @example
   * ```js
   * // enable filters
   * filters: true,
   * ```
   */
  filters: void 0,
  /**
   * The {@link Formulas} plugin allows Handsontable to process formula expressions defined in the provided data.
   *
   * @pro
   * @type {Boolean|Object}
   * @default undefined
   *
   * @example
   * ```js
   * // enable formulas plugin
   * formulas: true,
   *
   * // or as an object with custom variables to be used in formula expressions
   * formulas: {
   *   variables: {
   *     FOO: 64,
   *     BAR: 'baz',
   *   }
   * },
   * ```
   */
  formulas: void 0,
  /**
   * @description
   * The {@link GanttChart} plugin enables a possibility to create a Gantt chart using a Handsontable instance. In this
   * case, the whole table becomes read-only.
   *
   * @pro
   * @type {Object}
   * @default undefined
   */
  ganttChart: void 0,
  /**
   * @description
   * Allows adding a tooltip to the table headers.
   *
   * Available options:
   * * the `rows` property defines if tooltips should be added to row headers,
   * * the `columns` property defines if tooltips should be added to column headers,
   * * the `onlyTrimmed` property defines if tooltips should be added only to headers, which content is trimmed by the header itself (the content being wider then the header).
   *
   * @pro
   * @type {Boolean|Object}
   * @default undefined
   *
   * @example
   * ```js
   * // enable tooltips for all headers
   * headerTooltips: true,
   *
   * // or
   * headerTooltips: {
   *   rows: false,
   *   columns: true,
   *   onlyTrimmed: true
   * }
   * ```
   */
  headerTooltips: void 0,
  /**
   * The {@link HiddenColumns} plugin allows hiding of certain columns. You can pass additional configuration with an
   * object notation. Options that are then available are:
   *  * `columns` - an array of rows that should be hidden on plugin initialization
   *  * `indicators` - enables small ui markers to indicate where are hidden columns
   *
   * @pro
   * @type {Boolean|Object}
   * @default undefined
   *
   * @example
   * ```js
   * // enable column hiding
   * hiddenColumns: true,
   *
   * // or
   * hiddenColumns: {
   *   // set columns that are hidden by default
   *   columns: [5, 10, 15],
   *   // show where are hidden columns
   *   indicators: true
   * }
   * ```
   */
  hiddenColumns: void 0,
  /**
   * The {@link HiddenRows} plugin allows hiding of certain rows. You can pass additional configuration with an
   * object notation. Options that are then available are:
   *  * `rows` - an array of rows that should be hidden on plugin initialization
   *  * `indicators` - enables small ui markers to indicate where are hidden columns
   *
   * @pro
   * @type {Boolean|Object}
   * @default undefined
   *
   * @example
   * ```js
   * // enable row hiding
   * hiddenRows: true,
   *
   * // or
   * hiddenRows: {
   *   // set rows that are hidden by default
   *   rows: [5, 10, 15],
   *   // show where are hidden rows
   *   indicators: true
   * }
   * ```
   */
  hiddenRows: void 0,
  /**
   * @description
   * Allows creating a nested header structure, using the HTML's colspan attribute.
   *
   * @pro
   * @type {Array[]}
   * @default undefined
   *
   * @example
   * ```
   * nestedHeaders: [
   *   ['A', {label: 'B', colspan: 8}, 'C'],
   *   ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],
   *   ['H', 'I', 'J', 'K', 'L', 'M', 'N', 'R', 'S', 'T']
   * ],
   * ```
   */
  nestedHeaders: void 0,
  /**
   * @description
   * Plugin allowing hiding of certain rows.
   *
   * @pro
   * @type {Boolean|Number[]}
   * @default undefined
   *
   * @example
   * ```js
   * // enable plugin
   * trimRows: true,
   *
   * // or
   * // trim selected rows on table initialization
   * trimRows: [5, 10, 15],
   * ```
   */
  trimRows: void 0,
  /**
   * @description
   * Allows setting a custom width of the row headers. You can provide a number or an array of widths, if many row
   * header levels are defined.
   *
   * @type {Number|Number[]}
   * @default undefined
   *
   * @example
   * ```js
   * // set width for all row headers
   * rowHeaderWidth: 25,
   *
   * // or
   * // set width for selected headers only
   * rowHeaderWidth: [25, 30, 55],
   * ```
   */
  rowHeaderWidth: void 0,
  /**
   * @description
   * Allows setting a custom height of the column headers. You can provide a number or an array of heights, if many
   * column header levels are defined.
   *
   * @type {Number|Number[]}
   * @default undefined
   *
   * @example
   * ```js
   * // set shared height for all headers
   * columnHeaderHeight: 35,
   *
   * // or
   * // set height for each header individually
   * columnHeaderHeight: [35, 20, 55],
   *
   * // or
   * // skipped headers will fallback to default value
   * columnHeaderHeight: [35, undefined, 55],
   * ```
   */
  columnHeaderHeight: void 0,
  /**
   * @description
   * Enables the {@link ObserveChanges} plugin switches table into one-way data binding where changes are applied into
   * data source (from outside table) will be automatically reflected in the table.
   *
   * For every data change [afterChangesObserved](Hooks.html#event:afterChangesObserved) hook will be fired.
   *
   * @type {Boolean}
   * @default undefined
   *
   * @example
   * ```js
   * observeChanges: true,
   * ```
   */
  observeChanges: void 0,
  /**
   * If defined as `true`, the Autocomplete's suggestion list would be sorted by relevance (the closer to the left the
   * match is, the higher the suggestion).
   *
   * __Note__, this option only works for [autocomplete-typed](https://docs.handsontable.com/demo-autocomplete.html) cells.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     type: 'autocomplete',
   *     source: [ ... ],
   *     // keep options order as they were defined
   *     sortByRelevance: false
   *   }
   * ],
   * ```
   */
  sortByRelevance: true,
  /**
   * If defined as `true`, when the user types into the input area the Autocomplete's suggestion list is updated to only
   * include those choices starting with what has been typed; if defined as `false` all suggestions remain shown, with
   * those matching what has been typed marked in bold.
   *
   * __Note__, this option only works for [autocomplete-typed](https://docs.handsontable.com/demo-autocomplete.html) cells.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     type: 'autocomplete',
   *     source: [ ... ],
   *     // don't hide options that don't match search query
   *     filter: false
   *   }
   * ],
   * ```
   */
  filter: true,
  /**
   * If defined as `true`, filtering in the Autocomplete Editor will be case-sensitive.
   *
   * __Note__, this option only works for [autocomplete-typed](https://docs.handsontable.com/demo-autocomplete.html) cells.
   *
   * @type {Boolean}
   * @default: false
   *
   * @example
   * ```js
   * columns: [
   *   {
   *     type: 'autocomplete',
   *     source: [ ... ],
   *     // match case while searching autocomplete options
   *     filteringCaseSensitive: true
   *   }
   * ],
   * ```
   */
  filteringCaseSensitive: false,
  /**
   * @description
   * Disables or enables the drag to scroll functionality.
   *
   * @type {Boolean}
   * @default true
   *
   * @example
   * ```js
   * // don't scroll the viewport when selection gets to the viewport edge
   * dragToScroll: false,
   * ```
   */
  dragToScroll: true,
  /**
   * @description
   * Disable or enable the nested rows functionality - displaying nested structures in a two-dimensional data table.
   *
   * See [quick setup of the Nested rows](https://docs.handsontable.kbudnik/pro/next/demo-nested-rows.html).
   * @example
   * ```js
   * nestedRows: true,
   * ```
   *
   * @pro
   * @type {Boolean}
   * @default false
   */
  nestedRows: void 0
};
var defaultSettings_default = DefaultSettings;

// node_modules/handsontable/es/i18n/utils.js
function _templateObject3() {
  var data = _taggedTemplateLiteral3(['Language with code "', '" was not found. You should register particular language \n    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.']);
  _templateObject3 = function _templateObject8() {
    return data;
  };
  return data;
}
function _taggedTemplateLiteral3(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function extendNotExistingKeys(target, extension) {
  objectEach(extension, function(value, key) {
    if (isUndefined2(target[key])) {
      target[key] = value;
    }
  });
  return target;
}
function normalizeLanguageCode(languageCode) {
  var languageCodePattern = /^([a-zA-Z]{2})-([a-zA-Z]{2})$/;
  var partsOfLanguageCode = languageCodePattern.exec(languageCode);
  if (partsOfLanguageCode) {
    return "".concat(partsOfLanguageCode[1].toLowerCase(), "-").concat(partsOfLanguageCode[2].toUpperCase());
  }
  return languageCode;
}
function applyLanguageSetting(settings, languageCode) {
  var normalizedLanguageCode = normalizeLanguageCode(languageCode);
  if (hasLanguage(normalizedLanguageCode)) {
    settings.language = normalizedLanguageCode;
  } else {
    settings.language = DEFAULT_LANGUAGE_CODE;
    warnUserAboutLanguageRegistration(languageCode);
  }
}
function warnUserAboutLanguageRegistration(languageCode) {
  if (isDefined(languageCode)) {
    error(toSingleLine(_templateObject3(), languageCode));
  }
}

// node_modules/handsontable/es/i18n/constants.js
var constants_exports = {};
__export(constants_exports, {
  CONTEXTMENU_ITEMS_ADD_COMMENT: () => CONTEXTMENU_ITEMS_ADD_COMMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT: () => CONTEXTMENU_ITEMS_ALIGNMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM: () => CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM,
  CONTEXTMENU_ITEMS_ALIGNMENT_CENTER: () => CONTEXTMENU_ITEMS_ALIGNMENT_CENTER,
  CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY: () => CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY,
  CONTEXTMENU_ITEMS_ALIGNMENT_LEFT: () => CONTEXTMENU_ITEMS_ALIGNMENT_LEFT,
  CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE: () => CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE,
  CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT: () => CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT,
  CONTEXTMENU_ITEMS_ALIGNMENT_TOP: () => CONTEXTMENU_ITEMS_ALIGNMENT_TOP,
  CONTEXTMENU_ITEMS_BORDERS: () => CONTEXTMENU_ITEMS_BORDERS,
  CONTEXTMENU_ITEMS_BORDERS_BOTTOM: () => CONTEXTMENU_ITEMS_BORDERS_BOTTOM,
  CONTEXTMENU_ITEMS_BORDERS_LEFT: () => CONTEXTMENU_ITEMS_BORDERS_LEFT,
  CONTEXTMENU_ITEMS_BORDERS_RIGHT: () => CONTEXTMENU_ITEMS_BORDERS_RIGHT,
  CONTEXTMENU_ITEMS_BORDERS_TOP: () => CONTEXTMENU_ITEMS_BORDERS_TOP,
  CONTEXTMENU_ITEMS_CLEAR_COLUMN: () => CONTEXTMENU_ITEMS_CLEAR_COLUMN,
  CONTEXTMENU_ITEMS_COPY: () => CONTEXTMENU_ITEMS_COPY,
  CONTEXTMENU_ITEMS_CUT: () => CONTEXTMENU_ITEMS_CUT,
  CONTEXTMENU_ITEMS_EDIT_COMMENT: () => CONTEXTMENU_ITEMS_EDIT_COMMENT,
  CONTEXTMENU_ITEMS_FREEZE_COLUMN: () => CONTEXTMENU_ITEMS_FREEZE_COLUMN,
  CONTEXTMENU_ITEMS_HIDE_COLUMN: () => CONTEXTMENU_ITEMS_HIDE_COLUMN,
  CONTEXTMENU_ITEMS_HIDE_ROW: () => CONTEXTMENU_ITEMS_HIDE_ROW,
  CONTEXTMENU_ITEMS_INSERT_LEFT: () => CONTEXTMENU_ITEMS_INSERT_LEFT,
  CONTEXTMENU_ITEMS_INSERT_RIGHT: () => CONTEXTMENU_ITEMS_INSERT_RIGHT,
  CONTEXTMENU_ITEMS_MERGE_CELLS: () => CONTEXTMENU_ITEMS_MERGE_CELLS,
  CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD: () => CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD,
  CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD: () => CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD,
  CONTEXTMENU_ITEMS_READ_ONLY: () => CONTEXTMENU_ITEMS_READ_ONLY,
  CONTEXTMENU_ITEMS_READ_ONLY_COMMENT: () => CONTEXTMENU_ITEMS_READ_ONLY_COMMENT,
  CONTEXTMENU_ITEMS_REDO: () => CONTEXTMENU_ITEMS_REDO,
  CONTEXTMENU_ITEMS_REMOVE_BORDERS: () => CONTEXTMENU_ITEMS_REMOVE_BORDERS,
  CONTEXTMENU_ITEMS_REMOVE_COLUMN: () => CONTEXTMENU_ITEMS_REMOVE_COLUMN,
  CONTEXTMENU_ITEMS_REMOVE_COMMENT: () => CONTEXTMENU_ITEMS_REMOVE_COMMENT,
  CONTEXTMENU_ITEMS_REMOVE_ROW: () => CONTEXTMENU_ITEMS_REMOVE_ROW,
  CONTEXTMENU_ITEMS_ROW_ABOVE: () => CONTEXTMENU_ITEMS_ROW_ABOVE,
  CONTEXTMENU_ITEMS_ROW_BELOW: () => CONTEXTMENU_ITEMS_ROW_BELOW,
  CONTEXTMENU_ITEMS_SHOW_COLUMN: () => CONTEXTMENU_ITEMS_SHOW_COLUMN,
  CONTEXTMENU_ITEMS_SHOW_ROW: () => CONTEXTMENU_ITEMS_SHOW_ROW,
  CONTEXTMENU_ITEMS_UNDO: () => CONTEXTMENU_ITEMS_UNDO,
  CONTEXTMENU_ITEMS_UNFREEZE_COLUMN: () => CONTEXTMENU_ITEMS_UNFREEZE_COLUMN,
  CONTEXTMENU_ITEMS_UNMERGE_CELLS: () => CONTEXTMENU_ITEMS_UNMERGE_CELLS,
  CONTEXT_MENU_ITEMS_NAMESPACE: () => CONTEXT_MENU_ITEMS_NAMESPACE,
  FILTERS_BUTTONS_CANCEL: () => FILTERS_BUTTONS_CANCEL,
  FILTERS_BUTTONS_CLEAR: () => FILTERS_BUTTONS_CLEAR,
  FILTERS_BUTTONS_OK: () => FILTERS_BUTTONS_OK,
  FILTERS_BUTTONS_PLACEHOLDER_SEARCH: () => FILTERS_BUTTONS_PLACEHOLDER_SEARCH,
  FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE: () => FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE,
  FILTERS_BUTTONS_PLACEHOLDER_VALUE: () => FILTERS_BUTTONS_PLACEHOLDER_VALUE,
  FILTERS_BUTTONS_SELECT_ALL: () => FILTERS_BUTTONS_SELECT_ALL,
  FILTERS_CONDITIONS_AFTER: () => FILTERS_CONDITIONS_AFTER,
  FILTERS_CONDITIONS_BEFORE: () => FILTERS_CONDITIONS_BEFORE,
  FILTERS_CONDITIONS_BEGINS_WITH: () => FILTERS_CONDITIONS_BEGINS_WITH,
  FILTERS_CONDITIONS_BETWEEN: () => FILTERS_CONDITIONS_BETWEEN,
  FILTERS_CONDITIONS_BY_VALUE: () => FILTERS_CONDITIONS_BY_VALUE,
  FILTERS_CONDITIONS_CONTAINS: () => FILTERS_CONDITIONS_CONTAINS,
  FILTERS_CONDITIONS_EMPTY: () => FILTERS_CONDITIONS_EMPTY,
  FILTERS_CONDITIONS_ENDS_WITH: () => FILTERS_CONDITIONS_ENDS_WITH,
  FILTERS_CONDITIONS_EQUAL: () => FILTERS_CONDITIONS_EQUAL,
  FILTERS_CONDITIONS_GREATER_THAN: () => FILTERS_CONDITIONS_GREATER_THAN,
  FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL: () => FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_LESS_THAN: () => FILTERS_CONDITIONS_LESS_THAN,
  FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL: () => FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_NAMESPACE: () => FILTERS_CONDITIONS_NAMESPACE,
  FILTERS_CONDITIONS_NONE: () => FILTERS_CONDITIONS_NONE,
  FILTERS_CONDITIONS_NOT_BETWEEN: () => FILTERS_CONDITIONS_NOT_BETWEEN,
  FILTERS_CONDITIONS_NOT_CONTAIN: () => FILTERS_CONDITIONS_NOT_CONTAIN,
  FILTERS_CONDITIONS_NOT_EMPTY: () => FILTERS_CONDITIONS_NOT_EMPTY,
  FILTERS_CONDITIONS_NOT_EQUAL: () => FILTERS_CONDITIONS_NOT_EQUAL,
  FILTERS_CONDITIONS_TODAY: () => FILTERS_CONDITIONS_TODAY,
  FILTERS_CONDITIONS_TOMORROW: () => FILTERS_CONDITIONS_TOMORROW,
  FILTERS_CONDITIONS_YESTERDAY: () => FILTERS_CONDITIONS_YESTERDAY,
  FILTERS_DIVS_FILTER_BY_CONDITION: () => FILTERS_DIVS_FILTER_BY_CONDITION,
  FILTERS_DIVS_FILTER_BY_VALUE: () => FILTERS_DIVS_FILTER_BY_VALUE,
  FILTERS_LABELS_CONJUNCTION: () => FILTERS_LABELS_CONJUNCTION,
  FILTERS_LABELS_DISJUNCTION: () => FILTERS_LABELS_DISJUNCTION,
  FILTERS_NAMESPACE: () => FILTERS_NAMESPACE,
  FILTERS_VALUES_BLANK_CELLS: () => FILTERS_VALUES_BLANK_CELLS
});
var CONTEXT_MENU_ITEMS_NAMESPACE = "ContextMenu:items";
var CONTEXTMENU_ITEMS_ROW_ABOVE = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertRowAbove");
var CONTEXTMENU_ITEMS_ROW_BELOW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertRowBelow");
var CONTEXTMENU_ITEMS_INSERT_LEFT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertColumnOnTheLeft");
var CONTEXTMENU_ITEMS_INSERT_RIGHT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".insertColumnOnTheRight");
var CONTEXTMENU_ITEMS_REMOVE_ROW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".removeRow");
var CONTEXTMENU_ITEMS_REMOVE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".removeColumn");
var CONTEXTMENU_ITEMS_UNDO = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".undo");
var CONTEXTMENU_ITEMS_REDO = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".redo");
var CONTEXTMENU_ITEMS_READ_ONLY = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".readOnly");
var CONTEXTMENU_ITEMS_CLEAR_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".clearColumn");
var CONTEXTMENU_ITEMS_COPY = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".copy");
var CONTEXTMENU_ITEMS_CUT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".cut");
var CONTEXTMENU_ITEMS_FREEZE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".freezeColumn");
var CONTEXTMENU_ITEMS_UNFREEZE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".unfreezeColumn");
var CONTEXTMENU_ITEMS_MERGE_CELLS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".mergeCells");
var CONTEXTMENU_ITEMS_UNMERGE_CELLS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".unmergeCells");
var CONTEXTMENU_ITEMS_ADD_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".addComment");
var CONTEXTMENU_ITEMS_EDIT_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".editComment");
var CONTEXTMENU_ITEMS_REMOVE_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".removeComment");
var CONTEXTMENU_ITEMS_READ_ONLY_COMMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".readOnlyComment");
var CONTEXTMENU_ITEMS_ALIGNMENT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align");
var CONTEXTMENU_ITEMS_ALIGNMENT_LEFT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.left");
var CONTEXTMENU_ITEMS_ALIGNMENT_CENTER = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.center");
var CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.right");
var CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.justify");
var CONTEXTMENU_ITEMS_ALIGNMENT_TOP = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.top");
var CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.middle");
var CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".align.bottom");
var CONTEXTMENU_ITEMS_BORDERS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders");
var CONTEXTMENU_ITEMS_BORDERS_TOP = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.top");
var CONTEXTMENU_ITEMS_BORDERS_RIGHT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.right");
var CONTEXTMENU_ITEMS_BORDERS_BOTTOM = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.bottom");
var CONTEXTMENU_ITEMS_BORDERS_LEFT = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.left");
var CONTEXTMENU_ITEMS_REMOVE_BORDERS = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".borders.remove");
var CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".nestedHeaders.insertChildRow");
var CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".nestedHeaders.detachFromParent");
var CONTEXTMENU_ITEMS_HIDE_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".hideColumn");
var CONTEXTMENU_ITEMS_SHOW_COLUMN = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".showColumn");
var CONTEXTMENU_ITEMS_HIDE_ROW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".hideRow");
var CONTEXTMENU_ITEMS_SHOW_ROW = "".concat(CONTEXT_MENU_ITEMS_NAMESPACE, ".showRow");
var FILTERS_NAMESPACE = "Filters:";
var FILTERS_CONDITIONS_NAMESPACE = "".concat(FILTERS_NAMESPACE, "conditions");
var FILTERS_CONDITIONS_NONE = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".none");
var FILTERS_CONDITIONS_EMPTY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isEmpty");
var FILTERS_CONDITIONS_NOT_EMPTY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isNotEmpty");
var FILTERS_CONDITIONS_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isEqualTo");
var FILTERS_CONDITIONS_NOT_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isNotEqualTo");
var FILTERS_CONDITIONS_BEGINS_WITH = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".beginsWith");
var FILTERS_CONDITIONS_ENDS_WITH = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".endsWith");
var FILTERS_CONDITIONS_CONTAINS = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".contains");
var FILTERS_CONDITIONS_NOT_CONTAIN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".doesNotContain");
var FILTERS_CONDITIONS_BY_VALUE = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".byValue");
var FILTERS_CONDITIONS_GREATER_THAN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".greaterThan");
var FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".greaterThanOrEqualTo");
var FILTERS_CONDITIONS_LESS_THAN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".lessThan");
var FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".lessThanOrEqualTo");
var FILTERS_CONDITIONS_BETWEEN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isBetween");
var FILTERS_CONDITIONS_NOT_BETWEEN = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".isNotBetween");
var FILTERS_CONDITIONS_AFTER = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".after");
var FILTERS_CONDITIONS_BEFORE = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".before");
var FILTERS_CONDITIONS_TODAY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".today");
var FILTERS_CONDITIONS_TOMORROW = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".tomorrow");
var FILTERS_CONDITIONS_YESTERDAY = "".concat(FILTERS_CONDITIONS_NAMESPACE, ".yesterday");
var FILTERS_DIVS_FILTER_BY_CONDITION = "".concat(FILTERS_NAMESPACE, "labels.filterByCondition");
var FILTERS_DIVS_FILTER_BY_VALUE = "".concat(FILTERS_NAMESPACE, "labels.filterByValue");
var FILTERS_LABELS_CONJUNCTION = "".concat(FILTERS_NAMESPACE, "labels.conjunction");
var FILTERS_LABELS_DISJUNCTION = "".concat(FILTERS_NAMESPACE, "labels.disjunction");
var FILTERS_VALUES_BLANK_CELLS = "".concat(FILTERS_NAMESPACE, "values.blankCells");
var FILTERS_BUTTONS_SELECT_ALL = "".concat(FILTERS_NAMESPACE, "buttons.selectAll");
var FILTERS_BUTTONS_CLEAR = "".concat(FILTERS_NAMESPACE, "buttons.clear");
var FILTERS_BUTTONS_OK = "".concat(FILTERS_NAMESPACE, "buttons.ok");
var FILTERS_BUTTONS_CANCEL = "".concat(FILTERS_NAMESPACE, "buttons.cancel");
var FILTERS_BUTTONS_PLACEHOLDER_SEARCH = "".concat(FILTERS_NAMESPACE, "buttons.placeholder.search");
var FILTERS_BUTTONS_PLACEHOLDER_VALUE = "".concat(FILTERS_NAMESPACE, "buttons.placeholder.value");
var FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE = "".concat(FILTERS_NAMESPACE, "buttons.placeholder.secondValue");

// node_modules/handsontable/es/i18n/languages/en-US.js
var _dictionary;
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var dictionary = (_dictionary = {
  languageCode: "en-US"
}, _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ROW_ABOVE, "Insert row above"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ROW_BELOW, "Insert row below"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_INSERT_LEFT, "Insert column left"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_INSERT_RIGHT, "Insert column right"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_REMOVE_ROW, ["Remove row", "Remove rows"]), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_REMOVE_COLUMN, ["Remove column", "Remove columns"]), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_UNDO, "Undo"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_REDO, "Redo"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_READ_ONLY, "Read only"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_CLEAR_COLUMN, "Clear column"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT, "Alignment"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_LEFT, "Left"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_CENTER, "Center"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT, "Right"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY, "Justify"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_TOP, "Top"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE, "Middle"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM, "Bottom"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_FREEZE_COLUMN, "Freeze column"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_UNFREEZE_COLUMN, "Unfreeze column"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_BORDERS, "Borders"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_BORDERS_TOP, "Top"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_BORDERS_RIGHT, "Right"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_BORDERS_BOTTOM, "Bottom"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_BORDERS_LEFT, "Left"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_REMOVE_BORDERS, "Remove border(s)"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_ADD_COMMENT, "Add comment"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_EDIT_COMMENT, "Edit comment"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_REMOVE_COMMENT, "Delete comment"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_READ_ONLY_COMMENT, "Read-only comment"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_MERGE_CELLS, "Merge cells"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_UNMERGE_CELLS, "Unmerge cells"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_COPY, "Copy"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_CUT, "Cut"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD, "Insert child row"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD, "Detach from parent"), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_HIDE_COLUMN, ["Hide column", "Hide columns"]), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_SHOW_COLUMN, ["Show column", "Show columns"]), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_HIDE_ROW, ["Hide row", "Hide rows"]), _defineProperty2(_dictionary, CONTEXTMENU_ITEMS_SHOW_ROW, ["Show row", "Show rows"]), _defineProperty2(_dictionary, FILTERS_CONDITIONS_NONE, "None"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_EMPTY, "Is empty"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_NOT_EMPTY, "Is not empty"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_EQUAL, "Is equal to"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_NOT_EQUAL, "Is not equal to"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_BEGINS_WITH, "Begins with"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_ENDS_WITH, "Ends with"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_CONTAINS, "Contains"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_NOT_CONTAIN, "Does not contain"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_GREATER_THAN, "Greater than"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL, "Greater than or equal to"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_LESS_THAN, "Less than"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL, "Less than or equal to"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_BETWEEN, "Is between"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_NOT_BETWEEN, "Is not between"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_AFTER, "After"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_BEFORE, "Before"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_TODAY, "Today"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_TOMORROW, "Tomorrow"), _defineProperty2(_dictionary, FILTERS_CONDITIONS_YESTERDAY, "Yesterday"), _defineProperty2(_dictionary, FILTERS_VALUES_BLANK_CELLS, "Blank cells"), _defineProperty2(_dictionary, FILTERS_DIVS_FILTER_BY_CONDITION, "Filter by condition"), _defineProperty2(_dictionary, FILTERS_DIVS_FILTER_BY_VALUE, "Filter by value"), _defineProperty2(_dictionary, FILTERS_LABELS_CONJUNCTION, "And"), _defineProperty2(_dictionary, FILTERS_LABELS_DISJUNCTION, "Or"), _defineProperty2(_dictionary, FILTERS_BUTTONS_SELECT_ALL, "Select all"), _defineProperty2(_dictionary, FILTERS_BUTTONS_CLEAR, "Clear"), _defineProperty2(_dictionary, FILTERS_BUTTONS_OK, "OK"), _defineProperty2(_dictionary, FILTERS_BUTTONS_CANCEL, "Cancel"), _defineProperty2(_dictionary, FILTERS_BUTTONS_PLACEHOLDER_SEARCH, "Search"), _defineProperty2(_dictionary, FILTERS_BUTTONS_PLACEHOLDER_VALUE, "Value"), _defineProperty2(_dictionary, FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE, "Second value"), _dictionary);
var en_US_default = dictionary;

// node_modules/handsontable/es/i18n/dictionariesManager.js
var DEFAULT_LANGUAGE_CODE = en_US_default.languageCode;
var _staticRegister5 = staticRegister("languagesDictionaries");
var registerGloballyLanguageDictionary = _staticRegister5.register;
var getGlobalLanguageDictionary = _staticRegister5.getItem;
var hasGlobalLanguageDictionary = _staticRegister5.hasItem;
var getGlobalLanguagesDictionaries = _staticRegister5.getValues;
function registerLanguage(languageCodeOrDictionary, dictionary2) {
  var languageCode = languageCodeOrDictionary;
  var dictionaryObject = dictionary2;
  if (isObject(languageCodeOrDictionary)) {
    dictionaryObject = languageCodeOrDictionary;
    languageCode = dictionaryObject.languageCode;
  }
  extendLanguageDictionary(languageCode, dictionaryObject);
  registerGloballyLanguageDictionary(languageCode, deepClone(dictionaryObject));
  return deepClone(dictionaryObject);
}
function getLanguage(languageCode) {
  if (!hasLanguage(languageCode)) {
    return null;
  }
  return deepClone(getGlobalLanguageDictionary(languageCode));
}
function hasLanguage(languageCode) {
  return hasGlobalLanguageDictionary(languageCode);
}
function extendLanguageDictionary(languageCode, dictionary2) {
  if (languageCode !== DEFAULT_LANGUAGE_CODE) {
    extendNotExistingKeys(dictionary2, getGlobalLanguageDictionary(DEFAULT_LANGUAGE_CODE));
  }
}
function getLanguages() {
  return getGlobalLanguagesDictionaries();
}
registerLanguage(en_US_default);

// node_modules/handsontable/es/i18n/phraseFormatters/pluralize.js
function pluralize(phrasePropositions, pluralForm) {
  var isPluralizable = Array.isArray(phrasePropositions) && Number.isInteger(pluralForm);
  if (isPluralizable) {
    return phrasePropositions[pluralForm];
  }
  return phrasePropositions;
}

// node_modules/handsontable/es/i18n/phraseFormatters/index.js
var _staticRegister6 = staticRegister("phraseFormatters");
var registerGloballyPhraseFormatter = _staticRegister6.register;
var getGlobalPhraseFormatters = _staticRegister6.getValues;
function register5(name, formatterFn) {
  registerGloballyPhraseFormatter(name, formatterFn);
}
function getAll() {
  return getGlobalPhraseFormatters();
}
register5("pluralize", pluralize);

// node_modules/handsontable/es/i18n/index.js
function getTranslatedPhrase(languageCode, dictionaryKey, argumentsForFormatters) {
  var languageDictionary = getLanguage(languageCode);
  if (languageDictionary === null) {
    return null;
  }
  var phrasePropositions = languageDictionary[dictionaryKey];
  if (isUndefined2(phrasePropositions)) {
    return null;
  }
  var formattedPhrase = getFormattedPhrase(phrasePropositions, argumentsForFormatters);
  if (Array.isArray(formattedPhrase)) {
    return formattedPhrase[0];
  }
  return formattedPhrase;
}
function getFormattedPhrase(phrasePropositions, argumentsForFormatters) {
  var formattedPhrasePropositions = phrasePropositions;
  arrayEach(getAll(), function(formatter2) {
    formattedPhrasePropositions = formatter2(phrasePropositions, argumentsForFormatters);
  });
  return formattedPhrasePropositions;
}

// node_modules/handsontable/es/utils/keyStateObserver.js
var eventManager = new eventManager_default();
var pressedKeys = /* @__PURE__ */ new Set();
var refCount = 0;
function startObserving() {
  if (refCount === 0) {
    eventManager.addEventListener(document, "keydown", function(event2) {
      if (!pressedKeys.has(event2.keyCode)) {
        pressedKeys.add(event2.keyCode);
      }
    });
    eventManager.addEventListener(document, "keyup", function(event2) {
      if (pressedKeys.has(event2.keyCode)) {
        pressedKeys.delete(event2.keyCode);
      }
    });
    eventManager.addEventListener(document, "visibilitychange", function() {
      if (document.hidden) {
        pressedKeys.clear();
      }
    });
    eventManager.addEventListener(window, "blur", function() {
      pressedKeys.clear();
    });
  }
  refCount += 1;
}
function stopObserving() {
  if (refCount > 0) {
    refCount -= 1;
  }
  if (refCount === 0) {
    _resetState();
  }
}
function _resetState() {
  eventManager.clearEvents();
  pressedKeys.clear();
  refCount = 0;
}
function isPressedCtrlKey() {
  var values = Array.from(pressedKeys.values());
  return values.some(function(_keyCode) {
    return isCtrlMetaKey(_keyCode);
  });
}

// node_modules/handsontable/es/selection/highlight/types/activeHeader.js
function createHighlight(_ref) {
  var activeHeaderClassName = _ref.activeHeaderClassName;
  var s = new selection_default({
    highlightHeaderClassName: activeHeaderClassName
  });
  return s;
}
var activeHeader_default = createHighlight;

// node_modules/handsontable/es/selection/highlight/types/area.js
function createHighlight2(_ref) {
  var layerLevel = _ref.layerLevel, areaCornerVisible = _ref.areaCornerVisible;
  var s = new selection_default({
    className: "area",
    markIntersections: true,
    layerLevel: Math.min(layerLevel, 7),
    border: {
      width: 1,
      color: "#4b89ff",
      cornerVisible: areaCornerVisible
    }
  });
  return s;
}
var area_default = createHighlight2;

// node_modules/handsontable/es/selection/highlight/types/cell.js
function createHighlight3(_ref) {
  var cellCornerVisible = _ref.cellCornerVisible;
  var s = new selection_default({
    className: "current",
    border: {
      width: 2,
      color: "#4b89ff",
      cornerVisible: cellCornerVisible
    }
  });
  return s;
}
var cell_default = createHighlight3;

// node_modules/handsontable/es/selection/highlight/types/customSelection.js
function createHighlight4(_ref) {
  var border = _ref.border, cellRange = _ref.cellRange;
  var s = new selection_default(border, cellRange);
  return s;
}
var customSelection_default = createHighlight4;

// node_modules/handsontable/es/selection/highlight/types/fill.js
function createHighlight5() {
  var s = new selection_default({
    className: "fill",
    border: {
      width: 1,
      color: "#ff0000"
    }
  });
  return s;
}
var fill_default = createHighlight5;

// node_modules/handsontable/es/selection/highlight/types/header.js
function createHighlight6(_ref) {
  var headerClassName = _ref.headerClassName, rowClassName = _ref.rowClassName, columnClassName = _ref.columnClassName;
  var s = new selection_default({
    className: "highlight",
    highlightHeaderClassName: headerClassName,
    highlightRowClassName: rowClassName,
    highlightColumnClassName: columnClassName
  });
  return s;
}
var header_default = createHighlight6;

// node_modules/handsontable/es/selection/highlight/types/index.js
var _staticRegister7 = staticRegister("highlight/types");
var register6 = _staticRegister7.register;
var getItem5 = _staticRegister7.getItem;
register6("active-header", activeHeader_default);
register6("area", area_default);
register6("cell", cell_default);
register6("custom-selection", customSelection_default);
register6("fill", fill_default);
register6("header", header_default);
function createHighlight7(highlightType, options) {
  return getItem5(highlightType)(options);
}

// node_modules/handsontable/es/selection/highlight/highlight.js
function _toConsumableArray4(arr) {
  return _arrayWithoutHoles4(arr) || _iterableToArray4(arr) || _nonIterableSpread4();
}
function _nonIterableSpread4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray4(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles4(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty3(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck34(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties32(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass32(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties32(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties32(Constructor, staticProps);
  return Constructor;
}
var ACTIVE_HEADER_TYPE = "active-header";
var AREA_TYPE = "area";
var CELL_TYPE10 = "cell";
var FILL_TYPE = "fill";
var HEADER_TYPE = "header";
var CUSTOM_SELECTION = "custom-selection";
var Highlight = function() {
  function Highlight2(options) {
    _classCallCheck34(this, Highlight2);
    this.options = options;
    this.layerLevel = 0;
    this.cell = createHighlight7(CELL_TYPE10, options);
    this.fill = createHighlight7(FILL_TYPE, options);
    this.areas = /* @__PURE__ */ new Map();
    this.headers = /* @__PURE__ */ new Map();
    this.activeHeaders = /* @__PURE__ */ new Map();
    this.customSelections = [];
  }
  _createClass32(Highlight2, [{
    key: "isEnabledFor",
    value: function isEnabledFor(highlightType) {
      var type = highlightType === "current" ? CELL_TYPE10 : highlightType;
      var disableHighlight = this.options.disableHighlight;
      if (typeof disableHighlight === "string") {
        disableHighlight = [disableHighlight];
      }
      return disableHighlight === false || Array.isArray(disableHighlight) && !disableHighlight.includes(type);
    }
    /**
     * Set a new layer level to make access to the desire `area` and `header` highlights.
     *
     * @param {Number} [level=0] Layer level to use.
     * @returns {Highlight}
     */
  }, {
    key: "useLayerLevel",
    value: function useLayerLevel() {
      var level = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this.layerLevel = level;
      return this;
    }
    /**
     * Get Walkontable Selection instance created for controlling highlight of the currently selected/edited cell.
     *
     * @return {Selection}
     */
  }, {
    key: "getCell",
    value: function getCell() {
      return this.cell;
    }
    /**
     * Get Walkontable Selection instance created for controlling highlight of the autofill functionality.
     *
     * @return {Selection}
     */
  }, {
    key: "getFill",
    value: function getFill() {
      return this.fill;
    }
    /**
     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight
     * of the multiple selected cells.
     *
     * @return {Selection}
     */
  }, {
    key: "createOrGetArea",
    value: function createOrGetArea() {
      var layerLevel = this.layerLevel;
      var area;
      if (this.areas.has(layerLevel)) {
        area = this.areas.get(layerLevel);
      } else {
        area = createHighlight7(AREA_TYPE, _objectSpread({
          layerLevel
        }, this.options));
        this.areas.set(layerLevel, area);
      }
      return area;
    }
    /**
     * Get all Walkontable Selection instances which describes the state of the visual highlight of the cells.
     *
     * @return {Selection[]}
     */
  }, {
    key: "getAreas",
    value: function getAreas() {
      return _toConsumableArray4(this.areas.values());
    }
    /**
     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight
     * of the multiple selected header cells.
     *
     * @return {Selection}
     */
  }, {
    key: "createOrGetHeader",
    value: function createOrGetHeader() {
      var layerLevel = this.layerLevel;
      var header;
      if (this.headers.has(layerLevel)) {
        header = this.headers.get(layerLevel);
      } else {
        header = createHighlight7(HEADER_TYPE, _objectSpread({}, this.options));
        this.headers.set(layerLevel, header);
      }
      return header;
    }
    /**
     * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers.
     *
     * @return {Selection[]}
     */
  }, {
    key: "getHeaders",
    value: function getHeaders() {
      return _toConsumableArray4(this.headers.values());
    }
    /**
     * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight
     * of the multiple selected active header cells.
     *
     * @return {Selection}
     */
  }, {
    key: "createOrGetActiveHeader",
    value: function createOrGetActiveHeader() {
      var layerLevel = this.layerLevel;
      var header;
      if (this.activeHeaders.has(layerLevel)) {
        header = this.activeHeaders.get(layerLevel);
      } else {
        header = createHighlight7(ACTIVE_HEADER_TYPE, _objectSpread({}, this.options));
        this.activeHeaders.set(layerLevel, header);
      }
      return header;
    }
    /**
     * Get all Walkontable Selection instances which describes the state of the visual highlight of the active headers.
     *
     * @return {Selection[]}
     */
  }, {
    key: "getActiveHeaders",
    value: function getActiveHeaders() {
      return _toConsumableArray4(this.activeHeaders.values());
    }
    /**
     * Get Walkontable Selection instance created for controlling highlight of the custom selection functionality.
     *
     * @return {Selection}
     */
  }, {
    key: "getCustomSelections",
    value: function getCustomSelections() {
      return _toConsumableArray4(this.customSelections.values());
    }
    /**
     * Add selection to the custom selection instance. The new selection are added to the end of the selection collection.
     *
     * @param {Object} options
     */
  }, {
    key: "addCustomSelection",
    value: function addCustomSelection(options) {
      this.customSelections.push(createHighlight7(CUSTOM_SELECTION, _objectSpread({}, options)));
    }
    /**
     * Perform cleaning visual highlights for the whole table.
     */
  }, {
    key: "clear",
    value: function clear() {
      this.cell.clear();
      this.fill.clear();
      arrayEach(this.areas.values(), function(highlight) {
        return void highlight.clear();
      });
      arrayEach(this.headers.values(), function(highlight) {
        return void highlight.clear();
      });
      arrayEach(this.activeHeaders.values(), function(highlight) {
        return void highlight.clear();
      });
    }
    /**
     * This object can be iterate over using `for of` syntax or using internal `arrayEach` helper.
     */
  }, {
    key: Symbol.iterator,
    value: function value() {
      return [this.cell, this.fill].concat(_toConsumableArray4(this.areas.values()), _toConsumableArray4(this.headers.values()), _toConsumableArray4(this.activeHeaders.values()), _toConsumableArray4(this.customSelections))[Symbol.iterator]();
    }
  }]);
  return Highlight2;
}();
var highlight_default = Highlight;

// node_modules/handsontable/es/selection/range.js
function _classCallCheck35(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties33(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass33(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties33(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties33(Constructor, staticProps);
  return Constructor;
}
var SelectionRange = function() {
  function SelectionRange2() {
    _classCallCheck35(this, SelectionRange2);
    this.ranges = [];
  }
  _createClass33(SelectionRange2, [{
    key: "isEmpty",
    value: function isEmpty2() {
      return this.size() === 0;
    }
    /**
     * Set coordinates to the class instance. It clears all previously added coordinates and push `coords`
     * to the collection.
     *
     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
     * @returns {SelectionRange}
     */
  }, {
    key: "set",
    value: function set5(coords) {
      this.clear();
      this.ranges.push(new range_default(coords));
      return this;
    }
    /**
     * Add coordinates to the class instance. The new coordinates are added to the end of the range collection.
     *
     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
     * @returns {SelectionRange}
     */
  }, {
    key: "add",
    value: function add5(coords) {
      this.ranges.push(new range_default(coords));
      return this;
    }
    /**
     * Get last added coordinates from ranges, it returns a CellRange instance.
     *
     * @return {CellRange|undefined}
     */
  }, {
    key: "current",
    value: function current() {
      return this.peekByIndex(0);
    }
    /**
     * Get previously added coordinates from ranges, it returns a CellRange instance.
     *
     * @return {CellRange|undefined}
     */
  }, {
    key: "previous",
    value: function previous() {
      return this.peekByIndex(-1);
    }
    /**
     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if
     * the coords object is within selection range.
     *
     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
     * @returns {Boolean}
     */
  }, {
    key: "includes",
    value: function includes(coords) {
      return this.ranges.some(function(cellRange) {
        return cellRange.includes(coords);
      });
    }
    /**
     * Clear collection.
     *
     * @return {SelectionRange}
     */
  }, {
    key: "clear",
    value: function clear() {
      this.ranges.length = 0;
      return this;
    }
    /**
     * Get count of added all coordinates added to the selection.
     *
     * @return {Number}
     */
  }, {
    key: "size",
    value: function size() {
      return this.ranges.length;
    }
    /**
     * Peek the coordinates based on the offset where that coordinate resides in the collection.
     *
     * @param {Number} [offset=0] An offset where the coordinate will be retrieved from.
     * @return {CellRange|undefined}
     */
  }, {
    key: "peekByIndex",
    value: function peekByIndex() {
      var offset4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var rangeIndex = this.size() + offset4 - 1;
      var cellRange;
      if (rangeIndex >= 0) {
        cellRange = this.ranges[rangeIndex];
      }
      return cellRange;
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this.ranges[Symbol.iterator]();
    }
  }]);
  return SelectionRange2;
}();
var range_default2 = SelectionRange;

// node_modules/handsontable/es/mixins/localHooks.js
var MIXIN_NAME = "localHooks";
var localHooks = {
  /**
   * Internal hooks storage.
   */
  _localHooks: /* @__PURE__ */ Object.create(null),
  /**
   * Add hook to the collection.
   *
   * @param {String} key Hook name.
   * @param {Function} callback Hook callback
   * @returns {Object}
   */
  addLocalHook: function addLocalHook(key, callback) {
    if (!this._localHooks[key]) {
      this._localHooks[key] = [];
    }
    this._localHooks[key].push(callback);
    return this;
  },
  /**
   * Run hooks.
   *
   * @param {String} key Hook name.
   * @param {*} params
   */
  runLocalHooks: function runLocalHooks(key) {
    var _this = this;
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    if (this._localHooks[key]) {
      arrayEach(this._localHooks[key], function(callback) {
        return callback.apply(_this, params);
      });
    }
  },
  /**
   * Clear all added hooks.
   *
   * @returns {Object}
   */
  clearLocalHooks: function clearLocalHooks() {
    this._localHooks = {};
    return this;
  }
};
defineGetter(localHooks, "MIXIN_NAME", MIXIN_NAME, {
  writable: false,
  enumerable: false
});
var localHooks_default = localHooks;

// node_modules/handsontable/es/selection/transformation.js
function _classCallCheck36(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties34(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass34(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties34(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties34(Constructor, staticProps);
  return Constructor;
}
var Transformation = function() {
  function Transformation2(range, options) {
    _classCallCheck36(this, Transformation2);
    this.range = range;
    this.options = options;
  }
  _createClass34(Transformation2, [{
    key: "transformStart",
    value: function transformStart(rowDelta, colDelta, force) {
      var delta = new coords_default(rowDelta, colDelta);
      this.runLocalHooks("beforeTransformStart", delta);
      var totalRows = this.options.countRows();
      var totalCols = this.options.countCols();
      var fixedRowsBottom = this.options.fixedRowsBottom();
      var minSpareRows = this.options.minSpareRows();
      var minSpareCols = this.options.minSpareCols();
      var autoWrapRow = this.options.autoWrapRow();
      var autoWrapCol = this.options.autoWrapCol();
      var highlightCoords = this.range.current().highlight;
      if (highlightCoords.row + rowDelta > totalRows - 1) {
        if (force && minSpareRows > 0 && !(fixedRowsBottom && highlightCoords.row >= totalRows - fixedRowsBottom - 1)) {
          this.runLocalHooks("insertRowRequire", totalRows);
          totalRows = this.options.countRows();
        } else if (autoWrapCol) {
          delta.row = 1 - totalRows;
          delta.col = highlightCoords.col + delta.col === totalCols - 1 ? 1 - totalCols : 1;
        }
      } else if (autoWrapCol && highlightCoords.row + delta.row < 0 && highlightCoords.col + delta.col >= 0) {
        delta.row = totalRows - 1;
        delta.col = highlightCoords.col + delta.col === 0 ? totalCols - 1 : -1;
      }
      if (highlightCoords.col + delta.col > totalCols - 1) {
        if (force && minSpareCols > 0) {
          this.runLocalHooks("insertColRequire", totalCols);
          totalCols = this.options.countCols();
        } else if (autoWrapRow) {
          delta.row = highlightCoords.row + delta.row === totalRows - 1 ? 1 - totalRows : 1;
          delta.col = 1 - totalCols;
        }
      } else if (autoWrapRow && highlightCoords.col + delta.col < 0 && highlightCoords.row + delta.row >= 0) {
        delta.row = highlightCoords.row + delta.row === 0 ? totalRows - 1 : -1;
        delta.col = totalCols - 1;
      }
      var coords = new coords_default(highlightCoords.row + delta.row, highlightCoords.col + delta.col);
      var rowTransformDir = 0;
      var colTransformDir = 0;
      if (coords.row < 0) {
        rowTransformDir = -1;
        coords.row = 0;
      } else if (coords.row > 0 && coords.row >= totalRows) {
        rowTransformDir = 1;
        coords.row = totalRows - 1;
      }
      if (coords.col < 0) {
        colTransformDir = -1;
        coords.col = 0;
      } else if (coords.col > 0 && coords.col >= totalCols) {
        colTransformDir = 1;
        coords.col = totalCols - 1;
      }
      this.runLocalHooks("afterTransformStart", coords, rowTransformDir, colTransformDir);
      return coords;
    }
    /**
     * Sets selection end cell relative to current selection end cell (if possible).
     *
     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.
     * @param {Number} colDelta Columns number to move, value can be passed as negative number.
     * @returns {CellCoords}
     */
  }, {
    key: "transformEnd",
    value: function transformEnd(rowDelta, colDelta) {
      var delta = new coords_default(rowDelta, colDelta);
      this.runLocalHooks("beforeTransformEnd", delta);
      var totalRows = this.options.countRows();
      var totalCols = this.options.countCols();
      var cellRange = this.range.current();
      var coords = new coords_default(cellRange.to.row + delta.row, cellRange.to.col + delta.col);
      var rowTransformDir = 0;
      var colTransformDir = 0;
      if (coords.row < 0) {
        rowTransformDir = -1;
        coords.row = 0;
      } else if (coords.row > 0 && coords.row >= totalRows) {
        rowTransformDir = 1;
        coords.row = totalRows - 1;
      }
      if (coords.col < 0) {
        colTransformDir = -1;
        coords.col = 0;
      } else if (coords.col > 0 && coords.col >= totalCols) {
        colTransformDir = 1;
        coords.col = totalCols - 1;
      }
      this.runLocalHooks("afterTransformEnd", coords, rowTransformDir, colTransformDir);
      return coords;
    }
  }]);
  return Transformation2;
}();
mixin(Transformation, localHooks_default);
var transformation_default = Transformation;

// node_modules/handsontable/es/selection/utils.js
function _slicedToArray5(arr, i) {
  return _arrayWithHoles5(arr) || _iterableToArrayLimit5(arr, i) || _nonIterableRest5();
}
function _nonIterableRest5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit5(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles5(arr) {
  if (Array.isArray(arr)) return arr;
}
function _typeof22(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof22 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof22 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof22(obj);
}
var SELECTION_TYPE_UNRECOGNIZED = 0;
var SELECTION_TYPE_EMPTY = 1;
var SELECTION_TYPE_ARRAY = 2;
var SELECTION_TYPE_OBJECT = 3;
var SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];
var ARRAY_TYPE_PATTERN = [["number"], ["number", "string"], ["number", "undefined"], ["number", "string", "undefined"]];
var rootCall = Symbol("root");
var childCall = Symbol("child");
function detectSelectionType(selectionRanges) {
  var _callSymbol = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rootCall;
  if (_callSymbol !== rootCall && _callSymbol !== childCall) {
    throw new Error("The second argument is used internally only and cannot be overwritten.");
  }
  var isArray3 = Array.isArray(selectionRanges);
  var isRootCall = _callSymbol === rootCall;
  var result = SELECTION_TYPE_UNRECOGNIZED;
  if (isArray3) {
    var firstItem = selectionRanges[0];
    if (selectionRanges.length === 0) {
      result = SELECTION_TYPE_EMPTY;
    } else if (isRootCall && firstItem instanceof range_default) {
      result = SELECTION_TYPE_OBJECT;
    } else if (isRootCall && Array.isArray(firstItem)) {
      result = detectSelectionType(firstItem, childCall);
    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {
      var isArrayType = !selectionRanges.some(function(value, index2) {
        return !ARRAY_TYPE_PATTERN[index2].includes(_typeof22(value));
      });
      if (isArrayType) {
        result = SELECTION_TYPE_ARRAY;
      }
    }
  }
  return result;
}
function normalizeSelectionFactory(type) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$keepDirection = _ref.keepDirection, keepDirection = _ref$keepDirection === void 0 ? false : _ref$keepDirection, propToCol = _ref.propToCol;
  if (!SELECTION_TYPES.includes(type)) {
    throw new Error("Unsupported selection ranges schema type was provided.");
  }
  return function(selection) {
    var isObjectType = type === SELECTION_TYPE_OBJECT;
    var rowStart = isObjectType ? selection.from.row : selection[0];
    var columnStart = isObjectType ? selection.from.col : selection[1];
    var rowEnd = isObjectType ? selection.to.row : selection[2];
    var columnEnd = isObjectType ? selection.to.col : selection[3];
    if (typeof propToCol === "function") {
      if (typeof columnStart === "string") {
        columnStart = propToCol(columnStart);
      }
      if (typeof columnEnd === "string") {
        columnEnd = propToCol(columnEnd);
      }
    }
    if (isUndefined2(rowEnd)) {
      rowEnd = rowStart;
    }
    if (isUndefined2(columnEnd)) {
      columnEnd = columnStart;
    }
    if (!keepDirection) {
      var origRowStart = rowStart;
      var origColumnStart = columnStart;
      var origRowEnd = rowEnd;
      var origColumnEnd = columnEnd;
      rowStart = Math.min(origRowStart, origRowEnd);
      columnStart = Math.min(origColumnStart, origColumnEnd);
      rowEnd = Math.max(origRowStart, origRowEnd);
      columnEnd = Math.max(origColumnStart, origColumnEnd);
    }
    return [rowStart, columnStart, rowEnd, columnEnd];
  };
}
function transformSelectionToColumnDistance(selectionRanges) {
  var selectionType = detectSelectionType(selectionRanges);
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
  var unorderedIndexes = /* @__PURE__ */ new Set();
  arrayEach(selectionRanges, function(selection) {
    var _selectionSchemaNorma = selectionSchemaNormalizer(selection), _selectionSchemaNorma2 = _slicedToArray5(_selectionSchemaNorma, 4), columnStart = _selectionSchemaNorma2[1], columnEnd = _selectionSchemaNorma2[3];
    var amount = columnEnd - columnStart + 1;
    arrayEach(Array.from(new Array(amount), function(_, i) {
      return columnStart + i;
    }), function(index2) {
      if (!unorderedIndexes.has(index2)) {
        unorderedIndexes.add(index2);
      }
    });
  });
  var orderedIndexes = Array.from(unorderedIndexes).sort(function(a, b) {
    return a - b;
  });
  var normalizedColumnRanges = arrayReduce(orderedIndexes, function(acc, visualColumnIndex, index2, array) {
    if (index2 !== 0 && visualColumnIndex === array[index2 - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([visualColumnIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedColumnRanges;
}
function transformSelectionToRowDistance(selectionRanges) {
  var selectionType = detectSelectionType(selectionRanges);
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
  var unorderedIndexes = /* @__PURE__ */ new Set();
  arrayEach(selectionRanges, function(selection) {
    var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection), _selectionSchemaNorma4 = _slicedToArray5(_selectionSchemaNorma3, 3), rowStart = _selectionSchemaNorma4[0], rowEnd = _selectionSchemaNorma4[2];
    var amount = rowEnd - rowStart + 1;
    arrayEach(Array.from(new Array(amount), function(_, i) {
      return rowStart + i;
    }), function(index2) {
      if (!unorderedIndexes.has(index2)) {
        unorderedIndexes.add(index2);
      }
    });
  });
  var orderedIndexes = Array.from(unorderedIndexes).sort(function(a, b) {
    return a - b;
  });
  var normalizedRowRanges = arrayReduce(orderedIndexes, function(acc, rowIndex, index2, array) {
    if (index2 !== 0 && rowIndex === array[index2 - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([rowIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedRowRanges;
}
function isValidCoord(coord) {
  var maxTableItemsCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
  return typeof coord === "number" && coord >= 0 && coord < maxTableItemsCount;
}

// node_modules/handsontable/es/selection/selection.js
function _slicedToArray6(arr, i) {
  return _arrayWithHoles6(arr) || _iterableToArrayLimit6(arr, i) || _nonIterableRest6();
}
function _nonIterableRest6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit6(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles6(arr) {
  if (Array.isArray(arr)) return arr;
}
function _templateObject4() {
  var data = _taggedTemplateLiteral4(["Unsupported format of the selection ranges was passed. To select cells pass \n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, columnEnd/columnPropEnd]]) \n        or as an array of CellRange objects."]);
  _templateObject4 = function _templateObject8() {
    return data;
  };
  return data;
}
function _taggedTemplateLiteral4(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck37(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties35(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass35(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties35(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties35(Constructor, staticProps);
  return Constructor;
}
var Selection2 = function() {
  function Selection3(settings, tableProps) {
    var _this = this;
    _classCallCheck37(this, Selection3);
    this.settings = settings;
    this.tableProps = tableProps;
    this.inProgress = false;
    this.selectedByCorner = false;
    this.selectedByRowHeader = /* @__PURE__ */ new Set();
    this.selectedByColumnHeader = /* @__PURE__ */ new Set();
    this.selectedRange = new range_default2();
    this.highlight = new highlight_default({
      headerClassName: settings.currentHeaderClassName,
      activeHeaderClassName: settings.activeHeaderClassName,
      rowClassName: settings.currentRowClassName,
      columnClassName: settings.currentColClassName,
      disableHighlight: this.settings.disableVisualSelection,
      cellCornerVisible: function cellCornerVisible() {
        return _this.isCellCornerVisible.apply(_this, arguments);
      },
      areaCornerVisible: function areaCornerVisible() {
        return _this.isAreaCornerVisible.apply(_this, arguments);
      }
    });
    this.transformation = new transformation_default(this.selectedRange, {
      countRows: function countRows() {
        return _this.tableProps.countRows();
      },
      countCols: function countCols() {
        return _this.tableProps.countCols();
      },
      fixedRowsBottom: function fixedRowsBottom() {
        return settings.fixedRowsBottom;
      },
      minSpareRows: function minSpareRows() {
        return settings.minSpareRows;
      },
      minSpareCols: function minSpareCols() {
        return settings.minSpareCols;
      },
      autoWrapRow: function autoWrapRow() {
        return settings.autoWrapRow;
      },
      autoWrapCol: function autoWrapCol() {
        return settings.autoWrapCol;
      }
    });
    this.transformation.addLocalHook("beforeTransformStart", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _this.runLocalHooks.apply(_this, ["beforeModifyTransformStart"].concat(args));
    });
    this.transformation.addLocalHook("afterTransformStart", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.runLocalHooks.apply(_this, ["afterModifyTransformStart"].concat(args));
    });
    this.transformation.addLocalHook("beforeTransformEnd", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.runLocalHooks.apply(_this, ["beforeModifyTransformEnd"].concat(args));
    });
    this.transformation.addLocalHook("afterTransformEnd", function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.runLocalHooks.apply(_this, ["afterModifyTransformEnd"].concat(args));
    });
    this.transformation.addLocalHook("insertRowRequire", function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.runLocalHooks.apply(_this, ["insertRowRequire"].concat(args));
    });
    this.transformation.addLocalHook("insertColRequire", function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.runLocalHooks.apply(_this, ["insertColRequire"].concat(args));
    });
  }
  _createClass35(Selection3, [{
    key: "getSelectedRange",
    value: function getSelectedRange() {
      return this.selectedRange;
    }
    /**
     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.
     */
  }, {
    key: "begin",
    value: function begin() {
      this.inProgress = true;
    }
    /**
     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.
     */
  }, {
    key: "finish",
    value: function finish() {
      this.runLocalHooks("afterSelectionFinished", Array.from(this.selectedRange));
      this.inProgress = false;
    }
    /**
     * Check if the process of selecting the cell/cells is in progress.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isInProgress",
    value: function isInProgress() {
      return this.inProgress;
    }
    /**
     * Starts selection range on given coordinate object.
     *
     * @param {CellCoords} coords Visual coords.
     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works
     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined
     *                                      the default trigger will be used (isPressedCtrlKey() helper).
     * @param {Boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the
     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.
     */
  }, {
    key: "setRangeStart",
    value: function setRangeStart(coords, multipleSelection) {
      var fragment = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var isMultipleMode = this.settings.selectionMode === "multiple";
      var isMultipleSelection = isUndefined2(multipleSelection) ? isPressedCtrlKey() : multipleSelection;
      var isRowNegative = coords.row < 0;
      var isColumnNegative = coords.col < 0;
      var selectedByCorner = isRowNegative && isColumnNegative;
      if (isRowNegative) {
        coords.row = 0;
      }
      if (isColumnNegative) {
        coords.col = 0;
      }
      this.selectedByCorner = selectedByCorner;
      this.runLocalHooks("beforeSetRangeStart".concat(fragment ? "Only" : ""), coords);
      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined2(multipleSelection)) {
        this.selectedRange.clear();
      }
      this.selectedRange.add(coords);
      if (this.getLayerLevel() === 0) {
        this.selectedByRowHeader.clear();
        this.selectedByColumnHeader.clear();
      }
      if (!selectedByCorner && isColumnNegative) {
        this.selectedByRowHeader.add(this.getLayerLevel());
      }
      if (!selectedByCorner && isRowNegative) {
        this.selectedByColumnHeader.add(this.getLayerLevel());
      }
      if (!fragment) {
        this.setRangeEnd(coords);
      }
    }
    /**
     * Starts selection range on given coordinate object.
     *
     * @param {CellCoords} coords Visual coords.
     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works
     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined
     *                                      the default trigger will be used (isPressedCtrlKey() helper).
     */
  }, {
    key: "setRangeStartOnly",
    value: function setRangeStartOnly(coords, multipleSelection) {
      this.setRangeStart(coords, multipleSelection, true);
    }
    /**
     * Ends selection range on given coordinate object.
     *
     * @param {CellCoords} coords Visual coords.
     */
  }, {
    key: "setRangeEnd",
    value: function setRangeEnd(coords) {
      if (this.selectedRange.isEmpty()) {
        return;
      }
      this.runLocalHooks("beforeSetRangeEnd", coords);
      this.begin();
      var cellRange = this.selectedRange.current();
      if (this.settings.selectionMode !== "single") {
        cellRange.setTo(new coords_default(coords.row, coords.col));
      }
      this.highlight.getCell().clear();
      if (this.highlight.isEnabledFor(CELL_TYPE10)) {
        this.highlight.getCell().add(this.selectedRange.current().highlight);
      }
      var layerLevel = this.getLayerLevel();
      if (layerLevel < this.highlight.layerLevel) {
        arrayEach(this.highlight.getAreas(), function(highlight) {
          return void highlight.clear();
        });
        arrayEach(this.highlight.getHeaders(), function(highlight) {
          return void highlight.clear();
        });
        arrayEach(this.highlight.getActiveHeaders(), function(highlight) {
          return void highlight.clear();
        });
      }
      this.highlight.useLayerLevel(layerLevel);
      var areaHighlight = this.highlight.createOrGetArea();
      var headerHighlight = this.highlight.createOrGetHeader();
      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();
      areaHighlight.clear();
      headerHighlight.clear();
      activeHeaderHighlight.clear();
      if (this.highlight.isEnabledFor(AREA_TYPE) && (this.isMultiple() || layerLevel >= 1)) {
        areaHighlight.add(cellRange.from).add(cellRange.to);
        if (layerLevel === 1) {
          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(this.selectedRange.previous().from);
          this.highlight.useLayerLevel(layerLevel);
        }
      }
      if (this.highlight.isEnabledFor(HEADER_TYPE)) {
        if (this.settings.selectionMode === "single") {
          headerHighlight.add(cellRange.highlight);
        } else {
          headerHighlight.add(cellRange.from).add(cellRange.to);
        }
      }
      if (this.isSelectedByRowHeader()) {
        var isRowSelected = this.tableProps.countCols() === cellRange.getWidth();
        if (isRowSelected) {
          activeHeaderHighlight.add(new coords_default(cellRange.from.row, -1)).add(new coords_default(cellRange.to.row, -1));
        }
      }
      if (this.isSelectedByColumnHeader()) {
        var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight();
        if (isColumnSelected) {
          activeHeaderHighlight.add(new coords_default(-1, cellRange.from.col)).add(new coords_default(-1, cellRange.to.col));
        }
      }
      this.runLocalHooks("afterSetRangeEnd", coords);
    }
    /**
     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of
     * the selection.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isMultiple",
    value: function isMultiple() {
      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());
      this.runLocalHooks("afterIsMultipleSelection", isMultipleListener);
      return isMultipleListener.value;
    }
    /**
     * Selects cell relative to the current cell (if possible).
     *
     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.
     * @param {Number} colDelta Columns number to move, value can be passed as negative number.
     * @param {Boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will
     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.
     */
  }, {
    key: "transformStart",
    value: function transformStart(rowDelta, colDelta, force) {
      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));
    }
    /**
     * Sets selection end cell relative to the current selection end cell (if possible).
     *
     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.
     * @param {Number} colDelta Columns number to move, value can be passed as negative number.
     */
  }, {
    key: "transformEnd",
    value: function transformEnd(rowDelta, colDelta) {
      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));
    }
    /**
     * Returns currently used layer level.
     *
     * @return {Number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.
     */
  }, {
    key: "getLayerLevel",
    value: function getLayerLevel() {
      return this.selectedRange.size() - 1;
    }
    /**
     * Returns `true` if currently there is a selection on the screen, `false` otherwise.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isSelected",
    value: function isSelected() {
      return !this.selectedRange.isEmpty();
    }
    /**
     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`
     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header
     * was clicked on any selection layer level.
     *
     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
     * @return {Boolean}
     */
  }, {
    key: "isSelectedByRowHeader",
    value: function isSelectedByRowHeader() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);
    }
    /**
     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`
     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header
     * was clicked on any selection layer level.
     *
     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
     * @return {Boolean}
     */
  }, {
    key: "isSelectedByColumnHeader",
    value: function isSelectedByColumnHeader() {
      var layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);
    }
    /**
     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.
     *
     * @return {Boolean}
     */
  }, {
    key: "isSelectedByAnyHeader",
    value: function isSelectedByAnyHeader() {
      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1);
    }
    /**
     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.
     *
     * @return {Boolean}
     */
  }, {
    key: "isSelectedByCorner",
    value: function isSelectedByCorner() {
      return this.selectedByCorner;
    }
    /**
     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if
     * the coords object is within selection range.
     *
     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
     * @returns {Boolean}
     */
  }, {
    key: "inInSelection",
    value: function inInSelection(coords) {
      return this.selectedRange.includes(coords);
    }
    /**
     * Returns `true` if the cell corner should be visible.
     *
     * @private
     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.
     */
  }, {
    key: "isCellCornerVisible",
    value: function isCellCornerVisible() {
      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();
    }
    /**
     * Returns `true` if the area corner should be visible.
     *
     * @param {Number} layerLevel The layer level.
     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.
     */
  }, {
    key: "isAreaCornerVisible",
    value: function isAreaCornerVisible(layerLevel) {
      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {
        return false;
      }
      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();
    }
    /**
     * Clear the selection by resetting the collected ranges and highlights.
     */
  }, {
    key: "clear",
    value: function clear() {
      this.selectedRange.clear();
      this.highlight.clear();
    }
    /**
     * Deselects all selected cells.
     */
  }, {
    key: "deselect",
    value: function deselect() {
      if (!this.isSelected()) {
        return;
      }
      this.inProgress = false;
      this.clear();
      this.runLocalHooks("afterDeselect");
    }
    /**
     * Select all cells.
     */
  }, {
    key: "selectAll",
    value: function selectAll() {
      this.clear();
      this.setRangeStart(new coords_default(-1, -1));
      this.selectedByRowHeader.add(this.getLayerLevel());
      this.selectedByColumnHeader.add(this.getLayerLevel());
      this.setRangeEnd(new coords_default(this.tableProps.countRows() - 1, this.tableProps.countCols() - 1));
    }
    /**
     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells
     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such
     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.
     * If the passed ranges have another format the exception will be thrown.
     *
     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.
     * @return {Boolean} Returns `true` if selection was successful, `false` otherwise.
     */
  }, {
    key: "selectCells",
    value: function selectCells(selectionRanges) {
      var _this2 = this;
      var selectionType = detectSelectionType(selectionRanges);
      if (selectionType === SELECTION_TYPE_EMPTY) {
        return false;
      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {
        throw new Error(toSingleLine(_templateObject4()));
      }
      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {
        propToCol: function propToCol(prop) {
          return _this2.tableProps.propToCol(prop);
        },
        keepDirection: true
      });
      var countRows = this.tableProps.countRows();
      var countCols = this.tableProps.countCols();
      var isValid5 = !selectionRanges.some(function(selection) {
        var _selectionSchemaNorma = selectionSchemaNormalizer(selection), _selectionSchemaNorma2 = _slicedToArray6(_selectionSchemaNorma, 4), rowStart = _selectionSchemaNorma2[0], columnStart = _selectionSchemaNorma2[1], rowEnd = _selectionSchemaNorma2[2], columnEnd = _selectionSchemaNorma2[3];
        var _isValid = isValidCoord(rowStart, countRows) && isValidCoord(columnStart, countCols) && isValidCoord(rowEnd, countRows) && isValidCoord(columnEnd, countCols);
        return !_isValid;
      });
      if (isValid5) {
        this.clear();
        arrayEach(selectionRanges, function(selection) {
          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection), _selectionSchemaNorma4 = _slicedToArray6(_selectionSchemaNorma3, 4), rowStart = _selectionSchemaNorma4[0], columnStart = _selectionSchemaNorma4[1], rowEnd = _selectionSchemaNorma4[2], columnEnd = _selectionSchemaNorma4[3];
          _this2.setRangeStartOnly(new coords_default(rowStart, columnStart), false);
          _this2.setRangeEnd(new coords_default(rowEnd, columnEnd));
          _this2.finish();
        });
      }
      return isValid5;
    }
    /**
     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at `endColumn`.
     *
     * @param {Number|String} startColumn Visual column index or column property from which the selection starts.
     * @param {Number|String} [endColumn] Visual column index or column property from to the selection finishes.
     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.
     */
  }, {
    key: "selectColumns",
    value: function selectColumns(startColumn) {
      var endColumn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startColumn;
      var start = typeof startColumn === "string" ? this.tableProps.propToCol(startColumn) : startColumn;
      var end = typeof endColumn === "string" ? this.tableProps.propToCol(endColumn) : endColumn;
      var countCols = this.tableProps.countCols();
      var isValid5 = isValidCoord(start, countCols) && isValidCoord(end, countCols);
      if (isValid5) {
        this.setRangeStartOnly(new coords_default(-1, start));
        this.setRangeEnd(new coords_default(this.tableProps.countRows() - 1, end));
        this.finish();
      }
      return isValid5;
    }
    /**
     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.
     *
     * @param {Number} startRow Visual row index from which the selection starts.
     * @param {Number} [endRow] Visual row index from to the selection finishes.
     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.
     */
  }, {
    key: "selectRows",
    value: function selectRows(startRow) {
      var endRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startRow;
      var countRows = this.tableProps.countRows();
      var isValid5 = isValidCoord(startRow, countRows) && isValidCoord(endRow, countRows);
      if (isValid5) {
        this.setRangeStartOnly(new coords_default(startRow, -1));
        this.setRangeEnd(new coords_default(endRow, this.tableProps.countCols() - 1));
        this.finish();
      }
      return isValid5;
    }
  }]);
  return Selection3;
}();
mixin(Selection2, localHooks_default);
var selection_default2 = Selection2;

// node_modules/handsontable/es/core.js
function _templateObject5() {
  var data = _taggedTemplateLiteral5(["Deprecation warning: This method is going to be removed in the next release.\n      If you want to select a cell using props, please use the `selectCell` method."], ["Deprecation warning: This method is going to be removed in the next release.\n      If you want to select a cell using props, please use the \\`selectCell\\` method."]);
  _templateObject5 = function _templateObject8() {
    return data;
  };
  return data;
}
function _taggedTemplateLiteral5(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _typeof23(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof23 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof23 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof23(obj);
}
function _slicedToArray7(arr, i) {
  return _arrayWithHoles7(arr) || _iterableToArrayLimit7(arr, i) || _nonIterableRest7();
}
function _nonIterableRest7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit7(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles7(arr) {
  if (Array.isArray(arr)) return arr;
}
function _toConsumableArray5(arr) {
  return _arrayWithoutHoles5(arr) || _iterableToArray5(arr) || _nonIterableSpread5();
}
function _nonIterableSpread5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray5(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles5(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
var activeGuid = null;
function Core(rootElement, userSettings) {
  var _this = this;
  var rootInstanceSymbol2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var preventScrollingToCell = false;
  var instance = this;
  var GridSettings = function GridSettings2() {
  };
  var eventManager2 = new eventManager_default(instance);
  var priv;
  var datamap;
  var dataSource;
  var grid;
  var editorManager;
  extend(GridSettings.prototype, defaultSettings_default.prototype);
  extend(GridSettings.prototype, userSettings);
  extend(GridSettings.prototype, expandType(userSettings));
  applyLanguageSetting(GridSettings.prototype, userSettings.language);
  if (hasValidParameter(rootInstanceSymbol2)) {
    registerAsRootInstance(this);
  }
  startObserving();
  this.isDestroyed = false;
  this.rootElement = rootElement;
  this.isHotTableEnv = isChildOfWebComponentTable(this.rootElement);
  eventManager_default.isHotTableEnv = this.isHotTableEnv;
  this.container = document.createElement("div");
  this.renderCall = false;
  rootElement.insertBefore(this.container, rootElement.firstChild);
  if (false) {
    _injectProductInfo(userSettings.licenseKey, rootElement);
  }
  this.guid = "ht_".concat(randomString());
  var recordTranslator = getTranslator(instance);
  dataSource = new dataSource_default(instance);
  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === "ht_") {
    this.rootElement.id = this.guid;
  }
  priv = {
    cellSettings: [],
    columnSettings: [],
    columnsSettingConflicts: ["data", "width", "language"],
    settings: new GridSettings(),
    // current settings instance
    selRange: null,
    // exposed by public method `getSelectedRange`
    isPopulated: null,
    scrollable: null,
    firstRun: true
  };
  var selection = new selection_default2(priv.settings, {
    countCols: function countCols() {
      return instance.countCols();
    },
    countRows: function countRows() {
      return instance.countRows();
    },
    propToCol: function propToCol(prop) {
      return datamap.propToCol(prop);
    },
    isEditorOpened: function isEditorOpened() {
      return instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false;
    }
  });
  this.selection = selection;
  this.selection.addLocalHook("beforeSetRangeStart", function(cellCoords) {
    _this.runHooks("beforeSetRangeStart", cellCoords);
  });
  this.selection.addLocalHook("beforeSetRangeStartOnly", function(cellCoords) {
    _this.runHooks("beforeSetRangeStartOnly", cellCoords);
  });
  this.selection.addLocalHook("beforeSetRangeEnd", function(cellCoords) {
    _this.runHooks("beforeSetRangeEnd", cellCoords);
    if (cellCoords.row < 0) {
      cellCoords.row = _this.view.wt.wtTable.getFirstVisibleRow();
    }
    if (cellCoords.col < 0) {
      cellCoords.col = _this.view.wt.wtTable.getFirstVisibleColumn();
    }
  });
  this.selection.addLocalHook("afterSetRangeEnd", function(cellCoords) {
    var preventScrolling = createObjectPropListener(false);
    var selectionRange = _this.selection.getSelectedRange();
    var _selectionRange$curre = selectionRange.current(), from3 = _selectionRange$curre.from, to3 = _selectionRange$curre.to;
    var selectionLayerLevel = selectionRange.size() - 1;
    _this.runHooks("afterSelection", from3.row, from3.col, to3.row, to3.col, preventScrolling, selectionLayerLevel);
    _this.runHooks("afterSelectionByProp", from3.row, instance.colToProp(from3.col), to3.row, instance.colToProp(to3.col), preventScrolling, selectionLayerLevel);
    var isSelectedByAnyHeader = _this.selection.isSelectedByAnyHeader();
    var currentSelectedRange = _this.selection.selectedRange.current();
    var scrollToCell = true;
    if (preventScrollingToCell) {
      scrollToCell = false;
    }
    if (preventScrolling.isTouched()) {
      scrollToCell = !preventScrolling.value;
    }
    var isSelectedByRowHeader = _this.selection.isSelectedByRowHeader();
    var isSelectedByColumnHeader = _this.selection.isSelectedByColumnHeader();
    if (scrollToCell !== false) {
      if (!isSelectedByAnyHeader) {
        if (currentSelectedRange && !_this.selection.isMultiple()) {
          _this.view.scrollViewport(currentSelectedRange.from);
        } else {
          _this.view.scrollViewport(cellCoords);
        }
      } else if (isSelectedByRowHeader) {
        _this.view.scrollViewportVertically(cellCoords.row);
      } else if (isSelectedByColumnHeader) {
        _this.view.scrollViewportHorizontally(cellCoords.col);
      }
    }
    if (isSelectedByRowHeader && isSelectedByColumnHeader) {
      addClass(_this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    } else if (isSelectedByRowHeader) {
      removeClass(_this.rootElement, "ht__selection--columns");
      addClass(_this.rootElement, "ht__selection--rows");
    } else if (isSelectedByColumnHeader) {
      removeClass(_this.rootElement, "ht__selection--rows");
      addClass(_this.rootElement, "ht__selection--columns");
    } else {
      removeClass(_this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    }
    _this._refreshBorders(null);
  });
  this.selection.addLocalHook("afterSelectionFinished", function(cellRanges) {
    var selectionLayerLevel = cellRanges.length - 1;
    var _cellRanges$selection = cellRanges[selectionLayerLevel], from3 = _cellRanges$selection.from, to3 = _cellRanges$selection.to;
    _this.runHooks("afterSelectionEnd", from3.row, from3.col, to3.row, to3.col, selectionLayerLevel);
    _this.runHooks("afterSelectionEndByProp", from3.row, instance.colToProp(from3.col), to3.row, instance.colToProp(to3.col), selectionLayerLevel);
  });
  this.selection.addLocalHook("afterIsMultipleSelection", function(isMultiple) {
    var changedIsMultiple = _this.runHooks("afterIsMultipleSelection", isMultiple.value);
    if (isMultiple.value) {
      isMultiple.value = changedIsMultiple;
    }
  });
  this.selection.addLocalHook("beforeModifyTransformStart", function(cellCoordsDelta) {
    _this.runHooks("modifyTransformStart", cellCoordsDelta);
  });
  this.selection.addLocalHook("afterModifyTransformStart", function(coords, rowTransformDir, colTransformDir) {
    _this.runHooks("afterModifyTransformStart", coords, rowTransformDir, colTransformDir);
  });
  this.selection.addLocalHook("beforeModifyTransformEnd", function(cellCoordsDelta) {
    _this.runHooks("modifyTransformEnd", cellCoordsDelta);
  });
  this.selection.addLocalHook("afterModifyTransformEnd", function(coords, rowTransformDir, colTransformDir) {
    _this.runHooks("afterModifyTransformEnd", coords, rowTransformDir, colTransformDir);
  });
  this.selection.addLocalHook("afterDeselect", function() {
    editorManager.destroyEditor();
    _this._refreshBorders();
    removeClass(_this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    _this.runHooks("afterDeselect");
  });
  this.selection.addLocalHook("insertRowRequire", function(totalRows) {
    _this.alter("insert_row", totalRows, 1, "auto");
  });
  this.selection.addLocalHook("insertColRequire", function(totalCols) {
    _this.alter("insert_col", totalCols, 1, "auto");
  });
  grid = {
    /**
     * Inserts or removes rows and columns.
     *
     * @memberof Core#
     * @function alter
     * @private
     * @param {String} action Possible values: "insert_row", "insert_col", "remove_row", "remove_col".
     * @param {Number|Array} index Row or column visual index which from the alter action will be triggered.
     *                             Alter actions such as "remove_row" and "remove_col" support array indexes in the
     *                             format `[[index, amount], [index, amount]...]` this can be used to remove
     *                             non-consecutive columns or rows in one call.
     * @param {Number} [amount=1] Ammount rows or columns to remove.
     * @param {String} [source] Optional. Source of hook runner.
     * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.
     */
    alter: function alter(action, index2) {
      var amount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var source = arguments.length > 3 ? arguments[3] : void 0;
      var keepEmptyRows = arguments.length > 4 ? arguments[4] : void 0;
      var delta;
      function spliceWith(data, startIndex, count, toInject) {
        var valueFactory = function valueFactory2() {
          var result;
          if (toInject === "array") {
            result = [];
          } else if (toInject === "object") {
            result = {};
          }
          return result;
        };
        var spliceArgs = arrayMap(new Array(count), function() {
          return valueFactory();
        });
        spliceArgs.unshift(startIndex, 0);
        data.splice.apply(data, _toConsumableArray5(spliceArgs));
      }
      var normalizeIndexesGroup = function normalizeIndexesGroup2(indexes) {
        if (indexes.length === 0) {
          return [];
        }
        var sortedIndexes = _toConsumableArray5(indexes);
        sortedIndexes.sort(function(_ref, _ref2) {
          var _ref3 = _slicedToArray7(_ref, 1), indexA = _ref3[0];
          var _ref4 = _slicedToArray7(_ref2, 1), indexB = _ref4[0];
          if (indexA === indexB) {
            return 0;
          }
          return indexA > indexB ? 1 : -1;
        });
        var normalizedIndexes = arrayReduce(sortedIndexes, function(acc, _ref5) {
          var _ref6 = _slicedToArray7(_ref5, 2), groupIndex = _ref6[0], groupAmount = _ref6[1];
          var previousItem = acc[acc.length - 1];
          var _previousItem = _slicedToArray7(previousItem, 2), prevIndex = _previousItem[0], prevAmount = _previousItem[1];
          var prevLastIndex = prevIndex + prevAmount;
          if (groupIndex <= prevLastIndex) {
            var amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);
            previousItem[1] += amountToAdd;
          } else {
            acc.push([groupIndex, groupAmount]);
          }
          return acc;
        }, [sortedIndexes[0]]);
        return normalizedIndexes;
      };
      switch (action) {
        case "insert_row":
          var numberOfSourceRows = instance.countSourceRows();
          if (instance.getSettings().maxRows === numberOfSourceRows) {
            return;
          }
          index2 = isDefined(index2) ? index2 : numberOfSourceRows;
          delta = datamap.createRow(index2, amount, source);
          spliceWith(priv.cellSettings, index2, amount, "array");
          if (delta) {
            if (selection.isSelected() && selection.selectedRange.current().from.row >= index2) {
              selection.selectedRange.current().from.row += delta;
              selection.transformEnd(delta, 0);
            } else {
              instance._refreshBorders();
            }
          }
          break;
        case "insert_col":
          delta = datamap.createCol(index2, amount, source);
          for (var row = 0, len = instance.countSourceRows(); row < len; row++) {
            if (priv.cellSettings[row]) {
              spliceWith(priv.cellSettings[row], index2, amount);
            }
          }
          if (delta) {
            if (Array.isArray(instance.getSettings().colHeaders)) {
              var spliceArray = [index2, 0];
              spliceArray.length += delta;
              Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArray);
            }
            if (selection.isSelected() && selection.selectedRange.current().from.col >= index2) {
              selection.selectedRange.current().from.col += delta;
              selection.transformEnd(0, delta);
            } else {
              instance._refreshBorders();
            }
          }
          break;
        case "remove_row":
          var removeRow = function removeRow2(indexes) {
            var offset4 = 0;
            arrayEach(indexes, function(_ref7) {
              var _ref8 = _slicedToArray7(_ref7, 2), groupIndex = _ref8[0], groupAmount = _ref8[1];
              var calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset4, 0);
              if (Number.isInteger(groupIndex)) {
                groupIndex = Math.max(groupIndex - offset4, 0);
              }
              datamap.removeRow(groupIndex, groupAmount, source);
              priv.cellSettings.splice(calcIndex, amount);
              var totalRows = instance.countRows();
              var fixedRowsTop = instance.getSettings().fixedRowsTop;
              if (fixedRowsTop >= calcIndex + 1) {
                instance.getSettings().fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);
              }
              var fixedRowsBottom = instance.getSettings().fixedRowsBottom;
              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {
                instance.getSettings().fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);
              }
              offset4 += groupAmount;
            });
          };
          if (Array.isArray(index2)) {
            removeRow(normalizeIndexesGroup(index2));
          } else {
            removeRow([[index2, amount]]);
          }
          grid.adjustRowsAndCols();
          instance._refreshBorders();
          break;
        case "remove_col":
          var removeCol = function removeCol2(indexes) {
            var offset4 = 0;
            arrayEach(indexes, function(_ref9) {
              var _ref10 = _slicedToArray7(_ref9, 2), groupIndex = _ref10[0], groupAmount = _ref10[1];
              var calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset4, 0);
              var visualColumnIndex = recordTranslator.toPhysicalColumn(calcIndex);
              if (Number.isInteger(groupIndex)) {
                groupIndex = Math.max(groupIndex - offset4, 0);
              }
              datamap.removeCol(groupIndex, groupAmount, source);
              for (var _row = 0, _len = instance.countSourceRows(); _row < _len; _row++) {
                if (priv.cellSettings[_row]) {
                  priv.cellSettings[_row].splice(visualColumnIndex, groupAmount);
                }
              }
              var fixedColumnsLeft = instance.getSettings().fixedColumnsLeft;
              if (fixedColumnsLeft >= calcIndex + 1) {
                instance.getSettings().fixedColumnsLeft -= Math.min(groupAmount, fixedColumnsLeft - calcIndex);
              }
              if (Array.isArray(instance.getSettings().colHeaders)) {
                if (typeof visualColumnIndex === "undefined") {
                  visualColumnIndex = -1;
                }
                instance.getSettings().colHeaders.splice(visualColumnIndex, groupAmount);
              }
              offset4 += groupAmount;
            });
          };
          if (Array.isArray(index2)) {
            removeCol(normalizeIndexesGroup(index2));
          } else {
            removeCol([[index2, amount]]);
          }
          grid.adjustRowsAndCols();
          instance._refreshBorders();
          break;
        default:
          throw new Error('There is no such action "'.concat(action, '"'));
      }
      if (!keepEmptyRows) {
        grid.adjustRowsAndCols();
      }
    },
    /**
     * Makes sure there are empty rows at the bottom of the table
     */
    adjustRowsAndCols: function adjustRowsAndCols() {
      if (priv.settings.minRows) {
        var rows = instance.countRows();
        if (rows < priv.settings.minRows) {
          for (var r = 0, minRows = priv.settings.minRows; r < minRows - rows; r++) {
            datamap.createRow(instance.countRows(), 1, "auto");
          }
        }
      }
      if (priv.settings.minSpareRows) {
        var emptyRows = instance.countEmptyRows(true);
        if (emptyRows < priv.settings.minSpareRows) {
          for (; emptyRows < priv.settings.minSpareRows && instance.countSourceRows() < priv.settings.maxRows; emptyRows++) {
            datamap.createRow(instance.countRows(), 1, "auto");
          }
        }
      }
      {
        var emptyCols;
        if (priv.settings.minCols || priv.settings.minSpareCols) {
          emptyCols = instance.countEmptyCols(true);
        }
        if (priv.settings.minCols && !priv.settings.columns && instance.countCols() < priv.settings.minCols) {
          for (; instance.countCols() < priv.settings.minCols; emptyCols++) {
            datamap.createCol(instance.countCols(), 1, "auto");
          }
        }
        if (priv.settings.minSpareCols && !priv.settings.columns && instance.dataType === "array" && emptyCols < priv.settings.minSpareCols) {
          for (; emptyCols < priv.settings.minSpareCols && instance.countCols() < priv.settings.maxCols; emptyCols++) {
            datamap.createCol(instance.countCols(), 1, "auto");
          }
        }
      }
      var rowCount = instance.countRows();
      var colCount = instance.countCols();
      if (rowCount === 0 || colCount === 0) {
        selection.deselect();
      }
      if (selection.isSelected()) {
        arrayEach(selection.selectedRange, function(range) {
          var selectionChanged = false;
          var fromRow = range.from.row;
          var fromCol = range.from.col;
          var toRow = range.to.row;
          var toCol = range.to.col;
          if (fromRow > rowCount - 1) {
            fromRow = rowCount - 1;
            selectionChanged = true;
            if (toRow > fromRow) {
              toRow = fromRow;
            }
          } else if (toRow > rowCount - 1) {
            toRow = rowCount - 1;
            selectionChanged = true;
            if (fromRow > toRow) {
              fromRow = toRow;
            }
          }
          if (fromCol > colCount - 1) {
            fromCol = colCount - 1;
            selectionChanged = true;
            if (toCol > fromCol) {
              toCol = fromCol;
            }
          } else if (toCol > colCount - 1) {
            toCol = colCount - 1;
            selectionChanged = true;
            if (fromCol > toCol) {
              fromCol = toCol;
            }
          }
          if (selectionChanged) {
            instance.selectCell(fromRow, fromCol, toRow, toCol);
          }
        });
      }
      if (instance.view) {
        instance.view.wt.wtOverlays.adjustElementsSize();
      }
    },
    /**
     * Populate the data from the provided 2d array from the given cell coordinates.
     *
     * @private
     * @param {Object} start Start selection position. Visual indexes.
     * @param {Array} input 2d data array.
     * @param {Object} [end] End selection position (only for drag-down mode). Visual indexes.
     * @param {String} [source="populateFromArray"] Source information string.
     * @param {String} [method="overwrite"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.
     * @param {String} direction (left|right|up|down) String specifying the direction.
     * @param {Array} deltas The deltas array. A difference between values of adjacent cells.
     *                       Useful **only** when the type of handled cells is `numeric`.
     * @returns {Object|undefined} ending td in pasted area (only if any cell was changed).
     */
    populateFromArray: function populateFromArray(start, input, end, source, method, direction, deltas) {
      var r;
      var rlen;
      var c;
      var clen;
      var setData = [];
      var current = {};
      rlen = input.length;
      if (rlen === 0) {
        return false;
      }
      var repeatCol;
      var repeatRow;
      var cmax;
      var rmax;
      switch (method) {
        case "shift_down":
          repeatCol = end ? end.col - start.col + 1 : 0;
          repeatRow = end ? end.row - start.row + 1 : 0;
          input = translateRowsToColumns(input);
          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {
            if (c < clen) {
              var _instance;
              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {
                input[c].push(input[c][r % rlen]);
              }
              input[c].unshift(start.col + c, start.row, 0);
              (_instance = instance).spliceCol.apply(_instance, _toConsumableArray5(input[c]));
            } else {
              var _instance2;
              input[c % clen][0] = start.col + c;
              (_instance2 = instance).spliceCol.apply(_instance2, _toConsumableArray5(input[c % clen]));
            }
          }
          break;
        case "shift_right":
          repeatCol = end ? end.col - start.col + 1 : 0;
          repeatRow = end ? end.row - start.row + 1 : 0;
          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {
            if (r < rlen) {
              var _instance3;
              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {
                input[r].push(input[r][c % clen]);
              }
              input[r].unshift(start.row + r, start.col, 0);
              (_instance3 = instance).spliceRow.apply(_instance3, _toConsumableArray5(input[r]));
            } else {
              var _instance4;
              input[r % rlen][0] = start.row + r;
              (_instance4 = instance).spliceRow.apply(_instance4, _toConsumableArray5(input[r % rlen]));
            }
          }
          break;
        case "overwrite":
        default:
          current.row = start.row;
          current.col = start.col;
          var selected = {
            // selected range
            row: end && start ? end.row - start.row + 1 : 1,
            col: end && start ? end.col - start.col + 1 : 1
          };
          var skippedRow = 0;
          var skippedColumn = 0;
          var pushData = true;
          var cellMeta;
          var getInputValue = function getInputValue2(row) {
            var col = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var rowValue = input[row % input.length];
            if (col !== null) {
              return rowValue[col % rowValue.length];
            }
            return rowValue;
          };
          var rowInputLength = input.length;
          var rowSelectionLength = end ? end.row - start.row + 1 : 0;
          if (end) {
            rlen = rowSelectionLength;
          } else {
            rlen = Math.max(rowInputLength, rowSelectionLength);
          }
          for (r = 0; r < rlen; r++) {
            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !priv.settings.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= priv.settings.maxRows) {
              break;
            }
            var visualRow = r - skippedRow;
            var colInputLength = getInputValue(visualRow).length;
            var colSelectionLength = end ? end.col - start.col + 1 : 0;
            if (end) {
              clen = colSelectionLength;
            } else {
              clen = Math.max(colInputLength, colSelectionLength);
            }
            current.col = start.col;
            cellMeta = instance.getCellMeta(current.row, current.col);
            if ((source === "CopyPaste.paste" || source === "Autofill.autofill") && cellMeta.skipRowOnPaste) {
              skippedRow += 1;
              current.row += 1;
              rlen += 1;
              continue;
            }
            skippedColumn = 0;
            for (c = 0; c < clen; c++) {
              if (end && current.col > end.col && colSelectionLength > colInputLength || !priv.settings.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= priv.settings.maxCols) {
                break;
              }
              cellMeta = instance.getCellMeta(current.row, current.col);
              if ((source === "CopyPaste.paste" || source === "Autofill.fill") && cellMeta.skipColumnOnPaste) {
                skippedColumn += 1;
                current.col += 1;
                clen += 1;
                continue;
              }
              if (cellMeta.readOnly) {
                current.col += 1;
                continue;
              }
              var visualColumn = c - skippedColumn;
              var value = getInputValue(visualRow, visualColumn);
              var orgValue = instance.getDataAtCell(current.row, current.col);
              var index2 = {
                row: visualRow,
                col: visualColumn
              };
              if (source === "Autofill.fill") {
                var result = instance.runHooks("beforeAutofillInsidePopulate", index2, direction, input, deltas, {}, selected);
                if (result) {
                  value = isUndefined2(result.value) ? value : result.value;
                }
              }
              if (value !== null && _typeof23(value) === "object") {
                if (orgValue === null || _typeof23(orgValue) !== "object") {
                  pushData = false;
                } else {
                  var orgValueSchema = duckSchema(orgValue[0] || orgValue);
                  var valueSchema = duckSchema(value[0] || value);
                  if (isObjectEqual(orgValueSchema, valueSchema)) {
                    value = deepClone(value);
                  } else {
                    pushData = false;
                  }
                }
              } else if (orgValue !== null && _typeof23(orgValue) === "object") {
                pushData = false;
              }
              if (pushData) {
                setData.push([current.row, current.col, value]);
              }
              pushData = true;
              current.col += 1;
            }
            current.row += 1;
          }
          instance.setDataAtCell(setData, null, null, source || "populateFromArray");
          break;
      }
    }
  };
  function setLanguage(languageCode) {
    var normalizedLanguageCode = normalizeLanguageCode(languageCode);
    if (hasLanguage(normalizedLanguageCode)) {
      instance.runHooks("beforeLanguageChange", normalizedLanguageCode);
      GridSettings.prototype.language = normalizedLanguageCode;
      instance.runHooks("afterLanguageChange", normalizedLanguageCode);
    } else {
      warnUserAboutLanguageRegistration(languageCode);
    }
  }
  this.init = function() {
    dataSource.setData(priv.settings.data);
    instance.runHooks("beforeInit");
    if (isMobileBrowser()) {
      addClass(instance.rootElement, "mobile");
    }
    this.updateSettings(priv.settings, true);
    this.view = new tableView_default(this);
    editorManager = editorManager_default.getInstance(instance, priv, selection, datamap);
    this.forceFullRender = true;
    instance.runHooks("init");
    this.view.render();
    if (_typeof23(priv.firstRun) === "object") {
      instance.runHooks("afterChange", priv.firstRun[0], priv.firstRun[1]);
      priv.firstRun = false;
    }
    instance.runHooks("afterInit");
  };
  function ValidatorsQueue() {
    var resolved = false;
    return {
      validatorsInQueue: 0,
      valid: true,
      addValidatorToQueue: function addValidatorToQueue() {
        this.validatorsInQueue += 1;
        resolved = false;
      },
      removeValidatorFormQueue: function removeValidatorFormQueue() {
        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;
        this.checkIfQueueIsEmpty();
      },
      onQueueEmpty: function onQueueEmpty() {
      },
      checkIfQueueIsEmpty: function checkIfQueueIsEmpty() {
        if (this.validatorsInQueue === 0 && resolved === false) {
          resolved = true;
          this.onQueueEmpty(this.valid);
        }
      }
    };
  }
  function getParsedNumber(numericData) {
    var unifiedNumericData = numericData.replace(",", ".");
    if (isNaN(parseFloat(unifiedNumericData)) === false) {
      return parseFloat(unifiedNumericData);
    }
    return numericData;
  }
  function validateChanges(changes, source, callback) {
    var waitingForValidator = new ValidatorsQueue();
    var isNumericData = function isNumericData2(value) {
      return value.length > 0 && /^\s*[+-.]?\s*(?:(?:\d+(?:(\.|,)\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/.test(value);
    };
    waitingForValidator.onQueueEmpty = resolve;
    for (var i = changes.length - 1; i >= 0; i--) {
      if (changes[i] === null) {
        changes.splice(i, 1);
      } else {
        var _changes$i = _slicedToArray7(changes[i], 4), row = _changes$i[0], prop = _changes$i[1], newValue = _changes$i[3];
        var col = datamap.propToCol(prop);
        var cellProperties = instance.getCellMeta(row, col);
        if (cellProperties.type === "numeric" && typeof newValue === "string" && isNumericData(newValue)) {
          changes[i][3] = getParsedNumber(newValue);
        }
        if (instance.getCellValidator(cellProperties)) {
          waitingForValidator.addValidatorToQueue();
          instance.validateCell(changes[i][3], cellProperties, /* @__PURE__ */ function(index2, cellPropertiesReference) {
            return function(result) {
              if (typeof result !== "boolean") {
                throw new Error("Validation error: result is not boolean");
              }
              if (result === false && cellPropertiesReference.allowInvalid === false) {
                changes.splice(index2, 1);
                cellPropertiesReference.valid = true;
                var cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);
                if (cell !== null) {
                  removeClass(cell, instance.getSettings().invalidCellClassName);
                }
              }
              waitingForValidator.removeValidatorFormQueue();
            };
          }(i, cellProperties), source);
        }
      }
    }
    waitingForValidator.checkIfQueueIsEmpty();
    function resolve() {
      var beforeChangeResult;
      if (changes.length) {
        beforeChangeResult = instance.runHooks("beforeChange", changes, source || "edit");
        if (isFunction2(beforeChangeResult)) {
          warn2("Your beforeChange callback returns a function. It's not supported since Handsontable 0.12.1 (and the returned function will not be executed).");
        } else if (beforeChangeResult === false) {
          changes.splice(0, changes.length);
        }
      }
      callback();
    }
  }
  function applyChanges(changes, source) {
    var i = changes.length - 1;
    if (i < 0) {
      return;
    }
    for (; i >= 0; i--) {
      var skipThisChange = false;
      if (changes[i] === null) {
        changes.splice(i, 1);
        continue;
      }
      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {
        continue;
      }
      if (priv.settings.allowInsertRow) {
        while (changes[i][0] > instance.countRows() - 1) {
          var numberOfCreatedRows = datamap.createRow(void 0, void 0, source);
          if (numberOfCreatedRows === 0) {
            skipThisChange = true;
            break;
          }
        }
      }
      if (skipThisChange) {
        continue;
      }
      if (instance.dataType === "array" && (!priv.settings.columns || priv.settings.columns.length === 0) && priv.settings.allowInsertColumn) {
        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {
          datamap.createCol(void 0, void 0, source);
        }
      }
      datamap.set(changes[i][0], changes[i][1], changes[i][3]);
    }
    instance.forceFullRender = true;
    grid.adjustRowsAndCols();
    instance.runHooks("beforeChangeRender", changes, source);
    editorManager.lockEditor();
    instance._refreshBorders(null);
    editorManager.unlockEditor();
    instance.view.wt.wtOverlays.adjustElementsSize();
    instance.runHooks("afterChange", changes, source || "edit");
    var activeEditor = instance.getActiveEditor();
    if (activeEditor && isDefined(activeEditor.refreshValue)) {
      activeEditor.refreshValue();
    }
  }
  this.validateCell = function(value, cellProperties, callback, source) {
    var validator2 = instance.getCellValidator(cellProperties);
    function done(valid) {
      var canBeValidated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (!canBeValidated || cellProperties.hidden === true) {
        callback(valid);
        return;
      }
      var col = cellProperties.visualCol;
      var row = cellProperties.visualRow;
      var td = instance.getCell(row, col, true);
      if (td && td.nodeName !== "TH") {
        instance.view.wt.wtSettings.settings.cellRenderer(row, col, td);
      }
      callback(valid);
    }
    if (isRegExp(validator2)) {
      validator2 = /* @__PURE__ */ function(expression) {
        return function(cellValue, validatorCallback) {
          validatorCallback(expression.test(cellValue));
        };
      }(validator2);
    }
    if (isFunction2(validator2)) {
      value = instance.runHooks("beforeValidate", value, cellProperties.visualRow, cellProperties.prop, source);
      instance._registerTimeout(setTimeout(function() {
        validator2.call(cellProperties, value, function(valid) {
          valid = instance.runHooks("afterValidate", valid, value, cellProperties.visualRow, cellProperties.prop, source);
          cellProperties.valid = valid;
          done(valid);
          instance.runHooks("postAfterValidate", valid, value, cellProperties.visualRow, cellProperties.prop, source);
        });
      }, 0));
    } else {
      instance._registerTimeout(setTimeout(function() {
        cellProperties.valid = true;
        done(cellProperties.valid, false);
      }, 0));
    }
  };
  function setDataInputToArray(row, propOrCol, value) {
    if (_typeof23(row) === "object") {
      return row;
    }
    return [[row, propOrCol, value]];
  }
  this.setDataAtCell = function(row, column, value, source) {
    var input = setDataInputToArray(row, column, value);
    var changes = [];
    var changeSource = source;
    var i;
    var ilen;
    var prop;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      if (_typeof23(input[i]) !== "object") {
        throw new Error("Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter");
      }
      if (typeof input[i][1] !== "number") {
        throw new Error("Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`");
      }
      prop = datamap.colToProp(input[i][1]);
      changes.push([input[i][0], prop, dataSource.getAtCell(recordTranslator.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }
    if (!changeSource && _typeof23(row) === "object") {
      changeSource = column;
    }
    instance.runHooks("afterSetDataAtCell", changes, changeSource);
    validateChanges(changes, changeSource, function() {
      applyChanges(changes, changeSource);
    });
  };
  this.setDataAtRowProp = function(row, prop, value, source) {
    var input = setDataInputToArray(row, prop, value);
    var changes = [];
    var changeSource = source;
    var i;
    var ilen;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      changes.push([input[i][0], input[i][1], dataSource.getAtCell(recordTranslator.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }
    if (!changeSource && _typeof23(row) === "object") {
      changeSource = prop;
    }
    instance.runHooks("afterSetDataAtRowProp", changes, changeSource);
    validateChanges(changes, changeSource, function() {
      applyChanges(changes, changeSource);
    });
  };
  this.listen = function() {
    var modifyDocumentFocus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (modifyDocumentFocus) {
      var invalidActiveElement = !document.activeElement || document.activeElement && document.activeElement.nodeName === void 0;
      if (document.activeElement && document.activeElement !== document.body && !invalidActiveElement) {
        document.activeElement.blur();
      } else if (invalidActiveElement) {
        document.body.focus();
      }
    }
    if (instance && !instance.isListening()) {
      activeGuid = instance.guid;
      instance.runHooks("afterListen");
    }
  };
  this.unlisten = function() {
    if (this.isListening()) {
      activeGuid = null;
      instance.runHooks("afterUnlisten");
    }
  };
  this.isListening = function() {
    return activeGuid === instance.guid;
  };
  this.destroyEditor = function() {
    var revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);
  };
  this.populateFromArray = function(row, column, input, endRow, endCol, source, method, direction, deltas) {
    if (!(_typeof23(input) === "object" && _typeof23(input[0]) === "object")) {
      throw new Error("populateFromArray parameter `input` must be an array of arrays");
    }
    var c = typeof endRow === "number" ? new coords_default(endRow, endCol) : null;
    return grid.populateFromArray(new coords_default(row, column), input, c, source, method, direction, deltas);
  };
  this.spliceCol = function(column, index2, amount) {
    var _datamap;
    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key = 3; _key < _len2; _key++) {
      elements[_key - 3] = arguments[_key];
    }
    return (_datamap = datamap).spliceCol.apply(_datamap, [column, index2, amount].concat(elements));
  };
  this.spliceRow = function(row, index2, amount) {
    var _datamap2;
    for (var _len3 = arguments.length, elements = new Array(_len3 > 3 ? _len3 - 3 : 0), _key2 = 3; _key2 < _len3; _key2++) {
      elements[_key2 - 3] = arguments[_key2];
    }
    return (_datamap2 = datamap).spliceRow.apply(_datamap2, [row, index2, amount].concat(elements));
  };
  this.getSelected = function() {
    if (selection.isSelected()) {
      return arrayMap(selection.getSelectedRange(), function(_ref11) {
        var from3 = _ref11.from, to3 = _ref11.to;
        return [from3.row, from3.col, to3.row, to3.col];
      });
    }
  };
  this.getSelectedLast = function() {
    var selected = this.getSelected();
    var result;
    if (selected && selected.length > 0) {
      result = selected[selected.length - 1];
    }
    return result;
  };
  this.getSelectedRange = function() {
    if (selection.isSelected()) {
      return Array.from(selection.getSelectedRange());
    }
  };
  this.getSelectedRangeLast = function() {
    var selectedRange = this.getSelectedRange();
    var result;
    if (selectedRange && selectedRange.length > 0) {
      result = selectedRange[selectedRange.length - 1];
    }
    return result;
  };
  this.emptySelectedCells = function() {
    var _this2 = this;
    if (!selection.isSelected()) {
      return;
    }
    var changes = [];
    arrayEach(selection.getSelectedRange(), function(cellRange) {
      var topLeft = cellRange.getTopLeftCorner();
      var bottomRight = cellRange.getBottomRightCorner();
      rangeEach(topLeft.row, bottomRight.row, function(row) {
        rangeEach(topLeft.col, bottomRight.col, function(column) {
          if (!_this2.getCellMeta(row, column).readOnly) {
            changes.push([row, column, ""]);
          }
        });
      });
    });
    if (changes.length > 0) {
      this.setDataAtCell(changes);
    }
  };
  this.render = function() {
    if (instance.view) {
      instance.renderCall = true;
      instance.forceFullRender = true;
      editorManager.lockEditor();
      instance._refreshBorders(null);
      editorManager.unlockEditor();
    }
  };
  this.loadData = function(data) {
    if (Array.isArray(priv.settings.dataSchema)) {
      instance.dataType = "array";
    } else if (isFunction2(priv.settings.dataSchema)) {
      instance.dataType = "function";
    } else {
      instance.dataType = "object";
    }
    if (datamap) {
      datamap.destroy();
    }
    datamap = new dataMap_default(instance, priv, GridSettings);
    if (_typeof23(data) === "object" && data !== null) {
      if (!(data.push && data.splice)) {
        data = [data];
      }
    } else if (data === null) {
      var dataSchema = datamap.getSchema();
      data = [];
      var row;
      var r = 0;
      var rlen = 0;
      for (r = 0, rlen = priv.settings.startRows; r < rlen; r++) {
        if ((instance.dataType === "object" || instance.dataType === "function") && priv.settings.dataSchema) {
          row = deepClone(dataSchema);
          data.push(row);
        } else if (instance.dataType === "array") {
          row = deepClone(dataSchema[0]);
          data.push(row);
        } else {
          row = [];
          for (var c = 0, clen = priv.settings.startCols; c < clen; c++) {
            row.push(null);
          }
          data.push(row);
        }
      }
    } else {
      throw new Error("loadData only accepts array of objects or array of arrays (".concat(_typeof23(data), " given)"));
    }
    priv.isPopulated = false;
    GridSettings.prototype.data = data;
    if (Array.isArray(data[0])) {
      instance.dataType = "array";
    }
    datamap.dataSource = data;
    dataSource.data = data;
    dataSource.dataType = instance.dataType;
    dataSource.colToProp = datamap.colToProp.bind(datamap);
    dataSource.propToCol = datamap.propToCol.bind(datamap);
    clearCellSettingCache();
    grid.adjustRowsAndCols();
    instance.runHooks("afterLoadData", priv.firstRun);
    if (priv.firstRun) {
      priv.firstRun = [null, "loadData"];
    } else {
      instance.runHooks("afterChange", null, "loadData");
      instance.render();
    }
    priv.isPopulated = true;
    function clearCellSettingCache() {
      priv.cellSettings.length = 0;
    }
  };
  this.getData = function(row, column, row2, column2) {
    if (isUndefined2(row)) {
      return datamap.getAll();
    }
    return datamap.getRange(new coords_default(row, column), new coords_default(row2, column2), datamap.DESTINATION_RENDERER);
  };
  this.getCopyableText = function(startRow, startCol, endRow, endCol) {
    return datamap.getCopyableText(new coords_default(startRow, startCol), new coords_default(endRow, endCol));
  };
  this.getCopyableData = function(row, column) {
    return datamap.getCopyable(row, datamap.colToProp(column));
  };
  this.getSchema = function() {
    return datamap.getSchema();
  };
  this.updateSettings = function(settings) {
    var init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var columnsAsFunc = false;
    var i;
    var j;
    var clen;
    if (isDefined(settings.rows)) {
      throw new Error('"rows" setting is no longer supported. do you mean startRows, minRows or maxRows?');
    }
    if (isDefined(settings.cols)) {
      throw new Error('"cols" setting is no longer supported. do you mean startCols, minCols or maxCols?');
    }
    for (i in settings) {
      if (i === "data") {
        continue;
      } else if (i === "language") {
        setLanguage(settings.language);
        continue;
      } else if (pluginHooks_default.getSingleton().getRegistered().indexOf(i) > -1) {
        if (isFunction2(settings[i]) || Array.isArray(settings[i])) {
          settings[i].initialHook = true;
          instance.addHook(i, settings[i]);
        }
      } else if (!init2 && hasOwnProperty(settings, i)) {
        GridSettings.prototype[i] = settings[i];
      }
    }
    if (settings.data === void 0 && priv.settings.data === void 0) {
      instance.loadData(null);
    } else if (settings.data !== void 0) {
      instance.loadData(settings.data);
    } else if (settings.columns !== void 0) {
      datamap.createMap();
    }
    clen = instance.countCols();
    var columnSetting = settings.columns || GridSettings.prototype.columns;
    if (columnSetting && isFunction2(columnSetting)) {
      clen = instance.countSourceCols();
      columnsAsFunc = true;
    }
    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {
      priv.cellSettings.length = 0;
    }
    if (clen > 0) {
      var proto5;
      var column;
      for (i = 0, j = 0; i < clen; i++) {
        if (columnsAsFunc && !columnSetting(i)) {
          continue;
        }
        priv.columnSettings[j] = columnFactory(GridSettings, priv.columnsSettingConflicts);
        proto5 = priv.columnSettings[j].prototype;
        if (columnSetting) {
          if (columnsAsFunc) {
            column = columnSetting(i);
          } else {
            column = columnSetting[j];
          }
          if (column) {
            extend(proto5, column);
            extend(proto5, expandType(column));
          }
        }
        j += 1;
      }
    }
    if (isDefined(settings.cell)) {
      objectEach(settings.cell, function(cell) {
        instance.setCellMetaObject(cell.row, cell.col, cell);
      });
    }
    instance.runHooks("afterCellMetaReset");
    if (isDefined(settings.className)) {
      if (GridSettings.prototype.className) {
        removeClass(instance.rootElement, GridSettings.prototype.className);
      }
      if (settings.className) {
        addClass(instance.rootElement, settings.className);
      }
    }
    var currentHeight = instance.rootElement.style.height;
    if (currentHeight !== "") {
      currentHeight = parseInt(instance.rootElement.style.height, 10);
    }
    var height = settings.height;
    if (isFunction2(height)) {
      height = height();
    }
    if (init2) {
      var initialStyle = instance.rootElement.getAttribute("style");
      if (initialStyle) {
        instance.rootElement.setAttribute("data-initialstyle", instance.rootElement.getAttribute("style"));
      }
    }
    if (height === null) {
      var _initialStyle = instance.rootElement.getAttribute("data-initialstyle");
      if (_initialStyle && (_initialStyle.indexOf("height") > -1 || _initialStyle.indexOf("overflow") > -1)) {
        instance.rootElement.setAttribute("style", _initialStyle);
      } else {
        instance.rootElement.style.height = "";
        instance.rootElement.style.overflow = "";
      }
    } else if (height !== void 0) {
      instance.rootElement.style.height = "".concat(height, "px");
      instance.rootElement.style.overflow = "hidden";
    }
    if (typeof settings.width !== "undefined") {
      var width = settings.width;
      if (isFunction2(width)) {
        width = width();
      }
      instance.rootElement.style.width = "".concat(width, "px");
    }
    if (!init2) {
      datamap.clearLengthCache();
      if (instance.view) {
        instance.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked();
      }
      instance.runHooks("afterUpdateSettings", settings);
    }
    grid.adjustRowsAndCols();
    if (instance.view && !priv.firstRun) {
      instance.forceFullRender = true;
      editorManager.lockEditor();
      instance._refreshBorders(null);
      editorManager.unlockEditor();
    }
    if (!init2 && instance.view && (currentHeight === "" || height === "" || height === void 0) && currentHeight !== height) {
      instance.view.wt.wtOverlays.updateMainScrollableElements();
    }
  };
  this.getValue = function() {
    var sel = instance.getSelectedLast();
    if (GridSettings.prototype.getValue) {
      if (isFunction2(GridSettings.prototype.getValue)) {
        return GridSettings.prototype.getValue.call(instance);
      } else if (sel) {
        return instance.getData()[sel[0][0]][GridSettings.prototype.getValue];
      }
    } else if (sel) {
      return instance.getDataAtCell(sel[0], sel[1]);
    }
  };
  function expandType(obj) {
    if (!hasOwnProperty(obj, "type")) {
      return;
    }
    var expandedType = {};
    var type;
    if (_typeof23(obj.type) === "object") {
      type = obj.type;
    } else if (typeof obj.type === "string") {
      type = _getItem4(obj.type);
    }
    for (var i in type) {
      if (hasOwnProperty(type, i) && !hasOwnProperty(obj, i)) {
        expandedType[i] = type[i];
      }
    }
    return expandedType;
  }
  this.getSettings = function() {
    return priv.settings;
  };
  this.clear = function() {
    this.selectAll();
    this.emptySelectedCells();
  };
  this.alter = function(action, index2, amount, source, keepEmptyRows) {
    grid.alter(action, index2, amount, source, keepEmptyRows);
  };
  this.getCell = function(row, column) {
    var topmost = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return instance.view.getCellAtCoords(new coords_default(row, column), topmost);
  };
  this.getCoords = function(element) {
    return this.view.wt.wtTable.getCoords.call(this.view.wt.wtTable, element);
  };
  this.colToProp = function(column) {
    return datamap.colToProp(column);
  };
  this.propToCol = function(prop) {
    return datamap.propToCol(prop);
  };
  this.toVisualRow = function(row) {
    return recordTranslator.toVisualRow(row);
  };
  this.toVisualColumn = function(column) {
    return recordTranslator.toVisualColumn(column);
  };
  this.toPhysicalRow = function(row) {
    return recordTranslator.toPhysicalRow(row);
  };
  this.toPhysicalColumn = function(column) {
    return recordTranslator.toPhysicalColumn(column);
  };
  this.getDataAtCell = function(row, column) {
    return datamap.get(row, datamap.colToProp(column));
  };
  this.getDataAtRowProp = function(row, prop) {
    return datamap.get(row, prop);
  };
  this.getDataAtCol = function(column) {
    var _ref12;
    return (_ref12 = []).concat.apply(_ref12, _toConsumableArray5(datamap.getRange(new coords_default(0, column), new coords_default(priv.settings.data.length - 1, column), datamap.DESTINATION_RENDERER)));
  };
  this.getDataAtProp = function(prop) {
    var _ref13;
    var range = datamap.getRange(new coords_default(0, datamap.propToCol(prop)), new coords_default(priv.settings.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);
    return (_ref13 = []).concat.apply(_ref13, _toConsumableArray5(range));
  };
  this.getSourceData = function(row, column, row2, column2) {
    var data;
    if (row === void 0) {
      data = dataSource.getData();
    } else {
      data = dataSource.getByRange(new coords_default(row, column), new coords_default(row2, column2));
    }
    return data;
  };
  this.getSourceDataArray = function(row, column, row2, column2) {
    var data;
    if (row === void 0) {
      data = dataSource.getData(true);
    } else {
      data = dataSource.getByRange(new coords_default(row, column), new coords_default(row2, column2), true);
    }
    return data;
  };
  this.getSourceDataAtCol = function(column) {
    return dataSource.getAtColumn(column);
  };
  this.getSourceDataAtRow = function(row) {
    return dataSource.getAtRow(row);
  };
  this.getSourceDataAtCell = function(row, column) {
    return dataSource.getAtCell(row, column);
  };
  this.getDataAtRow = function(row) {
    var data = datamap.getRange(new coords_default(row, 0), new coords_default(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);
    return data[0] || [];
  };
  this.getDataType = function(rowFrom, columnFrom, rowTo, columnTo) {
    var _this3 = this;
    var coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];
    var rowStart = coords[0], columnStart = coords[1];
    var rowEnd = coords[2], columnEnd = coords[3];
    var previousType = null;
    var currentType = null;
    if (rowEnd === void 0) {
      rowEnd = rowStart;
    }
    if (columnEnd === void 0) {
      columnEnd = columnStart;
    }
    var type = "mixed";
    rangeEach(Math.min(rowStart, rowEnd), Math.max(rowStart, rowEnd), function(row) {
      var isTypeEqual = true;
      rangeEach(Math.min(columnStart, columnEnd), Math.max(columnStart, columnEnd), function(column) {
        var cellType = _this3.getCellMeta(row, column);
        currentType = cellType.type;
        if (previousType) {
          isTypeEqual = previousType === currentType;
        } else {
          previousType = currentType;
        }
        return isTypeEqual;
      });
      type = isTypeEqual ? currentType : "mixed";
      return isTypeEqual;
    });
    return type;
  };
  this.removeCellMeta = function(row, column, key) {
    var _recordTranslator$toP = recordTranslator.toPhysical(row, column), _recordTranslator$toP2 = _slicedToArray7(_recordTranslator$toP, 2), physicalRow = _recordTranslator$toP2[0], physicalColumn = _recordTranslator$toP2[1];
    var cachedValue = priv.cellSettings[physicalRow][physicalColumn][key];
    var hookResult = instance.runHooks("beforeRemoveCellMeta", row, column, key, cachedValue);
    if (hookResult !== false) {
      delete priv.cellSettings[physicalRow][physicalColumn][key];
      instance.runHooks("afterRemoveCellMeta", row, column, key, cachedValue);
    }
    cachedValue = null;
  };
  this.spliceCellsMeta = function(index2, deleteAmount) {
    var _priv$cellSettings;
    for (var _len4 = arguments.length, items = new Array(_len4 > 2 ? _len4 - 2 : 0), _key3 = 2; _key3 < _len4; _key3++) {
      items[_key3 - 2] = arguments[_key3];
    }
    (_priv$cellSettings = priv.cellSettings).splice.apply(_priv$cellSettings, [index2, deleteAmount].concat(items));
  };
  this.setCellMetaObject = function(row, column, prop) {
    var _this4 = this;
    if (_typeof23(prop) === "object") {
      objectEach(prop, function(value, key) {
        _this4.setCellMeta(row, column, key, value);
      });
    }
  };
  this.setCellMeta = function(row, column, key, value) {
    var _recordTranslator$toP3 = recordTranslator.toPhysical(row, column), _recordTranslator$toP4 = _slicedToArray7(_recordTranslator$toP3, 2), physicalRow = _recordTranslator$toP4[0], physicalColumn = _recordTranslator$toP4[1];
    if (!priv.columnSettings[physicalColumn]) {
      priv.columnSettings[physicalColumn] = columnFactory(GridSettings, priv.columnsSettingConflicts);
    }
    if (!priv.cellSettings[physicalRow]) {
      priv.cellSettings[physicalRow] = [];
    }
    if (!priv.cellSettings[physicalRow][physicalColumn]) {
      priv.cellSettings[physicalRow][physicalColumn] = new priv.columnSettings[physicalColumn]();
    }
    priv.cellSettings[physicalRow][physicalColumn][key] = value;
    instance.runHooks("afterSetCellMeta", row, column, key, value);
  };
  this.getCellsMeta = function() {
    return arrayFlatten(priv.cellSettings);
  };
  this.getCellMeta = function(row, column) {
    var prop = datamap.colToProp(column);
    var _recordTranslator$toP5 = recordTranslator.toPhysical(row, column), _recordTranslator$toP6 = _slicedToArray7(_recordTranslator$toP5, 2), potentialPhysicalRow = _recordTranslator$toP6[0], physicalColumn = _recordTranslator$toP6[1];
    var physicalRow = potentialPhysicalRow;
    if (physicalRow === null) {
      physicalRow = row;
    }
    if (!priv.columnSettings[physicalColumn]) {
      priv.columnSettings[physicalColumn] = columnFactory(GridSettings, priv.columnsSettingConflicts);
    }
    if (!priv.cellSettings[physicalRow]) {
      priv.cellSettings[physicalRow] = [];
    }
    if (!priv.cellSettings[physicalRow][physicalColumn]) {
      priv.cellSettings[physicalRow][physicalColumn] = new priv.columnSettings[physicalColumn]();
    }
    var cellProperties = priv.cellSettings[physicalRow][physicalColumn];
    cellProperties.row = physicalRow;
    cellProperties.col = physicalColumn;
    cellProperties.visualRow = row;
    cellProperties.visualCol = column;
    cellProperties.prop = prop;
    cellProperties.instance = instance;
    instance.runHooks("beforeGetCellMeta", row, column, cellProperties);
    extend(cellProperties, expandType(cellProperties));
    if (cellProperties.cells) {
      var settings = cellProperties.cells.call(cellProperties, physicalRow, physicalColumn, prop);
      if (settings) {
        extend(cellProperties, settings);
        extend(cellProperties, expandType(settings));
      }
    }
    instance.runHooks("afterGetCellMeta", row, column, cellProperties);
    return cellProperties;
  };
  this.getCellMetaAtRow = function(row) {
    return priv.cellSettings[row];
  };
  this.isColumnModificationAllowed = function() {
    return !(instance.dataType === "object" || instance.getSettings().columns);
  };
  var rendererLookup = cellMethodLookupFactory("renderer");
  this.getCellRenderer = function(row, column) {
    return _getItem2(rendererLookup.call(this, row, column));
  };
  this.getCellEditor = cellMethodLookupFactory("editor");
  var validatorLookup = cellMethodLookupFactory("validator");
  this.getCellValidator = function(row, column) {
    var validator2 = validatorLookup.call(this, row, column);
    if (typeof validator2 === "string") {
      validator2 = _getItem3(validator2);
    }
    return validator2;
  };
  this.validateCells = function(callback) {
    this._validateCells(callback);
  };
  this.validateRows = function(rows, callback) {
    if (!Array.isArray(rows)) {
      throw new Error("validateRows parameter `rows` must be an array");
    }
    this._validateCells(callback, rows);
  };
  this.validateColumns = function(columns, callback) {
    if (!Array.isArray(columns)) {
      throw new Error("validateColumns parameter `columns` must be an array");
    }
    this._validateCells(callback, void 0, columns);
  };
  this._validateCells = function(callback, rows, columns) {
    var waitingForValidator = new ValidatorsQueue();
    if (callback) {
      waitingForValidator.onQueueEmpty = callback;
    }
    var i = instance.countRows() - 1;
    while (i >= 0) {
      if (rows !== void 0 && rows.indexOf(i) === -1) {
        i -= 1;
        continue;
      }
      var j = instance.countCols() - 1;
      while (j >= 0) {
        if (columns !== void 0 && columns.indexOf(j) === -1) {
          j -= 1;
          continue;
        }
        waitingForValidator.addValidatorToQueue();
        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function(result) {
          if (typeof result !== "boolean") {
            throw new Error("Validation error: result is not boolean");
          }
          if (result === false) {
            waitingForValidator.valid = false;
          }
          waitingForValidator.removeValidatorFormQueue();
        }, "validateCells");
        j -= 1;
      }
      i -= 1;
    }
    waitingForValidator.checkIfQueueIsEmpty();
  };
  this.getRowHeader = function(row) {
    var rowHeader = priv.settings.rowHeaders;
    var physicalRow = row;
    if (physicalRow !== void 0) {
      physicalRow = instance.runHooks("modifyRowHeader", physicalRow);
    }
    if (physicalRow === void 0) {
      rowHeader = [];
      rangeEach(instance.countRows() - 1, function(i) {
        rowHeader.push(instance.getRowHeader(i));
      });
    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {
      rowHeader = rowHeader[physicalRow];
    } else if (isFunction2(rowHeader)) {
      rowHeader = rowHeader(physicalRow);
    } else if (rowHeader && typeof rowHeader !== "string" && typeof rowHeader !== "number") {
      rowHeader = physicalRow + 1;
    }
    return rowHeader;
  };
  this.hasRowHeaders = function() {
    return !!priv.settings.rowHeaders;
  };
  this.hasColHeaders = function() {
    if (priv.settings.colHeaders !== void 0 && priv.settings.colHeaders !== null) {
      return !!priv.settings.colHeaders;
    }
    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {
      if (instance.getColHeader(i)) {
        return true;
      }
    }
    return false;
  };
  this.getColHeader = function(column) {
    var columnsAsFunc = priv.settings.columns && isFunction2(priv.settings.columns);
    var columnIndex = instance.runHooks("modifyColHeader", column);
    var result = priv.settings.colHeaders;
    if (columnIndex === void 0) {
      var out = [];
      var ilen = columnsAsFunc ? instance.countSourceCols() : instance.countCols();
      for (var i = 0; i < ilen; i++) {
        out.push(instance.getColHeader(i));
      }
      result = out;
    } else {
      var translateVisualIndexToColumns = function translateVisualIndexToColumns2(visualColumnIndex) {
        var arr = [];
        var columnsLen = instance.countSourceCols();
        var index2 = 0;
        for (; index2 < columnsLen; index2++) {
          if (isFunction2(instance.getSettings().columns) && instance.getSettings().columns(index2)) {
            arr.push(index2);
          }
        }
        return arr[visualColumnIndex];
      };
      var baseCol = columnIndex;
      var physicalColumn = instance.runHooks("modifyCol", baseCol);
      var prop = translateVisualIndexToColumns(physicalColumn);
      if (priv.settings.colHeaders === false) {
        result = null;
      } else if (priv.settings.columns && isFunction2(priv.settings.columns) && priv.settings.columns(prop) && priv.settings.columns(prop).title) {
        result = priv.settings.columns(prop).title;
      } else if (priv.settings.columns && priv.settings.columns[physicalColumn] && priv.settings.columns[physicalColumn].title) {
        result = priv.settings.columns[physicalColumn].title;
      } else if (Array.isArray(priv.settings.colHeaders) && priv.settings.colHeaders[physicalColumn] !== void 0) {
        result = priv.settings.colHeaders[physicalColumn];
      } else if (isFunction2(priv.settings.colHeaders)) {
        result = priv.settings.colHeaders(physicalColumn);
      } else if (priv.settings.colHeaders && typeof priv.settings.colHeaders !== "string" && typeof priv.settings.colHeaders !== "number") {
        result = spreadsheetColumnLabel(baseCol);
      }
    }
    return result;
  };
  this._getColWidthFromSettings = function(col) {
    var cellProperties = instance.getCellMeta(0, col);
    var width = cellProperties.width;
    if (width === void 0 || width === priv.settings.width) {
      width = cellProperties.colWidths;
    }
    if (width !== void 0 && width !== null) {
      switch (_typeof23(width)) {
        case "object":
          width = width[col];
          break;
        case "function":
          width = width(col);
          break;
        default:
          break;
      }
      if (typeof width === "string") {
        width = parseInt(width, 10);
      }
    }
    return width;
  };
  this.getColWidth = function(column) {
    var width = instance._getColWidthFromSettings(column);
    width = instance.runHooks("modifyColWidth", width, column);
    if (width === void 0) {
      width = viewportColumns_default.DEFAULT_WIDTH;
    }
    return width;
  };
  this._getRowHeightFromSettings = function(row) {
    var height = priv.settings.rowHeights;
    if (height !== void 0 && height !== null) {
      switch (_typeof23(height)) {
        case "object":
          height = height[row];
          break;
        case "function":
          height = height(row);
          break;
        default:
          break;
      }
      if (typeof height === "string") {
        height = parseInt(height, 10);
      }
    }
    return height;
  };
  this.getRowHeight = function(row) {
    var height = instance._getRowHeightFromSettings(row);
    height = instance.runHooks("modifyRowHeight", height, row);
    return height;
  };
  this.countSourceRows = function() {
    var sourceLength = instance.runHooks("modifySourceLength");
    return sourceLength || (instance.getSourceData() ? instance.getSourceData().length : 0);
  };
  this.countSourceCols = function() {
    var len = 0;
    var obj = instance.getSourceData() && instance.getSourceData()[0] ? instance.getSourceData()[0] : [];
    if (isObject(obj)) {
      len = deepObjectSize(obj);
    } else {
      len = obj.length || 0;
    }
    return len;
  };
  this.countRows = function() {
    return datamap.getLength();
  };
  this.countCols = function() {
    var maxCols = this.getSettings().maxCols;
    var dataHasLength = false;
    var dataLen = 0;
    if (instance.dataType === "array") {
      dataHasLength = priv.settings.data && priv.settings.data[0] && priv.settings.data[0].length;
    }
    if (dataHasLength) {
      dataLen = priv.settings.data[0].length;
    }
    if (priv.settings.columns) {
      var columnsIsFunction = isFunction2(priv.settings.columns);
      if (columnsIsFunction) {
        if (instance.dataType === "array") {
          var columnLen = 0;
          for (var i = 0; i < dataLen; i++) {
            if (priv.settings.columns(i)) {
              columnLen += 1;
            }
          }
          dataLen = columnLen;
        } else if (instance.dataType === "object" || instance.dataType === "function") {
          dataLen = datamap.colToPropCache.length;
        }
      } else {
        dataLen = priv.settings.columns.length;
      }
    } else if (instance.dataType === "object" || instance.dataType === "function") {
      dataLen = datamap.colToPropCache.length;
    }
    return Math.min(maxCols, dataLen);
  };
  this.rowOffset = function() {
    return instance.view.wt.wtTable.getFirstRenderedRow();
  };
  this.colOffset = function() {
    return instance.view.wt.wtTable.getFirstRenderedColumn();
  };
  this.countRenderedRows = function() {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;
  };
  this.countVisibleRows = function() {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;
  };
  this.countRenderedCols = function() {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;
  };
  this.countVisibleCols = function() {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;
  };
  this.countEmptyRows = function() {
    var ending = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var emptyRows = 0;
    rangeEachReverse(instance.countRows() - 1, function(visualIndex) {
      if (instance.isEmptyRow(visualIndex)) {
        emptyRows += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyRows;
  };
  this.countEmptyCols = function() {
    var ending = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (instance.countRows() < 1) {
      return 0;
    }
    var emptyColumns = 0;
    rangeEachReverse(instance.countCols() - 1, function(visualIndex) {
      if (instance.isEmptyCol(visualIndex)) {
        emptyColumns += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyColumns;
  };
  this.isEmptyRow = function(row) {
    return priv.settings.isEmptyRow.call(instance, row);
  };
  this.isEmptyCol = function(column) {
    return priv.settings.isEmptyCol.call(instance, column);
  };
  this.selectCell = function(row, column, endRow, endColumn) {
    var scrollToCell = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var changeListener = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    if (isUndefined2(row) || isUndefined2(column)) {
      return false;
    }
    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);
  };
  this.selectCells = function() {
    var coords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [[]];
    var scrollToCell = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var changeListener = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (scrollToCell === false) {
      preventScrollingToCell = true;
    }
    var wasSelected = selection.selectCells(coords);
    if (wasSelected && changeListener) {
      instance.listen();
    }
    preventScrollingToCell = false;
    return wasSelected;
  };
  this.selectCellByProp = function(row, prop, endRow, endProp) {
    var scrollToCell = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var changeListener = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    warn2(toSingleLine(_templateObject5()));
    return this.selectCells([[row, prop, endRow, endProp]], scrollToCell, changeListener);
  };
  this.selectColumns = function(startColumn) {
    var endColumn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startColumn;
    return selection.selectColumns(startColumn, endColumn);
  };
  this.selectRows = function(startRow) {
    var endRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startRow;
    return selection.selectRows(startRow, endRow);
  };
  this.deselectCell = function() {
    selection.deselect();
  };
  this.selectAll = function() {
    preventScrollingToCell = true;
    selection.selectAll();
    preventScrollingToCell = false;
  };
  this.scrollViewportTo = function(row, column) {
    var snapToBottom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var snapToRight = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var snapToTop = !snapToBottom;
    var snapToLeft = !snapToRight;
    var result = false;
    if (row !== void 0 && column !== void 0) {
      result = instance.view.scrollViewport(new coords_default(row, column), snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
    if (typeof row === "number" && typeof column !== "number") {
      result = instance.view.scrollViewportVertically(row, snapToTop, snapToBottom);
    }
    if (typeof column === "number" && typeof row !== "number") {
      result = instance.view.scrollViewportHorizontally(column, snapToRight, snapToLeft);
    }
    return result;
  };
  this.destroy = function() {
    instance._clearTimeouts();
    instance._clearImmediates();
    if (instance.view) {
      instance.view.destroy();
    }
    if (dataSource) {
      dataSource.destroy();
    }
    dataSource = null;
    stopObserving();
    if (false) {
      var licenseInfo = document.querySelector("#hot-display-license-info");
      if (licenseInfo) {
        licenseInfo.parentNode.removeChild(licenseInfo);
      }
    }
    empty(instance.rootElement);
    eventManager2.destroy();
    if (editorManager) {
      editorManager.destroy();
    }
    instance.runHooks("afterDestroy");
    pluginHooks_default.getSingleton().destroy(instance);
    objectEach(instance, function(property, key, obj) {
      if (isFunction2(property)) {
        obj[key] = postMortem(key);
      } else if (key !== "guid") {
        obj[key] = null;
      }
    });
    instance.isDestroyed = true;
    if (datamap) {
      datamap.destroy();
    }
    datamap = null;
    priv = null;
    grid = null;
    selection = null;
    editorManager = null;
    instance = null;
    GridSettings = null;
  };
  function postMortem(method) {
    return function() {
      throw new Error('The "'.concat(method, '" method cannot be called because this Handsontable instance has been destroyed'));
    };
  }
  this.getActiveEditor = function() {
    return editorManager.getActiveEditor();
  };
  this.getPlugin = function(pluginName) {
    return getPlugin(this, pluginName);
  };
  this.getInstance = function() {
    return instance;
  };
  this.addHook = function(key, callback) {
    pluginHooks_default.getSingleton().add(key, callback, instance);
  };
  this.hasHook = function(key) {
    return pluginHooks_default.getSingleton().has(key, instance);
  };
  this.addHookOnce = function(key, callback) {
    pluginHooks_default.getSingleton().once(key, callback, instance);
  };
  this.removeHook = function(key, callback) {
    pluginHooks_default.getSingleton().remove(key, callback, instance);
  };
  this.runHooks = function(key, p1, p2, p3, p4, p5, p6) {
    return pluginHooks_default.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);
  };
  this.getTranslatedPhrase = function(dictionaryKey, extraArguments) {
    return getTranslatedPhrase(priv.settings.language, dictionaryKey, extraArguments);
  };
  this.timeouts = [];
  this._registerTimeout = function(handle) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var handleFunc = handle;
    if (typeof handleFunc === "function") {
      handleFunc = setTimeout(handleFunc, delay);
    }
    this.timeouts.push(handleFunc);
  };
  this._clearTimeouts = function() {
    arrayEach(this.timeouts, function(handler) {
      clearTimeout(handler);
    });
  };
  this.immediates = [];
  this._registerImmediate = function(callback) {
    this.immediates.push(setImmediate(callback));
  };
  this._clearImmediates = function() {
    arrayEach(this.immediates, function(handler) {
      clearImmediate(handler);
    });
  };
  this._refreshBorders = function() {
    var revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    editorManager.destroyEditor(revertOriginal);
    instance.view.render();
    if (prepareEditorIfNeeded && selection.isSelected()) {
      editorManager.prepareEditor();
    }
  };
  pluginHooks_default.getSingleton().run(instance, "construct");
}

// node_modules/handsontable/es/helpers/wrappers/jquery.js
function jQueryWrapper(Handsontable2) {
  var jQuery = typeof window === "undefined" ? false : window.jQuery;
  if (!jQuery) {
    return;
  }
  jQuery.fn.handsontable = function(action) {
    var $this = this.first();
    var instance = $this.data("handsontable");
    if (typeof action !== "string") {
      var userSettings = action || {};
      if (instance) {
        instance.updateSettings(userSettings);
      } else {
        instance = new Handsontable2.Core($this[0], userSettings);
        $this.data("handsontable", instance);
        instance.init();
      }
      return $this;
    }
    var output;
    if (instance) {
      if (typeof instance[action] !== "undefined") {
        var _instance$action;
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        output = (_instance$action = instance[action]).call.apply(_instance$action, [instance].concat(args));
        if (action === "destroy") {
          $this.removeData();
        }
      } else {
        throw new Error("Handsontable do not provide action: ".concat(action));
      }
    }
    return output;
  };
}

// node_modules/handsontable/es/utils/ghostTable.js
function _classCallCheck38(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties36(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass36(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties36(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties36(Constructor, staticProps);
  return Constructor;
}
var GhostTable = function() {
  function GhostTable2(hotInstance) {
    _classCallCheck38(this, GhostTable2);
    this.hot = hotInstance;
    this.container = null;
    this.injected = false;
    this.rows = [];
    this.columns = [];
    this.samples = null;
    this.settings = {
      useHeaders: true
    };
  }
  _createClass36(GhostTable2, [{
    key: "addRow",
    value: function addRow(row, samples) {
      if (this.columns.length) {
        throw new Error("Doesn't support multi-dimensional table");
      }
      if (!this.rows.length) {
        this.container = this.createContainer(this.hot.rootElement.className);
      }
      var rowObject = {
        row
      };
      this.rows.push(rowObject);
      this.samples = samples;
      this.table = this.createTable(this.hot.table.className);
      this.table.colGroup.appendChild(this.createColGroupsCol());
      this.table.tr.appendChild(this.createRow(row));
      this.container.container.appendChild(this.table.fragment);
      rowObject.table = this.table.table;
    }
    /**
     * Add a row consisting of the column headers.
     */
  }, {
    key: "addColumnHeadersRow",
    value: function addColumnHeadersRow(samples) {
      var colHeader = this.hot.getColHeader(0);
      if (colHeader !== null && colHeader !== void 0) {
        var rowObject = {
          row: -1
        };
        this.rows.push(rowObject);
        this.container = this.createContainer(this.hot.rootElement.className);
        this.samples = samples;
        this.table = this.createTable(this.hot.table.className);
        this.table.colGroup.appendChild(this.createColGroupsCol());
        this.table.tHead.appendChild(this.createColumnHeadersRow());
        this.container.container.appendChild(this.table.fragment);
        rowObject.table = this.table.table;
      }
    }
    /**
     * Add column.
     *
     * @param {Number} column Column index.
     * @param {Map} samples Samples Map object.
     */
  }, {
    key: "addColumn",
    value: function addColumn(column, samples) {
      if (this.rows.length) {
        throw new Error("Doesn't support multi-dimensional table");
      }
      if (!this.columns.length) {
        this.container = this.createContainer(this.hot.rootElement.className);
      }
      var columnObject = {
        col: column
      };
      this.columns.push(columnObject);
      this.samples = samples;
      this.table = this.createTable(this.hot.table.className);
      if (this.getSetting("useHeaders") && this.hot.getColHeader(column) !== null) {
        this.hot.view.appendColHeader(column, this.table.th);
      }
      this.table.tBody.appendChild(this.createCol(column));
      this.container.container.appendChild(this.table.fragment);
      columnObject.table = this.table.table;
    }
    /**
     * Get calculated heights.
     *
     * @param {Function} callback Callback which will be fired for each calculated row.
     */
  }, {
    key: "getHeights",
    value: function getHeights(callback) {
      if (!this.injected) {
        this.injectTable();
      }
      arrayEach(this.rows, function(row) {
        callback(row.row, outerHeight(row.table) - 1);
      });
    }
    /**
     * Get calculated widths.
     *
     * @param {Function} callback Callback which will be fired for each calculated column.
     */
  }, {
    key: "getWidths",
    value: function getWidths(callback) {
      if (!this.injected) {
        this.injectTable();
      }
      arrayEach(this.columns, function(column) {
        callback(column.col, outerWidth(column.table));
      });
    }
    /**
     * Set the Ghost Table settings to the provided object.
     *
     * @param {Object} settings New Ghost Table Settings
     */
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      this.settings = settings;
    }
    /**
     * Set a single setting of the Ghost Table.
     *
     * @param {String} name Setting name.
     * @param {*} value Setting value.
     */
  }, {
    key: "setSetting",
    value: function setSetting(name, value) {
      if (!this.settings) {
        this.settings = {};
      }
      this.settings[name] = value;
    }
    /**
     * Get the Ghost Table settings.
     *
     * @returns {Object|null}
     */
  }, {
    key: "getSettings",
    value: function getSettings() {
      return this.settings;
    }
    /**
     * Get a single Ghost Table setting.
     *
     * @param {String} name
     * @returns {Boolean|null}
     */
  }, {
    key: "getSetting",
    value: function getSetting(name) {
      if (this.settings) {
        return this.settings[name];
      }
      return null;
    }
    /**
     * Create colgroup col elements.
     *
     * @returns {DocumentFragment}
     */
  }, {
    key: "createColGroupsCol",
    value: function createColGroupsCol() {
      var _this = this;
      var d = document;
      var fragment = d.createDocumentFragment();
      if (this.hot.hasRowHeaders()) {
        fragment.appendChild(this.createColElement(-1));
      }
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          fragment.appendChild(_this.createColElement(string.col));
        });
      });
      return fragment;
    }
    /**
     * Create table row element.
     *
     * @param {Number} row Row index.
     * @returns {DocumentFragment} Returns created table row elements.
     */
  }, {
    key: "createRow",
    value: function createRow(row) {
      var _this2 = this;
      var d = document;
      var fragment = d.createDocumentFragment();
      var th = d.createElement("th");
      if (this.hot.hasRowHeaders()) {
        this.hot.view.appendRowHeader(row, th);
        fragment.appendChild(th);
      }
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          var column = string.col;
          var cellProperties = _this2.hot.getCellMeta(row, column);
          cellProperties.col = column;
          cellProperties.row = row;
          var renderer = _this2.hot.getCellRenderer(cellProperties);
          var td = d.createElement("td");
          renderer(_this2.hot, td, row, column, _this2.hot.colToProp(column), string.value, cellProperties);
          fragment.appendChild(td);
        });
      });
      return fragment;
    }
  }, {
    key: "createColumnHeadersRow",
    value: function createColumnHeadersRow() {
      var _this3 = this;
      var d = document;
      var fragment = d.createDocumentFragment();
      if (this.hot.hasRowHeaders()) {
        var th = d.createElement("th");
        this.hot.view.appendColHeader(-1, th);
        fragment.appendChild(th);
      }
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          var column = string.col;
          var th2 = d.createElement("th");
          _this3.hot.view.appendColHeader(column, th2);
          fragment.appendChild(th2);
        });
      });
      return fragment;
    }
    /**
     * Create table column elements.
     *
     * @param {Number} column Column index.
     * @returns {DocumentFragment} Returns created column table column elements.
     */
  }, {
    key: "createCol",
    value: function createCol(column) {
      var _this4 = this;
      var d = document;
      var fragment = d.createDocumentFragment();
      this.samples.forEach(function(sample) {
        arrayEach(sample.strings, function(string) {
          var row = string.row;
          var cellProperties = _this4.hot.getCellMeta(row, column);
          cellProperties.col = column;
          cellProperties.row = row;
          var renderer = _this4.hot.getCellRenderer(cellProperties);
          var td = d.createElement("td");
          var tr = d.createElement("tr");
          td.setAttribute("ghost-table", 1);
          renderer(_this4.hot, td, row, column, _this4.hot.colToProp(column), string.value, cellProperties);
          tr.appendChild(td);
          fragment.appendChild(tr);
        });
      });
      return fragment;
    }
    /**
     * Remove table from document and reset internal state.
     */
  }, {
    key: "clean",
    value: function clean() {
      this.rows.length = 0;
      this.rows[-1] = void 0;
      this.columns.length = 0;
      if (this.samples) {
        this.samples.clear();
      }
      this.samples = null;
      this.removeTable();
    }
    /**
     * Inject generated table into document.
     *
     * @param {HTMLElement} [parent=null]
     */
  }, {
    key: "injectTable",
    value: function injectTable() {
      var parent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (!this.injected) {
        (parent || this.hot.rootElement).appendChild(this.container.fragment);
        this.injected = true;
      }
    }
    /**
     * Remove table from document.
     */
  }, {
    key: "removeTable",
    value: function removeTable() {
      if (this.injected && this.container.container.parentNode) {
        this.container.container.parentNode.removeChild(this.container.container);
        this.container = null;
        this.injected = false;
      }
    }
    /**
     * Create col element.
     *
     * @param {Number} column Column index.
     * @returns {HTMLElement}
     */
  }, {
    key: "createColElement",
    value: function createColElement(column) {
      var d = document;
      var col = d.createElement("col");
      col.style.width = "".concat(this.hot.view.wt.wtTable.getStretchedColumnWidth(column), "px");
      return col;
    }
    /**
     * Create table element.
     *
     * @param {String} className
     * @returns {Object}
     */
  }, {
    key: "createTable",
    value: function createTable() {
      var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var d = document;
      var fragment = d.createDocumentFragment();
      var table = d.createElement("table");
      var tHead = d.createElement("thead");
      var tBody = d.createElement("tbody");
      var colGroup = d.createElement("colgroup");
      var tr = d.createElement("tr");
      var th = d.createElement("th");
      if (this.isVertical()) {
        table.appendChild(colGroup);
      }
      if (this.isHorizontal()) {
        tr.appendChild(th);
        tHead.appendChild(tr);
        table.style.tableLayout = "auto";
        table.style.width = "auto";
      }
      table.appendChild(tHead);
      if (this.isVertical()) {
        tBody.appendChild(tr);
      }
      table.appendChild(tBody);
      addClass(table, className);
      fragment.appendChild(table);
      return {
        fragment,
        table,
        tHead,
        tBody,
        colGroup,
        tr,
        th
      };
    }
    /**
     * Create container for tables.
     *
     * @param {String} className
     * @returns {Object}
     */
  }, {
    key: "createContainer",
    value: function createContainer() {
      var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var d = document;
      var fragment = d.createDocumentFragment();
      var container = d.createElement("div");
      var containerClassName = "htGhostTable htAutoSize ".concat(className.trim());
      addClass(container, containerClassName);
      fragment.appendChild(container);
      return {
        fragment,
        container
      };
    }
    /**
     * Checks if table is raised vertically (checking rows).
     *
     * @returns {Boolean}
     */
  }, {
    key: "isVertical",
    value: function isVertical() {
      return !!(this.rows.length && !this.columns.length);
    }
    /**
     * Checks if table is raised horizontally (checking columns).
     *
     * @returns {Boolean}
     */
  }, {
    key: "isHorizontal",
    value: function isHorizontal() {
      return !!(this.columns.length && !this.rows.length);
    }
  }]);
  return GhostTable2;
}();
var ghostTable_default = GhostTable;

// node_modules/handsontable/es/plugins/index.js
var plugins_exports = {};
__export(plugins_exports, {
  AutoColumnSize: () => autoColumnSize_default,
  AutoFill: () => autofill_default,
  AutoRowSize: () => autoRowSize_default,
  Base: () => base_default2,
  ColumnSorting: () => columnSorting_default,
  Comments: () => comments_default,
  ContextMenu: () => contextMenu_default,
  CopyPaste: () => copyPaste_default,
  CustomBorders: () => customBorders_default,
  DragToScroll: () => dragToScroll_default,
  ManualColumnFreeze: () => manualColumnFreeze_default,
  ManualColumnMove: () => manualColumnMove_default,
  ManualColumnResize: () => manualColumnResize_default,
  ManualRowMove: () => manualRowMove_default,
  ManualRowResize: () => manualRowResize_default,
  MergeCells: () => mergeCells_default,
  MultipleSelectionHandles: () => multipleSelectionHandles_default,
  ObserveChanges: () => observeChanges_default,
  PersistentState: () => persistentState_default,
  Search: () => search_default,
  TouchScroll: () => touchScroll_default,
  UndoRedo: () => undoRedo_default
});

// node_modules/handsontable/es/plugins/_base.js
function _classCallCheck39(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties37(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass37(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties37(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties37(Constructor, staticProps);
  return Constructor;
}
var privatePool4 = /* @__PURE__ */ new WeakMap();
var initializedPlugins = null;
var BasePlugin = function() {
  function BasePlugin2(hotInstance) {
    var _this = this;
    _classCallCheck39(this, BasePlugin2);
    defineGetter(this, "hot", hotInstance, {
      writable: false
    });
    defineGetter(this, "t", getTranslator(hotInstance), {
      writable: false
    });
    privatePool4.set(this, {
      hooks: {}
    });
    initializedPlugins = null;
    this.pluginName = null;
    this.pluginsInitializedCallbacks = [];
    this.isPluginsReady = false;
    this.enabled = false;
    this.initialized = false;
    this.hot.addHook("afterPluginsInitialized", function() {
      return _this.onAfterPluginsInitialized();
    });
    this.hot.addHook("afterUpdateSettings", function(newSettings) {
      return _this.onUpdateSettings(newSettings);
    });
    this.hot.addHook("beforeInit", function() {
      return _this.init();
    });
  }
  _createClass37(BasePlugin2, [{
    key: "init",
    value: function init2() {
      this.pluginName = getPluginName(this.hot, this);
      if (this.isEnabled && this.isEnabled()) {
        this.enablePlugin();
      }
      if (!initializedPlugins) {
        initializedPlugins = getRegistredPluginNames(this.hot);
      }
      if (initializedPlugins.indexOf(this.pluginName) >= 0) {
        initializedPlugins.splice(initializedPlugins.indexOf(this.pluginName), 1);
      }
      if (!initializedPlugins.length) {
        this.hot.runHooks("afterPluginsInitialized");
      }
      this.initialized = true;
    }
    /**
     * Enable plugin for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      this.enabled = true;
    }
    /**
     * Disable plugin for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      if (this.eventManager) {
        this.eventManager.clear();
      }
      this.clearHooks();
      this.enabled = false;
    }
    /**
     * Add listener to plugin hooks system.
     *
     * @param {String} name
     * @param {Function} callback
     */
  }, {
    key: "addHook",
    value: function addHook(name, callback) {
      privatePool4.get(this).hooks[name] = privatePool4.get(this).hooks[name] || [];
      var hooks3 = privatePool4.get(this).hooks[name];
      this.hot.addHook(name, callback);
      hooks3.push(callback);
      privatePool4.get(this).hooks[name] = hooks3;
    }
    /**
     * Remove all hooks listeners by hook name.
     *
     * @param {String} name
     */
  }, {
    key: "removeHooks",
    value: function removeHooks(name) {
      var _this2 = this;
      arrayEach(privatePool4.get(this).hooks[name] || [], function(callback) {
        _this2.hot.removeHook(name, callback);
      });
    }
    /**
     * Clear all hooks.
     */
  }, {
    key: "clearHooks",
    value: function clearHooks() {
      var _this3 = this;
      var hooks3 = privatePool4.get(this).hooks;
      objectEach(hooks3, function(callbacks, name) {
        return _this3.removeHooks(name);
      });
      hooks3.length = 0;
    }
    /**
     * Register function which will be immediately called after all plugins initialized.
     *
     * @param {Function} callback
     */
  }, {
    key: "callOnPluginsReady",
    value: function callOnPluginsReady(callback) {
      if (this.isPluginsReady) {
        callback();
      } else {
        this.pluginsInitializedCallbacks.push(callback);
      }
    }
    /**
     * On after plugins initialized listener.
     *
     * @private
     */
  }, {
    key: "onAfterPluginsInitialized",
    value: function onAfterPluginsInitialized() {
      arrayEach(this.pluginsInitializedCallbacks, function(callback) {
        return callback();
      });
      this.pluginsInitializedCallbacks.length = 0;
      this.isPluginsReady = true;
    }
    /**
     * On update settings listener.
     *
     * @private
     */
  }, {
    key: "onUpdateSettings",
    value: function onUpdateSettings() {
      if (this.isEnabled) {
        if (this.enabled && !this.isEnabled()) {
          this.disablePlugin();
        }
        if (!this.enabled && this.isEnabled()) {
          this.enablePlugin();
        }
        if (this.enabled && this.isEnabled()) {
          this.updatePlugin();
        }
      }
    }
    /**
     * Updates the plugin to use the latest options you have specified.
     *
     * @private
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
    }
    /**
     * Destroy plugin.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this4 = this;
      if (this.eventManager) {
        this.eventManager.destroy();
      }
      this.clearHooks();
      objectEach(this, function(value, property) {
        if (property !== "hot" && property !== "t") {
          _this4[property] = null;
        }
      });
      delete this.t;
      delete this.hot;
    }
  }]);
  return BasePlugin2;
}();
var base_default2 = BasePlugin;

// node_modules/handsontable/es/plugins/persistentState/storage.js
function _classCallCheck40(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties38(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass38(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties38(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties38(Constructor, staticProps);
  return Constructor;
}
var Storage = function() {
  function Storage2(prefix) {
    _classCallCheck40(this, Storage2);
    this.prefix = prefix;
    this.savedKeys = [];
    this.loadSavedKeys();
  }
  _createClass38(Storage2, [{
    key: "saveValue",
    value: function saveValue(key, value) {
      window.localStorage.setItem("".concat(this.prefix, "_").concat(key), JSON.stringify(value));
      if (this.savedKeys.indexOf(key) === -1) {
        this.savedKeys.push(key);
        this.saveSavedKeys();
      }
    }
    /**
     * Load data from localStorage.
     *
     * @param {String} key Key string.
     * @param {Object} defaultValue Object containing the loaded data.
     *
     * @returns {}
     */
  }, {
    key: "loadValue",
    value: function loadValue(key, defaultValue) {
      var itemKey = typeof key === "undefined" ? defaultValue : key;
      var value = window.localStorage.getItem("".concat(this.prefix, "_").concat(itemKey));
      return value === null ? void 0 : JSON.parse(value);
    }
    /**
     * Reset given data from localStorage.
     *
     * @param {String} key Key string.
     */
  }, {
    key: "reset",
    value: function reset(key) {
      window.localStorage.removeItem("".concat(this.prefix, "_").concat(key));
    }
    /**
     * Reset all data from localStorage.
     *
     */
  }, {
    key: "resetAll",
    value: function resetAll() {
      var _this = this;
      arrayEach(this.savedKeys, function(value, index2) {
        window.localStorage.removeItem("".concat(_this.prefix, "_").concat(_this.savedKeys[index2]));
      });
      this.clearSavedKeys();
    }
    /**
     * Load and save all keys from localStorage.
     *
     * @private
     */
  }, {
    key: "loadSavedKeys",
    value: function loadSavedKeys() {
      var keysJSON = window.localStorage.getItem("".concat(this.prefix, "__persistentStateKeys"));
      var keys3 = typeof keysJSON === "string" ? JSON.parse(keysJSON) : void 0;
      this.savedKeys = keys3 || [];
    }
    /**
     * Save saved key in localStorage.
     *
     * @private
     */
  }, {
    key: "saveSavedKeys",
    value: function saveSavedKeys() {
      window.localStorage.setItem("".concat(this.prefix, "__persistentStateKeys"), JSON.stringify(this.savedKeys));
    }
    /**
     * Clear saved key from localStorage.
     *
     * @private
     */
  }, {
    key: "clearSavedKeys",
    value: function clearSavedKeys() {
      this.savedKeys.length = 0;
      this.saveSavedKeys();
    }
  }]);
  return Storage2;
}();
var storage_default = Storage;

// node_modules/handsontable/es/plugins/persistentState/persistentState.js
function _typeof24(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof24 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof24 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof24(obj);
}
function _classCallCheck41(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties39(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass39(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties39(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties39(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn12(self2, call) {
  if (call && (_typeof24(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized12(self2);
}
function _assertThisInitialized12(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get4(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get4 = Reflect.get;
  } else {
    _get4 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase4(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get4(target, property, receiver || target);
}
function _superPropBase4(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf12(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf12(o) {
  _getPrototypeOf12 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf12(o);
}
function _inherits12(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf12(subClass, superClass);
}
function _setPrototypeOf12(o, p) {
  _setPrototypeOf12 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf12(o, p);
}
pluginHooks_default.getSingleton().register("persistentStateSave");
pluginHooks_default.getSingleton().register("persistentStateLoad");
pluginHooks_default.getSingleton().register("persistentStateReset");
var PersistentState = function(_BasePlugin) {
  _inherits12(PersistentState2, _BasePlugin);
  function PersistentState2(hotInstance) {
    var _this;
    _classCallCheck41(this, PersistentState2);
    _this = _possibleConstructorReturn12(this, _getPrototypeOf12(PersistentState2).call(this, hotInstance));
    _this.storage = void 0;
    return _this;
  }
  _createClass39(PersistentState2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings().persistentState;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      if (!this.storage) {
        this.storage = new storage_default(this.hot.rootElement.id);
      }
      this.addHook("persistentStateSave", function(key, value) {
        return _this2.saveValue(key, value);
      });
      this.addHook("persistentStateLoad", function(key, saveTo) {
        return _this2.loadValue(key, saveTo);
      });
      this.addHook("persistentStateReset", function() {
        return _this2.resetValue();
      });
      _get4(_getPrototypeOf12(PersistentState2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.storage = void 0;
      _get4(_getPrototypeOf12(PersistentState2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get4(_getPrototypeOf12(PersistentState2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Loads the value from local storage.
     *
     * @param {String} key Storage key.
     * @param {Object} saveTo Saved value from local storage.
     */
  }, {
    key: "loadValue",
    value: function loadValue(key, saveTo) {
      saveTo.value = this.storage.loadValue(key);
    }
    /**
     * Saves the data to local storage.
     *
     * @param {String} key Storage key.
     * @param {Mixed} value Value to save.
     */
  }, {
    key: "saveValue",
    value: function saveValue(key, value) {
      this.storage.saveValue(key, value);
    }
    /**
     * Resets the data or all data from local storage.
     *
     * @param {String} key [optional] Storage key.
     */
  }, {
    key: "resetValue",
    value: function resetValue(key) {
      if (typeof key === "undefined") {
        this.storage.resetAll();
      } else {
        this.storage.reset(key);
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get4(_getPrototypeOf12(PersistentState2.prototype), "destroy", this).call(this);
    }
  }]);
  return PersistentState2;
}(base_default2);
registerPlugin("persistentState", PersistentState);
var persistentState_default = PersistentState;

// node_modules/handsontable/es/utils/samplesGenerator.js
function _defineProperty4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck42(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties40(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass40(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties40(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties40(Constructor, staticProps);
  return Constructor;
}
var SamplesGenerator = function() {
  _createClass40(SamplesGenerator2, null, [{
    key: "SAMPLE_COUNT",
    /**
     * Number of samples to take of each value length.
     *
     * @type {Number}
     */
    get: function get5() {
      return 3;
    }
  }]);
  function SamplesGenerator2(dataFactory) {
    _classCallCheck42(this, SamplesGenerator2);
    this.samples = null;
    this.dataFactory = dataFactory;
    this.customSampleCount = null;
    this.allowDuplicates = false;
  }
  _createClass40(SamplesGenerator2, [{
    key: "getSampleCount",
    value: function getSampleCount() {
      if (this.customSampleCount) {
        return this.customSampleCount;
      }
      return SamplesGenerator2.SAMPLE_COUNT;
    }
    /**
     * Set the sample count.
     *
     * @param {Number} sampleCount Number of samples to be collected.
     */
  }, {
    key: "setSampleCount",
    value: function setSampleCount(sampleCount) {
      this.customSampleCount = sampleCount;
    }
    /**
     * Set if the generator should accept duplicate values.
     *
     * @param {Boolean} allowDuplicates `true` to allow duplicate values.
     */
  }, {
    key: "setAllowDuplicates",
    value: function setAllowDuplicates(allowDuplicates) {
      this.allowDuplicates = allowDuplicates;
    }
    /**
     * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.
     *
     * @param {Object|Number} rowRange
     * @param {Object} colRange
     * @returns {Object}
     */
  }, {
    key: "generateRowSamples",
    value: function generateRowSamples(rowRange, colRange) {
      return this.generateSamples("row", colRange, rowRange);
    }
    /**
     * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.
     *
     * @param {Object} colRange Column index.
     * @param {Object} rowRange Column index.
     * @returns {Object}
     */
  }, {
    key: "generateColumnSamples",
    value: function generateColumnSamples(colRange, rowRange) {
      return this.generateSamples("col", rowRange, colRange);
    }
    /**
     * Generate collection of samples.
     *
     * @param {String} type Type to generate. Can be `col` or `row`.
     * @param {Object} range
     * @param {Object|Number} specifierRange
     * @returns {Map}
     */
  }, {
    key: "generateSamples",
    value: function generateSamples(type, range, specifierRange) {
      var _this = this;
      var samples = /* @__PURE__ */ new Map();
      var _ref = typeof specifierRange === "number" ? {
        from: specifierRange,
        to: specifierRange
      } : specifierRange, from3 = _ref.from, to3 = _ref.to;
      rangeEach(from3, to3, function(index2) {
        var sample = _this.generateSample(type, range, index2);
        samples.set(index2, sample);
      });
      return samples;
    }
    /**
     * Generate sample for specified type (`row` or `col`).
     *
     * @param {String} type Samples type `row` or `col`.
     * @param {Object} range
     * @param {Number} specifierValue
     * @returns {Map}
     */
  }, {
    key: "generateSample",
    value: function generateSample(type, range, specifierValue) {
      var _this2 = this;
      if (type !== "row" && type !== "col") {
        throw new Error("Unsupported sample type");
      }
      var samples = /* @__PURE__ */ new Map();
      var computedKey = type === "row" ? "col" : "row";
      var sampledValues = [];
      rangeEach(range.from, range.to, function(index2) {
        var _ref2 = type === "row" ? _this2.dataFactory(specifierValue, index2) : _this2.dataFactory(index2, specifierValue), value = _ref2.value, bundleCountSeed = _ref2.bundleCountSeed;
        var hasCustomBundleSeed = bundleCountSeed > 0;
        var length;
        if (isObject(value)) {
          length = Object.keys(value).length;
        } else if (Array.isArray(value)) {
          length = value.length;
        } else {
          length = stringify(value).length;
        }
        if (hasCustomBundleSeed) {
          length += bundleCountSeed;
        }
        if (!samples.has(length)) {
          samples.set(length, {
            needed: _this2.getSampleCount(),
            strings: []
          });
        }
        var sample = samples.get(length);
        if (sample.needed) {
          var duplicate = sampledValues.indexOf(value) > -1;
          if (!duplicate || _this2.allowDuplicates || hasCustomBundleSeed) {
            sample.strings.push(_defineProperty4({
              value
            }, computedKey, index2));
            sampledValues.push(value);
            sample.needed -= 1;
          }
        }
      });
      return samples;
    }
  }]);
  return SamplesGenerator2;
}();
var samplesGenerator_default = SamplesGenerator;

// node_modules/handsontable/es/plugins/autoColumnSize/autoColumnSize.js
function _typeof25(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof25 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof25 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof25(obj);
}
function _slicedToArray8(arr, i) {
  return _arrayWithHoles8(arr) || _iterableToArrayLimit8(arr, i) || _nonIterableRest8();
}
function _nonIterableRest8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit8(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles8(arr) {
  if (Array.isArray(arr)) return arr;
}
function _classCallCheck43(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn13(self2, call) {
  if (call && (_typeof25(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized13(self2);
}
function _get5(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get5 = Reflect.get;
  } else {
    _get5 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase5(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get5(target, property, receiver || target);
}
function _superPropBase5(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf13(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf13(o) {
  _getPrototypeOf13 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf13(o);
}
function _defineProperties41(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass41(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties41(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties41(Constructor, staticProps);
  return Constructor;
}
function _inherits13(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf13(subClass, superClass);
}
function _setPrototypeOf13(o, p) {
  _setPrototypeOf13 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf13(o, p);
}
function _assertThisInitialized13(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var privatePool5 = /* @__PURE__ */ new WeakMap();
var AutoColumnSize = function(_BasePlugin) {
  _inherits13(AutoColumnSize2, _BasePlugin);
  _createClass41(AutoColumnSize2, null, [{
    key: "CALCULATION_STEP",
    get: function get5() {
      return 50;
    }
  }, {
    key: "SYNC_CALCULATION_LIMIT",
    get: function get5() {
      return 50;
    }
  }]);
  function AutoColumnSize2(hotInstance) {
    var _this;
    _classCallCheck43(this, AutoColumnSize2);
    _this = _possibleConstructorReturn13(this, _getPrototypeOf13(AutoColumnSize2).call(this, hotInstance));
    privatePool5.set(_assertThisInitialized13(_assertThisInitialized13(_this)), {
      /**
       * Cached column header names. It is used to diff current column headers with previous state and detect which
       * columns width should be updated.
       *
       * @private
       * @type {Array}
       */
      cachedColumnHeaders: []
    });
    _this.widths = [];
    _this.ghostTable = new ghostTable_default(_this.hot);
    _this.samplesGenerator = new samplesGenerator_default(function(row, column) {
      var cellMeta = _this.hot.getCellMeta(row, column);
      var cellValue = "";
      if (!cellMeta.spanned) {
        cellValue = _this.hot.getDataAtCell(row, column);
      }
      var bundleCountSeed = 0;
      if (cellMeta.label) {
        var _cellMeta$label = cellMeta.label, labelValue = _cellMeta$label.value, labelProperty = _cellMeta$label.property;
        var labelText = "";
        if (labelValue) {
          labelText = typeof labelValue === "function" ? labelValue(row, column, _this.hot.colToProp(column), cellValue) : labelValue;
        } else if (labelProperty) {
          labelText = _this.hot.getDataAtRowProp(row, labelProperty);
        }
        bundleCountSeed = labelText.length;
      }
      return {
        value: cellValue,
        bundleCountSeed
      };
    });
    _this.firstCalculation = true;
    _this.inProgress = false;
    _this.addHook("beforeColumnResize", function(col, size, isDblClick) {
      return _this.onBeforeColumnResize(col, size, isDblClick);
    });
    return _this;
  }
  _createClass41(AutoColumnSize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().autoColumnSize !== false && !this.hot.getSettings().colWidths;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var setting = this.hot.getSettings().autoColumnSize;
      if (setting && setting.useHeaders !== null && setting.useHeaders !== void 0) {
        this.ghostTable.setSetting("useHeaders", setting.useHeaders);
      }
      this.setSamplingOptions();
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData();
      });
      this.addHook("beforeChange", function(changes) {
        return _this2.onBeforeChange(changes);
      });
      this.addHook("beforeRender", function(force) {
        return _this2.onBeforeRender(force);
      });
      this.addHook("modifyColWidth", function(width, col) {
        return _this2.getColumnWidth(col, width);
      });
      this.addHook("afterInit", function() {
        return _this2.onAfterInit();
      });
      _get5(_getPrototypeOf13(AutoColumnSize2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var changedColumns = this.findColumnsWhereHeaderWasChanged();
      if (changedColumns.length) {
        this.clearCache(changedColumns);
      }
      _get5(_getPrototypeOf13(AutoColumnSize2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get5(_getPrototypeOf13(AutoColumnSize2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Calculates a columns width.
     *
     * @param {Number|Object} colRange Column index or an object with `from` and `to` indexes as a range.
     * @param {Number|Object} rowRange Row index or an object with `from` and `to` indexes as a range.
     * @param {Boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.
     */
  }, {
    key: "calculateColumnsWidth",
    value: function calculateColumnsWidth() {
      var _this3 = this;
      var colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countCols() - 1
      };
      var rowRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        from: 0,
        to: this.hot.countRows() - 1
      };
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var columnsRange = typeof colRange === "number" ? {
        from: colRange,
        to: colRange
      } : colRange;
      var rowsRange = typeof rowRange === "number" ? {
        from: rowRange,
        to: rowRange
      } : rowRange;
      rangeEach(columnsRange.from, columnsRange.to, function(col) {
        if (force || _this3.widths[col] === void 0 && !_this3.hot._getColWidthFromSettings(col)) {
          var samples = _this3.samplesGenerator.generateColumnSamples(col, rowsRange);
          arrayEach(samples, function(_ref) {
            var _ref2 = _slicedToArray8(_ref, 2), column = _ref2[0], sample = _ref2[1];
            return _this3.ghostTable.addColumn(column, sample);
          });
        }
      });
      if (this.ghostTable.columns.length) {
        this.ghostTable.getWidths(function(col, width) {
          _this3.widths[col] = width;
        });
        this.ghostTable.clean();
      }
    }
    /**
     * Calculates all columns width. The calculated column will be cached in the {@link AutoColumnSize#widths} property.
     * To retrieve width for specyfied column use {@link AutoColumnSize#getColumnWidth} method.
     *
     * @param {Object|Number} rowRange Row index or an object with `from` and `to` properties which define row range.
     */
  }, {
    key: "calculateAllColumnsWidth",
    value: function calculateAllColumnsWidth() {
      var _this4 = this;
      var rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countRows() - 1
      };
      var current = 0;
      var length = this.hot.countCols() - 1;
      var timer = null;
      this.inProgress = true;
      var loop = function loop2() {
        if (!_this4.hot) {
          cancelAnimationFrame(timer);
          _this4.inProgress = false;
          return;
        }
        _this4.calculateColumnsWidth({
          from: current,
          to: Math.min(current + AutoColumnSize2.CALCULATION_STEP, length)
        }, rowRange);
        current = current + AutoColumnSize2.CALCULATION_STEP + 1;
        if (current < length) {
          timer = requestAnimationFrame(loop2);
        } else {
          cancelAnimationFrame(timer);
          _this4.inProgress = false;
          _this4.hot.view.wt.wtOverlays.adjustElementsSize(true);
          if (_this4.hot.view.wt.wtOverlays.leftOverlay.needFullRender) {
            _this4.hot.view.wt.wtOverlays.leftOverlay.clone.draw();
          }
        }
      };
      var syncLimit = this.getSyncCalculationLimit();
      if (this.firstCalculation && syncLimit >= 0) {
        this.calculateColumnsWidth({
          from: 0,
          to: syncLimit
        }, rowRange);
        this.firstCalculation = false;
        current = syncLimit + 1;
      }
      if (current < length) {
        loop();
      } else {
        this.inProgress = false;
      }
    }
    /**
     * Sets the sampling options.
     *
     * @private
     */
  }, {
    key: "setSamplingOptions",
    value: function setSamplingOptions() {
      var setting = this.hot.getSettings().autoColumnSize;
      var samplingRatio = setting && hasOwnProperty(setting, "samplingRatio") ? this.hot.getSettings().autoColumnSize.samplingRatio : void 0;
      var allowSampleDuplicates = setting && hasOwnProperty(setting, "allowSampleDuplicates") ? this.hot.getSettings().autoColumnSize.allowSampleDuplicates : void 0;
      if (samplingRatio && !isNaN(samplingRatio)) {
        this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
      }
      if (allowSampleDuplicates) {
        this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
      }
    }
    /**
     * Recalculates all columns width (overwrite cache values).
     */
  }, {
    key: "recalculateAllColumnsWidth",
    value: function recalculateAllColumnsWidth() {
      if (this.hot.view && isVisible(this.hot.view.wt.wtTable.TABLE)) {
        this.clearCache();
        this.calculateAllColumnsWidth();
      }
    }
    /**
     * Gets value which tells how many columns should be calculated synchronously (rest of the columns will be calculated
     * asynchronously). The limit is calculated based on `syncLimit` set to `autoColumnSize` option (see {@link Options#autoColumnSize}).
     *
     * @returns {Number}
     */
  }, {
    key: "getSyncCalculationLimit",
    value: function getSyncCalculationLimit() {
      var limit = AutoColumnSize2.SYNC_CALCULATION_LIMIT;
      var colsLimit = this.hot.countCols() - 1;
      if (isObject(this.hot.getSettings().autoColumnSize)) {
        limit = this.hot.getSettings().autoColumnSize.syncLimit;
        if (isPercentValue(limit)) {
          limit = valueAccordingPercent(colsLimit, limit);
        } else {
          limit >>= 0;
        }
      }
      return Math.min(limit, colsLimit);
    }
    /**
     * Gets the calculated column width.
     *
     * @param {Number} column Column index.
     * @param {Number} [defaultWidth] Default column width. It will be picked up if no calculated width found.
     * @param {Boolean} [keepMinimum=true] If `true` then returned value won't be smaller then 50 (default column width).
     * @returns {Number}
     */
  }, {
    key: "getColumnWidth",
    value: function getColumnWidth(column) {
      var defaultWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      var keepMinimum = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var width = defaultWidth;
      if (width === void 0) {
        width = this.widths[column];
        if (keepMinimum && typeof width === "number") {
          width = Math.max(width, viewportColumns_default.DEFAULT_WIDTH);
        }
      }
      return width;
    }
    /**
     * Gets the first visible column.
     *
     * @returns {Number|null} Returns column index, -1 if table is not rendered or null if there are no columns to base the the calculations on.
     */
  }, {
    key: "getFirstVisibleColumn",
    value: function getFirstVisibleColumn() {
      var wot = this.hot.view.wt;
      if (wot.wtViewport.columnsVisibleCalculator) {
        return wot.wtTable.getFirstVisibleColumn();
      }
      if (wot.wtViewport.columnsRenderCalculator) {
        return wot.wtTable.getFirstRenderedColumn();
      }
      return -1;
    }
    /**
     * Gets the last visible column.
     *
     * @returns {Number} Returns column index or -1 if table is not rendered.
     */
  }, {
    key: "getLastVisibleColumn",
    value: function getLastVisibleColumn() {
      var wot = this.hot.view.wt;
      if (wot.wtViewport.columnsVisibleCalculator) {
        return wot.wtTable.getLastVisibleColumn();
      }
      if (wot.wtViewport.columnsRenderCalculator) {
        return wot.wtTable.getLastRenderedColumn();
      }
      return -1;
    }
    /**
     * Collects all columns which titles has been changed in comparison to the previous state.
     *
     * @private
     * @returns {Array} It returns an array of physical column indexes.
     */
  }, {
    key: "findColumnsWhereHeaderWasChanged",
    value: function findColumnsWhereHeaderWasChanged() {
      var columnHeaders = this.hot.getColHeader();
      var _privatePool$get = privatePool5.get(this), cachedColumnHeaders = _privatePool$get.cachedColumnHeaders;
      var changedColumns = arrayReduce(columnHeaders, function(acc, columnTitle, physicalColumn) {
        var cachedColumnsLength = cachedColumnHeaders.length;
        if (cachedColumnsLength - 1 < physicalColumn || cachedColumnHeaders[physicalColumn] !== columnTitle) {
          acc.push(physicalColumn);
        }
        if (cachedColumnsLength - 1 < physicalColumn) {
          cachedColumnHeaders.push(columnTitle);
        } else {
          cachedColumnHeaders[physicalColumn] = columnTitle;
        }
        return acc;
      }, []);
      return changedColumns;
    }
    /**
     * Clears cache of calculated column widths. If you want to clear only selected columns pass an array with their indexes.
     * Otherwise whole cache will be cleared.
     *
     * @param {Number[]} [columns] List of physical column indexes to clear.
     */
  }, {
    key: "clearCache",
    value: function clearCache() {
      var _this5 = this;
      var columns = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (columns.length) {
        arrayEach(columns, function(physicalIndex) {
          _this5.widths[physicalIndex] = void 0;
        });
      } else {
        this.widths.length = 0;
      }
    }
    /**
     * Checks if all widths were calculated. If not then return `true` (need recalculate).
     *
     * @returns {Boolean}
     */
  }, {
    key: "isNeedRecalculate",
    value: function isNeedRecalculate() {
      return !!arrayFilter(this.widths, function(item) {
        return item === void 0;
      }).length;
    }
    /**
     * On before render listener.
     *
     * @private
     */
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender() {
      var force = this.hot.renderCall;
      var rowsCount = this.hot.countRows();
      var firstVisibleColumn = this.getFirstVisibleColumn();
      var lastVisibleColumn = this.getLastVisibleColumn();
      if (firstVisibleColumn === null || lastVisibleColumn === null) {
        return;
      }
      if (!rowsCount) {
        return;
      }
      this.calculateColumnsWidth({
        from: firstVisibleColumn,
        to: lastVisibleColumn
      }, void 0, force);
      if (this.isNeedRecalculate() && !this.inProgress) {
        this.calculateAllColumnsWidth();
      }
    }
    /**
     * On after load data listener.
     *
     * @private
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      var _this6 = this;
      if (this.hot.view) {
        this.recalculateAllColumnsWidth();
      } else {
        setTimeout(function() {
          if (_this6.hot) {
            _this6.recalculateAllColumnsWidth();
          }
        }, 0);
      }
    }
    /**
     * On before change listener.
     *
     * @private
     * @param {Array} changes
     */
  }, {
    key: "onBeforeChange",
    value: function onBeforeChange(changes) {
      var _this7 = this;
      var changedColumns = arrayMap(changes, function(_ref3) {
        var _ref4 = _slicedToArray8(_ref3, 2), column = _ref4[1];
        return _this7.hot.propToCol(column);
      });
      this.clearCache(changedColumns);
    }
    /**
     * On before column resize listener.
     *
     * @private
     * @param {Number} col
     * @param {Number} size
     * @param {Boolean} isDblClick
     * @returns {Number}
     */
  }, {
    key: "onBeforeColumnResize",
    value: function onBeforeColumnResize(col, size, isDblClick) {
      var newSize = size;
      if (isDblClick) {
        this.calculateColumnsWidth(col, void 0, true);
        newSize = this.getColumnWidth(col, void 0, false);
      }
      return newSize;
    }
    /**
     * On after Handsontable init fill plugin with all necessary values.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      privatePool5.get(this).cachedColumnHeaders = this.hot.getColHeader();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.ghostTable.clean();
      _get5(_getPrototypeOf13(AutoColumnSize2.prototype), "destroy", this).call(this);
    }
  }]);
  return AutoColumnSize2;
}(base_default2);
registerPlugin("autoColumnSize", AutoColumnSize);
var autoColumnSize_default = AutoColumnSize;

// node_modules/handsontable/es/plugins/autofill/utils.js
var DIRECTIONS = {
  horizontal: "horizontal",
  vertical: "vertical"
};
function getDeltas(start, end, data, direction) {
  var rowsLength = data.length;
  var columnsLength = data ? data[0].length : 0;
  var deltas = [];
  var diffRow = end.row - start.row;
  var diffCol = end.col - start.col;
  if (["down", "up"].indexOf(direction) !== -1) {
    var arr = [];
    for (var col = 0; col <= diffCol; col++) {
      var startValue = parseInt(data[0][col], 10);
      var endValue = parseInt(data[rowsLength - 1][col], 10);
      var delta = (direction === "down" ? endValue - startValue : startValue - endValue) / (rowsLength - 1) || 0;
      arr.push(delta);
    }
    deltas.push(arr);
  }
  if (["right", "left"].indexOf(direction) !== -1) {
    for (var row = 0; row <= diffRow; row++) {
      var _startValue = parseInt(data[row][0], 10);
      var _endValue = parseInt(data[row][columnsLength - 1], 10);
      var _delta = (direction === "right" ? _endValue - _startValue : _startValue - _endValue) / (columnsLength - 1) || 0;
      deltas.push([_delta]);
    }
  }
  return deltas;
}
function getDragDirectionAndRange(startSelection, endSelection) {
  var startOfDragCoords;
  var endOfDragCoords;
  var directionOfDrag;
  if (endSelection[0] === startSelection[0] && endSelection[1] < startSelection[1]) {
    directionOfDrag = "left";
    startOfDragCoords = new coords_default(endSelection[0], endSelection[1]);
    endOfDragCoords = new coords_default(endSelection[2], startSelection[1] - 1);
  } else if (endSelection[2] === startSelection[2] && endSelection[0] === startSelection[0] && endSelection[3] > startSelection[3]) {
    directionOfDrag = "right";
    startOfDragCoords = new coords_default(endSelection[0], startSelection[3] + 1);
    endOfDragCoords = new coords_default(endSelection[2], endSelection[3]);
  } else if (endSelection[0] < startSelection[0] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "up";
    startOfDragCoords = new coords_default(endSelection[0], endSelection[1]);
    endOfDragCoords = new coords_default(startSelection[0] - 1, endSelection[3]);
  } else if (endSelection[2] > startSelection[2] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "down";
    startOfDragCoords = new coords_default(startSelection[2] + 1, endSelection[1]);
    endOfDragCoords = new coords_default(endSelection[2], endSelection[3]);
  }
  return {
    directionOfDrag,
    startOfDragCoords,
    endOfDragCoords
  };
}
function getMappedFillHandleSetting(fillHandle) {
  var mappedSettings = {};
  if (fillHandle === true) {
    mappedSettings.directions = Object.keys(DIRECTIONS);
    mappedSettings.autoInsertRow = true;
  } else if (isObject(fillHandle)) {
    if (isDefined(fillHandle.autoInsertRow)) {
      if (fillHandle.direction === DIRECTIONS.horizontal) {
        mappedSettings.autoInsertRow = false;
      } else {
        mappedSettings.autoInsertRow = fillHandle.autoInsertRow;
      }
    } else {
      mappedSettings.autoInsertRow = false;
    }
    if (isDefined(fillHandle.direction)) {
      mappedSettings.directions = [fillHandle.direction];
    } else {
      mappedSettings.directions = Object.keys(DIRECTIONS);
    }
  } else if (typeof fillHandle === "string") {
    mappedSettings.directions = [fillHandle];
    mappedSettings.autoInsertRow = true;
  } else {
    mappedSettings.directions = [];
    mappedSettings.autoInsertRow = false;
  }
  return mappedSettings;
}

// node_modules/handsontable/es/plugins/autofill/autofill.js
function _typeof26(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof26 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof26 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof26(obj);
}
function _toConsumableArray6(arr) {
  return _arrayWithoutHoles6(arr) || _iterableToArray6(arr) || _nonIterableSpread6();
}
function _nonIterableSpread6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray6(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles6(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function _classCallCheck44(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties42(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass42(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties42(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties42(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn14(self2, call) {
  if (call && (_typeof26(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized14(self2);
}
function _get6(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get6 = Reflect.get;
  } else {
    _get6 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase6(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get6(target, property, receiver || target);
}
function _superPropBase6(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf14(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf14(o) {
  _getPrototypeOf14 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf14(o);
}
function _inherits14(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf14(subClass, superClass);
}
function _setPrototypeOf14(o, p) {
  _setPrototypeOf14 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf14(o, p);
}
function _assertThisInitialized14(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
pluginHooks_default.getSingleton().register("modifyAutofillRange");
pluginHooks_default.getSingleton().register("beforeAutofill");
var INSERT_ROW_ALTER_ACTION_NAME = "insert_row";
var INTERVAL_FOR_ADDING_ROW = 200;
var Autofill = function(_BasePlugin) {
  _inherits14(Autofill2, _BasePlugin);
  function Autofill2(hotInstance) {
    var _this;
    _classCallCheck44(this, Autofill2);
    _this = _possibleConstructorReturn14(this, _getPrototypeOf14(Autofill2).call(this, hotInstance));
    _this.eventManager = new eventManager_default(_assertThisInitialized14(_assertThisInitialized14(_this)));
    _this.addingStarted = false;
    _this.mouseDownOnCellCorner = false;
    _this.mouseDragOutside = false;
    _this.handleDraggedCells = 0;
    _this.directions = [];
    _this.autoInsertRow = false;
    return _this;
  }
  _createClass42(Autofill2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().fillHandle;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.mapSettings();
      this.registerEvents();
      this.addHook("afterOnCellCornerMouseDown", function(event2) {
        return _this2.onAfterCellCornerMouseDown(event2);
      });
      this.addHook("afterOnCellCornerDblClick", function(event2) {
        return _this2.onCellCornerDblClick(event2);
      });
      this.addHook("beforeOnCellMouseOver", function(event2, coords) {
        return _this2.onBeforeCellMouseOver(coords);
      });
      _get6(_getPrototypeOf14(Autofill2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get6(_getPrototypeOf14(Autofill2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.clearMappedSettings();
      _get6(_getPrototypeOf14(Autofill2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Gets selection data
     *
     * @private
     * @returns {Array} Array with the data.
     */
  }, {
    key: "getSelectionData",
    value: function getSelectionData() {
      var selRange = {
        from: this.hot.getSelectedRangeLast().from,
        to: this.hot.getSelectedRangeLast().to
      };
      return this.hot.getData(selRange.from.row, selRange.from.col, selRange.to.row, selRange.to.col);
    }
    /**
     * Try to apply fill values to the area in fill border, omitting the selection border.
     *
     * @private
     * @returns {Boolean} reports if fill was applied.
     *
     * @fires Hooks#modifyAutofillRange
     * @fires Hooks#beforeAutofill
     */
  }, {
    key: "fillIn",
    value: function fillIn() {
      if (this.hot.selection.highlight.getFill().isEmpty()) {
        return false;
      }
      var cornersOfSelectionAndDragAreas = this.hot.selection.highlight.getFill().getCorners();
      this.resetSelectionOfDraggedArea();
      var cornersOfSelectedCells = this.getCornersOfSelectedCells();
      cornersOfSelectionAndDragAreas = this.hot.runHooks("modifyAutofillRange", cornersOfSelectionAndDragAreas, cornersOfSelectedCells);
      var _getDragDirectionAndR = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas), directionOfDrag = _getDragDirectionAndR.directionOfDrag, startOfDragCoords = _getDragDirectionAndR.startOfDragCoords, endOfDragCoords = _getDragDirectionAndR.endOfDragCoords;
      if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {
        var selectionData = this.getSelectionData();
        this.hot.runHooks("beforeAutofill", startOfDragCoords, endOfDragCoords, selectionData);
        var deltas = getDeltas(startOfDragCoords, endOfDragCoords, selectionData, directionOfDrag);
        var fillData = selectionData;
        if (["up", "left"].indexOf(directionOfDrag) > -1) {
          fillData = [];
          var dragLength = null;
          var fillOffset = null;
          if (directionOfDrag === "up") {
            dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;
            fillOffset = dragLength % selectionData.length;
            for (var i = 0; i < dragLength; i++) {
              fillData.push(selectionData[(i + (selectionData.length - fillOffset)) % selectionData.length]);
            }
          } else {
            dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;
            fillOffset = dragLength % selectionData[0].length;
            for (var _i = 0; _i < selectionData.length; _i++) {
              fillData.push([]);
              for (var j = 0; j < dragLength; j++) {
                fillData[_i].push(selectionData[_i][(j + (selectionData[_i].length - fillOffset)) % selectionData[_i].length]);
              }
            }
          }
        }
        this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, "".concat(this.pluginName, ".fill"), null, directionOfDrag, deltas);
        this.setSelection(cornersOfSelectionAndDragAreas);
      } else {
        this.hot._refreshBorders();
      }
      return true;
    }
    /**
     * Reduces the selection area if the handle was dragged outside of the table or on headers.
     *
     * @private
     * @param {CellCoords} coords indexes of selection corners.
     * @returns {CellCoords}
     */
  }, {
    key: "reduceSelectionAreaIfNeeded",
    value: function reduceSelectionAreaIfNeeded(coords) {
      if (coords.row < 0) {
        coords.row = 0;
      }
      if (coords.col < 0) {
        coords.col = 0;
      }
      return coords;
    }
    /**
     * Gets the coordinates of the drag & drop borders.
     *
     * @private
     * @param {CellCoords} coordsOfSelection `CellCoords` coord object.
     * @returns {Array}
     */
  }, {
    key: "getCoordsOfDragAndDropBorders",
    value: function getCoordsOfDragAndDropBorders(coordsOfSelection) {
      var topLeftCorner = this.hot.getSelectedRangeLast().getTopLeftCorner();
      var bottomRightCorner = this.hot.getSelectedRangeLast().getBottomRightCorner();
      var coords;
      if (this.directions.includes(DIRECTIONS.vertical) && (bottomRightCorner.row < coordsOfSelection.row || topLeftCorner.row > coordsOfSelection.row)) {
        coords = new coords_default(coordsOfSelection.row, bottomRightCorner.col);
      } else if (this.directions.includes(DIRECTIONS.horizontal)) {
        coords = new coords_default(bottomRightCorner.row, coordsOfSelection.col);
      } else {
        return;
      }
      return this.reduceSelectionAreaIfNeeded(coords);
    }
    /**
     * Show the fill border.
     *
     * @private
     * @param {CellCoords} coordsOfSelection `CellCoords` coord object.
     */
  }, {
    key: "showBorder",
    value: function showBorder(coordsOfSelection) {
      var coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);
      if (coordsOfDragAndDropBorders) {
        this.redrawBorders(coordsOfDragAndDropBorders);
      }
    }
    /**
     * Add new row
     *
     * @private
     */
  }, {
    key: "addRow",
    value: function addRow() {
      var _this3 = this;
      this.hot._registerTimeout(setTimeout(function() {
        _this3.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, void 0, 1, "".concat(_this3.pluginName, ".fill"));
        _this3.addingStarted = false;
      }, INTERVAL_FOR_ADDING_ROW));
    }
    /**
     * Add new rows if they are needed to continue auto-filling values.
     *
     * @private
     */
  }, {
    key: "addNewRowIfNeeded",
    value: function addNewRowIfNeeded() {
      if (this.hot.selection.highlight.getFill().cellRange && this.addingStarted === false && this.autoInsertRow) {
        var cornersOfSelectedCells = this.hot.getSelectedLast();
        var cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getCorners();
        var nrOfTableRows = this.hot.countRows();
        if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {
          this.addingStarted = true;
          this.addRow();
        }
      }
    }
    /**
     * Get corners of selected cells.
     *
     * @private
     * @returns {Array}
     */
  }, {
    key: "getCornersOfSelectedCells",
    value: function getCornersOfSelectedCells() {
      if (this.hot.selection.isMultiple()) {
        return this.hot.selection.highlight.createOrGetArea().getCorners();
      }
      return this.hot.selection.highlight.getCell().getCorners();
    }
    /**
     * Get index of last adjacent filled in row
     *
     * @private
     * @param {Array} cornersOfSelectedCells indexes of selection corners.
     * @returns {Number} gives number greater than or equal to zero when selection adjacent can be applied.
     * or -1 when selection adjacent can't be applied
     */
  }, {
    key: "getIndexOfLastAdjacentFilledInRow",
    value: function getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {
      var data = this.hot.getData();
      var nrOfTableRows = this.hot.countRows();
      var lastFilledInRowIndex;
      for (var rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {
        for (var columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {
          var dataInCell = data[rowIndex][columnIndex];
          if (dataInCell) {
            return -1;
          }
        }
        var dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];
        var dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];
        if (!!dataInNextLeftCell || !!dataInNextRightCell) {
          lastFilledInRowIndex = rowIndex;
        }
      }
      return lastFilledInRowIndex;
    }
    /**
     * Adds a selection from the start area to the specific row index.
     *
     * @private
     * @param {Array} selectStartArea selection area from which we start to create more comprehensive selection.
     * @param {Number} rowIndex
     */
  }, {
    key: "addSelectionFromStartAreaToSpecificRowIndex",
    value: function addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {
      this.hot.selection.highlight.getFill().clear().add(new coords_default(selectStartArea[0], selectStartArea[1])).add(new coords_default(rowIndex, selectStartArea[3]));
    }
    /**
     * Sets selection based on passed corners.
     *
     * @private
     * @param {Array} cornersOfArea
     */
  }, {
    key: "setSelection",
    value: function setSelection(cornersOfArea) {
      var _this$hot;
      (_this$hot = this.hot).selectCell.apply(_this$hot, _toConsumableArray6(cornersOfArea).concat([false, false]));
    }
    /**
     * Try to select cells down to the last row in the left column and then returns if selection was applied.
     *
     * @private
     * @returns {Boolean}
     */
  }, {
    key: "selectAdjacent",
    value: function selectAdjacent() {
      var cornersOfSelectedCells = this.getCornersOfSelectedCells();
      var lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);
      if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === void 0) {
        return false;
      }
      this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);
      return true;
    }
    /**
     * Resets selection of dragged area.
     *
     * @private
     */
  }, {
    key: "resetSelectionOfDraggedArea",
    value: function resetSelectionOfDraggedArea() {
      this.handleDraggedCells = 0;
      this.hot.selection.highlight.getFill().clear();
    }
    /**
     * Redraws borders.
     *
     * @private
     * @param {CellCoords} coords `CellCoords` coord object.
     */
  }, {
    key: "redrawBorders",
    value: function redrawBorders(coords) {
      this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords);
      this.hot.view.render();
    }
    /**
     * Get if mouse was dragged outside.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     * @returns {Boolean}
     */
  }, {
    key: "getIfMouseWasDraggedOutside",
    value: function getIfMouseWasDraggedOutside(event2) {
      var tableBottom = offset(this.hot.table).top - (window.pageYOffset || document.documentElement.scrollTop) + outerHeight(this.hot.table);
      var tableRight = offset(this.hot.table).left - (window.pageXOffset || document.documentElement.scrollLeft) + outerWidth(this.hot.table);
      return event2.clientY > tableBottom && event2.clientX <= tableRight;
    }
    /**
     * Bind the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this4 = this;
      this.eventManager.addEventListener(document.documentElement, "mouseup", function() {
        return _this4.onMouseUp();
      });
      this.eventManager.addEventListener(document.documentElement, "mousemove", function(event2) {
        return _this4.onMouseMove(event2);
      });
    }
    /**
     * On cell corner double click callback.
     *
     * @private
     */
  }, {
    key: "onCellCornerDblClick",
    value: function onCellCornerDblClick() {
      var selectionApplied = this.selectAdjacent();
      if (selectionApplied) {
        this.fillIn();
      }
    }
    /**
     * On after cell corner mouse down listener.
     *
     * @private
     */
  }, {
    key: "onAfterCellCornerMouseDown",
    value: function onAfterCellCornerMouseDown() {
      this.handleDraggedCells = 1;
      this.mouseDownOnCellCorner = true;
    }
    /**
     * On before cell mouse over listener.
     *
     * @private
     * @param {CellCoords} coords `CellCoords` coord object.
     */
  }, {
    key: "onBeforeCellMouseOver",
    value: function onBeforeCellMouseOver(coords) {
      if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {
        this.handleDraggedCells += 1;
        this.showBorder(coords);
        this.addNewRowIfNeeded();
      }
    }
    /**
     * On mouse up listener.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      if (this.handleDraggedCells) {
        if (this.handleDraggedCells > 1) {
          this.fillIn();
        }
        this.handleDraggedCells = 0;
        this.mouseDownOnCellCorner = false;
      }
    }
    /**
     * On mouse move listener.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event2);
      if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {
        this.mouseDragOutside = true;
        this.addingStarted = true;
      } else {
        this.mouseDragOutside = false;
      }
      if (this.mouseDragOutside && this.autoInsertRow) {
        this.addRow();
      }
    }
    /**
     * Clears mapped settings.
     *
     * @private
     */
  }, {
    key: "clearMappedSettings",
    value: function clearMappedSettings() {
      this.directions.length = 0;
      this.autoInsertRow = false;
    }
    /**
     * Map settings.
     *
     * @private
     */
  }, {
    key: "mapSettings",
    value: function mapSettings() {
      var mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);
      this.directions = mappedSettings.directions;
      this.autoInsertRow = mappedSettings.autoInsertRow;
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get6(_getPrototypeOf14(Autofill2.prototype), "destroy", this).call(this);
    }
  }]);
  return Autofill2;
}(base_default2);
registerPlugin("autofill", Autofill);
var autofill_default = Autofill;

// node_modules/handsontable/es/plugins/autoRowSize/autoRowSize.js
function _typeof27(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof27 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof27 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof27(obj);
}
function _slicedToArray9(arr, i) {
  return _arrayWithHoles9(arr) || _iterableToArrayLimit9(arr, i) || _nonIterableRest9();
}
function _nonIterableRest9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit9(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles9(arr) {
  if (Array.isArray(arr)) return arr;
}
function _classCallCheck45(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn15(self2, call) {
  if (call && (_typeof27(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized15(self2);
}
function _assertThisInitialized15(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get7(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get7 = Reflect.get;
  } else {
    _get7 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase7(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get7(target, property, receiver || target);
}
function _superPropBase7(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf15(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf15(o) {
  _getPrototypeOf15 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf15(o);
}
function _defineProperties43(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass43(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties43(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties43(Constructor, staticProps);
  return Constructor;
}
function _inherits15(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf15(subClass, superClass);
}
function _setPrototypeOf15(o, p) {
  _setPrototypeOf15 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf15(o, p);
}
var AutoRowSize = function(_BasePlugin) {
  _inherits15(AutoRowSize2, _BasePlugin);
  _createClass43(AutoRowSize2, null, [{
    key: "CALCULATION_STEP",
    get: function get5() {
      return 50;
    }
  }, {
    key: "SYNC_CALCULATION_LIMIT",
    get: function get5() {
      return 500;
    }
  }]);
  function AutoRowSize2(hotInstance) {
    var _this;
    _classCallCheck45(this, AutoRowSize2);
    _this = _possibleConstructorReturn15(this, _getPrototypeOf15(AutoRowSize2).call(this, hotInstance));
    _this.heights = [];
    _this.ghostTable = new ghostTable_default(_this.hot);
    _this.samplesGenerator = new samplesGenerator_default(function(row, col) {
      var cellValue;
      if (row >= 0) {
        cellValue = _this.hot.getDataAtCell(row, col);
      } else if (row === -1) {
        cellValue = _this.hot.getColHeader(col);
      }
      return {
        value: cellValue
      };
    });
    _this.firstCalculation = true;
    _this.inProgress = false;
    _this.addHook("beforeRowResize", function(row, size, isDblClick) {
      return _this.onBeforeRowResize(row, size, isDblClick);
    });
    return _this;
  }
  _createClass43(AutoRowSize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().autoRowSize === true || isObject(this.hot.getSettings().autoRowSize);
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.setSamplingOptions();
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData();
      });
      this.addHook("beforeChange", function(changes) {
        return _this2.onBeforeChange(changes);
      });
      this.addHook("beforeColumnMove", function() {
        return _this2.recalculateAllRowsHeight();
      });
      this.addHook("beforeColumnResize", function() {
        return _this2.recalculateAllRowsHeight();
      });
      this.addHook("beforeColumnSort", function() {
        return _this2.clearCache();
      });
      this.addHook("beforeRender", function(force) {
        return _this2.onBeforeRender(force);
      });
      this.addHook("beforeRowMove", function(rowStart, rowEnd) {
        return _this2.onBeforeRowMove(rowStart, rowEnd);
      });
      this.addHook("modifyRowHeight", function(height, row) {
        return _this2.getRowHeight(row, height);
      });
      this.addHook("modifyColumnHeaderHeight", function() {
        return _this2.getColumnHeaderHeight();
      });
      _get7(_getPrototypeOf15(AutoRowSize2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get7(_getPrototypeOf15(AutoRowSize2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Calculate a given rows height.
     *
     * @param {Number|Object} rowRange Row index or an object with `from` and `to` indexes as a range.
     * @param {Number|Object} colRange Column index or an object with `from` and `to` indexes as a range.
     * @param {Boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.
     */
  }, {
    key: "calculateRowsHeight",
    value: function calculateRowsHeight() {
      var _this3 = this;
      var rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countRows() - 1
      };
      var colRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        from: 0,
        to: this.hot.countCols() - 1
      };
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var rowsRange = typeof rowRange === "number" ? {
        from: rowRange,
        to: rowRange
      } : rowRange;
      var columnsRange = typeof colRange === "number" ? {
        from: colRange,
        to: colRange
      } : colRange;
      if (this.hot.getColHeader(0) !== null) {
        var samples = this.samplesGenerator.generateRowSamples(-1, columnsRange);
        this.ghostTable.addColumnHeadersRow(samples.get(-1));
      }
      rangeEach(rowsRange.from, rowsRange.to, function(row) {
        if (force || _this3.heights[row] === void 0) {
          var _samples = _this3.samplesGenerator.generateRowSamples(row, columnsRange);
          arrayEach(_samples, function(_ref) {
            var _ref2 = _slicedToArray9(_ref, 2), rowIndex = _ref2[0], sample = _ref2[1];
            return _this3.ghostTable.addRow(rowIndex, sample);
          });
        }
      });
      if (this.ghostTable.rows.length) {
        this.ghostTable.getHeights(function(row, height) {
          _this3.heights[row] = height;
        });
        this.ghostTable.clean();
      }
    }
    /**
     * Calculate all rows heights. The calculated row will be cached in the {@link AutoRowSize#heights} property.
     * To retrieve height for specyfied row use {@link AutoRowSize#getRowHeight} method.
     *
     * @param {Object|Number} rowRange Row index or an object with `from` and `to` properties which define row range.
     */
  }, {
    key: "calculateAllRowsHeight",
    value: function calculateAllRowsHeight() {
      var _this4 = this;
      var colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        from: 0,
        to: this.hot.countCols() - 1
      };
      var current = 0;
      var length = this.hot.countRows() - 1;
      var timer = null;
      this.inProgress = true;
      var loop = function loop2() {
        if (!_this4.hot) {
          cancelAnimationFrame(timer);
          _this4.inProgress = false;
          return;
        }
        _this4.calculateRowsHeight({
          from: current,
          to: Math.min(current + AutoRowSize2.CALCULATION_STEP, length)
        }, colRange);
        current = current + AutoRowSize2.CALCULATION_STEP + 1;
        if (current < length) {
          timer = requestAnimationFrame(loop2);
        } else {
          cancelAnimationFrame(timer);
          _this4.inProgress = false;
          _this4.hot.view.wt.wtOverlays.adjustElementsSize(true);
          if (_this4.hot.view.wt.wtOverlays.leftOverlay.needFullRender) {
            _this4.hot.view.wt.wtOverlays.leftOverlay.clone.draw();
          }
        }
      };
      var syncLimit = this.getSyncCalculationLimit();
      if (this.firstCalculation && syncLimit >= 0) {
        this.calculateRowsHeight({
          from: 0,
          to: syncLimit
        }, colRange);
        this.firstCalculation = false;
        current = syncLimit + 1;
      }
      if (current < length) {
        loop();
      } else {
        this.inProgress = false;
        this.hot.view.wt.wtOverlays.adjustElementsSize(false);
      }
    }
    /**
     * Sets the sampling options.
     *
     * @private
     */
  }, {
    key: "setSamplingOptions",
    value: function setSamplingOptions() {
      var setting = this.hot.getSettings().autoRowSize;
      var samplingRatio = setting && hasOwnProperty(setting, "samplingRatio") ? this.hot.getSettings().autoRowSize.samplingRatio : void 0;
      var allowSampleDuplicates = setting && hasOwnProperty(setting, "allowSampleDuplicates") ? this.hot.getSettings().autoRowSize.allowSampleDuplicates : void 0;
      if (samplingRatio && !isNaN(samplingRatio)) {
        this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
      }
      if (allowSampleDuplicates) {
        this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
      }
    }
    /**
     * Recalculates all rows height (overwrite cache values).
     */
  }, {
    key: "recalculateAllRowsHeight",
    value: function recalculateAllRowsHeight() {
      if (isVisible(this.hot.view.wt.wtTable.TABLE)) {
        this.clearCache();
        this.calculateAllRowsHeight();
      }
    }
    /**
     * Gets value which tells how many rows should be calculated synchronously (rest of the rows will be calculated
     * asynchronously). The limit is calculated based on `syncLimit` set to autoRowSize option (see {@link Options#autoRowSize}).
     *
     * @returns {Number}
     */
  }, {
    key: "getSyncCalculationLimit",
    value: function getSyncCalculationLimit() {
      var limit = AutoRowSize2.SYNC_CALCULATION_LIMIT;
      var rowsLimit = this.hot.countRows() - 1;
      if (isObject(this.hot.getSettings().autoRowSize)) {
        limit = this.hot.getSettings().autoRowSize.syncLimit;
        if (isPercentValue(limit)) {
          limit = valueAccordingPercent(rowsLimit, limit);
        } else {
          limit >>= 0;
        }
      }
      return Math.min(limit, rowsLimit);
    }
    /**
     * Gets the calculated row height.
     *
     * @param {Number} row Visual row index.
     * @param {Number} [defaultHeight] Default row height. It will be picked up if no calculated height found.
     * @returns {Number}
     */
  }, {
    key: "getRowHeight",
    value: function getRowHeight(row) {
      var defaultHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      var height = defaultHeight;
      if (this.heights[row] !== void 0 && this.heights[row] > (defaultHeight || 0)) {
        height = this.heights[row];
      }
      return height;
    }
    /**
     * Get the calculated column header height.
     *
     * @returns {Number|undefined}
     */
  }, {
    key: "getColumnHeaderHeight",
    value: function getColumnHeaderHeight() {
      return this.heights[-1];
    }
    /**
     * Get the first visible row.
     *
     * @returns {Number|null} Returns row index, -1 if table is not rendered or null if there are no rows to base the the calculations on.
     */
  }, {
    key: "getFirstVisibleRow",
    value: function getFirstVisibleRow() {
      var wot = this.hot.view.wt;
      if (wot.wtViewport.rowsVisibleCalculator) {
        return wot.wtTable.getFirstVisibleRow();
      }
      if (wot.wtViewport.rowsRenderCalculator) {
        return wot.wtTable.getFirstRenderedRow();
      }
      return -1;
    }
    /**
     * Gets the last visible row.
     *
     * @returns {Number} Returns row index or -1 if table is not rendered.
     */
  }, {
    key: "getLastVisibleRow",
    value: function getLastVisibleRow() {
      var wot = this.hot.view.wt;
      if (wot.wtViewport.rowsVisibleCalculator) {
        return wot.wtTable.getLastVisibleRow();
      }
      if (wot.wtViewport.rowsRenderCalculator) {
        return wot.wtTable.getLastRenderedRow();
      }
      return -1;
    }
    /**
     * Clears cached heights.
     */
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.heights.length = 0;
      this.heights[-1] = void 0;
    }
    /**
     * Clears cache by range.
     *
     * @param {Object|Number} range Row index or an object with `from` and `to` properties which define row range.
     */
  }, {
    key: "clearCacheByRange",
    value: function clearCacheByRange(range) {
      var _this5 = this;
      var _ref3 = typeof range === "number" ? {
        from: range,
        to: range
      } : range, from3 = _ref3.from, to3 = _ref3.to;
      rangeEach(Math.min(from3, to3), Math.max(from3, to3), function(row) {
        _this5.heights[row] = void 0;
      });
    }
    /**
     * Checks if all heights were calculated. If not then return `true` (need recalculate).
     *
     * @returns {Boolean}
     */
  }, {
    key: "isNeedRecalculate",
    value: function isNeedRecalculate() {
      return !!arrayFilter(this.heights, function(item) {
        return item === void 0;
      }).length;
    }
    /**
     * On before render listener.
     *
     * @private
     */
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender() {
      var force = this.hot.renderCall;
      var fixedRowsBottom = this.hot.getSettings().fixedRowsBottom;
      var firstVisibleRow = this.getFirstVisibleRow();
      var lastVisibleRow = this.getLastVisibleRow();
      if (firstVisibleRow === null || lastVisibleRow === null) {
        return;
      }
      this.calculateRowsHeight({
        from: firstVisibleRow,
        to: lastVisibleRow
      }, void 0, force);
      if (fixedRowsBottom) {
        var totalRows = this.hot.countRows() - 1;
        this.calculateRowsHeight({
          from: totalRows - fixedRowsBottom,
          to: totalRows
        });
      }
      if (this.isNeedRecalculate() && !this.inProgress) {
        this.calculateAllRowsHeight();
      }
    }
    /**
     * On before row move listener.
     *
     * @private
     * @param {Number} from Row index where was grabbed.
     * @param {Number} to Destination row index.
     */
  }, {
    key: "onBeforeRowMove",
    value: function onBeforeRowMove(from3, to3) {
      this.clearCacheByRange({
        from: from3,
        to: to3
      });
      this.calculateAllRowsHeight();
    }
    /**
     * On before row resize listener.
     *
     * @private
     * @param {Number} row
     * @param {Number} size
     * @param {Boolean} isDblClick
     * @returns {Number}
     */
  }, {
    key: "onBeforeRowResize",
    value: function onBeforeRowResize(row, size, isDblClick) {
      var newSize = size;
      if (isDblClick) {
        this.calculateRowsHeight(row, void 0, true);
        newSize = this.getRowHeight(row);
      }
      return newSize;
    }
    /**
     * On after load data listener.
     *
     * @private
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      var _this6 = this;
      if (this.hot.view) {
        this.recalculateAllRowsHeight();
      } else {
        setTimeout(function() {
          if (_this6.hot) {
            _this6.recalculateAllRowsHeight();
          }
        }, 0);
      }
    }
    /**
     * On before change listener.
     *
     * @private
     * @param {Array} changes
     */
  }, {
    key: "onBeforeChange",
    value: function onBeforeChange(changes) {
      var range = null;
      if (changes.length === 1) {
        range = changes[0][0];
      } else if (changes.length > 1) {
        range = {
          from: changes[0][0],
          to: changes[changes.length - 1][0]
        };
      }
      if (range !== null) {
        this.clearCacheByRange(range);
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.ghostTable.clean();
      _get7(_getPrototypeOf15(AutoRowSize2.prototype), "destroy", this).call(this);
    }
  }]);
  return AutoRowSize2;
}(base_default2);
registerPlugin("autoRowSize", AutoRowSize);
var autoRowSize_default = AutoRowSize;

// node_modules/handsontable/es/plugins/columnSorting/columnStatesManager.js
function _classCallCheck46(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties44(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass44(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties44(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties44(Constructor, staticProps);
  return Constructor;
}
var inheritedColumnProperties = ["sortEmptyCells", "indicator", "headerAction", "compareFunctionFactory"];
var SORT_EMPTY_CELLS_DEFAULT = false;
var SHOW_SORT_INDICATOR_DEFAULT = true;
var HEADER_ACTION_DEFAULT = true;
var ColumnStatesManager = function() {
  function ColumnStatesManager2() {
    _classCallCheck46(this, ColumnStatesManager2);
    this.sortedColumnsStates = [];
    this.sortEmptyCells = SORT_EMPTY_CELLS_DEFAULT;
    this.indicator = SHOW_SORT_INDICATOR_DEFAULT;
    this.headerAction = HEADER_ACTION_DEFAULT;
    this.compareFunctionFactory = void 0;
  }
  _createClass44(ColumnStatesManager2, [{
    key: "updateAllColumnsProperties",
    value: function updateAllColumnsProperties(allSortSettings) {
      var _this = this;
      if (!isObject(allSortSettings)) {
        return;
      }
      objectEach(allSortSettings, function(newValue, propertyName) {
        if (inheritedColumnProperties.includes(propertyName)) {
          _this[propertyName] = newValue;
        }
      });
    }
    /**
     * Get all column properties which affect the sorting result.
     *
     * @returns {Object}
     */
  }, {
    key: "getAllColumnsProperties",
    value: function getAllColumnsProperties() {
      var columnProperties = {
        sortEmptyCells: this.sortEmptyCells,
        indicator: this.indicator,
        headerAction: this.headerAction
      };
      if (typeof this.compareFunctionFactory === "function") {
        columnProperties.compareFunctionFactory = this.compareFunctionFactory;
      }
      return columnProperties;
    }
    /**
     * Get index of first sorted column.
     *
     * @returns {Number|undefined}
     */
  }, {
    key: "getFirstSortedColumn",
    value: function getFirstSortedColumn() {
      var firstSortedColumn;
      if (this.getNumberOfSortedColumns() > 0) {
        firstSortedColumn = this.sortedColumnsStates[0].column;
      }
      return firstSortedColumn;
    }
    /**
     * Get sort order of column.
     *
     * @param {Number} searchedColumn Physical column index.
     * @returns {String|undefined} Sort order (`asc` for ascending, `desc` for descending and undefined for not sorted).
     */
  }, {
    key: "getSortOrderOfColumn",
    value: function getSortOrderOfColumn(searchedColumn) {
      var searchedState = this.sortedColumnsStates.find(function(_ref) {
        var column = _ref.column;
        return searchedColumn === column;
      });
      var sortOrder;
      if (isObject(searchedState)) {
        sortOrder = searchedState.sortOrder;
      }
      return sortOrder;
    }
    /**
     * Get list of sorted columns.
     *
     * @returns {Array}
     */
  }, {
    key: "getSortedColumns",
    value: function getSortedColumns() {
      return arrayMap(this.sortedColumnsStates, function(_ref2) {
        var column = _ref2.column;
        return column;
      });
    }
    /**
     * Get order of particular column in the states queue.
     *
     * @param {Number} column Physical column index.
     * @returns {Number}
     */
  }, {
    key: "getIndexOfColumnInSortQueue",
    value: function getIndexOfColumnInSortQueue(column) {
      return this.getSortedColumns().indexOf(column);
    }
    /**
     * Get number of sorted columns.
     *
     * @returns {Number}
     */
  }, {
    key: "getNumberOfSortedColumns",
    value: function getNumberOfSortedColumns() {
      return this.sortedColumnsStates.length;
    }
    /**
     * Get if list of sorted columns is empty.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isListOfSortedColumnsEmpty",
    value: function isListOfSortedColumnsEmpty() {
      return this.getNumberOfSortedColumns() === 0;
    }
    /**
     * Get if particular column is sorted.
     *
     * @param {Number} column Physical column index.
     * @returns {Boolean}
     */
  }, {
    key: "isColumnSorted",
    value: function isColumnSorted(column) {
      return this.getSortedColumns().includes(column);
    }
    /**
     * Get states for all sorted columns.
     *
     * @returns {Array}
     */
  }, {
    key: "getSortStates",
    value: function getSortStates() {
      return deepClone(this.sortedColumnsStates);
    }
    /**
     * Get sort state for particular column. Object contains `column` and `sortOrder` properties.
     *
     * **Note**: Please keep in mind that returned objects expose **physical** column index under the `column` key.
     *
     * @param {Number} column Physical column index.
     * @returns {Object|undefined}
     */
  }, {
    key: "getColumnSortState",
    value: function getColumnSortState(column) {
      if (this.isColumnSorted(column)) {
        return deepClone(this.sortedColumnsStates[this.getIndexOfColumnInSortQueue(column)]);
      }
    }
    /**
     * Set all sorted columns states.
     *
     * @param {Array} sortStates
     */
  }, {
    key: "setSortStates",
    value: function setSortStates(sortStates) {
      this.sortedColumnsStates = sortStates;
    }
    /**
     * Destroy the state manager.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.sortedColumnsStates.length = 0;
      this.sortedColumnsStates = null;
    }
  }]);
  return ColumnStatesManager2;
}();

// node_modules/handsontable/es/plugins/columnSorting/utils.js
var ASC_SORT_STATE = "asc";
var DESC_SORT_STATE = "desc";
var HEADER_SPAN_CLASS = "colHeader";
function isValidColumnState(columnState) {
  if (isUndefined2(columnState)) {
    return false;
  }
  var column = columnState.column, sortOrder = columnState.sortOrder;
  return Number.isInteger(column) && [ASC_SORT_STATE, DESC_SORT_STATE].includes(sortOrder);
}
function areValidSortStates(sortStates) {
  if (Array.isArray(sortStates) === false || sortStates.every(function(columnState) {
    return isObject(columnState);
  }) === false) {
    return false;
  }
  var sortedColumns = sortStates.map(function(_ref) {
    var column = _ref.column;
    return column;
  });
  var indexOccursOnlyOnce = new Set(sortedColumns).size === sortedColumns.length;
  return indexOccursOnlyOnce && sortStates.every(isValidColumnState);
}
function getNextSortOrder(sortOrder) {
  if (sortOrder === DESC_SORT_STATE) {
    return;
  } else if (sortOrder === ASC_SORT_STATE) {
    return DESC_SORT_STATE;
  }
  return ASC_SORT_STATE;
}
function getHeaderSpanElement(TH) {
  var headerSpanElement = TH.querySelector(".".concat(HEADER_SPAN_CLASS));
  return headerSpanElement;
}
function isFirstLevelColumnHeader(column, TH) {
  if (column < 0 || !TH.parentNode) {
    return false;
  }
  var TRs = TH.parentNode.parentNode.childNodes;
  var headerLevel = Array.from(TRs).indexOf(TH.parentNode) - TRs.length;
  if (headerLevel !== -1) {
    return false;
  }
  return true;
}
function wasHeaderClickedProperly(row, column, clickEvent) {
  return row === -1 && column >= 0 && isRightClick(clickEvent) === false;
}

// node_modules/handsontable/es/plugins/columnSorting/domHelpers.js
var HEADER_CLASS_ASC_SORT = "ascending";
var HEADER_CLASS_DESC_SORT = "descending";
var HEADER_CLASS_INDICATOR_DISABLED = "indicatorDisabled";
var HEADER_SORT_CLASS = "columnSorting";
var HEADER_ACTION_CLASS = "sortAction";
var orderToCssClass = /* @__PURE__ */ new Map([[ASC_SORT_STATE, HEADER_CLASS_ASC_SORT], [DESC_SORT_STATE, HEADER_CLASS_DESC_SORT]]);
function getClassesToAdd(columnStatesManager, column, showSortIndicator, headerAction) {
  var cssClasses = [HEADER_SORT_CLASS];
  if (headerAction) {
    cssClasses.push(HEADER_ACTION_CLASS);
  }
  if (showSortIndicator === false) {
    cssClasses.push(HEADER_CLASS_INDICATOR_DISABLED);
  } else if (columnStatesManager.isColumnSorted(column)) {
    var columnOrder = columnStatesManager.getSortOrderOfColumn(column);
    cssClasses.push(orderToCssClass.get(columnOrder));
  }
  return cssClasses;
}
function getClassedToRemove() {
  return Array.from(orderToCssClass.values()).concat(HEADER_ACTION_CLASS, HEADER_CLASS_INDICATOR_DISABLED, HEADER_SORT_CLASS);
}

// node_modules/handsontable/es/mixins/arrayMapper.js
function _toConsumableArray7(arr) {
  return _arrayWithoutHoles7(arr) || _iterableToArray7(arr) || _nonIterableSpread7();
}
function _nonIterableSpread7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray7(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles7(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
var MIXIN_NAME2 = "arrayMapper";
var arrayMapper = {
  _arrayMap: [],
  /**
   * Get translated index by its physical index.
   *
   * @param {Number} physicalIndex Physical index.
   * @return {Number|null} Returns translated index mapped by passed physical index.
   */
  getValueByIndex: function getValueByIndex(physicalIndex) {
    var length = this._arrayMap.length;
    var translatedIndex = null;
    if (physicalIndex < length) {
      translatedIndex = this._arrayMap[physicalIndex];
    }
    return translatedIndex;
  },
  /**
   * Get physical index by its translated index.
   *
   * @param {*} translatedIndex Value to search.
   * @returns {Number|null} Returns a physical index of the array mapper.
   */
  getIndexByValue: function getIndexByValue(translatedIndex) {
    var physicalIndex;
    return (physicalIndex = this._arrayMap.indexOf(translatedIndex)) === -1 ? null : physicalIndex;
  },
  /**
   * Insert new items to array mapper starting at passed index. New entries will be a continuation of last value in the array.
   *
   * @param {Number} physicalIndex Array index.
   * @param {Number} [amount=1] Defines how many items will be created to an array.
   * @returns {Array} Returns added items.
   */
  insertItems: function insertItems(physicalIndex) {
    var _this = this;
    var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var newIndex = arrayMax(this._arrayMap) + 1;
    var addedItems = [];
    rangeEach(amount - 1, function(count) {
      addedItems.push(_this._arrayMap.splice(physicalIndex + count, 0, newIndex + count));
    });
    return addedItems;
  },
  /**
   * Remove items from array mapper.
   *
   * @param {Number} physicalIndex Array index.
   * @param {Number} [amount=1] Defines how many items will be created to an array.
   * @returns {Array} Returns removed items.
   */
  removeItems: function removeItems(physicalIndex) {
    var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var removedItems = [];
    if (Array.isArray(physicalIndex)) {
      var mapCopy = [].concat(this._arrayMap);
      physicalIndex.sort(function(a, b) {
        return b - a;
      });
      for (var i = 0, length = physicalIndex.length; i < length; i++) {
        var indexToRemove = physicalIndex[i];
        this._arrayMap.splice(indexToRemove, 1);
        removedItems.push(mapCopy[indexToRemove]);
      }
    } else {
      removedItems = this._arrayMap.splice(physicalIndex, amount);
    }
    return removedItems;
  },
  /**
   * Unshift items (remove and shift chunk of array to the left).
   *
   * @param {Number|Array} physicalIndex Array index or Array of indexes to unshift.
   * @param {Number} [amount=1] Defines how many items will be removed from an array (when index is passed as number).
   */
  unshiftItems: function unshiftItems(physicalIndex) {
    var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var removedItems = this.removeItems(physicalIndex, amount);
    function countRowShift(logicalRow) {
      return arrayReduce(removedItems, function(count, removedLogicalRow) {
        var result = count;
        if (logicalRow > removedLogicalRow) {
          result += 1;
        }
        return result;
      }, 0);
    }
    this._arrayMap = arrayMap(this._arrayMap, function(logicalRow) {
      var logicalRowIndex = logicalRow;
      var rowShift = countRowShift(logicalRowIndex);
      if (rowShift) {
        logicalRowIndex -= rowShift;
      }
      return logicalRowIndex;
    });
  },
  /**
   * Shift (right shifting) items starting at passed index.
   *
   * @param {Number} physicalIndex Array index.
   * @param {Number} [amount=1] Defines how many items will be created to an array.
   */
  shiftItems: function shiftItems(physicalIndex) {
    var _this2 = this;
    var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    this._arrayMap = arrayMap(this._arrayMap, function(row) {
      var physicalRowIndex = row;
      if (physicalRowIndex >= physicalIndex) {
        physicalRowIndex += amount;
      }
      return physicalRowIndex;
    });
    rangeEach(amount - 1, function(count) {
      _this2._arrayMap.splice(physicalIndex + count, 0, physicalIndex + count);
    });
  },
  /**
   * Swap indexes in arrayMapper.
   *
   * @param {Number} physicalIndexFrom index to move.
   * @param {Number} physicalIndexTo index to.
   */
  swapIndexes: function swapIndexes(physicalIndexFrom, physicalIndexTo) {
    var _this$_arrayMap;
    (_this$_arrayMap = this._arrayMap).splice.apply(_this$_arrayMap, [physicalIndexTo, 0].concat(_toConsumableArray7(this._arrayMap.splice(physicalIndexFrom, 1))));
  },
  /**
   * Clear all stored index<->value information from an array.
   */
  clearMap: function clearMap() {
    this._arrayMap.length = 0;
  }
};
defineGetter(arrayMapper, "MIXIN_NAME", MIXIN_NAME2, {
  writable: false,
  enumerable: false
});
var arrayMapper_default = arrayMapper;

// node_modules/handsontable/es/plugins/columnSorting/rowsMapper.js
function _classCallCheck47(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties45(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass45(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties45(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties45(Constructor, staticProps);
  return Constructor;
}
var RowsMapper = function() {
  function RowsMapper3() {
    _classCallCheck47(this, RowsMapper3);
  }
  _createClass45(RowsMapper3, [{
    key: "createMap",
    /**
     * Reset current map array and create new one.
     *
     * @param {Number} [length] Custom generated map length.
     */
    value: function createMap(length) {
      var _this = this;
      var originLength = length === void 0 ? this._arrayMap.length : length;
      this._arrayMap.length = 0;
      rangeEach(originLength - 1, function(itemIndex) {
        _this._arrayMap[itemIndex] = itemIndex;
      });
    }
    /**
     * Destroy class.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this._arrayMap = null;
    }
  }]);
  return RowsMapper3;
}();
mixin(RowsMapper, arrayMapper_default);
var rowsMapper_default = RowsMapper;

// node_modules/handsontable/es/plugins/columnSorting/sortFunction/default.js
function compareFunctionFactory(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    var sortEmptyCells = columnPluginSettings.sortEmptyCells;
    if (typeof value === "string") {
      value = value.toLowerCase();
    }
    if (typeof nextValue === "string") {
      nextValue = nextValue.toLowerCase();
    }
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    if (isNaN(value) && !isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    } else if (!isNaN(value) && isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (!(isNaN(value) || isNaN(nextValue))) {
      value = parseFloat(value);
      nextValue = parseFloat(nextValue);
    }
    if (value < nextValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (value > nextValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE = "default";

// node_modules/handsontable/es/plugins/columnSorting/sortFunction/numeric.js
function compareFunctionFactory2(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    var parsedFirstValue = parseFloat(value);
    var parsedSecondValue = parseFloat(nextValue);
    var sortEmptyCells = columnPluginSettings.sortEmptyCells;
    if (parsedFirstValue === parsedSecondValue || isNaN(parsedFirstValue) && isNaN(parsedSecondValue)) {
      return DO_NOT_SWAP;
    }
    if (sortEmptyCells) {
      if (isEmpty(value)) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      if (isEmpty(nextValue)) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
    }
    if (isNaN(parsedFirstValue)) {
      return FIRST_AFTER_SECOND;
    }
    if (isNaN(parsedSecondValue)) {
      return FIRST_BEFORE_SECOND;
    }
    if (parsedFirstValue < parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (parsedFirstValue > parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE2 = "numeric";

// node_modules/handsontable/es/plugins/columnSorting/sortFunction/date.js
function compareFunctionFactory3(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    var sortEmptyCells = columnPluginSettings.sortEmptyCells;
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    var dateFormat = columnMeta.dateFormat;
    var firstDate = moment_default(value, dateFormat);
    var nextDate = moment_default(nextValue, dateFormat);
    if (!firstDate.isValid()) {
      return FIRST_AFTER_SECOND;
    }
    if (!nextDate.isValid()) {
      return FIRST_BEFORE_SECOND;
    }
    if (nextDate.isAfter(firstDate)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (nextDate.isBefore(firstDate)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE3 = "date";

// node_modules/handsontable/es/plugins/columnSorting/sortService/registry.js
var _staticRegister8 = staticRegister("sorting.compareFunctionFactory");
var registerCompareFunctionFactory = _staticRegister8.register;
var getGloballyCompareFunctionFactory = _staticRegister8.getItem;
var hasGloballyCompareFunctionFactory = _staticRegister8.hasItem;
var _staticRegister22 = staticRegister("sorting.mainSortComparator");
var registerRootComparator = _staticRegister22.register;
var getRootComparator = _staticRegister22.getItem;
function getCompareFunctionFactory(type) {
  if (hasGloballyCompareFunctionFactory(type)) {
    return getGloballyCompareFunctionFactory(type);
  }
  return getGloballyCompareFunctionFactory(COLUMN_DATA_TYPE);
}
registerCompareFunctionFactory(COLUMN_DATA_TYPE2, compareFunctionFactory2);
registerCompareFunctionFactory(COLUMN_DATA_TYPE3, compareFunctionFactory3);
registerCompareFunctionFactory(COLUMN_DATA_TYPE, compareFunctionFactory);

// node_modules/handsontable/es/utils/dataStructures/linkedList.js
function _defineProperties46(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass46(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties46(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties46(Constructor, staticProps);
  return Constructor;
}
function _classCallCheck48(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var NodeStructure = function NodeStructure2(data) {
  _classCallCheck48(this, NodeStructure2);
  this.data = data;
  this.next = null;
  this.prev = null;
};
var LinkedList = function() {
  function LinkedList2() {
    _classCallCheck48(this, LinkedList2);
    this.first = null;
    this.last = null;
  }
  _createClass46(LinkedList2, [{
    key: "push",
    value: function push(data) {
      var node = new NodeStructure(data);
      if (this.first === null) {
        this.first = node;
        this.last = node;
      } else {
        var temp = this.last;
        this.last = node;
        node.prev = temp;
        temp.next = node;
      }
    }
    /**
     * Add data to the beginning of linked list.
     *
     * @param {Object} data Data which should be added.
     */
  }, {
    key: "unshift",
    value: function unshift(data) {
      var node = new NodeStructure(data);
      if (this.first === null) {
        this.first = node;
        this.last = node;
      } else {
        var temp = this.first;
        this.first = node;
        node.next = temp;
        temp.prev = node;
      }
    }
    /**
     * In order traversal of the linked list.
     *
     * @param {Function} callback Callback which should be executed on each node.
     */
  }, {
    key: "inorder",
    value: function inorder(callback) {
      var temp = this.first;
      while (temp) {
        callback(temp);
        temp = temp.next;
      }
    }
    /**
     * Remove data from the linked list.
     *
     * @param {Object} data Data which should be removed.
     * @returns {Boolean} Returns true if data has been removed.
     */
  }, {
    key: "remove",
    value: function remove(data) {
      if (this.first === null) {
        return false;
      }
      var temp = this.first;
      var next;
      var prev;
      while (temp) {
        if (temp.data === data) {
          next = temp.next;
          prev = temp.prev;
          if (next) {
            next.prev = prev;
          }
          if (prev) {
            prev.next = next;
          }
          if (temp === this.first) {
            this.first = next;
          }
          if (temp === this.last) {
            this.last = prev;
          }
          return true;
        }
        temp = temp.next;
      }
      return false;
    }
    /**
     * Check if linked list contains cycle.
     *
     * @returns {Boolean} Returns true if linked list contains cycle.
     */
  }, {
    key: "hasCycle",
    value: function hasCycle() {
      var fast = this.first;
      var slow = this.first;
      while (true) {
        if (fast === null) {
          return false;
        }
        fast = fast.next;
        if (fast === null) {
          return false;
        }
        fast = fast.next;
        slow = slow.next;
        if (fast === slow) {
          return true;
        }
      }
    }
    /**
     * Return last node from the linked list.
     *
     * @returns {NodeStructure} Last node.
     */
  }, {
    key: "pop",
    value: function pop() {
      if (this.last === null) {
        return null;
      }
      var temp = this.last;
      this.last = this.last.prev;
      return temp;
    }
    /**
     * Return first node from the linked list.
     *
     * @returns {NodeStructure} First node.
     */
  }, {
    key: "shift",
    value: function shift() {
      if (this.first === null) {
        return null;
      }
      var temp = this.first;
      this.first = this.first.next;
      return temp;
    }
    /**
     * Reverses the linked list recursively
     */
  }, {
    key: "recursiveReverse",
    value: function recursiveReverse() {
      function inverse(current, next) {
        if (!next) {
          return;
        }
        inverse(next, next.next);
        next.next = current;
      }
      if (!this.first) {
        return;
      }
      inverse(this.first, this.first.next);
      this.first.next = null;
      var temp = this.first;
      this.first = this.last;
      this.last = temp;
    }
    /**
     * Reverses the linked list iteratively
     */
  }, {
    key: "reverse",
    value: function reverse() {
      if (!this.first || !this.first.next) {
        return;
      }
      var current = this.first.next;
      var prev = this.first;
      var temp;
      while (current) {
        temp = current.next;
        current.next = prev;
        prev.prev = current;
        prev = current;
        current = temp;
      }
      this.first.next = null;
      this.last.prev = null;
      temp = this.first;
      this.first = prev;
      this.last = temp;
    }
  }]);
  return LinkedList2;
}();
var linkedList_default = LinkedList;

// node_modules/handsontable/es/utils/sortingAlgorithms/mergeSort.js
var defaultCompareFunction = function defaultCompareFunction2(a, b) {
  var firstValue = a.toString();
  var secondValue = b.toString();
  if (firstValue === secondValue) {
    return 0;
  } else if (firstValue < secondValue) {
    return -1;
  }
  return 1;
};
function mergeSort(array) {
  var compareFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultCompareFunction;
  var startIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var endIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : array.length;
  if (Math.abs(endIndex - startIndex) <= 1) {
    return [];
  }
  var middleIndex = Math.ceil((startIndex + endIndex) / 2);
  mergeSort(array, compareFunction, startIndex, middleIndex);
  mergeSort(array, compareFunction, middleIndex, endIndex);
  return merge(array, compareFunction, startIndex, middleIndex, endIndex);
}
function merge(array, compareFunction, startIndex, middleIndex, endIndex) {
  var leftElements = new linkedList_default();
  var rightElements = new linkedList_default();
  var leftSize = middleIndex - startIndex;
  var rightSize = endIndex - middleIndex;
  var maxSize = Math.max(leftSize, rightSize);
  var size = endIndex - startIndex;
  for (var _i = 0; _i < maxSize; _i += 1) {
    if (_i < leftSize) {
      leftElements.push(array[startIndex + _i]);
    }
    if (_i < rightSize) {
      rightElements.push(array[middleIndex + _i]);
    }
  }
  var i = 0;
  while (i < size) {
    if (leftElements.first && rightElements.first) {
      if (compareFunction(leftElements.first.data, rightElements.first.data) > 0) {
        array[startIndex + i] = rightElements.shift().data;
      } else {
        array[startIndex + i] = leftElements.shift().data;
      }
    } else if (leftElements.first) {
      array[startIndex + i] = leftElements.shift().data;
    } else {
      array[startIndex + i] = rightElements.shift().data;
    }
    i += 1;
  }
  return array;
}

// node_modules/handsontable/es/plugins/columnSorting/sortService/engine.js
var DO_NOT_SWAP = 0;
var FIRST_BEFORE_SECOND = -1;
var FIRST_AFTER_SECOND = 1;
function sort(indexesWithData, rootComparatorId) {
  var rootComparator2 = getRootComparator(rootComparatorId);
  for (var _len = arguments.length, argsForRootComparator = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    argsForRootComparator[_key - 2] = arguments[_key];
  }
  mergeSort(indexesWithData, rootComparator2.apply(void 0, argsForRootComparator));
}

// node_modules/handsontable/es/plugins/columnSorting/rootComparator.js
function _toArray(arr) {
  return _arrayWithHoles10(arr) || _iterableToArray8(arr) || _nonIterableRest10();
}
function _nonIterableRest10() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArray8(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithHoles10(arr) {
  if (Array.isArray(arr)) return arr;
}
function rootComparator(sortingOrders, columnMetas) {
  return function(rowIndexWithValues, nextRowIndexWithValues) {
    var _rowIndexWithValues = _toArray(rowIndexWithValues), values = _rowIndexWithValues.slice(1);
    var _nextRowIndexWithValu = _toArray(nextRowIndexWithValues), nextValues = _nextRowIndexWithValu.slice(1);
    return function getCompareResult(column) {
      var sortingOrder = sortingOrders[column];
      var columnMeta = columnMetas[column];
      var value = values[column];
      var nextValue = nextValues[column];
      var pluginSettings = columnMeta.columnSorting;
      var compareFunctionFactory4 = pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory : getCompareFunctionFactory(columnMeta.type);
      var compareResult = compareFunctionFactory4(sortingOrder, columnMeta, pluginSettings)(value, nextValue);
      return compareResult;
    }(0);
  };
}

// node_modules/handsontable/es/plugins/columnSorting/columnSorting.js
function _typeof28(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof28 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof28 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof28(obj);
}
function _toConsumableArray8(arr) {
  return _arrayWithoutHoles8(arr) || _iterableToArray9(arr) || _nonIterableSpread8();
}
function _nonIterableSpread8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray9(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles8(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty5(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck49(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties47(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass47(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties47(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties47(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn16(self2, call) {
  if (call && (_typeof28(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized16(self2);
}
function _get8(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get8 = Reflect.get;
  } else {
    _get8 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase8(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get8(target, property, receiver || target);
}
function _superPropBase8(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf16(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf16(o) {
  _getPrototypeOf16 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf16(o);
}
function _inherits16(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf16(subClass, superClass);
}
function _setPrototypeOf16(o, p) {
  _setPrototypeOf16 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf16(o, p);
}
function _assertThisInitialized16(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var APPEND_COLUMN_CONFIG_STRATEGY = "append";
var REPLACE_COLUMN_CONFIG_STRATEGY = "replace";
var PLUGIN_KEY = "columnSorting";
registerRootComparator(PLUGIN_KEY, rootComparator);
pluginHooks_default.getSingleton().register("beforeColumnSort");
pluginHooks_default.getSingleton().register("afterColumnSort");
var ColumnSorting = function(_BasePlugin) {
  _inherits16(ColumnSorting2, _BasePlugin);
  function ColumnSorting2(hotInstance) {
    var _this2;
    _classCallCheck49(this, ColumnSorting2);
    _this2 = _possibleConstructorReturn16(this, _getPrototypeOf16(ColumnSorting2).call(this, hotInstance));
    _this2.columnStatesManager = new ColumnStatesManager();
    _this2.rowsMapper = new rowsMapper_default(_assertThisInitialized16(_assertThisInitialized16(_this2)));
    _this2.blockPluginTranslation = true;
    _this2.columnMetaCache = /* @__PURE__ */ new Map();
    _this2.pluginKey = PLUGIN_KEY;
    return _this2;
  }
  _createClass47(ColumnSorting2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings()[this.pluginKey];
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this3 = this;
      if (this.enabled) {
        return;
      }
      if (isUndefined2(this.hot.getSettings().observeChanges)) {
        this.enableObserveChangesPlugin();
      }
      this.addHook("afterTrimRow", function() {
        return _this3.sortByPresetSortStates();
      });
      this.addHook("afterUntrimRow", function() {
        return _this3.sortByPresetSortStates();
      });
      this.addHook("modifyRow", function(row, source) {
        return _this3.onModifyRow(row, source);
      });
      this.addHook("unmodifyRow", function(row, source) {
        return _this3.onUnmodifyRow(row, source);
      });
      this.addHook("afterGetColHeader", function(column, TH) {
        return _this3.onAfterGetColHeader(column, TH);
      });
      this.addHook("beforeOnCellMouseDown", function(event2, coords, TD, controller) {
        return _this3.onBeforeOnCellMouseDown(event2, coords, TD, controller);
      });
      this.addHook("afterOnCellMouseDown", function(event2, target) {
        return _this3.onAfterOnCellMouseDown(event2, target);
      });
      this.addHook("afterCreateRow", function(index2, amount) {
        return _this3.onAfterCreateRow(index2, amount);
      });
      this.addHook("afterRemoveRow", function(index2, amount) {
        return _this3.onAfterRemoveRow(index2, amount);
      });
      this.addHook("afterInit", function() {
        return _this3.loadOrSortBySettings();
      });
      this.addHook("afterLoadData", function(initialLoad) {
        return _this3.onAfterLoadData(initialLoad);
      });
      this.addHook("afterCreateCol", function() {
        return _this3.onAfterCreateCol();
      });
      this.addHook("afterRemoveCol", function() {
        return _this3.onAfterRemoveCol();
      });
      if (this.hot.view) {
        this.loadOrSortBySettings();
      }
      _get8(_getPrototypeOf16(ColumnSorting2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this4 = this;
      var clearColHeader = function clearColHeader2(column, TH) {
        var headerSpanElement = getHeaderSpanElement(TH);
        if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
          return;
        }
        _this4.updateHeaderClasses(headerSpanElement);
      };
      this.hot.addHook("afterGetColHeader", clearColHeader);
      this.hot.addHookOnce("afterRender", function() {
        _this4.hot.removeHook("afterGetColHeader", clearColHeader);
      });
      this.rowsMapper.clearMap();
      _get8(_getPrototypeOf16(ColumnSorting2.prototype), "disablePlugin", this).call(this);
    }
    // DIFF - MultiColumnSorting & ColumnSorting: changed function documentation.
    /**
     * Sorts the table by chosen columns and orders.
     *
     * @param {undefined|Object} sortConfig Single column sort configuration. The configuration object contains `column` and `sortOrder` properties.
     * First of them contains visual column index, the second one contains sort order (`asc` for ascending, `desc` for descending).
     *
     * **Note**: Please keep in mind that every call of `sort` function set an entirely new sort order. Previous sort configs aren't preserved.
     *
     * @example
     * ```js
     * // sort ascending first visual column
     * hot.getPlugin('columnSorting').sort({ column: 0, sortOrder: 'asc' });
     * ```
     *
     * @fires Hooks#beforeColumnSort
     * @fires Hooks#afterColumnSort
     */
  }, {
    key: "sort",
    value: function sort2(sortConfig) {
      var _this5 = this;
      var currentSortConfig = this.getSortConfig();
      var destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
      var sortPossible = this.areValidSortConfigs(destinationSortConfigs);
      var allowSort = this.hot.runHooks("beforeColumnSort", currentSortConfig, destinationSortConfigs, sortPossible);
      if (allowSort === false) {
        return;
      }
      if (sortPossible) {
        var translateColumnToPhysical = function translateColumnToPhysical2(_ref) {
          var visualColumn = _ref.column, restOfProperties = _objectWithoutProperties(_ref, ["column"]);
          return _objectSpread2({
            column: _this5.hot.toPhysicalColumn(visualColumn)
          }, restOfProperties);
        };
        var internalSortStates = arrayMap(destinationSortConfigs, function(columnSortConfig) {
          return translateColumnToPhysical(columnSortConfig);
        });
        this.columnStatesManager.setSortStates(internalSortStates);
        this.sortByPresetSortStates();
        this.saveAllSortSettings();
        this.hot.render();
        this.hot.view.wt.draw(true);
      }
      this.hot.runHooks("afterColumnSort", currentSortConfig, this.getSortConfig(), sortPossible);
    }
    /**
     * Clear the sort performed on the table.
     */
  }, {
    key: "clearSort",
    value: function clearSort() {
      this.sort([]);
    }
    /**
     * Checks if the table is sorted (any column have to be sorted).
     *
     * @returns {Boolean}
     */
  }, {
    key: "isSorted",
    value: function isSorted() {
      return this.enabled && !this.columnStatesManager.isListOfSortedColumnsEmpty();
    }
    /**
     * Get sort configuration for particular column or for all sorted columns. Objects contain `column` and `sortOrder` properties.
     *
     * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key. They are handled by the `sort` function.
     *
     * @param {Number} [column] Visual column index.
     * @returns {undefined|Object|Array}
     */
  }, {
    key: "getSortConfig",
    value: function getSortConfig(column) {
      var _this6 = this;
      var translateColumnToVisual = function translateColumnToVisual2(_ref2) {
        var physicalColumn2 = _ref2.column, restOfProperties = _objectWithoutProperties(_ref2, ["column"]);
        return _objectSpread2({
          column: _this6.hot.toVisualColumn(physicalColumn2)
        }, restOfProperties);
      };
      if (isDefined(column)) {
        var physicalColumn = this.hot.toPhysicalColumn(column);
        var columnSortState = this.columnStatesManager.getColumnSortState(physicalColumn);
        if (isDefined(columnSortState)) {
          return translateColumnToVisual(columnSortState);
        }
        return;
      }
      var sortStates = this.columnStatesManager.getSortStates();
      return arrayMap(sortStates, function(columnState) {
        return translateColumnToVisual(columnState);
      });
    }
    /**
     * @description
     * Warn: Useful mainly for providing server side sort implementation (see in the example below). It doesn't sort the data set. It just sets sort configuration for all sorted columns.
     *
     * @example
     * ```js
     * beforeColumnSort: function(currentSortConfig, destinationSortConfigs) {
     *   const columnSortPlugin = this.getPlugin('columnSorting');
     *
     *   columnSortPlugin.setSortConfig(destinationSortConfigs);
     *
     *   // const newData = ... // Calculated data set, ie. from an AJAX call.
     *
     *   // this.loadData(newData); // Load new data set.
     *
     *   return false; // The blockade for the default sort action.
     * }```
     *
     * @param {undefined|Object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
     * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
     * sort order (`asc` for ascending, `desc` for descending).
     */
  }, {
    key: "setSortConfig",
    value: function setSortConfig(sortConfig) {
      var _this7 = this;
      var destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
      if (this.areValidSortConfigs(destinationSortConfigs)) {
        var translateColumnToPhysical = function translateColumnToPhysical2(_ref3) {
          var visualColumn = _ref3.column, restOfProperties = _objectWithoutProperties(_ref3, ["column"]);
          return _objectSpread2({
            column: _this7.hot.toPhysicalColumn(visualColumn)
          }, restOfProperties);
        };
        var internalSortStates = arrayMap(destinationSortConfigs, function(columnSortConfig) {
          return translateColumnToPhysical(columnSortConfig);
        });
        this.columnStatesManager.setSortStates(internalSortStates);
      }
    }
    /**
     * Get normalized sort configs.
     *
     * @private
     * @param {Object|Array} [sortConfig=[]] Single column sort configuration or full sort configuration (for all sorted columns).
     * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
     * sort order (`asc` for ascending, `desc` for descending).
     * @returns {Array}
     */
  }, {
    key: "getNormalizedSortConfigs",
    value: function getNormalizedSortConfigs() {
      var sortConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (Array.isArray(sortConfig)) {
        return sortConfig.slice(0, 1);
      }
      return [sortConfig].slice(0, 1);
    }
    /**
     * Get if sort configs are valid.
     *
     * @private
     * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
     * @returns {Boolean}
     */
  }, {
    key: "areValidSortConfigs",
    value: function areValidSortConfigs(sortConfigs) {
      if (Array.isArray(sortConfigs) === false) {
        return false;
      }
      var sortedColumns = sortConfigs.map(function(_ref4) {
        var column = _ref4.column;
        return column;
      });
      var numberOfColumns = this.hot.countCols();
      var onlyExistingVisualIndexes = sortedColumns.every(function(visualColumn) {
        return visualColumn <= numberOfColumns && visualColumn >= 0;
      });
      return areValidSortStates(sortConfigs) && onlyExistingVisualIndexes;
    }
    /**
     * Saves all sorting settings. Saving works only when {@link Options#persistentState} option is enabled.
     *
     * @private
     * @fires Hooks#persistentStateSave
     */
  }, {
    key: "saveAllSortSettings",
    value: function saveAllSortSettings() {
      var allSortSettings = this.columnStatesManager.getAllColumnsProperties();
      allSortSettings.initialConfig = this.columnStatesManager.getSortStates();
      this.hot.runHooks("persistentStateSave", "columnSorting", allSortSettings);
    }
    /**
     * Get all saved sorting settings. Loading works only when {@link Options#persistentState} option is enabled.
     *
     * @private
     * @returns {Object} Previously saved sort settings.
     *
     * @fires Hooks#persistentStateLoad
     */
  }, {
    key: "getAllSavedSortSettings",
    value: function getAllSavedSortSettings() {
      var _this8 = this;
      var storedAllSortSettings = {};
      this.hot.runHooks("persistentStateLoad", "columnSorting", storedAllSortSettings);
      var allSortSettings = storedAllSortSettings.value;
      var translateColumnToVisual = function translateColumnToVisual2(_ref5) {
        var physicalColumn = _ref5.column, restOfProperties = _objectWithoutProperties(_ref5, ["column"]);
        return _objectSpread2({
          column: _this8.hot.toVisualColumn(physicalColumn)
        }, restOfProperties);
      };
      if (isDefined(allSortSettings) && Array.isArray(allSortSettings.initialConfig)) {
        allSortSettings.initialConfig = arrayMap(allSortSettings.initialConfig, translateColumnToVisual);
      }
      return allSortSettings;
    }
    /**
     * Get next sort configuration for particular column. Object contain `column` and `sortOrder` properties.
     *
     * **Note**: Please keep in mind that returned object expose **visual** column index under the `column` key.
     *
     * @private
     * @param {Number} column Visual column index.
     * @returns {undefined|Object}
     */
  }, {
    key: "getColumnNextConfig",
    value: function getColumnNextConfig(column) {
      var physicalColumn = this.hot.toPhysicalColumn(column);
      if (this.columnStatesManager.isColumnSorted(physicalColumn)) {
        var columnSortConfig = this.getSortConfig(column);
        var sortOrder = getNextSortOrder(columnSortConfig.sortOrder);
        if (isDefined(sortOrder)) {
          columnSortConfig.sortOrder = sortOrder;
          return columnSortConfig;
        }
        return;
      }
      var nrOfColumns = this.hot.countCols();
      if (Number.isInteger(column) && column >= 0 && column < nrOfColumns) {
        return {
          column,
          sortOrder: getNextSortOrder()
        };
      }
    }
    /**
     * Get sort configuration with "next order" for particular column.
     *
     * @private
     * @param {Number} columnToChange Visual column index of column which order will be changed.
     * @param {String} strategyId ID of strategy. Possible values: 'append' and 'replace'. The first one
     * change order of particular column and change it's position in the sort queue to the last one. The second one
     * just change order of particular column.
     *
     * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
     *
     * @returns {Array}
     */
  }, {
    key: "getNextSortConfig",
    value: function getNextSortConfig(columnToChange) {
      var strategyId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : APPEND_COLUMN_CONFIG_STRATEGY;
      var physicalColumn = this.hot.toPhysicalColumn(columnToChange);
      var indexOfColumnToChange = this.columnStatesManager.getIndexOfColumnInSortQueue(physicalColumn);
      var isColumnSorted = this.columnStatesManager.isColumnSorted(physicalColumn);
      var currentSortConfig = this.getSortConfig();
      var nextColumnConfig = this.getColumnNextConfig(columnToChange);
      if (isColumnSorted) {
        if (isUndefined2(nextColumnConfig)) {
          return [].concat(_toConsumableArray8(currentSortConfig.slice(0, indexOfColumnToChange)), _toConsumableArray8(currentSortConfig.slice(indexOfColumnToChange + 1)));
        }
        if (strategyId === APPEND_COLUMN_CONFIG_STRATEGY) {
          return [].concat(_toConsumableArray8(currentSortConfig.slice(0, indexOfColumnToChange)), _toConsumableArray8(currentSortConfig.slice(indexOfColumnToChange + 1)), [nextColumnConfig]);
        } else if (strategyId === REPLACE_COLUMN_CONFIG_STRATEGY) {
          return [].concat(_toConsumableArray8(currentSortConfig.slice(0, indexOfColumnToChange)), [nextColumnConfig], _toConsumableArray8(currentSortConfig.slice(indexOfColumnToChange + 1)));
        }
      }
      if (isDefined(nextColumnConfig)) {
        return currentSortConfig.concat(nextColumnConfig);
      }
      return currentSortConfig;
    }
    /**
     * Saves to cache part of plugins related properties, properly merged from cascade settings.
     *
     * @private
     * @param {Number} column Visual column index.
     * @returns {Object}
     */
    // TODO: Workaround. Inheriting of non-primitive cell meta values doesn't work. Using this function we don't count
    // merged properties few times.
  }, {
    key: "setMergedPluginSettings",
    value: function setMergedPluginSettings(column) {
      var physicalColumnIndex = this.hot.toPhysicalColumn(column);
      var pluginMainSettings = this.hot.getSettings()[this.pluginKey];
      var storedColumnProperties = this.columnStatesManager.getAllColumnsProperties();
      var cellMeta = this.hot.getCellMeta(0, column);
      var columnMeta = Object.getPrototypeOf(cellMeta);
      var columnMetaHasPluginSettings = Object.hasOwnProperty.call(columnMeta, this.pluginKey);
      var pluginColumnConfig = columnMetaHasPluginSettings ? columnMeta[this.pluginKey] : {};
      this.columnMetaCache.set(physicalColumnIndex, Object.assign(storedColumnProperties, pluginMainSettings, pluginColumnConfig));
    }
    /**
     * Get copy of settings for first cell in the column.
     *
     * @private
     * @param {Number} column Visual column index.
     * @returns {Object}
     */
    // TODO: Workaround. Inheriting of non-primitive cell meta values doesn't work. Instead of getting properties from
    // column meta we call this function.
  }, {
    key: "getFirstCellSettings",
    value: function getFirstCellSettings(column) {
      var actualBlockTranslationFlag = this.blockPluginTranslation;
      this.blockPluginTranslation = true;
      if (this.columnMetaCache.size === 0 || this.columnMetaCache.size < this.hot.countCols()) {
        this.rebuildColumnMetaCache();
      }
      var cellMeta = this.hot.getCellMeta(0, column);
      this.blockPluginTranslation = actualBlockTranslationFlag;
      var cellMetaCopy = Object.create(cellMeta);
      cellMetaCopy[this.pluginKey] = this.columnMetaCache.get(this.hot.toPhysicalColumn(column));
      return cellMetaCopy;
    }
    /**
     * Rebuild the column meta cache for all the columns.
     *
     * @private
     */
  }, {
    key: "rebuildColumnMetaCache",
    value: function rebuildColumnMetaCache() {
      var _this9 = this;
      var numberOfColumns = this.hot.countCols();
      if (numberOfColumns === 0) {
        this.columnMetaCache.clear();
      } else {
        rangeEach(numberOfColumns - 1, function(visualColumnIndex) {
          return _this9.setMergedPluginSettings(visualColumnIndex);
        });
      }
    }
    /**
     * Get number of rows which should be sorted.
     *
     * @private
     * @param {Number} numberOfRows Total number of displayed rows.
     * @returns {Number}
     */
  }, {
    key: "getNumberOfRowsToSort",
    value: function getNumberOfRowsToSort(numberOfRows) {
      var settings = this.hot.getSettings();
      if (settings.maxRows <= numberOfRows) {
        return settings.maxRows;
      }
      return numberOfRows - settings.minSpareRows;
    }
    /**
     * Performs the sorting using a stable sort function basing on internal state of sorting.
     *
     * @private
     */
  }, {
    key: "sortByPresetSortStates",
    value: function sortByPresetSortStates() {
      var _this10 = this;
      if (this.columnStatesManager.isListOfSortedColumnsEmpty()) {
        this.rowsMapper.clearMap();
        return;
      }
      var indexesWithData = [];
      var sortedColumnsList = this.columnStatesManager.getSortedColumns();
      var numberOfRows = this.hot.countRows();
      this.blockPluginTranslation = true;
      var getDataForSortedColumns = function getDataForSortedColumns2(visualRowIndex2) {
        return arrayMap(sortedColumnsList, function(physicalColumn) {
          return _this10.hot.getDataAtCell(visualRowIndex2, _this10.hot.toVisualColumn(physicalColumn));
        });
      };
      for (var visualRowIndex = 0; visualRowIndex < this.getNumberOfRowsToSort(numberOfRows); visualRowIndex += 1) {
        indexesWithData.push([visualRowIndex].concat(getDataForSortedColumns(visualRowIndex)));
      }
      sort(indexesWithData, this.pluginKey, arrayMap(sortedColumnsList, function(physicalColumn) {
        return _this10.columnStatesManager.getSortOrderOfColumn(physicalColumn);
      }), arrayMap(sortedColumnsList, function(physicalColumn) {
        return _this10.getFirstCellSettings(_this10.hot.toVisualColumn(physicalColumn));
      }));
      for (var _visualRowIndex = indexesWithData.length; _visualRowIndex < numberOfRows; _visualRowIndex += 1) {
        indexesWithData.push([_visualRowIndex].concat(getDataForSortedColumns(_visualRowIndex)));
      }
      this.blockPluginTranslation = false;
      this.rowsMapper._arrayMap = arrayMap(indexesWithData, function(indexWithData) {
        return indexWithData[0];
      });
    }
    /**
     * Load saved settings or sort by predefined plugin configuration.
     *
     * @private
     */
  }, {
    key: "loadOrSortBySettings",
    value: function loadOrSortBySettings() {
      this.columnMetaCache.clear();
      var storedAllSortSettings = this.getAllSavedSortSettings();
      if (isObject(storedAllSortSettings)) {
        this.sortBySettings(storedAllSortSettings);
      } else {
        var allSortSettings = this.hot.getSettings()[this.pluginKey];
        this.sortBySettings(allSortSettings);
      }
    }
    /**
     * Sort the table by provided configuration.
     *
     * @private
     * @param {Object} allSortSettings All sort config settings. Object may contain `initialConfig`, `indicator`,
     * `sortEmptyCells`, `headerAction` and `compareFunctionFactory` properties.
     */
  }, {
    key: "sortBySettings",
    value: function sortBySettings(allSortSettings) {
      if (isObject(allSortSettings)) {
        this.columnStatesManager.updateAllColumnsProperties(allSortSettings);
        var initialConfig = allSortSettings.initialConfig;
        if (Array.isArray(initialConfig) || isObject(initialConfig)) {
          this.sort(initialConfig);
        }
      } else {
        this.hot.render();
      }
    }
    /**
     * Enables the ObserveChanges plugin.
     *
     * @private
     */
  }, {
    key: "enableObserveChangesPlugin",
    value: function enableObserveChangesPlugin() {
      var _this = this;
      this.hot._registerTimeout(setTimeout(function() {
        _this.hot.updateSettings({
          observeChanges: true
        });
      }, 0));
    }
    /**
     * Callback for `modifyRow` hook. Translates visual row index to the sorted row index.
     *
     * @private
     * @param {Number} row Visual row index.
     * @returns {Number} Physical row index.
     */
  }, {
    key: "onModifyRow",
    value: function onModifyRow(row, source) {
      if (this.blockPluginTranslation === false && source !== this.pluginName && this.isSorted()) {
        var rowInMapper = this.rowsMapper.getValueByIndex(row);
        row = rowInMapper === null ? row : rowInMapper;
      }
      return row;
    }
    /**
     * Callback for `unmodifyRow` hook. Translates sorted row index to visual row index.
     *
     * @private
     * @param {Number} row Physical row index.
     * @returns {Number} Visual row index.
     */
  }, {
    key: "onUnmodifyRow",
    value: function onUnmodifyRow(row, source) {
      if (this.blockPluginTranslation === false && source !== this.pluginName && this.isSorted()) {
        row = this.rowsMapper.getIndexByValue(row);
      }
      return row;
    }
    /**
     * Callback for the `onAfterGetColHeader` hook. Adds column sorting CSS classes.
     *
     * @private
     * @param {Number} column Visual column index.
     * @param {Element} TH TH HTML element.
     */
  }, {
    key: "onAfterGetColHeader",
    value: function onAfterGetColHeader(column, TH) {
      var headerSpanElement = getHeaderSpanElement(TH);
      if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
        return;
      }
      var physicalColumn = this.hot.toPhysicalColumn(column);
      var pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
      var showSortIndicator = pluginSettingsForColumn.indicator;
      var headerActionEnabled = pluginSettingsForColumn.headerAction;
      this.updateHeaderClasses(headerSpanElement, this.columnStatesManager, physicalColumn, showSortIndicator, headerActionEnabled);
    }
    /**
     * Update header classes.
     *
     * @private
     * @param {HTMLElement} headerSpanElement Header span element.
     * @param {...*} args Extra arguments for helpers.
     */
  }, {
    key: "updateHeaderClasses",
    value: function updateHeaderClasses(headerSpanElement) {
      removeClass(headerSpanElement, getClassedToRemove(headerSpanElement));
      if (this.enabled !== false) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        addClass(headerSpanElement, getClassesToAdd.apply(void 0, args));
      }
    }
    /**
     * Overwriting base plugin's `onUpdateSettings` method. Please keep in mind that `onAfterUpdateSettings` isn't called
     * for `updateSettings` in specific situations.
     *
     * @private
     * @param {Object} newSettings New settings object.
     */
  }, {
    key: "onUpdateSettings",
    value: function onUpdateSettings(newSettings) {
      _get8(_getPrototypeOf16(ColumnSorting2.prototype), "onUpdateSettings", this).call(this);
      this.columnMetaCache.clear();
      if (isDefined(newSettings[this.pluginKey])) {
        this.sortBySettings(newSettings[this.pluginKey]);
      }
    }
    /**
     * Callback for the `afterLoadData` hook.
     *
     * @private
     * @param {Boolean} initialLoad flag that determines whether the data has been loaded during the initialization.
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(initialLoad) {
      this.rowsMapper.clearMap();
      this.columnMetaCache.clear();
      if (initialLoad === true) {
        if (this.hot.view) {
          this.loadOrSortBySettings();
        }
      }
    }
    /**
     * Callback for the `afterCreateRow` hook.
     *
     * @private
     * @param {Number} index Visual index of the created row.
     * @param {Number} amount Amount of created rows.
     */
  }, {
    key: "onAfterCreateRow",
    value: function onAfterCreateRow(index2, amount) {
      this.rowsMapper.shiftItems(index2, amount);
    }
    /**
     * Callback for the `afterRemoveRow` hook.
     *
     * @private
     * @param {Number} removedRows Visual indexes of the removed row.
     * @param {Number} amount  Amount of removed rows.
     */
  }, {
    key: "onAfterRemoveRow",
    value: function onAfterRemoveRow(removedRows, amount) {
      this.rowsMapper.unshiftItems(removedRows, amount);
    }
    // TODO: Workaround. Inheriting of non-primitive cell meta values doesn't work. We clear the cache after action which reorganize sequence of columns.
    // TODO: Remove test named: "should add new columns properly when the `columnSorting` plugin is enabled (inheriting of non-primitive cell meta values)".
    /**
     * Callback for the `afterCreateCol` hook.
     *
     * @private
     */
  }, {
    key: "onAfterCreateCol",
    value: function onAfterCreateCol() {
      this.columnMetaCache.clear();
    }
    // TODO: Workaround. Inheriting of non-primitive cell meta values doesn't work. We clear the cache after action which reorganize sequence of columns.
    // TODO: Remove test named: "should add new columns properly when the `columnSorting` plugin is enabled (inheriting of non-primitive cell meta values)".
    /**
     * Callback for the `afterRemoveCol` hook.
     *
     * @private
     */
  }, {
    key: "onAfterRemoveCol",
    value: function onAfterRemoveCol() {
      this.columnMetaCache.clear();
    }
    /**
     * Indicates if clickable header was clicked.
     *
     * @private
     * @param {MouseEvent} event The `mousedown` event.
     * @param {Number} column Visual column index.
     * @returns {Boolean}
     */
  }, {
    key: "wasClickableHeaderClicked",
    value: function wasClickableHeaderClicked(event2, column) {
      var pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
      var headerActionEnabled = pluginSettingsForColumn.headerAction;
      return headerActionEnabled && event2.realTarget.nodeName === "SPAN";
    }
    /**
     * Changes the behavior of selection / dragging.
     *
     * @private
     * @param {MouseEvent} event The `mousedown` event.
     * @param {CellCoords} coords Visual coordinates.
     * @param {HTMLElement} TD
     * @param {Object} blockCalculations
     */
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event2, coords, TD, blockCalculations) {
      if (wasHeaderClickedProperly(coords.row, coords.col, event2) === false) {
        return;
      }
      if (this.wasClickableHeaderClicked(event2, coords.col) && isPressedCtrlKey()) {
        blockCalculations.column = true;
      }
    }
    /**
     * Callback for the `onAfterOnCellMouseDown` hook.
     *
     * @private
     * @param {Event} event Event which are provided by hook.
     * @param {CellCoords} coords Visual coords of the selected cell.
     */
  }, {
    key: "onAfterOnCellMouseDown",
    value: function onAfterOnCellMouseDown(event2, coords) {
      if (wasHeaderClickedProperly(coords.row, coords.col, event2) === false) {
        return;
      }
      if (this.wasClickableHeaderClicked(event2, coords.col)) {
        if (isPressedCtrlKey()) {
          this.hot.deselectCell();
          this.hot.selectColumns(coords.col);
        }
        this.sort(this.getColumnNextConfig(coords.col));
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.rowsMapper.destroy();
      this.columnStatesManager.destroy();
      _get8(_getPrototypeOf16(ColumnSorting2.prototype), "destroy", this).call(this);
    }
  }]);
  return ColumnSorting2;
}(base_default2);
registerPlugin(PLUGIN_KEY, ColumnSorting);
var columnSorting_default = ColumnSorting;

// node_modules/handsontable/es/plugins/comments/commentEditor.js
function _classCallCheck50(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties48(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass48(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties48(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties48(Constructor, staticProps);
  return Constructor;
}
var CommentEditor = function() {
  _createClass48(CommentEditor2, null, [{
    key: "CLASS_EDITOR_CONTAINER",
    get: function get5() {
      return "htCommentsContainer";
    }
  }, {
    key: "CLASS_EDITOR",
    get: function get5() {
      return "htComments";
    }
  }, {
    key: "CLASS_INPUT",
    get: function get5() {
      return "htCommentTextArea";
    }
  }, {
    key: "CLASS_CELL",
    get: function get5() {
      return "htCommentCell";
    }
  }]);
  function CommentEditor2() {
    _classCallCheck50(this, CommentEditor2);
    this.editor = this.createEditor();
    this.editorStyle = this.editor.style;
    this.hidden = true;
    this.hide();
  }
  _createClass48(CommentEditor2, [{
    key: "setPosition",
    value: function setPosition(x, y) {
      this.editorStyle.left = "".concat(x, "px");
      this.editorStyle.top = "".concat(y, "px");
    }
    /**
     * Set the editor size according to the provided arguments.
     *
     * @param {Number} width Width in pixels.
     * @param {Number} height Height in pixels.
     */
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      if (width && height) {
        var input = this.getInputElement();
        input.style.width = "".concat(width, "px");
        input.style.height = "".concat(height, "px");
      }
    }
    /**
     * Reset the editor size to its initial state.
     */
  }, {
    key: "resetSize",
    value: function resetSize() {
      var input = this.getInputElement();
      input.style.width = "";
      input.style.height = "";
    }
    /**
     * Set the read-only state for the comments editor.
     *
     * @param {Boolean} state The new read only state.
     */
  }, {
    key: "setReadOnlyState",
    value: function setReadOnlyState(state) {
      var input = this.getInputElement();
      input.readOnly = state;
    }
    /**
     * Show the comments editor.
     */
  }, {
    key: "show",
    value: function show() {
      this.editorStyle.display = "block";
      this.hidden = false;
    }
    /**
     * Hide the comments editor.
     */
  }, {
    key: "hide",
    value: function hide() {
      this.editorStyle.display = "none";
      this.hidden = true;
    }
    /**
     * Checks if the editor is visible.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isVisible",
    value: function isVisible2() {
      return this.editorStyle.display === "block";
    }
    /**
     * Set the comment value.
     *
     * @param {String} [value] The value to use.
     */
  }, {
    key: "setValue",
    value: function setValue() {
      var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var comment = value || "";
      this.getInputElement().value = comment;
    }
    /**
     * Get the comment value.
     *
     * @returns {String}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.getInputElement().value;
    }
    /**
     * Checks if the comment input element is focused.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isFocused",
    value: function isFocused() {
      return document.activeElement === this.getInputElement();
    }
    /**
     * Focus the comments input element.
     */
  }, {
    key: "focus",
    value: function focus() {
      this.getInputElement().focus();
    }
    /**
     * Create the `textarea` to be used as a comments editor.
     *
     * @returns {HTMLElement}
     */
  }, {
    key: "createEditor",
    value: function createEditor() {
      var editor = document.createElement("div");
      var textArea = document.createElement("textarea");
      var container = document.querySelector(".".concat(CommentEditor2.CLASS_EDITOR_CONTAINER));
      if (!container) {
        container = document.createElement("div");
        addClass(container, CommentEditor2.CLASS_EDITOR_CONTAINER);
        document.body.appendChild(container);
      }
      addClass(editor, CommentEditor2.CLASS_EDITOR);
      addClass(textArea, CommentEditor2.CLASS_INPUT);
      editor.appendChild(textArea);
      container.appendChild(editor);
      return editor;
    }
    /**
     * Get the input element.
     *
     * @returns {HTMLElement}
     */
  }, {
    key: "getInputElement",
    value: function getInputElement() {
      return this.editor.querySelector(".".concat(CommentEditor2.CLASS_INPUT));
    }
    /**
     * Destroy the comments editor.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.editor.parentNode.removeChild(this.editor);
      this.editor = null;
      this.editorStyle = null;
    }
  }]);
  return CommentEditor2;
}();
var commentEditor_default = CommentEditor;

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/separator.js
var KEY = "---------";
function separatorItem() {
  return {
    name: KEY
  };
}

// node_modules/handsontable/es/plugins/contextMenu/utils.js
function normalizeSelection(selRanges) {
  return arrayMap(selRanges, function(range) {
    return {
      start: range.getTopLeftCorner(),
      end: range.getBottomRightCorner()
    };
  });
}
function isSeparator(cell) {
  return hasClass(cell, "htSeparator");
}
function hasSubMenu(cell) {
  return hasClass(cell, "htSubmenu");
}
function isDisabled(cell) {
  return hasClass(cell, "htDisabled");
}
function isSelectionDisabled(cell) {
  return hasClass(cell, "htSelectionDisabled");
}
function getValidSelection(hot) {
  var selected = hot.getSelected();
  if (!selected) {
    return null;
  }
  if (selected[0] < 0) {
    return null;
  }
  return selected;
}
function prepareVerticalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  var replacedClassName = className.replace("htTop", "").replace("htMiddle", "").replace("htBottom", "").replace("  ", "");
  return "".concat(replacedClassName, " ").concat(alignment);
}
function prepareHorizontalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  var replacedClassName = className.replace("htLeft", "").replace("htCenter", "").replace("htRight", "").replace("htJustify", "").replace("  ", "");
  return "".concat(replacedClassName, " ").concat(alignment);
}
function getAlignmentClasses(ranges, callback) {
  var classes = {};
  arrayEach(ranges, function(_ref) {
    var from3 = _ref.from, to3 = _ref.to;
    for (var row = from3.row; row <= to3.row; row++) {
      for (var col = from3.col; col <= to3.col; col++) {
        if (!classes[row]) {
          classes[row] = [];
        }
        classes[row][col] = callback(row, col);
      }
    }
  });
  return classes;
}
function align(ranges, type, alignment, cellDescriptor, propertySetter) {
  arrayEach(ranges, function(_ref2) {
    var from3 = _ref2.from, to3 = _ref2.to;
    if (from3.row === to3.row && from3.col === to3.col) {
      applyAlignClassName(from3.row, from3.col, type, alignment, cellDescriptor, propertySetter);
    } else {
      for (var row = from3.row; row <= to3.row; row++) {
        for (var col = from3.col; col <= to3.col; col++) {
          applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter);
        }
      }
    }
  });
}
function applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter) {
  var cellMeta = cellDescriptor(row, col);
  var className = alignment;
  if (cellMeta.className) {
    if (type === "vertical") {
      className = prepareVerticalAlignClass(cellMeta.className, alignment);
    } else {
      className = prepareHorizontalAlignClass(cellMeta.className, alignment);
    }
  }
  propertySetter(row, col, "className", className);
}
function checkSelectionConsistency(ranges, comparator) {
  var result = false;
  if (Array.isArray(ranges)) {
    arrayEach(ranges, function(range) {
      range.forAll(function(row, col) {
        if (comparator(row, col)) {
          result = true;
          return false;
        }
      });
      return result;
    });
  }
  return result;
}
function markLabelAsSelected(label) {
  return '<span class="selected">'.concat(String.fromCharCode(10003), "</span>").concat(label);
}
function isItemHidden(item, instance) {
  return !item.hidden || !(typeof item.hidden === "function" && item.hidden.call(instance));
}
function shiftSeparators(items, separator) {
  var result = items.slice(0);
  for (var i = 0; i < result.length; ) {
    if (result[i].name === separator) {
      result.shift();
    } else {
      break;
    }
  }
  return result;
}
function popSeparators(items, separator) {
  var result = items.slice(0);
  result.reverse();
  result = shiftSeparators(result, separator);
  result.reverse();
  return result;
}
function removeDuplicatedSeparators(items) {
  var result = [];
  arrayEach(items, function(value, index2) {
    if (index2 > 0) {
      if (result[result.length - 1].name !== value.name) {
        result.push(value);
      }
    } else {
      result.push(value);
    }
  });
  return result;
}
function filterSeparators(items) {
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : KEY;
  var result = items.slice(0);
  result = shiftSeparators(result, separator);
  result = popSeparators(result, separator);
  result = removeDuplicatedSeparators(result);
  return result;
}

// node_modules/handsontable/es/plugins/comments/displaySwitch.js
function _classCallCheck51(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties49(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass49(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties49(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties49(Constructor, staticProps);
  return Constructor;
}
var DEFAULT_DISPLAY_DELAY = 250;
var DEFAULT_HIDE_DELAY = 250;
var DisplaySwitch = function() {
  function DisplaySwitch2(displayDelay) {
    _classCallCheck51(this, DisplaySwitch2);
    this.wasLastActionShow = true;
    this.showDebounced = null;
    this.hidingTimer = null;
    this.updateDelay(displayDelay);
  }
  _createClass49(DisplaySwitch2, [{
    key: "hide",
    value: function hide() {
      var _this = this;
      this.wasLastActionShow = false;
      this.hidingTimer = setTimeout(function() {
        if (_this.wasLastActionShow === false) {
          _this.runLocalHooks("hide");
        }
      }, DEFAULT_HIDE_DELAY);
    }
    /**
     * Responsible for showing comment after proper delay.
     *
     * @param {Object} range Coordinates of selected cell.
     */
  }, {
    key: "show",
    value: function show(range) {
      this.wasLastActionShow = true;
      this.showDebounced(range);
    }
    /**
     * Cancel hiding comment.
     */
  }, {
    key: "cancelHiding",
    value: function cancelHiding() {
      this.wasLastActionShow = true;
      clearTimeout(this.hidingTimer);
      this.hidingTimer = null;
    }
    /**
     * Update the switch settings.
     *
     * @param {Number} displayDelay Delay of showing the comments (in milliseconds).
     */
  }, {
    key: "updateDelay",
    value: function updateDelay() {
      var _this2 = this;
      var displayDelay = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_DISPLAY_DELAY;
      this.showDebounced = debounce(function(range) {
        if (_this2.wasLastActionShow) {
          _this2.runLocalHooks("show", range.from.row, range.from.col);
        }
      }, displayDelay);
    }
    /**
     * Destroy the switcher.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.clearLocalHooks();
    }
  }]);
  return DisplaySwitch2;
}();
mixin(DisplaySwitch, localHooks_default);
var displaySwitch_default = DisplaySwitch;

// node_modules/handsontable/es/plugins/comments/comments.js
function _typeof29(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof29 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof29 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof29(obj);
}
function _defineProperty6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck52(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties50(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass50(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties50(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties50(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn17(self2, call) {
  if (call && (_typeof29(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized17(self2);
}
function _get9(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get9 = Reflect.get;
  } else {
    _get9 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase9(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get9(target, property, receiver || target);
}
function _superPropBase9(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf17(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf17(o) {
  _getPrototypeOf17 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf17(o);
}
function _inherits17(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf17(subClass, superClass);
}
function _setPrototypeOf17(o, p) {
  _setPrototypeOf17 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf17(o, p);
}
function _assertThisInitialized17(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var privatePool6 = /* @__PURE__ */ new WeakMap();
var META_COMMENT = "comment";
var META_COMMENT_VALUE = "value";
var META_STYLE = "style";
var META_READONLY = "readOnly";
var Comments = function(_BasePlugin) {
  _inherits17(Comments2, _BasePlugin);
  function Comments2(hotInstance) {
    var _this;
    _classCallCheck52(this, Comments2);
    _this = _possibleConstructorReturn17(this, _getPrototypeOf17(Comments2).call(this, hotInstance));
    _this.editor = null;
    _this.displaySwitch = null;
    _this.eventManager = null;
    _this.range = {};
    _this.mouseDown = false;
    _this.contextMenuEvent = false;
    _this.timer = null;
    privatePool6.set(_assertThisInitialized17(_assertThisInitialized17(_this)), {
      tempEditorDimensions: {},
      cellBelowCursor: null
    });
    return _this;
  }
  _createClass50(Comments2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings().comments;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      if (!this.editor) {
        this.editor = new commentEditor_default();
      }
      if (!this.eventManager) {
        this.eventManager = new eventManager_default(this);
      }
      if (!this.displaySwitch) {
        this.displaySwitch = new displaySwitch_default(this.getDisplayDelaySetting());
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.addToContextMenu(options);
      });
      this.addHook("afterRenderer", function(TD, row, col, prop, value, cellProperties) {
        return _this2.onAfterRenderer(TD, cellProperties);
      });
      this.addHook("afterScrollHorizontally", function() {
        return _this2.hide();
      });
      this.addHook("afterScrollVertically", function() {
        return _this2.hide();
      });
      this.addHook("afterBeginEditing", function() {
        return _this2.onAfterBeginEditing();
      });
      this.displaySwitch.addLocalHook("hide", function() {
        return _this2.hide();
      });
      this.displaySwitch.addLocalHook("show", function(row, col) {
        return _this2.showAtCell(row, col);
      });
      this.registerListeners();
      _get9(_getPrototypeOf17(Comments2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get9(_getPrototypeOf17(Comments2.prototype), "updatePlugin", this).call(this);
      this.displaySwitch.updateDelay(this.getDisplayDelaySetting());
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get9(_getPrototypeOf17(Comments2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Registers all necessary DOM listeners.
     *
     * @private
     */
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this3 = this;
      this.eventManager.addEventListener(document, "mouseover", function(event2) {
        return _this3.onMouseOver(event2);
      });
      this.eventManager.addEventListener(document, "mousedown", function(event2) {
        return _this3.onMouseDown(event2);
      });
      this.eventManager.addEventListener(document, "mouseup", function() {
        return _this3.onMouseUp();
      });
      this.eventManager.addEventListener(this.editor.getInputElement(), "blur", function() {
        return _this3.onEditorBlur();
      });
      this.eventManager.addEventListener(this.editor.getInputElement(), "mousedown", function(event2) {
        return _this3.onEditorMouseDown(event2);
      });
      this.eventManager.addEventListener(this.editor.getInputElement(), "mouseup", function(event2) {
        return _this3.onEditorMouseUp(event2);
      });
    }
    /**
     * Sets the current cell range to be able to use general methods like {@link Comments#setComment}, {@link Comments#removeComment}, {@link Comments#show}.
     *
     * @param {Object} range Object with `from` property, each with `row` and `col` properties.
     */
  }, {
    key: "setRange",
    value: function setRange(range) {
      this.range = range;
    }
    /**
     * Clears the currently selected cell.
     */
  }, {
    key: "clearRange",
    value: function clearRange() {
      this.range = {};
    }
    /**
     * Checks if the event target is a cell containing a comment.
     *
     * @private
     * @param {Event} event DOM event
     * @returns {Boolean}
     */
  }, {
    key: "targetIsCellWithComment",
    value: function targetIsCellWithComment(event2) {
      var closestCell = closest(event2.target, "TD", "TBODY");
      return !!(closestCell && hasClass(closestCell, "htCommentCell") && closest(closestCell, [this.hot.rootElement]));
    }
    /**
     * Checks if the event target is a comment textarea.
     *
     * @private
     * @param {Event} event DOM event.
     * @returns {Boolean}
     */
  }, {
    key: "targetIsCommentTextArea",
    value: function targetIsCommentTextArea(event2) {
      return this.editor.getInputElement() === event2.target;
    }
    /**
     * Sets a comment for a cell according to the previously set range (see {@link Comments#setRange}).
     *
     * @param {String} value Comment contents.
     */
  }, {
    key: "setComment",
    value: function setComment(value) {
      if (!this.range.from) {
        throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
      }
      var editorValue = this.editor.getValue();
      var comment = "";
      if (value !== null && value !== void 0) {
        comment = value;
      } else if (editorValue !== null && editorValue !== void 0) {
        comment = editorValue;
      }
      var row = this.range.from.row;
      var col = this.range.from.col;
      this.updateCommentMeta(row, col, _defineProperty6({}, META_COMMENT_VALUE, comment));
      this.hot.render();
    }
    /**
     * Sets a comment for a specified cell.
     *
     * @param {Number} row Visual row index.
     * @param {Number} column Visual column index.
     * @param {String} value Comment contents.
     */
  }, {
    key: "setCommentAtCell",
    value: function setCommentAtCell(row, column, value) {
      this.setRange({
        from: new coords_default(row, column)
      });
      this.setComment(value);
    }
    /**
     * Removes a comment from a cell according to previously set range (see {@link Comments#setRange}).
     *
     * @param {Boolean} [forceRender=true] If set to `true`, the table will be re-rendered at the end of the operation.
     */
  }, {
    key: "removeComment",
    value: function removeComment() {
      var forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!this.range.from) {
        throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
      }
      this.hot.setCellMeta(this.range.from.row, this.range.from.col, META_COMMENT, void 0);
      if (forceRender) {
        this.hot.render();
      }
      this.hide();
    }
    /**
     * Removes a comment from a specified cell.
     *
     * @param {Number} row Visual row index.
     * @param {Number} column Visual column index.
     * @param {Boolean} [forceRender=true] If `true`, the table will be re-rendered at the end of the operation.
     */
  }, {
    key: "removeCommentAtCell",
    value: function removeCommentAtCell(row, column) {
      var forceRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      this.setRange({
        from: new coords_default(row, column)
      });
      this.removeComment(forceRender);
    }
    /**
     * Gets comment from a cell according to previously set range (see {@link Comments#setRange}).
     *
     * @returns {String|undefined} Returns a content of the comment.
     */
  }, {
    key: "getComment",
    value: function getComment() {
      var row = this.range.from.row;
      var column = this.range.from.col;
      return this.getCommentMeta(row, column, META_COMMENT_VALUE);
    }
    /**
     * Gets comment from a cell at the provided coordinates.
     *
     * @param {Number} row Visual row index.
     * @param {Number} column Visual column index.
     * @returns {String|undefined} Returns a content of the comment.
     */
  }, {
    key: "getCommentAtCell",
    value: function getCommentAtCell(row, column) {
      return this.getCommentMeta(row, column, META_COMMENT_VALUE);
    }
    /**
     * Shows the comment editor accordingly to the previously set range (see {@link Comments#setRange}).
     *
     * @returns {Boolean} Returns `true` if comment editor was shown.
     */
  }, {
    key: "show",
    value: function show() {
      if (!this.range.from) {
        throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
      }
      var meta = this.hot.getCellMeta(this.range.from.row, this.range.from.col);
      this.refreshEditor(true);
      this.editor.setValue(meta[META_COMMENT] ? meta[META_COMMENT][META_COMMENT_VALUE] : "");
      if (this.editor.hidden) {
        this.editor.show();
      }
      return true;
    }
    /**
     * Shows comment editor according to cell coordinates.
     *
     * @param {Number} row Visual row index.
     * @param {Number} column Visual column index.
     * @returns {Boolean} Returns `true` if comment editor was shown.
     */
  }, {
    key: "showAtCell",
    value: function showAtCell(row, column) {
      this.setRange({
        from: new coords_default(row, column)
      });
      return this.show();
    }
    /**
     * Hides the comment editor.
     */
  }, {
    key: "hide",
    value: function hide() {
      if (!this.editor.hidden) {
        this.editor.hide();
      }
    }
    /**
     * Refreshes comment editor position and styling.
     *
     * @param {Boolean} [force=false] If `true` then recalculation will be forced.
     */
  }, {
    key: "refreshEditor",
    value: function refreshEditor() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!force && (!this.range.from || !this.editor.isVisible())) {
        return;
      }
      var scrollableElement = getScrollableElement(this.hot.view.wt.wtTable.TABLE);
      var TD = this.hot.view.wt.wtTable.getCell(this.range.from);
      var row = this.range.from.row;
      var column = this.range.from.col;
      var cellOffset = offset(TD);
      var lastColWidth = this.hot.view.wt.wtTable.getStretchedColumnWidth(column);
      var cellTopOffset = cellOffset.top < 0 ? 0 : cellOffset.top;
      var cellLeftOffset = cellOffset.left;
      if (this.hot.view.wt.wtViewport.hasVerticalScroll() && scrollableElement !== window) {
        cellTopOffset -= this.hot.view.wt.wtOverlays.topOverlay.getScrollPosition();
      }
      if (this.hot.view.wt.wtViewport.hasHorizontalScroll() && scrollableElement !== window) {
        cellLeftOffset -= this.hot.view.wt.wtOverlays.leftOverlay.getScrollPosition();
      }
      var x = cellLeftOffset + lastColWidth;
      var y = cellTopOffset;
      var commentStyle = this.getCommentMeta(row, column, META_STYLE);
      var readOnly = this.getCommentMeta(row, column, META_READONLY);
      if (commentStyle) {
        this.editor.setSize(commentStyle.width, commentStyle.height);
      } else {
        this.editor.resetSize();
      }
      this.editor.setReadOnlyState(readOnly);
      this.editor.setPosition(x, y);
    }
    /**
     * Checks if there is a comment for selected range.
     *
     * @private
     * @returns {Boolean}
     */
  }, {
    key: "checkSelectionCommentsConsistency",
    value: function checkSelectionCommentsConsistency() {
      var selected = this.hot.getSelectedRangeLast();
      if (!selected) {
        return false;
      }
      var hasComment = false;
      var cell = selected.from;
      if (this.getCommentMeta(cell.row, cell.col, META_COMMENT_VALUE)) {
        hasComment = true;
      }
      return hasComment;
    }
    /**
     * Sets or update the comment-related cell meta.
     *
     * @param {Number} row Visual row index.
     * @param {Number} column Visual column index.
     * @param {Object} metaObject Object defining all the comment-related meta information.
     */
  }, {
    key: "updateCommentMeta",
    value: function updateCommentMeta(row, column, metaObject) {
      var oldComment = this.hot.getCellMeta(row, column)[META_COMMENT];
      var newComment;
      if (oldComment) {
        newComment = deepClone(oldComment);
        deepExtend(newComment, metaObject);
      } else {
        newComment = metaObject;
      }
      this.hot.setCellMeta(row, column, META_COMMENT, newComment);
    }
    /**
     * Gets the comment related meta information.
     *
     * @param {Number} row Visual row index.
     * @param {Number} column Visual column index.
     * @param {String} property Cell meta property.
     * @returns {Mixed}
     */
  }, {
    key: "getCommentMeta",
    value: function getCommentMeta(row, column, property) {
      var cellMeta = this.hot.getCellMeta(row, column);
      if (!cellMeta[META_COMMENT]) {
        return void 0;
      }
      return cellMeta[META_COMMENT][property];
    }
    /**
     * `mousedown` event callback.
     *
     * @private
     * @param {MouseEvent} event The `mousedown` event.
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event2) {
      this.mouseDown = true;
      if (!this.hot.view || !this.hot.view.wt) {
        return;
      }
      if (!this.contextMenuEvent && !this.targetIsCommentTextArea(event2)) {
        var eventCell = closest(event2.target, "TD", "TBODY");
        var coordinates = null;
        if (eventCell) {
          coordinates = this.hot.view.wt.wtTable.getCoords(eventCell);
        }
        if (!eventCell || this.range.from && coordinates && (this.range.from.row !== coordinates.row || this.range.from.col !== coordinates.col)) {
          this.hide();
        }
      }
      this.contextMenuEvent = false;
    }
    /**
     * `mouseover` event callback.
     *
     * @private
     * @param {MouseEvent} event The `mouseover` event.
     */
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event2) {
      var priv = privatePool6.get(this);
      priv.cellBelowCursor = document.elementFromPoint(event2.clientX, event2.clientY);
      if (this.mouseDown || this.editor.isFocused() || hasClass(event2.target, "wtBorder") || priv.cellBelowCursor !== event2.target || !this.editor) {
        return;
      }
      if (this.targetIsCellWithComment(event2)) {
        var coordinates = this.hot.view.wt.wtTable.getCoords(event2.target);
        var range = {
          from: new coords_default(coordinates.row, coordinates.col)
        };
        this.displaySwitch.show(range);
      } else if (isChildOf(event2.target, document) && !this.targetIsCommentTextArea(event2)) {
        this.displaySwitch.hide();
      }
    }
    /**
     * `mouseup` event callback.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      this.mouseDown = false;
    }
    /** *
     * The `afterRenderer` hook callback..
     *
     * @private
     * @param {HTMLTableCellElement} TD The rendered `TD` element.
     * @param {Object} cellProperties The rendered cell's property object.
     */
  }, {
    key: "onAfterRenderer",
    value: function onAfterRenderer(TD, cellProperties) {
      if (cellProperties[META_COMMENT] && cellProperties[META_COMMENT][META_COMMENT_VALUE]) {
        addClass(TD, cellProperties.commentedCellClassName);
      }
    }
    /**
     * `blur` event callback for the comment editor.
     *
     * @private
     */
  }, {
    key: "onEditorBlur",
    value: function onEditorBlur() {
      this.setComment();
    }
    /**
     * `mousedown` hook. Along with `onEditorMouseUp` used to simulate the textarea resizing event.
     *
     * @private
     * @param {MouseEvent} event The `mousedown` event.
     */
  }, {
    key: "onEditorMouseDown",
    value: function onEditorMouseDown(event2) {
      var priv = privatePool6.get(this);
      priv.tempEditorDimensions = {
        width: outerWidth(event2.target),
        height: outerHeight(event2.target)
      };
    }
    /**
     * `mouseup` hook. Along with `onEditorMouseDown` used to simulate the textarea resizing event.
     *
     * @private
     * @param {MouseEvent} event The `mouseup` event.
     */
  }, {
    key: "onEditorMouseUp",
    value: function onEditorMouseUp(event2) {
      var priv = privatePool6.get(this);
      var currentWidth = outerWidth(event2.target);
      var currentHeight = outerHeight(event2.target);
      if (currentWidth !== priv.tempEditorDimensions.width + 1 || currentHeight !== priv.tempEditorDimensions.height + 2) {
        this.updateCommentMeta(this.range.from.row, this.range.from.col, _defineProperty6({}, META_STYLE, {
          width: currentWidth,
          height: currentHeight
        }));
      }
    }
    /**
     * Context Menu's "Add comment" callback. Results in showing the comment editor.
     *
     * @private
     */
  }, {
    key: "onContextMenuAddComment",
    value: function onContextMenuAddComment() {
      var _this4 = this;
      this.displaySwitch.cancelHiding();
      var coords = this.hot.getSelectedRangeLast();
      this.contextMenuEvent = true;
      this.setRange({
        from: coords.from
      });
      this.show();
      setTimeout(function() {
        if (_this4.hot) {
          _this4.hot.deselectCell();
          _this4.editor.focus();
        }
      }, 10);
    }
    /**
     * Context Menu's "remove comment" callback.
     *
     * @private
     */
  }, {
    key: "onContextMenuRemoveComment",
    value: function onContextMenuRemoveComment() {
      var _this$hot$getSelected = this.hot.getSelectedRangeLast(), from3 = _this$hot$getSelected.from, to3 = _this$hot$getSelected.to;
      this.contextMenuEvent = true;
      for (var i = from3.row; i <= to3.row; i++) {
        for (var j = from3.col; j <= to3.col; j++) {
          this.removeCommentAtCell(i, j, false);
        }
      }
      this.hot.render();
    }
    /**
     * Context Menu's "make comment read-only" callback.
     *
     * @private
     */
  }, {
    key: "onContextMenuMakeReadOnly",
    value: function onContextMenuMakeReadOnly() {
      var _this$hot$getSelected2 = this.hot.getSelectedRangeLast(), from3 = _this$hot$getSelected2.from, to3 = _this$hot$getSelected2.to;
      this.contextMenuEvent = true;
      for (var i = from3.row; i <= to3.row; i++) {
        for (var j = from3.col; j <= to3.col; j++) {
          var currentState = !!this.getCommentMeta(i, j, META_READONLY);
          this.updateCommentMeta(i, j, _defineProperty6({}, META_READONLY, !currentState));
        }
      }
    }
    /**
     * Add Comments plugin options to the Context Menu.
     *
     * @private
     * @param {Object} defaultOptions
     */
  }, {
    key: "addToContextMenu",
    value: function addToContextMenu(defaultOptions2) {
      var _this5 = this;
      defaultOptions2.items.push({
        name: "---------"
      }, {
        key: "commentsAddEdit",
        name: function name() {
          if (_this5.checkSelectionCommentsConsistency()) {
            return _this5.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_EDIT_COMMENT);
          }
          return _this5.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_ADD_COMMENT);
        },
        callback: function callback() {
          return _this5.onContextMenuAddComment();
        },
        disabled: function disabled() {
          return !(this.getSelectedLast() && !this.selection.isSelectedByCorner());
        }
      }, {
        key: "commentsRemove",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COMMENT);
        },
        callback: function callback() {
          return _this5.onContextMenuRemoveComment();
        },
        disabled: function disabled() {
          return _this5.hot.selection.isSelectedByCorner();
        }
      }, {
        key: "commentsReadOnly",
        name: function name() {
          var _this6 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY_COMMENT);
          var hasProperty = checkSelectionConsistency(this.getSelectedRangeLast(), function(row, col) {
            var readOnlyProperty = _this6.getCellMeta(row, col)[META_COMMENT];
            if (readOnlyProperty) {
              readOnlyProperty = readOnlyProperty[META_READONLY];
            }
            if (readOnlyProperty) {
              return true;
            }
          });
          if (hasProperty) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          return _this5.onContextMenuMakeReadOnly();
        },
        disabled: function disabled() {
          return _this5.hot.selection.isSelectedByCorner() || !_this5.checkSelectionCommentsConsistency();
        }
      });
    }
    /**
     * Get `displayDelay` setting of comment plugin.
     *
     * @private
     * @returns {Number|undefined}
     */
  }, {
    key: "getDisplayDelaySetting",
    value: function getDisplayDelaySetting() {
      var commentSetting = this.hot.getSettings().comments;
      if (isObject(commentSetting)) {
        return commentSetting.displayDelay;
      }
      return void 0;
    }
    /**
     * `afterBeginEditing` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterBeginEditing",
    value: function onAfterBeginEditing() {
      this.hide();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.editor) {
        this.editor.destroy();
      }
      if (this.displaySwitch) {
        this.displaySwitch.destroy();
      }
      _get9(_getPrototypeOf17(Comments2.prototype), "destroy", this).call(this);
    }
  }]);
  return Comments2;
}(base_default2);
registerPlugin("comments", Comments);
var comments_default = Comments;

// node_modules/handsontable/es/plugins/contextMenu/commandExecutor.js
function _classCallCheck53(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties51(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass51(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties51(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties51(Constructor, staticProps);
  return Constructor;
}
var CommandExecutor = function() {
  function CommandExecutor2(hotInstance) {
    _classCallCheck53(this, CommandExecutor2);
    this.hot = hotInstance;
    this.commands = {};
    this.commonCallback = null;
  }
  _createClass51(CommandExecutor2, [{
    key: "registerCommand",
    value: function registerCommand(name, commandDescriptor) {
      this.commands[name] = commandDescriptor;
    }
    /**
     * Set common callback which will be trigger on every executed command.
     *
     * @param {Function} callback Function which will be fired on every command execute.
     */
  }, {
    key: "setCommonCallback",
    value: function setCommonCallback(callback) {
      this.commonCallback = callback;
    }
    /**
     * Execute command by its name.
     *
     * @param {String} commandName Command id.
     * @param {*} params Arguments passed to command task.
     */
  }, {
    key: "execute",
    value: function execute(commandName) {
      var _this = this;
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      var commandSplit = commandName.split(":");
      var commandNamePrimary = commandSplit[0];
      var subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;
      var command = this.commands[commandNamePrimary];
      if (!command) {
        throw new Error("Menu command '".concat(commandNamePrimary, "' not exists."));
      }
      if (subCommandName && command.submenu) {
        command = findSubCommand(subCommandName, command.submenu.items);
      }
      if (command.disabled === true) {
        return;
      }
      if (typeof command.disabled === "function" && command.disabled.call(this.hot) === true) {
        return;
      }
      if (hasOwnProperty(command, "submenu")) {
        return;
      }
      var callbacks = [];
      if (typeof command.callback === "function") {
        callbacks.push(command.callback);
      }
      if (typeof this.commonCallback === "function") {
        callbacks.push(this.commonCallback);
      }
      params.unshift(commandSplit.join(":"));
      arrayEach(callbacks, function(callback) {
        return callback.apply(_this.hot, params);
      });
    }
  }]);
  return CommandExecutor2;
}();
function findSubCommand(subCommandName, subCommands) {
  var command;
  arrayEach(subCommands, function(cmd) {
    var cmds = cmd.key ? cmd.key.split(":") : null;
    if (Array.isArray(cmds) && cmds[1] === subCommandName) {
      command = cmd;
      return false;
    }
  });
  return command;
}
var commandExecutor_default = CommandExecutor;

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/alignment.js
var KEY2 = "alignment";
function alignmentItem() {
  return {
    key: KEY2,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT);
    },
    disabled: function disabled() {
      return !(this.getSelectedRange() && !this.selection.isSelectedByCorner());
    },
    submenu: {
      items: [{
        key: "".concat(KEY2, ":left"),
        name: function name() {
          var _this = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this.getCellMeta(row, col).className;
            if (className && className.indexOf("htLeft") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this2 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this2.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htLeft";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this2.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this2.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY2, ":center"),
        name: function name() {
          var _this3 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this3.getCellMeta(row, col).className;
            if (className && className.indexOf("htCenter") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this4 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this4.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htCenter";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this4.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this4.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY2, ":right"),
        name: function name() {
          var _this5 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this5.getCellMeta(row, col).className;
            if (className && className.indexOf("htRight") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this6 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this6.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htRight";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this6.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this6.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY2, ":justify"),
        name: function name() {
          var _this7 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this7.getCellMeta(row, col).className;
            if (className && className.indexOf("htJustify") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this8 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this8.getCellMeta(row, col).className;
          });
          var type = "horizontal";
          var alignment = "htJustify";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this8.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this8.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        name: KEY
      }, {
        key: "".concat(KEY2, ":top"),
        name: function name() {
          var _this9 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_TOP);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this9.getCellMeta(row, col).className;
            if (className && className.indexOf("htTop") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this10 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this10.getCellMeta(row, col).className;
          });
          var type = "vertical";
          var alignment = "htTop";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this10.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this10.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY2, ":middle"),
        name: function name() {
          var _this11 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this11.getCellMeta(row, col).className;
            if (className && className.indexOf("htMiddle") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this12 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this12.getCellMeta(row, col).className;
          });
          var type = "vertical";
          var alignment = "htMiddle";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this12.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this12.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }, {
        key: "".concat(KEY2, ":bottom"),
        name: function name() {
          var _this13 = this;
          var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);
          var hasClass2 = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
            var className = _this13.getCellMeta(row, col).className;
            if (className && className.indexOf("htBottom") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback: function callback() {
          var _this14 = this;
          var selectedRange = this.getSelectedRange();
          var stateBefore = getAlignmentClasses(selectedRange, function(row, col) {
            return _this14.getCellMeta(row, col).className;
          });
          var type = "vertical";
          var alignment = "htBottom";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, function(row, col) {
            return _this14.getCellMeta(row, col);
          }, function(row, col, key, value) {
            return _this14.setCellMeta(row, col, key, value);
          });
          this.render();
        },
        disabled: false
      }]
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/clearColumn.js
function _slicedToArray10(arr, i) {
  return _arrayWithHoles11(arr) || _iterableToArrayLimit10(arr, i) || _nonIterableRest11();
}
function _nonIterableRest11() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit10(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles11(arr) {
  if (Array.isArray(arr)) return arr;
}
var KEY3 = "clear_column";
function clearColumnItem() {
  return {
    key: KEY3,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CLEAR_COLUMN);
    },
    callback: function callback(key, selection) {
      var column = selection[0].start.col;
      if (this.countRows()) {
        this.populateFromArray(0, column, [[null]], Math.max(selection[0].start.row, selection[0].end.row), column, "ContextMenu.clearColumn");
      }
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      var _selected$ = _slicedToArray10(selected[0], 3), startRow = _selected$[0], startColumn = _selected$[1], endRow = _selected$[2];
      var entireRowSelection = [startRow, 0, endRow, this.countCols() - 1];
      var rowSelected = entireRowSelection.join(",") === selected.join(",");
      return startColumn < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/columnLeft.js
function _slicedToArray11(arr, i) {
  return _arrayWithHoles12(arr) || _iterableToArrayLimit11(arr, i) || _nonIterableRest12();
}
function _nonIterableRest12() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit11(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles12(arr) {
  if (Array.isArray(arr)) return arr;
}
var KEY4 = "col_left";
function columnLeftItem() {
  return {
    key: KEY4,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_LEFT);
    },
    callback: function callback(key, normalizedSelection) {
      var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
      this.alter("insert_col", latestSelection.start.col, 1, "ContextMenu.columnLeft");
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      var _selected$ = _slicedToArray11(selected[0], 3), startRow = _selected$[0], startColumn = _selected$[1], endRow = _selected$[2];
      var entireRowSelection = [startRow, 0, endRow, this.countCols() - 1];
      var rowSelected = entireRowSelection.join(",") === selected.join(",");
      var onlyOneColumn = this.countCols() === 1;
      return startColumn < 0 || this.countCols() >= this.getSettings().maxCols || !onlyOneColumn && rowSelected;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/columnRight.js
function _slicedToArray12(arr, i) {
  return _arrayWithHoles13(arr) || _iterableToArrayLimit12(arr, i) || _nonIterableRest13();
}
function _nonIterableRest13() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit12(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles13(arr) {
  if (Array.isArray(arr)) return arr;
}
var KEY5 = "col_right";
function columnRightItem() {
  return {
    key: KEY5,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_RIGHT);
    },
    callback: function callback(key, normalizedSelection) {
      var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
      this.alter("insert_col", latestSelection.end.col + 1, 1, "ContextMenu.columnRight");
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      var _selected$ = _slicedToArray12(selected[0], 3), startRow = _selected$[0], startColumn = _selected$[1], endRow = _selected$[2];
      var entireRowSelection = [startRow, 0, endRow, this.countCols() - 1];
      var rowSelected = entireRowSelection.join(",") === selected.join(",");
      var onlyOneColumn = this.countCols() === 1;
      return startColumn < 0 || this.countCols() >= this.getSettings().maxCols || !onlyOneColumn && rowSelected;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/readOnly.js
var KEY6 = "make_read_only";
function readOnlyItem() {
  return {
    key: KEY6,
    name: function name() {
      var _this = this;
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY);
      var atLeastOneReadOnly = checkSelectionConsistency(this.getSelectedRange(), function(row, col) {
        return _this.getCellMeta(row, col).readOnly;
      });
      if (atLeastOneReadOnly) {
        label = markLabelAsSelected(label);
      }
      return label;
    },
    callback: function callback() {
      var _this2 = this;
      var ranges = this.getSelectedRange();
      var atLeastOneReadOnly = checkSelectionConsistency(ranges, function(row, col) {
        return _this2.getCellMeta(row, col).readOnly;
      });
      arrayEach(ranges, function(range) {
        range.forAll(function(row, col) {
          _this2.setCellMeta(row, col, "readOnly", !atLeastOneReadOnly);
        });
      });
      this.render();
    },
    disabled: function disabled() {
      return !(this.getSelectedRange() && !this.selection.isSelectedByCorner());
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/redo.js
var KEY7 = "redo";
function redoItem() {
  return {
    key: KEY7,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REDO);
    },
    callback: function callback() {
      this.redo();
    },
    disabled: function disabled() {
      return this.undoRedo && !this.undoRedo.isRedoAvailable();
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/removeColumn.js
function _slicedToArray13(arr, i) {
  return _arrayWithHoles14(arr) || _iterableToArrayLimit13(arr, i) || _nonIterableRest14();
}
function _nonIterableRest14() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit13(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles14(arr) {
  if (Array.isArray(arr)) return arr;
}
var KEY8 = "remove_col";
function removeColumnItem() {
  return {
    key: KEY8,
    name: function name() {
      var selection = this.getSelected();
      var pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          var _selection$ = _slicedToArray13(selection[0], 4), fromColumn = _selection$[1], toColumn = _selection$[3];
          if (fromColumn - toColumn !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COLUMN, pluralForm);
    },
    callback: function callback() {
      this.alter("remove_col", transformSelectionToColumnDistance(this.getSelected()), null, "ContextMenu.removeColumn");
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      var totalColumns = this.countCols();
      if (!selected) {
        return true;
      }
      return this.selection.isSelectedByRowHeader() || this.selection.isSelectedByCorner() || !this.isColumnModificationAllowed() || !totalColumns;
    },
    hidden: function hidden() {
      return !this.getSettings().allowRemoveColumn;
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/removeRow.js
function _slicedToArray14(arr, i) {
  return _arrayWithHoles15(arr) || _iterableToArrayLimit14(arr, i) || _nonIterableRest15();
}
function _nonIterableRest15() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit14(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles15(arr) {
  if (Array.isArray(arr)) return arr;
}
var KEY9 = "remove_row";
function removeRowItem() {
  return {
    key: KEY9,
    name: function name() {
      var selection = this.getSelected();
      var pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          var _selection$ = _slicedToArray14(selection[0], 3), fromRow = _selection$[0], toRow = _selection$[2];
          if (fromRow - toRow !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_ROW, pluralForm);
    },
    callback: function callback() {
      this.alter("remove_row", transformSelectionToRowDistance(this.getSelected()), 1, "ContextMenu.removeRow");
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      var totalRows = this.countRows();
      if (!selected) {
        return true;
      }
      return this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner() || !totalRows;
    },
    hidden: function hidden() {
      return !this.getSettings().allowRemoveRow;
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/rowAbove.js
var KEY10 = "row_above";
function rowAboveItem() {
  return {
    key: KEY10,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_ABOVE);
    },
    callback: function callback(key, normalizedSelection) {
      var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
      this.alter("insert_row", latestSelection.start.row, 1, "ContextMenu.rowAbove");
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/rowBelow.js
var KEY11 = "row_below";
function rowBelowItem() {
  return {
    key: KEY11,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_BELOW);
    },
    callback: function callback(key, normalizedSelection) {
      var latestSelection = normalizedSelection[Math.max(normalizedSelection.length - 1, 0)];
      this.alter("insert_row", latestSelection.end.row + 1, 1, "ContextMenu.rowBelow");
    },
    disabled: function disabled() {
      var selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden: function hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems/undo.js
var KEY12 = "undo";
function undoItem() {
  return {
    key: KEY12,
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNDO);
    },
    callback: function callback() {
      this.undo();
    },
    disabled: function disabled() {
      return this.undoRedo && !this.undoRedo.isUndoAvailable();
    }
  };
}

// node_modules/handsontable/es/plugins/contextMenu/predefinedItems.js
var _predefinedItems2;
function _defineProperty7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ITEMS = [KEY10, KEY11, KEY4, KEY5, KEY3, KEY9, KEY8, KEY12, KEY7, KEY6, KEY2, KEY];
var _predefinedItems = (_predefinedItems2 = {}, _defineProperty7(_predefinedItems2, KEY, separatorItem), _defineProperty7(_predefinedItems2, KEY10, rowAboveItem), _defineProperty7(_predefinedItems2, KEY11, rowBelowItem), _defineProperty7(_predefinedItems2, KEY4, columnLeftItem), _defineProperty7(_predefinedItems2, KEY5, columnRightItem), _defineProperty7(_predefinedItems2, KEY3, clearColumnItem), _defineProperty7(_predefinedItems2, KEY9, removeRowItem), _defineProperty7(_predefinedItems2, KEY8, removeColumnItem), _defineProperty7(_predefinedItems2, KEY12, undoItem), _defineProperty7(_predefinedItems2, KEY7, redoItem), _defineProperty7(_predefinedItems2, KEY6, readOnlyItem), _defineProperty7(_predefinedItems2, KEY2, alignmentItem), _predefinedItems2);
function predefinedItems() {
  var items = {};
  objectEach(_predefinedItems, function(itemFactory, key) {
    items[key] = itemFactory();
  });
  return items;
}

// node_modules/handsontable/es/plugins/contextMenu/itemsFactory.js
function _classCallCheck54(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties52(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass52(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties52(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties52(Constructor, staticProps);
  return Constructor;
}
var ItemsFactory = function() {
  function ItemsFactory2(hotInstance) {
    var orderPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    _classCallCheck54(this, ItemsFactory2);
    this.hot = hotInstance;
    this.predefinedItems = predefinedItems();
    this.defaultOrderPattern = orderPattern;
  }
  _createClass52(ItemsFactory2, [{
    key: "setPredefinedItems",
    value: function setPredefinedItems(predefinedItemsCollection) {
      var _this = this;
      var items = {};
      this.defaultOrderPattern.length = 0;
      objectEach(predefinedItemsCollection, function(value, key) {
        var menuItemKey = "";
        if (value.name === KEY) {
          items[KEY] = value;
          menuItemKey = KEY;
        } else if (isNaN(parseInt(key, 10))) {
          value.key = value.key === void 0 ? key : value.key;
          items[key] = value;
          menuItemKey = value.key;
        } else {
          items[value.key] = value;
          menuItemKey = value.key;
        }
        _this.defaultOrderPattern.push(menuItemKey);
      });
      this.predefinedItems = items;
    }
    /**
     * Get all menu items based on pattern.
     *
     * @param {Array|Object|Boolean} pattern Pattern which you can define by displaying menu items order. If `true` default
     *                                       pattern will be used.
     * @returns {Array}
     */
  }, {
    key: "getItems",
    value: function getItems() {
      var pattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return _getItems(pattern, this.defaultOrderPattern, this.predefinedItems);
    }
  }]);
  return ItemsFactory2;
}();
function _getItems() {
  var itemsPattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
  var defaultPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var items = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var result = [];
  var pattern = itemsPattern;
  if (pattern && pattern.items) {
    pattern = pattern.items;
  } else if (!Array.isArray(pattern)) {
    pattern = defaultPattern;
  }
  if (isObject(pattern)) {
    objectEach(pattern, function(value, key) {
      var item = items[typeof value === "string" ? value : key];
      if (!item) {
        item = value;
      }
      if (isObject(value)) {
        extend(item, value);
      } else if (typeof item === "string") {
        item = {
          name: item
        };
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  } else {
    arrayEach(pattern, function(name, key) {
      var item = items[name];
      if (!item && ITEMS.indexOf(name) >= 0) {
        return;
      }
      if (!item) {
        item = {
          name,
          key: "".concat(key)
        };
      }
      if (isObject(name)) {
        extend(item, name);
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  }
  return result;
}
var itemsFactory_default = ItemsFactory;

// node_modules/handsontable/es/plugins/contextMenu/cursor.js
function _classCallCheck55(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties53(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass53(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties53(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties53(Constructor, staticProps);
  return Constructor;
}
var Cursor = function() {
  function Cursor2(object) {
    _classCallCheck55(this, Cursor2);
    var windowScrollTop = getWindowScrollTop();
    var windowScrollLeft = getWindowScrollLeft();
    var top2;
    var topRelative;
    var left2;
    var leftRelative;
    var cellHeight;
    var cellWidth;
    this.type = this.getSourceType(object);
    if (this.type === "literal") {
      top2 = parseInt(object.top, 10);
      left2 = parseInt(object.left, 10);
      cellHeight = object.height || 0;
      cellWidth = object.width || 0;
      topRelative = top2;
      leftRelative = left2;
      top2 += windowScrollTop;
      left2 += windowScrollLeft;
    } else if (this.type === "event") {
      top2 = parseInt(pageY(object), 10);
      left2 = parseInt(pageX(object), 10);
      cellHeight = object.target.clientHeight;
      cellWidth = object.target.clientWidth;
      topRelative = top2 - windowScrollTop;
      leftRelative = left2 - windowScrollLeft;
    }
    this.top = top2;
    this.topRelative = topRelative;
    this.left = left2;
    this.leftRelative = leftRelative;
    this.scrollTop = windowScrollTop;
    this.scrollLeft = windowScrollLeft;
    this.cellHeight = cellHeight;
    this.cellWidth = cellWidth;
  }
  _createClass53(Cursor2, [{
    key: "getSourceType",
    value: function getSourceType(object) {
      var type = "literal";
      if (object instanceof Event) {
        type = "event";
      }
      return type;
    }
    /**
     * Checks if element can be placed above the cursor.
     *
     * @param {HTMLElement} element Element to check if it's size will fit above the cursor.
     * @returns {Boolean}
     */
  }, {
    key: "fitsAbove",
    value: function fitsAbove(element) {
      return this.topRelative >= element.offsetHeight;
    }
    /**
     * Checks if element can be placed below the cursor.
     *
     * @param {HTMLElement} element Element to check if it's size will fit below the cursor.
     * @param {Number} [viewportHeight] The viewport height.
     * @returns {Boolean}
     */
  }, {
    key: "fitsBelow",
    value: function fitsBelow(element) {
      var viewportHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window.innerHeight;
      return this.topRelative + element.offsetHeight <= viewportHeight;
    }
    /**
     * Checks if element can be placed on the right of the cursor.
     *
     * @param {HTMLElement} element Element to check if it's size will fit on the right of the cursor.
     * @param {Number} [viewportWidth] The viewport width.
     * @returns {Boolean}
     */
  }, {
    key: "fitsOnRight",
    value: function fitsOnRight(element) {
      var viewportWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window.innerWidth;
      return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;
    }
    /**
     * Checks if element can be placed on the left on the cursor.
     *
     * @param {HTMLElement} element Element to check if it's size will fit on the left of the cursor.
     * @returns {Boolean}
     */
  }, {
    key: "fitsOnLeft",
    value: function fitsOnLeft(element) {
      return this.leftRelative >= element.offsetWidth;
    }
  }]);
  return Cursor2;
}();
var cursor_default = Cursor;

// node_modules/handsontable/es/plugins/contextMenu/menu.js
function _classCallCheck56(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties54(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass54(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties54(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties54(Constructor, staticProps);
  return Constructor;
}
var MIN_WIDTH = 215;
var Menu = function() {
  function Menu2(hotInstance, options) {
    _classCallCheck56(this, Menu2);
    this.hot = hotInstance;
    this.options = options || {
      parent: null,
      name: null,
      className: "",
      keepInViewport: true,
      standalone: false,
      minWidth: MIN_WIDTH
    };
    this.eventManager = new eventManager_default(this);
    this.container = this.createContainer(this.options.name);
    this.hotMenu = null;
    this.hotSubMenus = {};
    this.parentMenu = this.options.parent || null;
    this.menuItems = null;
    this.origOutsideClickDeselects = null;
    this.keyEvent = false;
    this.offset = {
      above: 0,
      below: 0,
      left: 0,
      right: 0
    };
    this._afterScrollCallback = null;
    this.registerEvents();
  }
  _createClass54(Menu2, [{
    key: "registerEvents",
    value: function registerEvents2() {
      var _this = this;
      this.eventManager.addEventListener(document.documentElement, "mousedown", function(event2) {
        return _this.onDocumentMouseDown(event2);
      });
    }
    /**
     * Set array of objects which defines menu items.
     *
     * @param {Array} menuItems Menu items to display.
     */
  }, {
    key: "setMenuItems",
    value: function setMenuItems(menuItems) {
      this.menuItems = menuItems;
    }
    /**
     * Set offset menu position for specified area (`above`, `below`, `left` or `right`).
     *
     * @param {String} area Specified area name (`above`, `below`, `left` or `right`).
     * @param {Number} offset Offset value.
     */
  }, {
    key: "setOffset",
    value: function setOffset(area) {
      var offset4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      this.offset[area] = offset4;
    }
    /**
     * Check if menu is using as sub-menu.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isSubMenu",
    value: function isSubMenu() {
      return this.parentMenu !== null;
    }
    /**
     * Open menu.
     *
     * @fires Hooks#beforeContextMenuShow
     * @fires Hooks#afterContextMenuShow
     */
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;
      this.runLocalHooks("beforeOpen");
      this.container.removeAttribute("style");
      this.container.style.display = "block";
      var delayedOpenSubMenu = debounce(function(row) {
        return _this2.openSubMenu(row);
      }, 300);
      var minWidthOfMenu = this.options.minWidth || MIN_WIDTH;
      var filteredItems = arrayFilter(this.menuItems, function(item) {
        return isItemHidden(item, _this2.hot);
      });
      filteredItems = filterSeparators(filteredItems, KEY);
      var settings = {
        data: filteredItems,
        colHeaders: false,
        autoColumnSize: true,
        modifyColWidth: function modifyColWidth(width) {
          if (isDefined(width) && width < minWidthOfMenu) {
            return minWidthOfMenu;
          }
          return width;
        },
        autoRowSize: false,
        readOnly: true,
        copyPaste: false,
        columns: [{
          data: "name",
          renderer: function renderer(hot, TD, row, col, prop, value) {
            return _this2.menuItemRenderer(hot, TD, row, col, prop, value);
          }
        }],
        renderAllRows: true,
        fragmentSelection: "cell",
        disableVisualSelection: "area",
        beforeKeyDown: function beforeKeyDown(event2) {
          return _this2.onBeforeKeyDown(event2);
        },
        afterOnCellMouseOver: function afterOnCellMouseOver(event2, coords) {
          if (_this2.isAllSubMenusClosed()) {
            delayedOpenSubMenu(coords.row);
          } else {
            _this2.openSubMenu(coords.row);
          }
        },
        rowHeights: function rowHeights(row) {
          return filteredItems[row].name === KEY ? 1 : 23;
        }
      };
      this.origOutsideClickDeselects = this.hot.getSettings().outsideClickDeselects;
      this.hot.getSettings().outsideClickDeselects = false;
      this.hotMenu = new Core(this.container, settings);
      this.hotMenu.addHook("afterInit", function() {
        return _this2.onAfterInit();
      });
      this.hotMenu.addHook("afterSelection", function() {
        return _this2.onAfterSelection.apply(_this2, arguments);
      });
      this.hotMenu.init();
      this.hotMenu.listen();
      this.blockMainTableCallbacks();
      this.runLocalHooks("afterOpen");
    }
    /**
     * Close menu.
     *
     * @param {Boolean} [closeParent=false] if `true` try to close parent menu if exists.
     */
  }, {
    key: "close",
    value: function close() {
      var closeParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!this.isOpened()) {
        return;
      }
      if (closeParent && this.parentMenu) {
        this.parentMenu.close();
      } else {
        this.closeAllSubMenus();
        this.container.style.display = "none";
        this.releaseMainTableCallbacks();
        this.hotMenu.destroy();
        this.hotMenu = null;
        this.hot.getSettings().outsideClickDeselects = this.origOutsideClickDeselects;
        this.runLocalHooks("afterClose");
        if (this.parentMenu) {
          this.parentMenu.hotMenu.listen();
        }
      }
    }
    /**
     * Open sub menu at the provided row index.
     *
     * @param {Number} row Row index.
     * @returns {Menu|Boolean} Returns created menu or `false` if no one menu was created.
     */
  }, {
    key: "openSubMenu",
    value: function openSubMenu(row) {
      if (!this.hotMenu) {
        return false;
      }
      var cell = this.hotMenu.getCell(row, 0);
      this.closeAllSubMenus();
      if (!cell || !hasSubMenu(cell)) {
        return false;
      }
      var dataItem = this.hotMenu.getSourceDataAtRow(row);
      var subMenu = new Menu2(this.hot, {
        parent: this,
        name: dataItem.name,
        className: this.options.className,
        keepInViewport: true
      });
      subMenu.setMenuItems(dataItem.submenu.items);
      subMenu.open();
      subMenu.setPosition(cell.getBoundingClientRect());
      this.hotSubMenus[dataItem.key] = subMenu;
      return subMenu;
    }
    /**
     * Close sub menu at row index.
     *
     * @param {Number} row Row index.
     */
  }, {
    key: "closeSubMenu",
    value: function closeSubMenu(row) {
      var dataItem = this.hotMenu.getSourceDataAtRow(row);
      var menus = this.hotSubMenus[dataItem.key];
      if (menus) {
        menus.destroy();
        delete this.hotSubMenus[dataItem.key];
      }
    }
    /**
     * Close all opened sub menus.
     */
  }, {
    key: "closeAllSubMenus",
    value: function closeAllSubMenus() {
      var _this3 = this;
      arrayEach(this.hotMenu.getData(), function(value, row) {
        return _this3.closeSubMenu(row);
      });
    }
    /**
     * Checks if all created and opened sub menus are closed.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isAllSubMenusClosed",
    value: function isAllSubMenusClosed() {
      return Object.keys(this.hotSubMenus).length === 0;
    }
    /**
     * Destroy instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.clearLocalHooks();
      this.close();
      this.parentMenu = null;
      this.eventManager.destroy();
    }
    /**
     * Checks if menu was opened.
     *
     * @returns {Boolean} Returns `true` if menu was opened.
     */
  }, {
    key: "isOpened",
    value: function isOpened() {
      return this.hotMenu !== null;
    }
    /**
     * Execute menu command.
     *
     * @param {Event} [event]
     */
  }, {
    key: "executeCommand",
    value: function executeCommand(event2) {
      if (!this.isOpened() || !this.hotMenu.getSelectedLast()) {
        return;
      }
      var selectedItem = this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelectedLast()[0]);
      this.runLocalHooks("select", selectedItem, event2);
      if (selectedItem.isCommand === false || selectedItem.name === KEY) {
        return;
      }
      var selRanges = this.hot.getSelectedRange();
      var normalizedSelection = selRanges ? normalizeSelection(selRanges) : [];
      var autoClose = true;
      if (selectedItem.disabled === true || typeof selectedItem.disabled === "function" && selectedItem.disabled.call(this.hot) === true || selectedItem.submenu) {
        autoClose = false;
      }
      this.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event2);
      if (this.isSubMenu()) {
        this.parentMenu.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event2);
      }
      if (autoClose) {
        this.close(true);
      }
    }
    /**
     * Set menu position based on dom event or based on literal object.
     *
     * @param {Event|Object} coords Event or literal Object with coordinates.
     */
  }, {
    key: "setPosition",
    value: function setPosition(coords) {
      var cursor = new cursor_default(coords);
      if (this.options.keepInViewport) {
        if (cursor.fitsBelow(this.container)) {
          this.setPositionBelowCursor(cursor);
        } else if (cursor.fitsAbove(this.container)) {
          this.setPositionAboveCursor(cursor);
        } else {
          this.setPositionBelowCursor(cursor);
        }
        if (cursor.fitsOnRight(this.container)) {
          this.setPositionOnRightOfCursor(cursor);
        } else {
          this.setPositionOnLeftOfCursor(cursor);
        }
      } else {
        this.setPositionBelowCursor(cursor);
        this.setPositionOnRightOfCursor(cursor);
      }
    }
    /**
     * Set menu position above cursor object.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setPositionAboveCursor",
    value: function setPositionAboveCursor(cursor) {
      var top2 = this.offset.above + cursor.top - this.container.offsetHeight;
      if (this.isSubMenu()) {
        top2 = cursor.top + cursor.cellHeight - this.container.offsetHeight + 3;
      }
      this.container.style.top = "".concat(top2, "px");
    }
    /**
     * Set menu position below cursor object.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setPositionBelowCursor",
    value: function setPositionBelowCursor(cursor) {
      var top2 = this.offset.below + cursor.top;
      if (this.isSubMenu()) {
        top2 = cursor.top - 1;
      }
      this.container.style.top = "".concat(top2, "px");
    }
    /**
     * Set menu position on the right of cursor object.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setPositionOnRightOfCursor",
    value: function setPositionOnRightOfCursor(cursor) {
      var left2;
      if (this.isSubMenu()) {
        left2 = 1 + cursor.left + cursor.cellWidth;
      } else {
        left2 = this.offset.right + 1 + cursor.left;
      }
      this.container.style.left = "".concat(left2, "px");
    }
    /**
     * Set menu position on the left of cursor object.
     *
     * @param {Cursor} cursor `Cursor` object.
     */
  }, {
    key: "setPositionOnLeftOfCursor",
    value: function setPositionOnLeftOfCursor(cursor) {
      var left2 = this.offset.left + cursor.left - this.container.offsetWidth + getScrollbarWidth() + 4;
      this.container.style.left = "".concat(left2, "px");
    }
    /**
     * Select first cell in opened menu.
     */
  }, {
    key: "selectFirstCell",
    value: function selectFirstCell() {
      var cell = this.hotMenu.getCell(0, 0);
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectNextCell(0, 0);
      } else {
        this.hotMenu.selectCell(0, 0);
      }
    }
    /**
     * Select last cell in opened menu.
     */
  }, {
    key: "selectLastCell",
    value: function selectLastCell() {
      var lastRow = this.hotMenu.countRows() - 1;
      var cell = this.hotMenu.getCell(lastRow, 0);
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectPrevCell(lastRow, 0);
      } else {
        this.hotMenu.selectCell(lastRow, 0);
      }
    }
    /**
     * Select next cell in opened menu.
     *
     * @param {Number} row Row index.
     * @param {Number} col Column index.
     */
  }, {
    key: "selectNextCell",
    value: function selectNextCell(row, col) {
      var nextRow = row + 1;
      var cell = nextRow < this.hotMenu.countRows() ? this.hotMenu.getCell(nextRow, col) : null;
      if (!cell) {
        return;
      }
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectNextCell(nextRow, col);
      } else {
        this.hotMenu.selectCell(nextRow, col);
      }
    }
    /**
     * Select previous cell in opened menu.
     *
     * @param {Number} row Row index.
     * @param {Number} col Column index.
     */
  }, {
    key: "selectPrevCell",
    value: function selectPrevCell(row, col) {
      var prevRow = row - 1;
      var cell = prevRow >= 0 ? this.hotMenu.getCell(prevRow, col) : null;
      if (!cell) {
        return;
      }
      if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        this.selectPrevCell(prevRow, col);
      } else {
        this.hotMenu.selectCell(prevRow, col);
      }
    }
    /**
     * Menu item renderer.
     *
     * @private
     */
  }, {
    key: "menuItemRenderer",
    value: function menuItemRenderer(hot, TD, row, col, prop, value) {
      var _this4 = this;
      var item = hot.getSourceDataAtRow(row);
      var wrapper = document.createElement("div");
      var isSubMenu = function isSubMenu2(itemToTest) {
        return hasOwnProperty(itemToTest, "submenu");
      };
      var itemIsSeparator = function itemIsSeparator2(itemToTest) {
        return new RegExp(KEY, "i").test(itemToTest.name);
      };
      var itemIsDisabled = function itemIsDisabled2(itemToTest) {
        return itemToTest.disabled === true || typeof itemToTest.disabled === "function" && itemToTest.disabled.call(_this4.hot) === true;
      };
      var itemIsSelectionDisabled = function itemIsSelectionDisabled2(itemToTest) {
        return itemToTest.disableSelection;
      };
      var itemValue = value;
      if (typeof itemValue === "function") {
        itemValue = itemValue.call(this.hot);
      }
      empty(TD);
      addClass(wrapper, "htItemWrapper");
      TD.appendChild(wrapper);
      if (itemIsSeparator(item)) {
        addClass(TD, "htSeparator");
      } else if (typeof item.renderer === "function") {
        addClass(TD, "htCustomMenuRenderer");
        TD.appendChild(item.renderer(hot, wrapper, row, col, prop, itemValue));
      } else {
        fastInnerHTML(wrapper, itemValue);
      }
      if (itemIsDisabled(item)) {
        addClass(TD, "htDisabled");
        this.eventManager.addEventListener(TD, "mouseenter", function() {
          return hot.deselectCell();
        });
      } else if (itemIsSelectionDisabled(item)) {
        addClass(TD, "htSelectionDisabled");
        this.eventManager.addEventListener(TD, "mouseenter", function() {
          return hot.deselectCell();
        });
      } else if (isSubMenu(item)) {
        addClass(TD, "htSubmenu");
        if (itemIsSelectionDisabled(item)) {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.deselectCell();
          });
        } else {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.selectCell(row, col, void 0, void 0, false, false);
          });
        }
      } else {
        removeClass(TD, "htSubmenu");
        removeClass(TD, "htDisabled");
        if (itemIsSelectionDisabled(item)) {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.deselectCell();
          });
        } else {
          this.eventManager.addEventListener(TD, "mouseenter", function() {
            return hot.selectCell(row, col, void 0, void 0, false, false);
          });
        }
      }
    }
    /**
     * Create container/wrapper for handsontable.
     *
     * @private
     * @param {String} [name] Class name.
     * @returns {HTMLElement}
     */
  }, {
    key: "createContainer",
    value: function createContainer() {
      var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      var className = name;
      var container;
      if (className) {
        if (isFunction2(className)) {
          className = className.call(this.hot);
          if (className === null || isUndefined2(className)) {
            className = "";
          } else {
            className = className.toString();
          }
        }
        className = className.replace(/[^A-z0-9]/g, "_");
        className = "".concat(this.options.className, "Sub_").concat(className);
        container = document.querySelector(".".concat(this.options.className, ".").concat(className));
      } else {
        container = document.querySelector(".".concat(this.options.className));
      }
      if (!container) {
        container = document.createElement("div");
        addClass(container, "htMenu ".concat(this.options.className));
        if (className) {
          addClass(container, className);
        }
        document.getElementsByTagName("body")[0].appendChild(container);
      }
      return container;
    }
    /**
     * @private
     */
  }, {
    key: "blockMainTableCallbacks",
    value: function blockMainTableCallbacks() {
      this._afterScrollCallback = function() {
      };
      this.hot.addHook("afterScrollVertically", this._afterScrollCallback);
      this.hot.addHook("afterScrollHorizontally", this._afterScrollCallback);
    }
    /**
     * @private
     */
  }, {
    key: "releaseMainTableCallbacks",
    value: function releaseMainTableCallbacks() {
      if (this._afterScrollCallback) {
        this.hot.removeHook("afterScrollVertically", this._afterScrollCallback);
        this.hot.removeHook("afterScrollHorizontally", this._afterScrollCallback);
        this._afterScrollCallback = null;
      }
    }
    /**
     * On before key down listener.
     *
     * @private
     * @param {Event} event
     */
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown9(event2) {
      var selection = this.hotMenu.getSelectedLast();
      var stopEvent = false;
      this.keyEvent = true;
      switch (event2.keyCode) {
        case KEY_CODES.ESCAPE:
          this.close();
          stopEvent = true;
          break;
        case KEY_CODES.ENTER:
          if (selection) {
            if (this.hotMenu.getSourceDataAtRow(selection[0]).submenu) {
              stopEvent = true;
            } else {
              this.executeCommand(event2);
              this.close(true);
            }
          }
          break;
        case KEY_CODES.ARROW_DOWN:
          if (selection) {
            this.selectNextCell(selection[0], selection[1]);
          } else {
            this.selectFirstCell();
          }
          stopEvent = true;
          break;
        case KEY_CODES.ARROW_UP:
          if (selection) {
            this.selectPrevCell(selection[0], selection[1]);
          } else {
            this.selectLastCell();
          }
          stopEvent = true;
          break;
        case KEY_CODES.ARROW_RIGHT:
          if (selection) {
            var menu = this.openSubMenu(selection[0]);
            if (menu) {
              menu.selectFirstCell();
            }
          }
          stopEvent = true;
          break;
        case KEY_CODES.ARROW_LEFT:
          if (selection && this.isSubMenu()) {
            this.close();
            if (this.parentMenu) {
              this.parentMenu.hotMenu.listen();
            }
            stopEvent = true;
          }
          break;
        default:
          break;
      }
      if (stopEvent) {
        event2.preventDefault();
        stopImmediatePropagation(event2);
      }
      this.keyEvent = false;
    }
    /**
     * On after init listener.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      var data = this.hotMenu.getSettings().data;
      var hiderStyle = this.hotMenu.view.wt.wtTable.hider.style;
      var holderStyle = this.hotMenu.view.wt.wtTable.holder.style;
      var currentHiderWidth = parseInt(hiderStyle.width, 10);
      var realHeight = arrayReduce(data, function(accumulator, value) {
        return accumulator + (value.name === KEY ? 1 : 26);
      }, 0);
      holderStyle.width = "".concat(currentHiderWidth + 22, "px");
      holderStyle.height = "".concat(realHeight + 4, "px");
      hiderStyle.height = holderStyle.height;
    }
    /**
     * On after selection listener.
     *
     * @param {Number} r Selection start row index.
     * @param {Number} c Selection start column index.
     * @param {Number} r2 Selection end row index.
     * @param {Number} c2 Selection end column index.
     * @param {Object} preventScrolling Object with `value` property where its value change will be observed.
     * @param {Number} selectionLayerLevel The number which indicates what selection layer is currently modified.
     */
  }, {
    key: "onAfterSelection",
    value: function onAfterSelection(r, c, r2, c2, preventScrolling) {
      if (this.keyEvent === false) {
        preventScrolling.value = true;
      }
    }
    /**
     * Document mouse down listener.
     *
     * @private
     * @param {Event} event
     */
  }, {
    key: "onDocumentMouseDown",
    value: function onDocumentMouseDown(event2) {
      if (!this.isOpened()) {
        return;
      }
      if (this.container && isChildOf(event2.target, this.container)) {
        this.executeCommand(event2);
      }
      if (this.options.standalone && this.hotMenu && !isChildOf(event2.target, this.hotMenu.rootElement)) {
        this.close(true);
      } else if ((this.isAllSubMenusClosed() || this.isSubMenu()) && !isChildOf(event2.target, ".htMenu") && isChildOf(event2.target, document)) {
        this.close(true);
      }
    }
  }]);
  return Menu2;
}();
mixin(Menu, localHooks_default);
var menu_default = Menu;

// node_modules/handsontable/es/plugins/contextMenu/contextMenu.js
function _typeof30(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof30 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof30 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof30(obj);
}
function _classCallCheck57(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn18(self2, call) {
  if (call && (_typeof30(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized18(self2);
}
function _get10(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get10 = Reflect.get;
  } else {
    _get10 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase10(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get10(target, property, receiver || target);
}
function _superPropBase10(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf18(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf18(o) {
  _getPrototypeOf18 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf18(o);
}
function _defineProperties55(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass55(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties55(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties55(Constructor, staticProps);
  return Constructor;
}
function _inherits18(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf18(subClass, superClass);
}
function _setPrototypeOf18(o, p) {
  _setPrototypeOf18 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf18(o, p);
}
function _assertThisInitialized18(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
pluginHooks_default.getSingleton().register("afterContextMenuDefaultOptions");
pluginHooks_default.getSingleton().register("beforeContextMenuShow");
pluginHooks_default.getSingleton().register("afterContextMenuShow");
pluginHooks_default.getSingleton().register("afterContextMenuHide");
pluginHooks_default.getSingleton().register("afterContextMenuExecute");
var ContextMenu = function(_BasePlugin) {
  _inherits18(ContextMenu2, _BasePlugin);
  _createClass55(ContextMenu2, null, [{
    key: "DEFAULT_ITEMS",
    /**
     * Context menu default items order when `contextMenu` options is set as `true`.
     *
     * @returns {String[]}
     */
    get: function get5() {
      return [KEY10, KEY11, KEY, KEY4, KEY5, KEY, KEY9, KEY8, KEY, KEY12, KEY7, KEY, KEY6, KEY, KEY2];
    }
  }]);
  function ContextMenu2(hotInstance) {
    var _this;
    _classCallCheck57(this, ContextMenu2);
    _this = _possibleConstructorReturn18(this, _getPrototypeOf18(ContextMenu2).call(this, hotInstance));
    _this.eventManager = new eventManager_default(_assertThisInitialized18(_assertThisInitialized18(_this)));
    _this.commandExecutor = new commandExecutor_default(_this.hot);
    _this.itemsFactory = null;
    _this.menu = null;
    return _this;
  }
  _createClass55(ContextMenu2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().contextMenu;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.itemsFactory = new itemsFactory_default(this.hot, ContextMenu2.DEFAULT_ITEMS);
      var settings = this.hot.getSettings().contextMenu;
      var predefinedItems2 = {
        items: this.itemsFactory.getItems(settings)
      };
      if (typeof settings.callback === "function") {
        this.commandExecutor.setCommonCallback(settings.callback);
      }
      _get10(_getPrototypeOf18(ContextMenu2.prototype), "enablePlugin", this).call(this);
      var delayedInitialization = function delayedInitialization2() {
        if (!_this2.hot) {
          return;
        }
        _this2.hot.runHooks("afterContextMenuDefaultOptions", predefinedItems2);
        _this2.itemsFactory.setPredefinedItems(predefinedItems2.items);
        var menuItems = _this2.itemsFactory.getItems(settings);
        _this2.menu = new menu_default(_this2.hot, {
          className: "htContextMenu",
          keepInViewport: true
        });
        _this2.hot.runHooks("beforeContextMenuSetItems", menuItems);
        _this2.menu.setMenuItems(menuItems);
        _this2.menu.addLocalHook("beforeOpen", function() {
          return _this2.onMenuBeforeOpen();
        });
        _this2.menu.addLocalHook("afterOpen", function() {
          return _this2.onMenuAfterOpen();
        });
        _this2.menu.addLocalHook("afterClose", function() {
          return _this2.onMenuAfterClose();
        });
        _this2.menu.addLocalHook("executeCommand", function() {
          var _this2$executeCommand;
          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
            params[_key] = arguments[_key];
          }
          return (_this2$executeCommand = _this2.executeCommand).call.apply(_this2$executeCommand, [_this2].concat(params));
        });
        _this2.addHook("afterOnCellContextMenu", function(event2) {
          return _this2.onAfterOnCellContextMenu(event2);
        });
        arrayEach(menuItems, function(command) {
          return _this2.commandExecutor.registerCommand(command.key, command);
        });
      };
      this.callOnPluginsReady(function() {
        if (_this2.isPluginsReady) {
          setTimeout(delayedInitialization, 0);
        } else {
          delayedInitialization();
        }
      });
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get10(_getPrototypeOf18(ContextMenu2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
        this.menu = null;
      }
      _get10(_getPrototypeOf18(ContextMenu2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Opens menu and re-position it based on the passed coordinates.
     *
     * @param {Object|Event} position An object with `pageX` and `pageY` properties which contains values relative to
     *                                the top left of the fully rendered content area in the browser or with `clientX`
     *                                and `clientY`  properties which contains values relative to the upper left edge
     *                                of the content area (the viewport) of the browser window. This object is structurally
     *                                compatible with native mouse event so it can be used either.
     */
  }, {
    key: "open",
    value: function open(event2) {
      if (!this.menu) {
        return;
      }
      this.menu.open();
      this.menu.setPosition({
        top: parseInt(pageY(event2), 10) - getWindowScrollTop(),
        left: parseInt(pageX(event2), 10) - getWindowScrollLeft()
      });
      this.menu.hotMenu.isHotTableEnv = this.hot.isHotTableEnv;
    }
    /**
     * Closes the menu.
     */
  }, {
    key: "close",
    value: function close() {
      if (!this.menu) {
        return;
      }
      this.menu.close();
    }
    /**
     * Execute context menu command.
     *
     * You can execute all predefined commands:
     *  * `'row_above'` - Insert row above
     *  * `'row_below'` - Insert row below
     *  * `'col_left'` - Insert column left
     *  * `'col_right'` - Insert column right
     *  * `'clear_column'` - Clear selected column
     *  * `'remove_row'` - Remove row
     *  * `'remove_col'` - Remove column
     *  * `'undo'` - Undo last action
     *  * `'redo'` - Redo last action
     *  * `'make_read_only'` - Make cell read only
     *  * `'alignment:left'` - Alignment to the left
     *  * `'alignment:top'` - Alignment to the top
     *  * `'alignment:right'` - Alignment to the right
     *  * `'alignment:bottom'` - Alignment to the bottom
     *  * `'alignment:middle'` - Alignment to the middle
     *  * `'alignment:center'` - Alignment to the center (justify)
     *
     * Or you can execute command registered in settings where `key` is your command name.
     *
     * @param {String} commandName The command name to be executed.
     * @param {...*} params
     */
  }, {
    key: "executeCommand",
    value: function executeCommand(commandName) {
      var _this$commandExecutor;
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      (_this$commandExecutor = this.commandExecutor).execute.apply(_this$commandExecutor, [commandName].concat(params));
    }
    /**
     * On contextmenu listener.
     *
     * @private
     * @param {Event} event
     */
  }, {
    key: "onAfterOnCellContextMenu",
    value: function onAfterOnCellContextMenu(event2) {
      var settings = this.hot.getSettings();
      var showRowHeaders = settings.rowHeaders;
      var showColHeaders = settings.colHeaders;
      function isValidElement(element2) {
        return element2.nodeName === "TD" || element2.parentNode.nodeName === "TD";
      }
      var element = event2.realTarget;
      this.close();
      if (hasClass(element, "handsontableInput")) {
        return;
      }
      event2.preventDefault();
      stopPropagation(event2);
      if (!(showRowHeaders || showColHeaders)) {
        if (!isValidElement(element) && !(hasClass(element, "current") && hasClass(element, "wtBorder"))) {
          return;
        }
      }
      this.open(event2);
    }
    /**
     * On menu before open listener.
     *
     * @private
     */
  }, {
    key: "onMenuBeforeOpen",
    value: function onMenuBeforeOpen() {
      this.hot.runHooks("beforeContextMenuShow", this);
    }
    /**
     * On menu after open listener.
     *
     * @private
     */
  }, {
    key: "onMenuAfterOpen",
    value: function onMenuAfterOpen() {
      this.hot.runHooks("afterContextMenuShow", this);
    }
    /**
     * On menu after close listener.
     *
     * @private
     */
  }, {
    key: "onMenuAfterClose",
    value: function onMenuAfterClose() {
      this.hot.listen();
      this.hot.runHooks("afterContextMenuHide", this);
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.close();
      if (this.menu) {
        this.menu.destroy();
      }
      _get10(_getPrototypeOf18(ContextMenu2.prototype), "destroy", this).call(this);
    }
  }]);
  return ContextMenu2;
}(base_default2);
ContextMenu.SEPARATOR = {
  name: KEY
};
registerPlugin("contextMenu", ContextMenu);
var contextMenu_default = ContextMenu;

// node_modules/handsontable/es/plugins/copyPaste/copyPaste.js
var import_SheetClip2 = __toESM(require_SheetClip());

// node_modules/handsontable/es/plugins/copyPaste/contextMenuItem/copy.js
function copyItem(copyPastePlugin) {
  return {
    key: "copy",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY);
    },
    callback: function callback() {
      copyPastePlugin.copy();
    },
    disabled: function disabled() {
      var selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/es/plugins/copyPaste/contextMenuItem/cut.js
function cutItem(copyPastePlugin) {
  return {
    key: "cut",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CUT);
    },
    callback: function callback() {
      copyPastePlugin.cut();
    },
    disabled: function disabled() {
      var selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/es/plugins/copyPaste/clipboardData.js
function _classCallCheck58(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties56(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass56(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties56(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties56(Constructor, staticProps);
  return Constructor;
}
var ClipboardData = function() {
  function ClipboardData2() {
    _classCallCheck58(this, ClipboardData2);
    this.data = {};
  }
  _createClass56(ClipboardData2, [{
    key: "setData",
    value: function setData(type, value) {
      this.data[type] = value;
    }
  }, {
    key: "getData",
    value: function getData(type) {
      return this.data[type] || void 0;
    }
  }]);
  return ClipboardData2;
}();

// node_modules/handsontable/es/plugins/copyPaste/pasteEvent.js
function _classCallCheck59(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var PasteEvent = function PasteEvent2() {
  _classCallCheck59(this, PasteEvent2);
  this.clipboardData = new ClipboardData();
};

// node_modules/handsontable/es/plugins/copyPaste/focusableElement.js
function _classCallCheck60(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties57(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass57(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties57(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties57(Constructor, staticProps);
  return Constructor;
}
var FocusableWrapper = function() {
  function FocusableWrapper2() {
    _classCallCheck60(this, FocusableWrapper2);
    this.mainElement = null;
    this.eventManager = new eventManager_default(this);
    this.listenersCount = /* @__PURE__ */ new WeakSet();
  }
  _createClass57(FocusableWrapper2, [{
    key: "useSecondaryElement",
    value: function useSecondaryElement() {
      var el = createOrGetSecondaryElement();
      if (!this.listenersCount.has(el)) {
        this.listenersCount.add(el);
        forwardEventsToLocalHooks(this.eventManager, el, this);
      }
      this.mainElement = el;
    }
    /**
     * Switch to the main focusable element.
     */
  }, {
    key: "setFocusableElement",
    value: function setFocusableElement(element) {
      if (!this.listenersCount.has(element)) {
        this.listenersCount.add(element);
        forwardEventsToLocalHooks(this.eventManager, element, this);
      }
      this.mainElement = element;
    }
    /**
     * Get currently set focusable element.
     *
     * @return {HTMLElement}
     */
  }, {
    key: "getFocusableElement",
    value: function getFocusableElement() {
      return this.mainElement;
    }
    /**
     * Set focus to the focusable element.
     */
  }, {
    key: "focus",
    value: function focus() {
      this.mainElement.value = " ";
      if (!isMobileBrowser()) {
        this.mainElement.select();
      }
    }
  }]);
  return FocusableWrapper2;
}();
mixin(FocusableWrapper, localHooks_default);
var refCounter = 0;
function createElement() {
  var focusableWrapper = new FocusableWrapper();
  refCounter += 1;
  return focusableWrapper;
}
function deactivateElement(wrapper) {
  wrapper.eventManager.clear();
}
var runLocalHooks2 = function runLocalHooks3(eventName, subject) {
  return function(event2) {
    return subject.runLocalHooks(eventName, event2);
  };
};
function forwardEventsToLocalHooks(eventManager2, element, subject) {
  eventManager2.addEventListener(element, "copy", runLocalHooks2("copy", subject));
  eventManager2.addEventListener(element, "cut", runLocalHooks2("cut", subject));
  eventManager2.addEventListener(element, "paste", runLocalHooks2("paste", subject));
}
var secondaryElement;
function createOrGetSecondaryElement() {
  if (secondaryElement) {
    if (!secondaryElement.parentElement) {
      document.body.appendChild(secondaryElement);
    }
    return secondaryElement;
  }
  var element = document.createElement("textarea");
  secondaryElement = element;
  element.id = "HandsontableCopyPaste";
  element.className = "copyPaste";
  element.tabIndex = -1;
  element.autocomplete = "off";
  element.wrap = "hard";
  element.value = " ";
  document.body.appendChild(element);
  return element;
}
function destroyElement(wrapper) {
  if (!(wrapper instanceof FocusableWrapper)) {
    return;
  }
  if (refCounter > 0) {
    refCounter -= 1;
  }
  deactivateElement(wrapper);
  if (refCounter <= 0) {
    refCounter = 0;
    if (secondaryElement && secondaryElement.parentNode) {
      secondaryElement.parentNode.removeChild(secondaryElement);
      secondaryElement = null;
    }
    wrapper.mainElement = null;
  }
}

// node_modules/handsontable/es/plugins/copyPaste/utils.js
function arrayToTable(input) {
  var inputLen = input.length;
  var result = ["<table>"];
  var tempElement = document.createElement("div");
  document.documentElement.appendChild(tempElement);
  for (var row = 0; row < inputLen; row += 1) {
    var rowData = input[row];
    var columnsLen = rowData.length;
    var columnsResult = [];
    if (row === 0) {
      result.push("<tbody>");
    }
    for (var column = 0; column < columnsLen; column += 1) {
      tempElement.innerText = "".concat(isEmpty(rowData[column]) ? "" : rowData[column]);
      columnsResult.push("<td>".concat(tempElement.innerHTML, "</td>"));
    }
    result.push.apply(result, ["<tr>"].concat(columnsResult, ["</tr>"]));
    if (row + 1 === inputLen) {
      result.push("</tbody>");
    }
  }
  document.documentElement.removeChild(tempElement);
  result.push("</table>");
  return result.join("");
}
function isHTMLTable(element) {
  return (element && element.nodeName || "").toLowerCase() === "table";
}
function tableToArray(element) {
  var result = [];
  var checkElement = element;
  if (typeof checkElement === "string") {
    var tempElem = document.createElement("div");
    tempElem.innerHTML = checkElement.replace(/\n/g, "");
    checkElement = tempElem.querySelector("table");
  }
  if (checkElement && isHTMLTable(checkElement)) {
    var rows = checkElement.rows;
    var rowsLen = rows && rows.length;
    var tempArray = [];
    for (var row = 0; row < rowsLen; row += 1) {
      var cells = rows[row].cells;
      var cellsLen = cells.length;
      var newRow = [];
      for (var column = 0; column < cellsLen; column += 1) {
        var cell = cells[column];
        cell.innerHTML = cell.innerHTML.trim().replace(/<br(.|)>(\n?)/, "\n");
        var cellText = cell.innerText;
        newRow.push(cellText);
      }
      tempArray.push(newRow);
    }
    result.push.apply(result, tempArray);
  }
  return result;
}

// node_modules/handsontable/es/plugins/copyPaste/copyPaste.js
function _slicedToArray15(arr, i) {
  return _arrayWithHoles16(arr) || _iterableToArrayLimit15(arr, i) || _nonIterableRest16();
}
function _nonIterableRest16() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit15(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles16(arr) {
  if (Array.isArray(arr)) return arr;
}
function _typeof31(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof31 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof31 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof31(obj);
}
function _classCallCheck61(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties58(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass58(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties58(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties58(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn19(self2, call) {
  if (call && (_typeof31(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized19(self2);
}
function _get11(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get11 = Reflect.get;
  } else {
    _get11 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase11(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get11(target, property, receiver || target);
}
function _superPropBase11(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf19(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf19(o) {
  _getPrototypeOf19 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf19(o);
}
function _inherits19(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf19(subClass, superClass);
}
function _setPrototypeOf19(o, p) {
  _setPrototypeOf19 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf19(o, p);
}
function _assertThisInitialized19(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
pluginHooks_default.getSingleton().register("afterCopyLimit");
pluginHooks_default.getSingleton().register("modifyCopyableRange");
pluginHooks_default.getSingleton().register("beforeCut");
pluginHooks_default.getSingleton().register("afterCut");
pluginHooks_default.getSingleton().register("beforePaste");
pluginHooks_default.getSingleton().register("afterPaste");
pluginHooks_default.getSingleton().register("beforeCopy");
pluginHooks_default.getSingleton().register("afterCopy");
var ROWS_LIMIT = 1e3;
var COLUMNS_LIMIT = 1e3;
var privatePool7 = /* @__PURE__ */ new WeakMap();
var CopyPaste = function(_BasePlugin) {
  _inherits19(CopyPaste2, _BasePlugin);
  function CopyPaste2(hotInstance) {
    var _this;
    _classCallCheck61(this, CopyPaste2);
    _this = _possibleConstructorReturn19(this, _getPrototypeOf19(CopyPaste2).call(this, hotInstance));
    _this.columnsLimit = COLUMNS_LIMIT;
    _this.copyableRanges = [];
    _this.pasteMode = "overwrite";
    _this.rowsLimit = ROWS_LIMIT;
    privatePool7.set(_assertThisInitialized19(_assertThisInitialized19(_this)), {
      isTriggeredByCopy: false,
      isTriggeredByCut: false,
      isBeginEditing: false,
      isFragmentSelectionEnabled: false
    });
    return _this;
  }
  _createClass58(CopyPaste2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings().copyPaste;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var settings = this.hot.getSettings();
      var priv = privatePool7.get(this);
      priv.isFragmentSelectionEnabled = settings.fragmentSelection;
      if (_typeof31(settings.copyPaste) === "object") {
        this.pasteMode = settings.copyPaste.pasteMode || this.pasteMode;
        this.rowsLimit = settings.copyPaste.rowsLimit || this.rowsLimit;
        this.columnsLimit = settings.copyPaste.columnsLimit || this.columnsLimit;
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.onAfterContextMenuDefaultOptions(options);
      });
      this.addHook("afterOnCellMouseUp", function() {
        return _this2.onAfterOnCellMouseUp();
      });
      this.addHook("afterSelectionEnd", function() {
        return _this2.onAfterSelectionEnd();
      });
      this.addHook("beforeKeyDown", function() {
        return _this2.onBeforeKeyDown();
      });
      this.focusableElement = createElement();
      this.focusableElement.addLocalHook("copy", function(event2) {
        return _this2.onCopy(event2);
      }).addLocalHook("cut", function(event2) {
        return _this2.onCut(event2);
      }).addLocalHook("paste", function(event2) {
        return _this2.onPaste(event2);
      });
      _get11(_getPrototypeOf19(CopyPaste2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.getOrCreateFocusableElement();
      _get11(_getPrototypeOf19(CopyPaste2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      if (this.focusableElement) {
        destroyElement(this.focusableElement);
      }
      _get11(_getPrototypeOf19(CopyPaste2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Copies the selected cell into the clipboard.
     */
  }, {
    key: "copy",
    value: function copy() {
      var priv = privatePool7.get(this);
      priv.isTriggeredByCopy = true;
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
      document.execCommand("copy");
    }
    /**
     * Cuts the selected cell into the clipboard.
     */
  }, {
    key: "cut",
    value: function cut() {
      var priv = privatePool7.get(this);
      priv.isTriggeredByCut = true;
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
      document.execCommand("cut");
    }
    /**
     * Creates copyable text releated to range objects.
     *
     * @param {Object[]} ranges Array of objects with properties `startRow`, `endRow`, `startCol` and `endCol`.
     * @returns {String} Returns string which will be copied into clipboard.
     */
  }, {
    key: "getRangedCopyableData",
    value: function getRangedCopyableData(ranges) {
      var _this3 = this;
      var dataSet = [];
      var copyableRows = [];
      var copyableColumns = [];
      arrayEach(ranges, function(range) {
        rangeEach(range.startRow, range.endRow, function(row) {
          if (copyableRows.indexOf(row) === -1) {
            copyableRows.push(row);
          }
        });
        rangeEach(range.startCol, range.endCol, function(column) {
          if (copyableColumns.indexOf(column) === -1) {
            copyableColumns.push(column);
          }
        });
      });
      arrayEach(copyableRows, function(row) {
        var rowSet = [];
        arrayEach(copyableColumns, function(column) {
          rowSet.push(_this3.hot.getCopyableData(row, column));
        });
        dataSet.push(rowSet);
      });
      return import_SheetClip2.default.stringify(dataSet);
    }
    /**
     * Creates copyable text releated to range objects.
     *
     * @param {Object[]} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.
     * @returns {Array[]} Returns array of arrays which will be copied into clipboard.
     */
  }, {
    key: "getRangedData",
    value: function getRangedData(ranges) {
      var _this4 = this;
      var dataSet = [];
      var copyableRows = [];
      var copyableColumns = [];
      arrayEach(ranges, function(range) {
        rangeEach(range.startRow, range.endRow, function(row) {
          if (copyableRows.indexOf(row) === -1) {
            copyableRows.push(row);
          }
        });
        rangeEach(range.startCol, range.endCol, function(column) {
          if (copyableColumns.indexOf(column) === -1) {
            copyableColumns.push(column);
          }
        });
      });
      arrayEach(copyableRows, function(row) {
        var rowSet = [];
        arrayEach(copyableColumns, function(column) {
          rowSet.push(_this4.hot.getCopyableData(row, column));
        });
        dataSet.push(rowSet);
      });
      return dataSet;
    }
    /**
     * Simulates the paste action.
     *
     * @param {String} [value] Value to paste.
     */
  }, {
    key: "paste",
    value: function paste() {
      var pastableText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var pastableHtml = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pastableText;
      if (!pastableText && !pastableHtml) {
        return;
      }
      var pasteData = new PasteEvent();
      if (pastableText) {
        pasteData.clipboardData.setData("text/plain", pastableText);
      }
      if (pastableHtml) {
        pasteData.clipboardData.setData("text/html", pastableHtml);
      }
      this.getOrCreateFocusableElement();
      this.onPaste(pasteData);
    }
    /**
     * Prepares copyable text from the cells selection in the invisible textarea.
     */
  }, {
    key: "setCopyableText",
    value: function setCopyableText() {
      var selRange = this.hot.getSelectedRangeLast();
      if (!selRange) {
        return;
      }
      var topLeft = selRange.getTopLeftCorner();
      var bottomRight = selRange.getBottomRightCorner();
      var startRow = topLeft.row;
      var startCol = topLeft.col;
      var endRow = bottomRight.row;
      var endCol = bottomRight.col;
      var finalEndRow = Math.min(endRow, startRow + this.rowsLimit - 1);
      var finalEndCol = Math.min(endCol, startCol + this.columnsLimit - 1);
      this.copyableRanges.length = 0;
      this.copyableRanges.push({
        startRow,
        startCol,
        endRow: finalEndRow,
        endCol: finalEndCol
      });
      this.copyableRanges = this.hot.runHooks("modifyCopyableRange", this.copyableRanges);
      if (endRow !== finalEndRow || endCol !== finalEndCol) {
        this.hot.runHooks("afterCopyLimit", endRow - startRow + 1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);
      }
    }
    /**
     * Force focus on editable element.
     *
     * @private
     */
  }, {
    key: "getOrCreateFocusableElement",
    value: function getOrCreateFocusableElement() {
      var editor = this.hot.getActiveEditor();
      var editableElement = editor ? editor.TEXTAREA : void 0;
      if (editableElement) {
        this.focusableElement.setFocusableElement(editableElement);
      } else {
        this.focusableElement.useSecondaryElement();
      }
    }
    /**
     * Verifies if editor exists and is open.
     *
     * @private
     */
  }, {
    key: "isEditorOpened",
    value: function isEditorOpened() {
      var editor = this.hot.getActiveEditor();
      return editor && editor.isOpened();
    }
    /**
     * Prepares new values to populate them into datasource.
     *
     * @private
     * @param {Array} inputArray
     * @param {Array} selection
     * @returns {Array} Range coordinates after populate data
     */
  }, {
    key: "populateValues",
    value: function populateValues(inputArray) {
      var selection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.hot.getSelectedLast();
      if (!inputArray.length) {
        return;
      }
      var newValuesMaxRow = inputArray.length - 1;
      var newValuesMaxColumn = inputArray[0].length - 1;
      var startRow = Math.min(selection[0], selection[2]);
      var endRow = Math.max(selection[0], selection[2], newValuesMaxRow + startRow);
      var startColumn = Math.min(selection[1], selection[3]);
      var endColumn = Math.max(selection[1], selection[3], newValuesMaxColumn + startColumn);
      var newValues = [];
      for (var row = startRow, valuesRow = 0; row <= endRow; row += 1) {
        var newRow = [];
        for (var column = startColumn, valuesColumn = 0; column <= endColumn; column += 1) {
          newRow.push(inputArray[valuesRow][valuesColumn]);
          valuesColumn = valuesColumn === newValuesMaxColumn ? 0 : valuesColumn += 1;
        }
        newValues.push(newRow);
        valuesRow = valuesRow === newValuesMaxRow ? 0 : valuesRow += 1;
      }
      this.hot.populateFromArray(startRow, startColumn, newValues, void 0, void 0, "CopyPaste.paste", this.pasteMode);
      return [startRow, startColumn, endRow, endColumn];
    }
    /**
     * `copy` event callback on textarea element.
     *
     * @param {Event} event ClipboardEvent.
     * @private
     */
  }, {
    key: "onCopy",
    value: function onCopy(event2) {
      var priv = privatePool7.get(this);
      if (!this.hot.isListening() && !priv.isTriggeredByCopy || this.isEditorOpened()) {
        return;
      }
      this.setCopyableText();
      priv.isTriggeredByCopy = false;
      var rangedData = this.getRangedData(this.copyableRanges);
      var allowCopying = !!this.hot.runHooks("beforeCopy", rangedData, this.copyableRanges);
      if (allowCopying) {
        var textPlain = import_SheetClip2.default.stringify(rangedData);
        if (event2 && event2.clipboardData) {
          var textHTML = arrayToTable(rangedData);
          event2.clipboardData.setData("text/plain", textPlain);
          event2.clipboardData.setData("text/html", textHTML);
        } else if (typeof ClipboardEvent === "undefined") {
          window.clipboardData.setData("Text", textPlain);
        }
        this.hot.runHooks("afterCopy", rangedData, this.copyableRanges);
      }
      event2.preventDefault();
    }
    /**
     * `cut` event callback on textarea element.
     *
     * @param {Event} event ClipboardEvent.
     * @private
     */
  }, {
    key: "onCut",
    value: function onCut(event2) {
      var priv = privatePool7.get(this);
      if (!this.hot.isListening() && !priv.isTriggeredByCut || this.isEditorOpened()) {
        return;
      }
      this.setCopyableText();
      priv.isTriggeredByCut = false;
      var rangedData = this.getRangedData(this.copyableRanges);
      var allowCuttingOut = !!this.hot.runHooks("beforeCut", rangedData, this.copyableRanges);
      if (allowCuttingOut) {
        var textPlain = import_SheetClip2.default.stringify(rangedData);
        if (event2 && event2.clipboardData) {
          var textHTML = arrayToTable(rangedData);
          event2.clipboardData.setData("text/plain", textPlain);
          event2.clipboardData.setData("text/html", textHTML);
        } else if (typeof ClipboardEvent === "undefined") {
          window.clipboardData.setData("Text", textPlain);
        }
        this.hot.emptySelectedCells();
        this.hot.runHooks("afterCut", rangedData, this.copyableRanges);
      }
      event2.preventDefault();
    }
    /**
     * `paste` event callback on textarea element.
     *
     * @param {Event} event ClipboardEvent or pseudo ClipboardEvent, if paste was called manually.
     * @private
     */
  }, {
    key: "onPaste",
    value: function onPaste(event2) {
      if (!this.hot.isListening() || this.isEditorOpened()) {
        return;
      }
      if (event2 && event2.preventDefault) {
        event2.preventDefault();
      }
      var pastedData;
      if (event2 && typeof event2.clipboardData !== "undefined") {
        var textHTML = event2.clipboardData.getData("text/html");
        if (textHTML && /(<table)|(<TABLE)/.test(textHTML)) {
          pastedData = tableToArray(textHTML);
        } else {
          pastedData = event2.clipboardData.getData("text/plain");
        }
      } else if (typeof ClipboardEvent === "undefined" && typeof window.clipboardData !== "undefined") {
        pastedData = window.clipboardData.getData("Text");
      }
      var inputArray = typeof pastedData !== "string" ? pastedData : import_SheetClip2.default.parse(pastedData);
      if (inputArray.length === 0) {
        return;
      }
      if (this.hot.runHooks("beforePaste", inputArray, this.copyableRanges) === false) {
        return;
      }
      var _this$populateValues = this.populateValues(inputArray), _this$populateValues2 = _slicedToArray15(_this$populateValues, 4), startRow = _this$populateValues2[0], startColumn = _this$populateValues2[1], endRow = _this$populateValues2[2], endColumn = _this$populateValues2[3];
      this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, endRow), Math.min(this.hot.countCols() - 1, endColumn));
      this.hot.runHooks("afterPaste", inputArray, this.copyableRanges);
    }
    /**
     * Add copy, cut and paste options to the Context Menu.
     *
     * @private
     * @param {Object} options Contains default added options of the Context Menu.
     */
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(options) {
      options.items.push({
        name: "---------"
      }, copyItem(this), cutItem(this));
    }
    /**
     * Force focus on focusableElement.
     *
     * @private
     */
  }, {
    key: "onAfterOnCellMouseUp",
    value: function onAfterOnCellMouseUp() {
      if (!this.hot.isListening() || this.isEditorOpened()) {
        return;
      }
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
    }
    /**
     * Force focus on focusableElement after end of the selection.
     *
     * @private
     */
  }, {
    key: "onAfterSelectionEnd",
    value: function onAfterSelectionEnd() {
      var _privatePool$get = privatePool7.get(this), isFragmentSelectionEnabled = _privatePool$get.isFragmentSelectionEnabled;
      if (this.isEditorOpened()) {
        return;
      }
      this.getOrCreateFocusableElement();
      if (isFragmentSelectionEnabled && this.focusableElement.getFocusableElement() !== document.activeElement && getSelectionText()) {
        return;
      }
      this.setCopyableText();
      this.focusableElement.focus();
    }
    /**
     * `beforeKeyDown` listener to force focus of focusableElement.
     *
     * @private
     */
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown9() {
      if (!this.hot.isListening() || this.isEditorOpened()) {
        return;
      }
      var activeElement = document.activeElement;
      var activeEditor = this.hot.getActiveEditor();
      if (!activeEditor || activeElement !== this.focusableElement.getFocusableElement() && activeElement !== activeEditor.select) {
        return;
      }
      this.getOrCreateFocusableElement();
      this.focusableElement.focus();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.focusableElement) {
        destroyElement(this.focusableElement);
        this.focusableElement = null;
      }
      _get11(_getPrototypeOf19(CopyPaste2.prototype), "destroy", this).call(this);
    }
  }]);
  return CopyPaste2;
}(base_default2);
registerPlugin("CopyPaste", CopyPaste);
var copyPaste_default = CopyPaste;

// node_modules/handsontable/es/plugins/customBorders/utils.js
function createId(row, col) {
  return "border_row".concat(row, "col").concat(col);
}
function createDefaultCustomBorder() {
  return {
    width: 1,
    color: "#000"
  };
}
function createSingleEmptyBorder() {
  return {
    hide: true
  };
}
function createDefaultHtBorder() {
  return {
    width: 1,
    color: "#000",
    cornerVisible: false
  };
}
function createEmptyBorders(row, col) {
  return {
    id: createId(row, col),
    border: createDefaultHtBorder(),
    row,
    col,
    top: createSingleEmptyBorder(),
    right: createSingleEmptyBorder(),
    bottom: createSingleEmptyBorder(),
    left: createSingleEmptyBorder()
  };
}
function extendDefaultBorder(defaultBorder, customBorder) {
  if (hasOwnProperty(customBorder, "border")) {
    defaultBorder.border = customBorder.border;
  }
  if (hasOwnProperty(customBorder, "top")) {
    if (customBorder.top) {
      if (!isObject(customBorder.top)) {
        customBorder.top = createDefaultCustomBorder();
      }
      defaultBorder.top = customBorder.top;
    } else {
      customBorder.top = createSingleEmptyBorder();
      defaultBorder.top = customBorder.top;
    }
  }
  if (hasOwnProperty(customBorder, "right")) {
    if (customBorder.right) {
      if (!isObject(customBorder.right)) {
        customBorder.right = createDefaultCustomBorder();
      }
      defaultBorder.right = customBorder.right;
    } else {
      customBorder.right = createSingleEmptyBorder();
      defaultBorder.right = customBorder.right;
    }
  }
  if (hasOwnProperty(customBorder, "bottom")) {
    if (customBorder.bottom) {
      if (!isObject(customBorder.bottom)) {
        customBorder.bottom = createDefaultCustomBorder();
      }
      defaultBorder.bottom = customBorder.bottom;
    } else {
      customBorder.bottom = createSingleEmptyBorder();
      defaultBorder.bottom = customBorder.bottom;
    }
  }
  if (hasOwnProperty(customBorder, "left")) {
    if (customBorder.left) {
      if (!isObject(customBorder.left)) {
        customBorder.left = createDefaultCustomBorder();
      }
      defaultBorder.left = customBorder.left;
    } else {
      customBorder.left = createSingleEmptyBorder();
      defaultBorder.left = customBorder.left;
    }
  }
  return defaultBorder;
}
function checkSelectionBorders(hot, direction) {
  var atLeastOneHasBorder = false;
  arrayEach(hot.getSelectedRange(), function(range) {
    range.forAll(function(r, c) {
      var metaBorders = hot.getCellMeta(r, c).borders;
      if (metaBorders) {
        if (direction) {
          if (!hasOwnProperty(metaBorders[direction], "hide") || metaBorders[direction].hide === false) {
            atLeastOneHasBorder = true;
            return false;
          }
        } else {
          atLeastOneHasBorder = true;
          return false;
        }
      }
    });
  });
  return atLeastOneHasBorder;
}
function markSelected(label) {
  return '<span class="selected">'.concat(String.fromCharCode(10003), "</span>").concat(label);
}

// node_modules/handsontable/es/plugins/customBorders/contextMenuItem/bottom.js
function bottom(customBordersPlugin) {
  return {
    key: "borders:bottom",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_BOTTOM);
      var hasBorder = checkSelectionBorders(this, "bottom");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "bottom");
      customBordersPlugin.prepareBorder(selected, "bottom", hasBorder);
    }
  };
}

// node_modules/handsontable/es/plugins/customBorders/contextMenuItem/left.js
function left(customBordersPlugin) {
  return {
    key: "borders:left",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_LEFT);
      var hasBorder = checkSelectionBorders(this, "left");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "left");
      customBordersPlugin.prepareBorder(selected, "left", hasBorder);
    }
  };
}

// node_modules/handsontable/es/plugins/customBorders/contextMenuItem/noBorders.js
function noBorders(customBordersPlugin) {
  return {
    key: "borders:no_borders",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_BORDERS);
    },
    callback: function callback(key, selected) {
      customBordersPlugin.prepareBorder(selected, "noBorders");
    },
    disabled: function disabled() {
      return !checkSelectionBorders(this);
    }
  };
}

// node_modules/handsontable/es/plugins/customBorders/contextMenuItem/right.js
function right(customBordersPlugin) {
  return {
    key: "borders:right",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_RIGHT);
      var hasBorder = checkSelectionBorders(this, "right");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "right");
      customBordersPlugin.prepareBorder(selected, "right", hasBorder);
    }
  };
}

// node_modules/handsontable/es/plugins/customBorders/contextMenuItem/top.js
function top(customBordersPlugin) {
  return {
    key: "borders:top",
    name: function name() {
      var label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_TOP);
      var hasBorder = checkSelectionBorders(this, "top");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback: function callback(key, selected) {
      var hasBorder = checkSelectionBorders(this, "top");
      customBordersPlugin.prepareBorder(selected, "top", hasBorder);
    }
  };
}

// node_modules/handsontable/es/plugins/customBorders/customBorders.js
function _typeof32(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof32 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof32 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof32(obj);
}
function _slicedToArray16(arr, i) {
  return _arrayWithHoles17(arr) || _iterableToArrayLimit16(arr, i) || _nonIterableRest17();
}
function _nonIterableRest17() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit16(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles17(arr) {
  if (Array.isArray(arr)) return arr;
}
function _classCallCheck62(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties59(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass59(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties59(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties59(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn20(self2, call) {
  if (call && (_typeof32(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized20(self2);
}
function _assertThisInitialized20(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get12(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get12 = Reflect.get;
  } else {
    _get12 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase12(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get12(target, property, receiver || target);
}
function _superPropBase12(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf20(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf20(o) {
  _getPrototypeOf20 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf20(o);
}
function _inherits20(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf20(subClass, superClass);
}
function _setPrototypeOf20(o, p) {
  _setPrototypeOf20 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf20(o, p);
}
var CustomBorders = function(_BasePlugin) {
  _inherits20(CustomBorders2, _BasePlugin);
  function CustomBorders2(hotInstance) {
    var _this;
    _classCallCheck62(this, CustomBorders2);
    _this = _possibleConstructorReturn20(this, _getPrototypeOf20(CustomBorders2).call(this, hotInstance));
    _this.savedBorders = [];
    return _this;
  }
  _createClass59(CustomBorders2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings().customBorders;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.onAfterContextMenuDefaultOptions(options);
      });
      this.addHook("afterInit", function() {
        return _this2.onAfterInit();
      });
      _get12(_getPrototypeOf20(CustomBorders2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.hideBorders();
      _get12(_getPrototypeOf20(CustomBorders2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.changeBorderSettings();
      _get12(_getPrototypeOf20(CustomBorders2.prototype), "updatePlugin", this).call(this);
    }
    /**
      * Set custom borders.
      *
      * @example
      * ```js
      * const customBordersPlugin = hot.getPlugin('customBorders');
      *
      * // Using an array of arrays (produced by `.getSelected()` method).
      * customBordersPlugin.setBorders([[1, 1, 2, 2], [6, 2, 0, 2]], {left: {width: 2, color: 'blue'}});
      * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
      * customBordersPlugin.setBorders(hot.getSelectedRange(), {left: {hide: false, width: 2, color: 'blue'}});
      * ```
      *
      * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
      * @param {Object} borderObject Object with `top`, `right`, `bottom` and `left` properties.
      */
  }, {
    key: "setBorders",
    value: function setBorders(selectionRanges, borderObject) {
      var _this3 = this;
      var defaultBorderKeys = ["top", "right", "bottom", "left"];
      var borderKeys = borderObject ? Object.keys(borderObject) : defaultBorderKeys;
      var selectionType = detectSelectionType(selectionRanges);
      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
      arrayEach(selectionRanges, function(selection) {
        var _selectionSchemaNorma = selectionSchemaNormalizer(selection), _selectionSchemaNorma2 = _slicedToArray16(_selectionSchemaNorma, 4), rowStart = _selectionSchemaNorma2[0], columnStart = _selectionSchemaNorma2[1], rowEnd = _selectionSchemaNorma2[2], columnEnd = _selectionSchemaNorma2[3];
        var _loop = function _loop2(row2) {
          var _loop22 = function _loop23(col2) {
            arrayEach(borderKeys, function(borderKey) {
              _this3.prepareBorderFromCustomAdded(row2, col2, borderObject, borderKey);
            });
          };
          for (var col = columnStart; col <= columnEnd; col += 1) {
            _loop22(col);
          }
        };
        for (var row = rowStart; row <= rowEnd; row += 1) {
          _loop(row);
        }
      });
    }
    /**
      * Get custom borders.
      *
      * @example
      * ```js
      * const customBordersPlugin = hot.getPlugin('customBorders');
      *
      * // Using an array of arrays (produced by `.getSelected()` method).
      * customBordersPlugin.getBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);
      * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
      * customBordersPlugin.getBorders(hot.getSelectedRange());
      * // Using without param - return all customBorders.
      * customBordersPlugin.getBorders();
      * ```
      *
      * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
      * @return {Object[]} Returns array of border objects.
      */
  }, {
    key: "getBorders",
    value: function getBorders(selectionRanges) {
      var _this4 = this;
      if (!Array.isArray(selectionRanges)) {
        return this.savedBorders;
      }
      var selectionType = detectSelectionType(selectionRanges);
      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
      var selectedBorders = [];
      arrayEach(selectionRanges, function(selection) {
        var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection), _selectionSchemaNorma4 = _slicedToArray16(_selectionSchemaNorma3, 4), rowStart = _selectionSchemaNorma4[0], columnStart = _selectionSchemaNorma4[1], rowEnd = _selectionSchemaNorma4[2], columnEnd = _selectionSchemaNorma4[3];
        var _loop3 = function _loop32(row2) {
          var _loop4 = function _loop42(col2) {
            arrayEach(_this4.savedBorders, function(border) {
              if (border.row === row2 && border.col === col2) {
                selectedBorders.push(border);
              }
            });
          };
          for (var col = columnStart; col <= columnEnd; col += 1) {
            _loop4(col);
          }
        };
        for (var row = rowStart; row <= rowEnd; row += 1) {
          _loop3(row);
        }
      });
      return selectedBorders;
    }
    /**
      * Clear custom borders.
      *
      * @example
      * ```js
      * const customBordersPlugin = hot.getPlugin('customBorders');
      *
      * // Using an array of arrays (produced by `.getSelected()` method).
      * customBordersPlugin.clearBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);
      * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
      * customBordersPlugin.clearBorders(hot.getSelectedRange());
      * // Using without param - clear all customBorders.
      * customBordersPlugin.clearBorders();
      * ```
      *
      * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
      */
  }, {
    key: "clearBorders",
    value: function clearBorders(selectionRanges) {
      var _this5 = this;
      if (selectionRanges) {
        this.setBorders(selectionRanges);
      } else {
        arrayEach(this.savedBorders, function(border) {
          _this5.clearBordersFromSelectionSettings(border.id);
          _this5.clearNullCellRange();
          _this5.hot.removeCellMeta(border.row, border.col, "borders");
        });
        this.savedBorders.length = 0;
      }
    }
    /**
     * Insert WalkontableSelection instance into Walkontable settings.
     *
     * @private
     * @param {Object} border Object with `row` and `col`, `left`, `right`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
     * @param {String} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right`.
     */
  }, {
    key: "insertBorderIntoSettings",
    value: function insertBorderIntoSettings(border, place) {
      var hasSavedBorders = this.checkSavedBorders(border);
      if (!hasSavedBorders) {
        this.savedBorders.push(border);
      }
      var coordinates = {
        row: border.row,
        col: border.col
      };
      var cellRange = new range_default(coordinates, coordinates, coordinates);
      var hasCustomSelections = this.checkCustomSelections(border, cellRange, place);
      if (!hasCustomSelections) {
        this.hot.selection.highlight.addCustomSelection({
          border,
          cellRange
        });
        this.hot.view.wt.draw(true);
      }
    }
    /**
     * Prepare borders from setting (single cell).
     *
     * @private
     * @param {Number} row Visual row index.
     * @param {Number} column Visual column index.
     * @param {Object} borderDescriptor Object with `row` and `col`, `left`, `right`, `top` and `bottom` properties.
     * @param {String} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right`.
     */
  }, {
    key: "prepareBorderFromCustomAdded",
    value: function prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {
      var border = createEmptyBorders(row, column);
      if (borderDescriptor) {
        border = extendDefaultBorder(border, borderDescriptor);
        arrayEach(this.hot.selection.highlight.customSelections, function(customSelection) {
          if (border.id === customSelection.settings.id) {
            Object.assign(customSelection.settings, borderDescriptor);
            border = customSelection.settings;
            return false;
          }
        });
      }
      this.hot.setCellMeta(row, column, "borders", border);
      this.insertBorderIntoSettings(border, place);
    }
    /**
     * Prepare borders from setting (object).
     *
     * @private
     * @param {Object} rowDecriptor Object with `range`, `left`, `right`, `top` and `bottom` properties.
     */
  }, {
    key: "prepareBorderFromCustomAddedRange",
    value: function prepareBorderFromCustomAddedRange(rowDecriptor) {
      var _this6 = this;
      var range = rowDecriptor.range;
      rangeEach(range.from.row, range.to.row, function(rowIndex) {
        rangeEach(range.from.col, range.to.col, function(colIndex) {
          var border = createEmptyBorders(rowIndex, colIndex);
          var add5 = 0;
          if (rowIndex === range.from.row) {
            add5 += 1;
            if (hasOwnProperty(rowDecriptor, "top")) {
              border.top = rowDecriptor.top;
            }
          }
          if (rowIndex === range.to.row) {
            add5 += 1;
            if (hasOwnProperty(rowDecriptor, "bottom")) {
              border.bottom = rowDecriptor.bottom;
            }
          }
          if (colIndex === range.from.col) {
            add5 += 1;
            if (hasOwnProperty(rowDecriptor, "left")) {
              border.left = rowDecriptor.left;
            }
          }
          if (colIndex === range.to.col) {
            add5 += 1;
            if (hasOwnProperty(rowDecriptor, "right")) {
              border.right = rowDecriptor.right;
            }
          }
          if (add5 > 0) {
            _this6.hot.setCellMeta(rowIndex, colIndex, "borders", border);
            _this6.insertBorderIntoSettings(border);
          }
        });
      });
    }
    /**
     * Remove border (triggered from context menu).
     *
     * @private
     * @param {Number} row Visual row index.
     * @param {Number} column Visual column index.
     */
  }, {
    key: "removeAllBorders",
    value: function removeAllBorders(row, column) {
      var borderId = createId(row, column);
      this.spliceBorder(borderId);
      this.clearBordersFromSelectionSettings(borderId);
      this.clearNullCellRange();
      this.hot.removeCellMeta(row, column, "borders");
    }
    /**
     * Set borders for each cell re. to border position.
     *
     * @private
     * @param {Number} row Visual row index.
     * @param {Number} column Visual column index.
     * @param {String} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.
     * @param {Boolean} remove True when remove borders, and false when add borders.
     */
  }, {
    key: "setBorder",
    value: function setBorder(row, column, place, remove) {
      var bordersMeta = this.hot.getCellMeta(row, column).borders;
      if (!bordersMeta || bordersMeta.border === void 0) {
        bordersMeta = createEmptyBorders(row, column);
      }
      if (remove) {
        bordersMeta[place] = createSingleEmptyBorder();
        var hideCount = this.countHide(bordersMeta);
        if (hideCount === 4) {
          this.removeAllBorders(row, column);
        } else {
          var customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
          if (!customSelectionsChecker) {
            this.insertBorderIntoSettings(bordersMeta);
          }
          this.hot.setCellMeta(row, column, "borders", bordersMeta);
        }
      } else {
        bordersMeta[place] = createDefaultCustomBorder();
        var _customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
        if (!_customSelectionsChecker) {
          this.insertBorderIntoSettings(bordersMeta);
        }
        this.hot.setCellMeta(row, column, "borders", bordersMeta);
      }
    }
    /**
     * Prepare borders based on cell and border position.
     *
     * @private
     * @param {Object} selected
     * @param {String} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.
     * @param {Boolean} remove True when remove borders, and false when add borders.
     */
  }, {
    key: "prepareBorder",
    value: function prepareBorder(selected, place, remove) {
      var _this7 = this;
      arrayEach(selected, function(_ref) {
        var start = _ref.start, end = _ref.end;
        if (start.row === end.row && start.col === end.col) {
          if (place === "noBorders") {
            _this7.removeAllBorders(start.row, start.col);
          } else {
            _this7.setBorder(start.row, start.col, place, remove);
          }
        } else {
          switch (place) {
            case "noBorders":
              rangeEach(start.col, end.col, function(colIndex) {
                rangeEach(start.row, end.row, function(rowIndex) {
                  _this7.removeAllBorders(rowIndex, colIndex);
                });
              });
              break;
            case "top":
              rangeEach(start.col, end.col, function(topCol) {
                _this7.setBorder(start.row, topCol, place, remove);
              });
              break;
            case "right":
              rangeEach(start.row, end.row, function(rowRight) {
                _this7.setBorder(rowRight, end.col, place, remove);
              });
              break;
            case "bottom":
              rangeEach(start.col, end.col, function(bottomCol) {
                _this7.setBorder(end.row, bottomCol, place, remove);
              });
              break;
            case "left":
              rangeEach(start.row, end.row, function(rowLeft) {
                _this7.setBorder(rowLeft, start.col, place, remove);
              });
              break;
            default:
              break;
          }
        }
      });
    }
    /**
     * Create borders from settings.
     *
     * @private
     * @param {Array} customBorders Object with `row` and `col`, `left`, `right`, `top` and `bottom` properties.
     */
  }, {
    key: "createCustomBorders",
    value: function createCustomBorders(customBorders) {
      var _this8 = this;
      arrayEach(customBorders, function(customBorder) {
        if (customBorder.range) {
          _this8.prepareBorderFromCustomAddedRange(customBorder);
        } else {
          _this8.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, customBorder);
        }
      });
    }
    /**
    * Count hide property in border object.
    *
    * @private
    * @param {Object} border Object with `row` and `col`, `left`, `right`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
    */
  }, {
    key: "countHide",
    value: function countHide(border) {
      var values = Object.values(border);
      return arrayReduce(values, function(accumulator, value) {
        var result = accumulator;
        if (value.hide) {
          result += 1;
        }
        return result;
      }, 0);
    }
    /**
    * Clear borders settings from custom selections.
    *
    * @private
    * @param {String} borderId Border id name as string.
    */
  }, {
    key: "clearBordersFromSelectionSettings",
    value: function clearBordersFromSelectionSettings(borderId) {
      var index2 = arrayMap(this.hot.selection.highlight.customSelections, function(customSelection) {
        return customSelection.settings.id;
      }).indexOf(borderId);
      if (index2 > -1) {
        this.hot.selection.highlight.customSelections[index2].clear();
      }
      this.hot.view.wt.draw(true);
    }
    /**
    * Clear cellRange with null value.
    *
    * @private
    */
  }, {
    key: "clearNullCellRange",
    value: function clearNullCellRange() {
      var _this9 = this;
      arrayEach(this.hot.selection.highlight.customSelections, function(customSelection, index2) {
        if (customSelection.cellRange === null) {
          _this9.hot.selection.highlight.customSelections.splice(index2, 1);
          return false;
        }
      });
    }
    /**
      * Hide custom borders.
      *
      * @private
      */
  }, {
    key: "hideBorders",
    value: function hideBorders() {
      var _this10 = this;
      arrayEach(this.savedBorders, function(border) {
        _this10.clearBordersFromSelectionSettings(border.id);
      });
    }
    /**
    * Splice border from savedBorders.
    *
    * @private
    * @param {String} borderId Border id name as string.
    */
  }, {
    key: "spliceBorder",
    value: function spliceBorder(borderId) {
      var index2 = arrayMap(this.savedBorders, function(border) {
        return border.id;
      }).indexOf(borderId);
      if (index2 > -1) {
        this.savedBorders.splice(index2, 1);
      }
    }
    /**
    * Check if an border already exists in the savedBorders array, and if true update border in savedBorders.
    *
    * @private
    * @param {Object} border Object with `row` and `col`, `left`, `right`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
    *
    * @return {Boolean}
    */
  }, {
    key: "checkSavedBorders",
    value: function checkSavedBorders(border) {
      var _this11 = this;
      var check = false;
      var hideCount = this.countHide(border);
      if (hideCount === 4) {
        this.spliceBorder(border.id);
        check = true;
      } else {
        arrayEach(this.savedBorders, function(savedBorder, index2) {
          if (border.id === savedBorder.id) {
            _this11.savedBorders[index2] = border;
            check = true;
            return false;
          }
        });
      }
      return check;
    }
    /**
    * Check if an border already exists in the customSelections, and if true call toggleHiddenClass method.
    *
    * @private
    * @param {Object} border Object with `row` and `col`, `left`, `right`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
    * @param {String} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.
    * @param {Boolean} remove True when remove borders, and false when add borders.
    *
    * @return {Boolean}
    */
  }, {
    key: "checkCustomSelectionsFromContextMenu",
    value: function checkCustomSelectionsFromContextMenu(border, place, remove) {
      var check = false;
      arrayEach(this.hot.selection.highlight.customSelections, function(customSelection) {
        if (border.id === customSelection.settings.id) {
          objectEach(customSelection.instanceBorders, function(borderObject) {
            borderObject.toggleHiddenClass(place, remove);
          });
          check = true;
          return false;
        }
      });
      return check;
    }
    /**
    * Check if an border already exists in the customSelections, and if true reset cellRange.
    *
    * @private
    * @param {Object} border Object with `row` and `col`, `left`, `right`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
    * @param {CellRange} cellRange
    * @param {String} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right`.
    *
    * @return {Boolean}
    */
  }, {
    key: "checkCustomSelections",
    value: function checkCustomSelections(border, cellRange, place) {
      var hideCount = this.countHide(border);
      var check = false;
      if (hideCount === 4) {
        this.removeAllBorders(border.row, border.col);
        this.clearBordersFromSelectionSettings(border.id);
        this.clearNullCellRange();
        check = true;
      } else {
        arrayEach(this.hot.selection.highlight.customSelections, function(customSelection) {
          if (border.id === customSelection.settings.id) {
            customSelection.cellRange = cellRange;
            if (place) {
              objectEach(customSelection.instanceBorders, function(borderObject) {
                borderObject.changeBorderStyle(place, border);
              });
            }
            check = true;
            return false;
          }
        });
      }
      return check;
    }
    /**
     * Change borders from settings.
     *
     * @private
     */
  }, {
    key: "changeBorderSettings",
    value: function changeBorderSettings() {
      var customBorders = this.hot.getSettings().customBorders;
      if (Array.isArray(customBorders)) {
        if (!customBorders.length) {
          this.savedBorders = customBorders;
        }
        this.createCustomBorders(customBorders);
      } else if (customBorders !== void 0) {
        this.createCustomBorders(this.savedBorders);
      }
    }
    /**
    * Add border options to context menu.
    *
    * @private
    * @param {Object} defaultOptions Context menu items.
    */
  }, {
    key: "onAfterContextMenuDefaultOptions",
    value: function onAfterContextMenuDefaultOptions(defaultOptions2) {
      if (!this.hot.getSettings().customBorders) {
        return;
      }
      defaultOptions2.items.push({
        name: "---------"
      }, {
        key: "borders",
        name: function name() {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS);
        },
        disabled: function disabled() {
          return this.selection.isSelectedByCorner();
        },
        submenu: {
          items: [top(this), right(this), bottom(this), left(this), noBorders(this)]
        }
      });
    }
    /**
     * `afterInit` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      this.changeBorderSettings();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get12(_getPrototypeOf20(CustomBorders2.prototype), "destroy", this).call(this);
    }
  }]);
  return CustomBorders2;
}(base_default2);
registerPlugin("customBorders", CustomBorders);
var customBorders_default = CustomBorders;

// node_modules/handsontable/es/plugins/dragToScroll/dragToScroll.js
function _typeof33(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof33 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof33 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof33(obj);
}
function _classCallCheck63(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties60(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass60(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties60(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties60(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn21(self2, call) {
  if (call && (_typeof33(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized21(self2);
}
function _get13(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get13 = Reflect.get;
  } else {
    _get13 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase13(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get13(target, property, receiver || target);
}
function _superPropBase13(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf21(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf21(o) {
  _getPrototypeOf21 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf21(o);
}
function _inherits21(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf21(subClass, superClass);
}
function _setPrototypeOf21(o, p) {
  _setPrototypeOf21 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf21(o, p);
}
function _assertThisInitialized21(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var DragToScroll = function(_BasePlugin) {
  _inherits21(DragToScroll2, _BasePlugin);
  function DragToScroll2(hotInstance) {
    var _this;
    _classCallCheck63(this, DragToScroll2);
    _this = _possibleConstructorReturn21(this, _getPrototypeOf21(DragToScroll2).call(this, hotInstance));
    _this.eventManager = new eventManager_default(_assertThisInitialized21(_assertThisInitialized21(_this)));
    _this.boundaries = null;
    _this.callback = null;
    _this.listening = false;
    return _this;
  }
  _createClass60(DragToScroll2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings().dragToScroll;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterOnCellMouseDown", function() {
        return _this2.setupListening();
      });
      this.addHook("afterOnCellCornerMouseDown", function() {
        return _this2.setupListening();
      });
      this.registerEvents();
      _get13(_getPrototypeOf21(DragToScroll2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get13(_getPrototypeOf21(DragToScroll2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.unregisterEvents();
      _get13(_getPrototypeOf21(DragToScroll2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Sets the value of the visible element.
     *
     * @param boundaries {DOMRect} An object with coordinates compatible with DOMRect.
     */
  }, {
    key: "setBoundaries",
    value: function setBoundaries(boundaries) {
      this.boundaries = boundaries;
    }
    /**
     * Changes callback function.
     *
     * @param callback {Function}
     */
  }, {
    key: "setCallback",
    value: function setCallback(callback) {
      this.callback = callback;
    }
    /**
     * Checks if the mouse position (X, Y) is outside of the viewport and fires a callback with calculated X an Y diffs
     * between passed boundaries.
     *
     * @param {Number} x Mouse X coordinate to check.
     * @param {Number} y Mouse Y coordinate to check.
     */
  }, {
    key: "check",
    value: function check(x, y) {
      var diffX = 0;
      var diffY = 0;
      if (y < this.boundaries.top) {
        diffY = y - this.boundaries.top;
      } else if (y > this.boundaries.bottom) {
        diffY = y - this.boundaries.bottom;
      }
      if (x < this.boundaries.left) {
        diffX = x - this.boundaries.left;
      } else if (x > this.boundaries.right) {
        diffX = x - this.boundaries.right;
      }
      this.callback(diffX, diffY);
    }
    /**
     * Registers dom listeners.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this3 = this;
      this.eventManager.addEventListener(document, "mouseup", function() {
        return _this3.onMouseUp();
      });
      this.eventManager.addEventListener(document, "mousemove", function(event2) {
        return _this3.onMouseMove(event2);
      });
    }
    /**
     * Unbinds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "unregisterEvents",
    value: function unregisterEvents() {
      this.eventManager.clear();
    }
    /**
     * On after on cell/cellCorner mouse down listener.
     *
     * @private
     */
  }, {
    key: "setupListening",
    value: function setupListening() {
      var scrollHandler = this.hot.view.wt.wtTable.holder;
      if (scrollHandler === window) {
        return;
      }
      this.setBoundaries(scrollHandler.getBoundingClientRect());
      this.setCallback(function(scrollX, scrollY) {
        if (scrollX < 0) {
          scrollHandler.scrollLeft -= 50;
        } else if (scrollX > 0) {
          scrollHandler.scrollLeft += 50;
        }
        if (scrollY < 0) {
          scrollHandler.scrollTop -= 20;
        } else if (scrollY > 0) {
          scrollHandler.scrollTop += 20;
        }
      });
      this.listening = true;
    }
    /**
     * 'mouseMove' event callback.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      if (this.listening) {
        this.check(event2.clientX, event2.clientY);
      }
    }
    /**
     * `onMouseUp` hook callback.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      this.listening = false;
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get13(_getPrototypeOf21(DragToScroll2.prototype), "destroy", this).call(this);
    }
  }]);
  return DragToScroll2;
}(base_default2);
registerPlugin("dragToScroll", DragToScroll);
var dragToScroll_default = DragToScroll;

// node_modules/handsontable/es/plugins/manualColumnFreeze/contextMenuItem/freezeColumn.js
function _slicedToArray17(arr, i) {
  return _arrayWithHoles18(arr) || _iterableToArrayLimit17(arr, i) || _nonIterableRest18();
}
function _nonIterableRest18() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit17(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles18(arr) {
  if (Array.isArray(arr)) return arr;
}
function freezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "freeze_column",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_FREEZE_COLUMN);
    },
    callback: function callback(key, selected) {
      var _selected = _slicedToArray17(selected, 1), selectedColumn = _selected[0].start.col;
      manualColumnFreezePlugin.freezeColumn(selectedColumn);
      this.render();
      this.view.wt.wtOverlays.adjustElementsSize(true);
    },
    hidden: function hidden() {
      var selection = this.getSelectedRange();
      var hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col <= this.getSettings().fixedColumnsLeft - 1) {
        hide = true;
      }
      return hide;
    }
  };
}

// node_modules/handsontable/es/plugins/manualColumnFreeze/contextMenuItem/unfreezeColumn.js
function _slicedToArray18(arr, i) {
  return _arrayWithHoles19(arr) || _iterableToArrayLimit18(arr, i) || _nonIterableRest19();
}
function _nonIterableRest19() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit18(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles19(arr) {
  if (Array.isArray(arr)) return arr;
}
function unfreezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "unfreeze_column",
    name: function name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNFREEZE_COLUMN);
    },
    callback: function callback(key, selected) {
      var _selected = _slicedToArray18(selected, 1), selectedColumn = _selected[0].start.col;
      manualColumnFreezePlugin.unfreezeColumn(selectedColumn);
      this.render();
      this.view.wt.wtOverlays.adjustElementsSize(true);
    },
    hidden: function hidden() {
      var selection = this.getSelectedRange();
      var hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col >= this.getSettings().fixedColumnsLeft) {
        hide = true;
      }
      return hide;
    }
  };
}

// node_modules/handsontable/es/plugins/manualColumnFreeze/manualColumnFreeze.js
function _typeof34(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof34 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof34 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof34(obj);
}
function _classCallCheck64(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties61(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass61(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties61(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties61(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn22(self2, call) {
  if (call && (_typeof34(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized22(self2);
}
function _get14(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get14 = Reflect.get;
  } else {
    _get14 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase14(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get14(target, property, receiver || target);
}
function _superPropBase14(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf22(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf22(o) {
  _getPrototypeOf22 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf22(o);
}
function _inherits22(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf22(subClass, superClass);
}
function _setPrototypeOf22(o, p) {
  _setPrototypeOf22 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf22(o, p);
}
function _assertThisInitialized22(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var privatePool8 = /* @__PURE__ */ new WeakMap();
var ManualColumnFreeze = function(_BasePlugin) {
  _inherits22(ManualColumnFreeze2, _BasePlugin);
  function ManualColumnFreeze2(hotInstance) {
    var _this;
    _classCallCheck64(this, ManualColumnFreeze2);
    _this = _possibleConstructorReturn22(this, _getPrototypeOf22(ManualColumnFreeze2).call(this, hotInstance));
    privatePool8.set(_assertThisInitialized22(_assertThisInitialized22(_this)), {
      moveByFreeze: false,
      afterFirstUse: false
    });
    _this.frozenColumnsBasePositions = [];
    _this.manualColumnMovePlugin = void 0;
    return _this;
  }
  _createClass61(ManualColumnFreeze2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings().manualColumnFreeze;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterContextMenuDefaultOptions", function(options) {
        return _this2.addContextMenuEntry(options);
      });
      this.addHook("afterInit", function() {
        return _this2.onAfterInit();
      });
      this.addHook("beforeColumnMove", function(rows, target) {
        return _this2.onBeforeColumnMove(rows, target);
      });
      _get14(_getPrototypeOf22(ManualColumnFreeze2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var priv = privatePool8.get(this);
      priv.afterFirstUse = false;
      priv.moveByFreeze = false;
      _get14(_getPrototypeOf22(ManualColumnFreeze2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get14(_getPrototypeOf22(ManualColumnFreeze2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Freezes the given column (add it to fixed columns).
     *
     * @param {Number} column Visual column index.
     */
  }, {
    key: "freezeColumn",
    value: function freezeColumn(column) {
      var priv = privatePool8.get(this);
      var settings = this.hot.getSettings();
      if (!priv.afterFirstUse) {
        priv.afterFirstUse = true;
      }
      if (settings.fixedColumnsLeft === this.hot.countCols() || column <= settings.fixedColumnsLeft - 1) {
        return;
      }
      priv.moveByFreeze = true;
      if (column !== this.getMovePlugin().columnsMapper.getValueByIndex(column)) {
        this.frozenColumnsBasePositions[settings.fixedColumnsLeft] = column;
      }
      this.getMovePlugin().moveColumn(column, settings.fixedColumnsLeft);
      settings.fixedColumnsLeft += 1;
    }
    /**
     * Unfreezes the given column (remove it from fixed columns and bring to it's previous position).
     *
     * @param {Number} column Visual column index.
     */
  }, {
    key: "unfreezeColumn",
    value: function unfreezeColumn(column) {
      var priv = privatePool8.get(this);
      var settings = this.hot.getSettings();
      if (!priv.afterFirstUse) {
        priv.afterFirstUse = true;
      }
      if (settings.fixedColumnsLeft <= 0 || column > settings.fixedColumnsLeft - 1) {
        return;
      }
      var returnCol = this.getBestColumnReturnPosition(column);
      priv.moveByFreeze = true;
      settings.fixedColumnsLeft -= 1;
      this.getMovePlugin().moveColumn(column, returnCol + 1);
    }
    /**
     * Gets the reference to the ManualColumnMove plugin.
     *
     * @private
     * @returns {Object}
     */
  }, {
    key: "getMovePlugin",
    value: function getMovePlugin() {
      if (!this.manualColumnMovePlugin) {
        this.manualColumnMovePlugin = this.hot.getPlugin("manualColumnMove");
      }
      return this.manualColumnMovePlugin;
    }
    /**
     * Estimates the most fitting return position for unfrozen column.
     *
     * @private
     * @param {Number} column Visual column index.
     */
  }, {
    key: "getBestColumnReturnPosition",
    value: function getBestColumnReturnPosition(column) {
      var movePlugin = this.getMovePlugin();
      var settings = this.hot.getSettings();
      var i = settings.fixedColumnsLeft;
      var j = movePlugin.columnsMapper.getValueByIndex(i);
      var initialCol;
      if (this.frozenColumnsBasePositions[column] === null || this.frozenColumnsBasePositions[column] === void 0) {
        initialCol = movePlugin.columnsMapper.getValueByIndex(column);
        while (j !== null && j <= initialCol) {
          i += 1;
          j = movePlugin.columnsMapper.getValueByIndex(i);
        }
      } else {
        initialCol = this.frozenColumnsBasePositions[column];
        this.frozenColumnsBasePositions[column] = void 0;
        while (j !== null && j <= initialCol) {
          i += 1;
          j = movePlugin.columnsMapper.getValueByIndex(i);
        }
        i = j;
      }
      return i - 1;
    }
    /**
     * Adds the manualColumnFreeze context menu entries.
     *
     * @private
     * @param {Object} options Context menu options.
     */
  }, {
    key: "addContextMenuEntry",
    value: function addContextMenuEntry(options) {
      options.items.push({
        name: "---------"
      }, freezeColumnItem(this), unfreezeColumnItem(this));
    }
    /**
     * Enables `manualColumnMove` plugin on `afterInit` hook.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      if (!this.getMovePlugin().isEnabled()) {
        this.getMovePlugin().enablePlugin();
      }
    }
    /**
     * Prevents moving the rows from/to fixed area.
     *
     * @private
     * @param {Array} rows
     * @param {Number} target
     */
  }, {
    key: "onBeforeColumnMove",
    value: function onBeforeColumnMove(rows, target) {
      var priv = privatePool8.get(this);
      if (priv.afterFirstUse && !priv.moveByFreeze) {
        var frozenLen = this.hot.getSettings().fixedColumnsLeft;
        var disallowMoving = target < frozenLen;
        if (!disallowMoving) {
          arrayEach(rows, function(value) {
            if (value < frozenLen) {
              disallowMoving = true;
              return false;
            }
          });
        }
        if (disallowMoving) {
          return false;
        }
      }
      if (priv.moveByFreeze) {
        priv.moveByFreeze = false;
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get14(_getPrototypeOf22(ManualColumnFreeze2.prototype), "destroy", this).call(this);
    }
  }]);
  return ManualColumnFreeze2;
}(base_default2);
registerPlugin("manualColumnFreeze", ManualColumnFreeze);
var manualColumnFreeze_default = ManualColumnFreeze;

// node_modules/handsontable/es/plugins/manualColumnMove/columnsMapper.js
function _classCallCheck65(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties62(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass62(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties62(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties62(Constructor, staticProps);
  return Constructor;
}
var ColumnsMapper = function() {
  function ColumnsMapper2(manualColumnMove) {
    _classCallCheck65(this, ColumnsMapper2);
    this.manualColumnMove = manualColumnMove;
  }
  _createClass62(ColumnsMapper2, [{
    key: "createMap",
    value: function createMap(length) {
      var _this = this;
      var originLength = length === void 0 ? this._arrayMap.length : length;
      this._arrayMap.length = 0;
      rangeEach(originLength - 1, function(itemIndex) {
        _this._arrayMap[itemIndex] = itemIndex;
      });
    }
    /**
     * Destroy class.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this._arrayMap = null;
    }
    /**
     * Moving elements in columnsMapper.
     *
     * @param {Number} from Column index to move.
     * @param {Number} to Target index.
     */
  }, {
    key: "moveColumn",
    value: function moveColumn(from3, to3) {
      var indexToMove = this._arrayMap[from3];
      this._arrayMap[from3] = null;
      this._arrayMap.splice(to3, 0, indexToMove);
    }
    /**
     * Clearing arrayMap from `null` entries.
     */
  }, {
    key: "clearNull",
    value: function clearNull() {
      this._arrayMap = arrayFilter(this._arrayMap, function(i) {
        return i !== null;
      });
    }
  }]);
  return ColumnsMapper2;
}();
mixin(ColumnsMapper, arrayMapper_default);
var columnsMapper_default = ColumnsMapper;

// node_modules/handsontable/es/plugins/manualColumnMove/ui/_base.js
function _classCallCheck66(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties63(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass63(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties63(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties63(Constructor, staticProps);
  return Constructor;
}
var STATE_INITIALIZED = 0;
var STATE_BUILT = 1;
var STATE_APPENDED = 2;
var UNIT = "px";
var BaseUI = function() {
  function BaseUI3(hotInstance) {
    _classCallCheck66(this, BaseUI3);
    this.hot = hotInstance;
    this._element = null;
    this.state = STATE_INITIALIZED;
  }
  _createClass63(BaseUI3, [{
    key: "appendTo",
    value: function appendTo(wrapper) {
      wrapper.appendChild(this._element);
      this.state = STATE_APPENDED;
    }
    /**
     * Method for create UI element. Only create, without append to table.
     */
  }, {
    key: "build",
    value: function build() {
      this._element = document.createElement("div");
      this.state = STATE_BUILT;
    }
    /**
     * Method for remove UI element.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.isAppended()) {
        this._element.parentElement.removeChild(this._element);
      }
      this._element = null;
      this.state = STATE_INITIALIZED;
    }
    /**
     * Check if UI element are appended.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isAppended",
    value: function isAppended() {
      return this.state === STATE_APPENDED;
    }
    /**
     * Check if UI element are built.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isBuilt",
    value: function isBuilt() {
      return this.state >= STATE_BUILT;
    }
    /**
     * Setter for position.
     *
     * @param {Number} top New top position of the element.
     * @param {Number} left New left position of the element.
     */
  }, {
    key: "setPosition",
    value: function setPosition(top2, left2) {
      if (isNumeric(top2)) {
        this._element.style.top = top2 + UNIT;
      }
      if (isNumeric(left2)) {
        this._element.style.left = left2 + UNIT;
      }
    }
    /**
     * Getter for the element position.
     *
     * @returns {Object} Object contains left and top position of the element.
     */
  }, {
    key: "getPosition",
    value: function getPosition() {
      return {
        top: this._element.style.top ? parseInt(this._element.style.top, 10) : 0,
        left: this._element.style.left ? parseInt(this._element.style.left, 10) : 0
      };
    }
    /**
     * Setter for the element size.
     *
     * @param {Number} width New width of the element.
     * @param {Number} height New height of the element.
     */
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      if (isNumeric(width)) {
        this._element.style.width = width + UNIT;
      }
      if (isNumeric(height)) {
        this._element.style.height = height + UNIT;
      }
    }
    /**
     * Getter for the element position.
     *
     * @returns {Object} Object contains height and width of the element.
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return {
        width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
        height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
      };
    }
    /**
     * Setter for the element offset. Offset means marginTop and marginLeft of the element.
     *
     * @param {Number} top New margin top of the element.
     * @param {Number} left New margin left of the element.
     */
  }, {
    key: "setOffset",
    value: function setOffset(top2, left2) {
      if (isNumeric(top2)) {
        this._element.style.marginTop = top2 + UNIT;
      }
      if (isNumeric(left2)) {
        this._element.style.marginLeft = left2 + UNIT;
      }
    }
    /**
     * Getter for the element offset.
     *
     * @returns {Object} Object contains top and left offset of the element.
     */
  }, {
    key: "getOffset",
    value: function getOffset() {
      return {
        top: this._element.style.marginTop ? parseInt(this._element.style.marginTop, 10) : 0,
        left: this._element.style.marginLeft ? parseInt(this._element.style.marginLeft, 10) : 0
      };
    }
  }]);
  return BaseUI3;
}();
var base_default3 = BaseUI;

// node_modules/handsontable/es/plugins/manualColumnMove/ui/backlight.js
function _typeof35(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof35 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof35 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof35(obj);
}
function _classCallCheck67(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties64(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass64(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties64(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties64(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn23(self2, call) {
  if (call && (_typeof35(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized23(self2);
}
function _assertThisInitialized23(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get15(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get15 = Reflect.get;
  } else {
    _get15 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase15(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get15(target, property, receiver || target);
}
function _superPropBase15(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf23(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf23(o) {
  _getPrototypeOf23 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf23(o);
}
function _inherits23(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf23(subClass, superClass);
}
function _setPrototypeOf23(o, p) {
  _setPrototypeOf23 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf23(o, p);
}
var CSS_CLASSNAME = "ht__manualColumnMove--backlight";
var BacklightUI = function(_BaseUI) {
  _inherits23(BacklightUI3, _BaseUI);
  function BacklightUI3() {
    _classCallCheck67(this, BacklightUI3);
    return _possibleConstructorReturn23(this, _getPrototypeOf23(BacklightUI3).apply(this, arguments));
  }
  _createClass64(BacklightUI3, [{
    key: "build",
    /**
     * Custom className on build process.
     */
    value: function build() {
      _get15(_getPrototypeOf23(BacklightUI3.prototype), "build", this).call(this);
      addClass(this._element, CSS_CLASSNAME);
    }
  }]);
  return BacklightUI3;
}(base_default3);
var backlight_default = BacklightUI;

// node_modules/handsontable/es/plugins/manualColumnMove/ui/guideline.js
function _typeof36(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof36 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof36 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof36(obj);
}
function _classCallCheck68(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties65(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass65(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties65(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties65(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn24(self2, call) {
  if (call && (_typeof36(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized24(self2);
}
function _assertThisInitialized24(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get16(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get16 = Reflect.get;
  } else {
    _get16 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase16(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get16(target, property, receiver || target);
}
function _superPropBase16(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf24(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf24(o) {
  _getPrototypeOf24 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf24(o);
}
function _inherits24(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf24(subClass, superClass);
}
function _setPrototypeOf24(o, p) {
  _setPrototypeOf24 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf24(o, p);
}
var CSS_CLASSNAME2 = "ht__manualColumnMove--guideline";
var GuidelineUI = function(_BaseUI) {
  _inherits24(GuidelineUI3, _BaseUI);
  function GuidelineUI3() {
    _classCallCheck68(this, GuidelineUI3);
    return _possibleConstructorReturn24(this, _getPrototypeOf24(GuidelineUI3).apply(this, arguments));
  }
  _createClass65(GuidelineUI3, [{
    key: "build",
    /**
     * Custom className on build process.
     */
    value: function build() {
      _get16(_getPrototypeOf24(GuidelineUI3.prototype), "build", this).call(this);
      addClass(this._element, CSS_CLASSNAME2);
    }
  }]);
  return GuidelineUI3;
}(base_default3);
var guideline_default = GuidelineUI;

// node_modules/handsontable/es/plugins/manualColumnMove/manualColumnMove.js
function _typeof37(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof37 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof37 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof37(obj);
}
function _toConsumableArray9(arr) {
  return _arrayWithoutHoles9(arr) || _iterableToArray10(arr) || _nonIterableSpread9();
}
function _nonIterableSpread9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray10(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles9(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function _classCallCheck69(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties66(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass66(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties66(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties66(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn25(self2, call) {
  if (call && (_typeof37(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized25(self2);
}
function _get17(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get17 = Reflect.get;
  } else {
    _get17 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase17(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get17(target, property, receiver || target);
}
function _superPropBase17(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf25(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf25(o) {
  _getPrototypeOf25 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf25(o);
}
function _inherits25(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf25(subClass, superClass);
}
function _setPrototypeOf25(o, p) {
  _setPrototypeOf25 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf25(o, p);
}
function _assertThisInitialized25(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
pluginHooks_default.getSingleton().register("beforeColumnMove");
pluginHooks_default.getSingleton().register("afterColumnMove");
pluginHooks_default.getSingleton().register("unmodifyCol");
var privatePool9 = /* @__PURE__ */ new WeakMap();
var CSS_PLUGIN = "ht__manualColumnMove";
var CSS_SHOW_UI = "show-ui";
var CSS_ON_MOVING = "on-moving--columns";
var CSS_AFTER_SELECTION = "after-selection--columns";
var ManualColumnMove = function(_BasePlugin) {
  _inherits25(ManualColumnMove2, _BasePlugin);
  function ManualColumnMove2(hotInstance) {
    var _this;
    _classCallCheck69(this, ManualColumnMove2);
    _this = _possibleConstructorReturn25(this, _getPrototypeOf25(ManualColumnMove2).call(this, hotInstance));
    privatePool9.set(_assertThisInitialized25(_assertThisInitialized25(_this)), {
      columnsToMove: [],
      countCols: 0,
      fixedColumns: 0,
      pressed: void 0,
      disallowMoving: void 0,
      target: {
        eventPageX: void 0,
        coords: void 0,
        TD: void 0,
        col: void 0
      }
    });
    _this.removedColumns = [];
    _this.columnsMapper = new columnsMapper_default(_assertThisInitialized25(_assertThisInitialized25(_this)));
    _this.eventManager = new eventManager_default(_assertThisInitialized25(_assertThisInitialized25(_this)));
    _this.backlight = new backlight_default(hotInstance);
    _this.guideline = new guideline_default(hotInstance);
    return _this;
  }
  _createClass66(ManualColumnMove2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings().manualColumnMove;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("beforeOnCellMouseDown", function(event2, coords, TD, blockCalculations) {
        return _this2.onBeforeOnCellMouseDown(event2, coords, TD, blockCalculations);
      });
      this.addHook("beforeOnCellMouseOver", function(event2, coords, TD, blockCalculations) {
        return _this2.onBeforeOnCellMouseOver(event2, coords, TD, blockCalculations);
      });
      this.addHook("afterScrollVertically", function() {
        return _this2.onAfterScrollVertically();
      });
      this.addHook("modifyCol", function(row, source) {
        return _this2.onModifyCol(row, source);
      });
      this.addHook("beforeRemoveCol", function(index2, amount) {
        return _this2.onBeforeRemoveCol(index2, amount);
      });
      this.addHook("afterRemoveCol", function() {
        return _this2.onAfterRemoveCol();
      });
      this.addHook("afterCreateCol", function(index2, amount) {
        return _this2.onAfterCreateCol(index2, amount);
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData();
      });
      this.addHook("unmodifyCol", function(column) {
        return _this2.onUnmodifyCol(column);
      });
      this.registerEvents();
      addClass(this.hot.rootElement, CSS_PLUGIN);
      _get17(_getPrototypeOf25(ManualColumnMove2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.onAfterPluginsInitialized();
      _get17(_getPrototypeOf25(ManualColumnMove2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var pluginSettings = this.hot.getSettings().manualColumnMove;
      if (Array.isArray(pluginSettings)) {
        this.columnsMapper.clearMap();
      }
      removeClass(this.hot.rootElement, CSS_PLUGIN);
      this.unregisterEvents();
      this.backlight.destroy();
      this.guideline.destroy();
      _get17(_getPrototypeOf25(ManualColumnMove2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Moves a single column.
     *
     * @param {Number} column Visual column index to be moved.
     * @param {Number} target Visual column index being a target for the moved column.
     * @fires Hooks#beforeColumnMove
     * @fires Hooks#afterColumnMove
     */
  }, {
    key: "moveColumn",
    value: function moveColumn(column, target) {
      this.moveColumns([column], target);
    }
    /**
     * Moves a multiple columns.
     *
     * @param {Array} columns Array of visual column indexes to be moved.
     * @param {Number} target Visual column index being a target for the moved columns.
     * @fires Hooks#beforeColumnMove
     * @fires Hooks#afterColumnMove
     */
  }, {
    key: "moveColumns",
    value: function moveColumns(columns, target) {
      var _this3 = this;
      var visualColumns = _toConsumableArray9(columns);
      var priv = privatePool9.get(this);
      var beforeColumnHook = this.hot.runHooks("beforeColumnMove", visualColumns, target);
      priv.disallowMoving = !beforeColumnHook;
      if (beforeColumnHook !== false) {
        arrayEach(columns, function(column, index2, array) {
          array[index2] = _this3.columnsMapper.getValueByIndex(column);
        });
        arrayEach(columns, function(column, index2) {
          var actualPosition = _this3.columnsMapper.getIndexByValue(column);
          if (actualPosition !== target) {
            _this3.columnsMapper.moveColumn(actualPosition, target + index2);
          }
        });
        this.columnsMapper.clearNull();
      }
      this.hot.runHooks("afterColumnMove", visualColumns, target);
    }
    /**
     * Correct the cell selection after the move action. Fired only when action was made with a mouse.
     * That means that changing the column order using the API won't correct the selection.
     *
     * @private
     * @param {Number} startColumn Visual column index for the start of the selection.
     * @param {Number} endColumn Visual column index for the end of the selection.
     */
  }, {
    key: "changeSelection",
    value: function changeSelection(startColumn, endColumn) {
      this.hot.selectColumns(startColumn, endColumn);
    }
    /**
     * Gets the sum of the widths of columns in the provided range.
     *
     * @private
     * @param {Number} from Visual column index.
     * @param {Number} to Visual column index.
     * @returns {Number}
     */
  }, {
    key: "getColumnsWidth",
    value: function getColumnsWidth(from3, to3) {
      var width = 0;
      for (var i = from3; i < to3; i++) {
        var columnWidth = 0;
        if (i < 0) {
          columnWidth = this.hot.view.wt.wtViewport.getRowHeaderWidth() || 0;
        } else {
          columnWidth = this.hot.view.wt.wtTable.getStretchedColumnWidth(i) || 0;
        }
        width += columnWidth;
      }
      return width;
    }
    /**
     * Loads initial settings when persistent state is saved or when plugin was initialized as an array.
     *
     * @private
     */
  }, {
    key: "initialSettings",
    value: function initialSettings() {
      var pluginSettings = this.hot.getSettings().manualColumnMove;
      if (Array.isArray(pluginSettings)) {
        this.moveColumns(pluginSettings, 0);
      } else if (pluginSettings !== void 0) {
        this.persistentStateLoad();
      }
    }
    /**
     * Checks if the provided column is in the fixedColumnsLeft section.
     *
     * @private
     * @param {Number} column Visual column index to check.
     * @returns {Boolean}
     */
  }, {
    key: "isFixedColumnsLeft",
    value: function isFixedColumnsLeft(column) {
      return column < this.hot.getSettings().fixedColumnsLeft;
    }
    /**
     * Saves the manual column positions to the persistent state (the {@link Options#persistentState} option has to be enabled).
     */
  }, {
    key: "persistentStateSave",
    value: function persistentStateSave() {
      this.hot.runHooks("persistentStateSave", "manualColumnMove", this.columnsMapper._arrayMap);
    }
    /**
     * Loads the manual column positions from the persistent state (the {@link Options#persistentState} option has to be enabled).
     */
  }, {
    key: "persistentStateLoad",
    value: function persistentStateLoad() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", "manualColumnMove", storedState);
      if (storedState.value) {
        this.columnsMapper._arrayMap = storedState.value;
      }
    }
    /**
     * Prepares an array of indexes based on actual selection.
     *
     * @private
     * @returns {Array}
     */
  }, {
    key: "prepareColumnsToMoving",
    value: function prepareColumnsToMoving(start, end) {
      var selectedColumns = [];
      rangeEach(start, end, function(i) {
        selectedColumns.push(i);
      });
      return selectedColumns;
    }
    /**
     * Updates the UI visual position.
     *
     * @private
     */
  }, {
    key: "refreshPositions",
    value: function refreshPositions() {
      var priv = privatePool9.get(this);
      var firstVisible = this.hot.view.wt.wtTable.getFirstVisibleColumn();
      var lastVisible = this.hot.view.wt.wtTable.getLastVisibleColumn();
      var wtTable = this.hot.view.wt.wtTable;
      var scrollableElement = this.hot.view.wt.wtOverlays.scrollableElement;
      var scrollLeft = typeof scrollableElement.scrollX === "number" ? scrollableElement.scrollX : scrollableElement.scrollLeft;
      var tdOffsetLeft = this.hot.view.THEAD.offsetLeft + this.getColumnsWidth(0, priv.coordsColumn);
      var mouseOffsetLeft = priv.target.eventPageX - (priv.rootElementOffset - (scrollableElement.scrollX === void 0 ? scrollLeft : 0));
      var hiderWidth = wtTable.hider.offsetWidth;
      var tbodyOffsetLeft = wtTable.TBODY.offsetLeft;
      var backlightElemMarginLeft = this.backlight.getOffset().left;
      var backlightElemWidth = this.backlight.getSize().width;
      var rowHeaderWidth = 0;
      if (priv.rootElementOffset + wtTable.holder.offsetWidth + scrollLeft < priv.target.eventPageX) {
        if (priv.coordsColumn < priv.countCols) {
          priv.coordsColumn += 1;
        }
      }
      if (priv.hasRowHeaders) {
        rowHeaderWidth = this.hot.view.wt.wtOverlays.leftOverlay.clone.wtTable.getColumnHeader(-1).offsetWidth;
      }
      if (this.isFixedColumnsLeft(priv.coordsColumn)) {
        tdOffsetLeft += scrollLeft;
      }
      tdOffsetLeft += rowHeaderWidth;
      if (priv.coordsColumn < 0) {
        if (priv.fixedColumns > 0) {
          priv.target.col = 0;
        } else {
          priv.target.col = firstVisible > 0 ? firstVisible - 1 : firstVisible;
        }
      } else if (priv.target.TD.offsetWidth / 2 + tdOffsetLeft <= mouseOffsetLeft) {
        var newCoordsCol = priv.coordsColumn >= priv.countCols ? priv.countCols - 1 : priv.coordsColumn;
        priv.target.col = newCoordsCol + 1;
        tdOffsetLeft += priv.target.TD.offsetWidth;
        if (priv.target.col > lastVisible && lastVisible < priv.countCols) {
          this.hot.scrollViewportTo(void 0, lastVisible + 1, void 0, true);
        }
      } else {
        priv.target.col = priv.coordsColumn;
        if (priv.target.col <= firstVisible && priv.target.col >= priv.fixedColumns && firstVisible > 0) {
          this.hot.scrollViewportTo(void 0, firstVisible - 1);
        }
      }
      if (priv.target.col <= firstVisible && priv.target.col >= priv.fixedColumns && firstVisible > 0) {
        this.hot.scrollViewportTo(void 0, firstVisible - 1);
      }
      var backlightLeft = mouseOffsetLeft;
      var guidelineLeft = tdOffsetLeft;
      if (mouseOffsetLeft + backlightElemWidth + backlightElemMarginLeft >= hiderWidth) {
        backlightLeft = hiderWidth - backlightElemWidth - backlightElemMarginLeft;
      } else if (mouseOffsetLeft + backlightElemMarginLeft < tbodyOffsetLeft + rowHeaderWidth) {
        backlightLeft = tbodyOffsetLeft + rowHeaderWidth + Math.abs(backlightElemMarginLeft);
      }
      if (tdOffsetLeft >= hiderWidth - 1) {
        guidelineLeft = hiderWidth - 1;
      } else if (guidelineLeft === 0) {
        guidelineLeft = 1;
      } else if (scrollableElement.scrollX !== void 0 && priv.coordsColumn < priv.fixedColumns) {
        guidelineLeft -= priv.rootElementOffset <= scrollableElement.scrollX ? priv.rootElementOffset : 0;
      }
      this.backlight.setPosition(null, backlightLeft);
      this.guideline.setPosition(null, guidelineLeft);
    }
    /**
     * This method checks arrayMap from columnsMapper and updates the columnsMapper if it's necessary.
     *
     * @private
     */
  }, {
    key: "updateColumnsMapper",
    value: function updateColumnsMapper() {
      var countCols = this.hot.countSourceCols();
      var columnsMapperLen = this.columnsMapper._arrayMap.length;
      if (columnsMapperLen === 0) {
        this.columnsMapper.createMap(countCols || this.hot.getSettings().startCols);
      } else if (columnsMapperLen < countCols) {
        var diff3 = countCols - columnsMapperLen;
        this.columnsMapper.insertItems(columnsMapperLen, diff3);
      } else if (columnsMapperLen > countCols) {
        var maxIndex = countCols - 1;
        var columnsToRemove = [];
        arrayEach(this.columnsMapper._arrayMap, function(value, index2) {
          if (value > maxIndex) {
            columnsToRemove.push(index2);
          }
        });
        this.columnsMapper.removeItems(columnsToRemove);
      }
    }
    /**
     * Binds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this4 = this;
      this.eventManager.addEventListener(document.documentElement, "mousemove", function(event2) {
        return _this4.onMouseMove(event2);
      });
      this.eventManager.addEventListener(document.documentElement, "mouseup", function() {
        return _this4.onMouseUp();
      });
    }
    /**
     * Unbinds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "unregisterEvents",
    value: function unregisterEvents() {
      this.eventManager.clear();
    }
    /**
     * Changes the behavior of selection / dragging.
     *
     * @private
     * @param {MouseEvent} event `mousedown` event properties.
     * @param {CellCoords} coords Visual cell coordinates where was fired event.
     * @param {HTMLElement} TD Cell represented as HTMLElement.
     * @param {Object} blockCalculations Object which contains information about blockCalculation for row, column or cells.
     */
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event2, coords, TD, blockCalculations) {
      var wtTable = this.hot.view.wt.wtTable;
      var isHeaderSelection = this.hot.selection.isSelectedByColumnHeader();
      var selection = this.hot.getSelectedRangeLast();
      var priv = privatePool9.get(this);
      var isSortingElement = event2.realTarget.className.indexOf("sortAction") > -1;
      if (!selection || !isHeaderSelection || priv.pressed || event2.button !== 0 || isSortingElement) {
        priv.pressed = false;
        priv.columnsToMove.length = 0;
        removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);
        return;
      }
      var guidelineIsNotReady = this.guideline.isBuilt() && !this.guideline.isAppended();
      var backlightIsNotReady = this.backlight.isBuilt() && !this.backlight.isAppended();
      if (guidelineIsNotReady && backlightIsNotReady) {
        this.guideline.appendTo(wtTable.hider);
        this.backlight.appendTo(wtTable.hider);
      }
      var from3 = selection.from, to3 = selection.to;
      var start = Math.min(from3.col, to3.col);
      var end = Math.max(from3.col, to3.col);
      if (coords.row < 0 && coords.col >= start && coords.col <= end) {
        blockCalculations.column = true;
        priv.pressed = true;
        priv.target.eventPageX = event2.pageX;
        priv.coordsColumn = coords.col;
        priv.target.TD = TD;
        priv.target.col = coords.col;
        priv.columnsToMove = this.prepareColumnsToMoving(start, end);
        priv.hasRowHeaders = !!this.hot.getSettings().rowHeaders;
        priv.countCols = this.hot.countCols();
        priv.fixedColumns = this.hot.getSettings().fixedColumnsLeft;
        priv.rootElementOffset = offset(this.hot.rootElement).left;
        var countColumnsFrom = priv.hasRowHeaders ? -1 : 0;
        var topPos = wtTable.holder.scrollTop + wtTable.getColumnHeaderHeight(0) + 1;
        var fixedColumns = coords.col < priv.fixedColumns;
        var scrollableElement = this.hot.view.wt.wtOverlays.scrollableElement;
        var wrapperIsWindow = scrollableElement.scrollX ? scrollableElement.scrollX - priv.rootElementOffset : 0;
        var mouseOffset = event2.layerX - (fixedColumns ? wrapperIsWindow : 0);
        var leftOffset = Math.abs(this.getColumnsWidth(start, coords.col) + mouseOffset);
        this.backlight.setPosition(topPos, this.getColumnsWidth(countColumnsFrom, start) + leftOffset);
        this.backlight.setSize(this.getColumnsWidth(start, end + 1), wtTable.hider.offsetHeight - topPos);
        this.backlight.setOffset(null, leftOffset * -1);
        addClass(this.hot.rootElement, CSS_ON_MOVING);
      } else {
        removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);
        priv.pressed = false;
        priv.columnsToMove.length = 0;
      }
    }
    /**
     * 'mouseMove' event callback. Fired when pointer move on document.documentElement.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var priv = privatePool9.get(this);
      if (!priv.pressed) {
        return;
      }
      if (event2.realTarget === this.backlight.element) {
        var width = this.backlight.getSize().width;
        this.backlight.setSize(0);
        setTimeout(function() {
          this.backlight.setPosition(width);
        });
      }
      priv.target.eventPageX = event2.pageX;
      this.refreshPositions();
    }
    /**
     * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.
     *
     * @private
     * @param {MouseEvent} event `mouseover` event properties.
     * @param {CellCoords} coords Visual cell coordinates where was fired event.
     * @param {HTMLElement} TD Cell represented as HTMLElement.
     * @param {Object} blockCalculations Object which contains information about blockCalculation for row, column or cells.
     */
  }, {
    key: "onBeforeOnCellMouseOver",
    value: function onBeforeOnCellMouseOver(event2, coords, TD, blockCalculations) {
      var selectedRange = this.hot.getSelectedRangeLast();
      var priv = privatePool9.get(this);
      if (!selectedRange || !priv.pressed) {
        return;
      }
      if (priv.columnsToMove.indexOf(coords.col) > -1) {
        removeClass(this.hot.rootElement, CSS_SHOW_UI);
      } else {
        addClass(this.hot.rootElement, CSS_SHOW_UI);
      }
      blockCalculations.row = true;
      blockCalculations.column = true;
      blockCalculations.cell = true;
      priv.coordsColumn = coords.col;
      priv.target.TD = TD;
    }
    /**
     * `onMouseUp` hook callback.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      var priv = privatePool9.get(this);
      priv.coordsColumn = void 0;
      priv.pressed = false;
      priv.backlightWidth = 0;
      removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);
      if (this.hot.selection.isSelectedByColumnHeader()) {
        addClass(this.hot.rootElement, CSS_AFTER_SELECTION);
      }
      if (priv.columnsToMove.length < 1 || priv.target.col === void 0 || priv.columnsToMove.indexOf(priv.target.col) > -1) {
        return;
      }
      this.moveColumns(priv.columnsToMove, priv.target.col);
      this.persistentStateSave();
      this.hot.render();
      this.hot.view.wt.wtOverlays.adjustElementsSize(true);
      if (!priv.disallowMoving) {
        var selectionStart = this.columnsMapper.getIndexByValue(priv.columnsToMove[0]);
        var selectionEnd = this.columnsMapper.getIndexByValue(priv.columnsToMove[priv.columnsToMove.length - 1]);
        this.changeSelection(selectionStart, selectionEnd);
      }
      priv.columnsToMove.length = 0;
    }
    /**
     * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.
     *
     * @private
     */
  }, {
    key: "onAfterScrollVertically",
    value: function onAfterScrollVertically() {
      var wtTable = this.hot.view.wt.wtTable;
      var headerHeight = wtTable.getColumnHeaderHeight(0) + 1;
      var scrollTop = wtTable.holder.scrollTop;
      var posTop = headerHeight + scrollTop;
      this.backlight.setPosition(posTop);
      this.backlight.setSize(null, wtTable.hider.offsetHeight - posTop);
    }
    /**
     * `afterCreateCol` hook callback.
     *
     * @private
     * @param {Number} index Visual index of the created column.
     * @param {Number} amount Amount of created columns.
     */
  }, {
    key: "onAfterCreateCol",
    value: function onAfterCreateCol(index2, amount) {
      this.columnsMapper.shiftItems(index2, amount);
    }
    /**
     * On before remove column listener.
     *
     * @private
     * @param {Number} index Visual column index.
     * @param {Number} amount Defines how many columns removed.
     */
  }, {
    key: "onBeforeRemoveCol",
    value: function onBeforeRemoveCol(index2, amount) {
      var _this5 = this;
      this.removedColumns.length = 0;
      if (index2 !== false) {
        rangeEach(index2, index2 + amount - 1, function(removedIndex) {
          _this5.removedColumns.push(_this5.hot.runHooks("modifyCol", removedIndex, _this5.pluginName));
        });
      }
    }
    /**
     * `afterRemoveCol` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterRemoveCol",
    value: function onAfterRemoveCol() {
      this.columnsMapper.unshiftItems(this.removedColumns);
    }
    /**
     * `afterLoadData` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      this.updateColumnsMapper();
    }
    /**
     * 'modifyRow' hook callback.
     *
     * @private
     * @param {Number} column Visual column index.
     * @returns {Number} Physical column index.
     */
  }, {
    key: "onModifyCol",
    value: function onModifyCol(column, source) {
      var physicalColumn = column;
      if (source !== this.pluginName) {
        var columnInMapper = this.columnsMapper.getValueByIndex(physicalColumn);
        physicalColumn = columnInMapper === null ? physicalColumn : columnInMapper;
      }
      return physicalColumn;
    }
    /**
     * 'unmodifyCol' hook callback.
     *
     * @private
     * @param {Number} column Physical column index.
     * @returns {Number} Visual column index.
     */
  }, {
    key: "onUnmodifyCol",
    value: function onUnmodifyCol(column) {
      var indexInMapper = this.columnsMapper.getIndexByValue(column);
      return indexInMapper === null ? column : indexInMapper;
    }
    /**
     * `afterPluginsInitialized` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterPluginsInitialized",
    value: function onAfterPluginsInitialized() {
      this.updateColumnsMapper();
      this.initialSettings();
      this.backlight.build();
      this.guideline.build();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.backlight.destroy();
      this.guideline.destroy();
      _get17(_getPrototypeOf25(ManualColumnMove2.prototype), "destroy", this).call(this);
    }
  }]);
  return ManualColumnMove2;
}(base_default2);
registerPlugin("ManualColumnMove", ManualColumnMove);
var manualColumnMove_default = ManualColumnMove;

// node_modules/handsontable/es/plugins/manualColumnResize/manualColumnResize.js
function _typeof38(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof38 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof38 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof38(obj);
}
function _classCallCheck70(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties67(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass67(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties67(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties67(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn26(self2, call) {
  if (call && (_typeof38(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized26(self2);
}
function _get18(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get18 = Reflect.get;
  } else {
    _get18 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase18(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get18(target, property, receiver || target);
}
function _superPropBase18(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf26(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf26(o) {
  _getPrototypeOf26 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf26(o);
}
function _inherits26(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf26(subClass, superClass);
}
function _setPrototypeOf26(o, p) {
  _setPrototypeOf26 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf26(o, p);
}
function _assertThisInitialized26(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var ManualColumnResize = function(_BasePlugin) {
  _inherits26(ManualColumnResize2, _BasePlugin);
  function ManualColumnResize2(hotInstance) {
    var _this;
    _classCallCheck70(this, ManualColumnResize2);
    _this = _possibleConstructorReturn26(this, _getPrototypeOf26(ManualColumnResize2).call(this, hotInstance));
    _this.currentTH = null;
    _this.currentCol = null;
    _this.selectedCols = [];
    _this.currentWidth = null;
    _this.newSize = null;
    _this.startY = null;
    _this.startWidth = null;
    _this.startOffset = null;
    _this.handle = document.createElement("DIV");
    _this.guide = document.createElement("DIV");
    _this.eventManager = new eventManager_default(_assertThisInitialized26(_assertThisInitialized26(_this)));
    _this.pressed = null;
    _this.dblclick = 0;
    _this.autoresizeTimeout = null;
    _this.manualColumnWidths = [];
    addClass(_this.handle, "manualColumnResizer");
    addClass(_this.guide, "manualColumnResizerGuide");
    return _this;
  }
  _createClass67(ManualColumnResize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().manualColumnResize;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.manualColumnWidths = [];
      var initialColumnWidth = this.hot.getSettings().manualColumnResize;
      var loadedManualColumnWidths = this.loadManualColumnWidths();
      this.addHook("modifyColWidth", function(width, col) {
        return _this2.onModifyColWidth(width, col);
      });
      this.addHook("beforeStretchingColumnWidth", function(stretchedWidth, column) {
        return _this2.onBeforeStretchingColumnWidth(stretchedWidth, column);
      });
      this.addHook("beforeColumnResize", function(currentColumn, newSize, isDoubleClick) {
        return _this2.onBeforeColumnResize(currentColumn, newSize, isDoubleClick);
      });
      if (typeof loadedManualColumnWidths !== "undefined") {
        this.manualColumnWidths = loadedManualColumnWidths;
      } else if (Array.isArray(initialColumnWidth)) {
        this.manualColumnWidths = initialColumnWidth;
      } else {
        this.manualColumnWidths = [];
      }
      this.bindEvents();
      _get18(_getPrototypeOf26(ManualColumnResize2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var initialColumnWidth = this.hot.getSettings().manualColumnResize;
      if (Array.isArray(initialColumnWidth)) {
        this.manualColumnWidths = initialColumnWidth;
      } else if (!initialColumnWidth) {
        this.manualColumnWidths = [];
      }
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get18(_getPrototypeOf26(ManualColumnResize2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
     */
  }, {
    key: "saveManualColumnWidths",
    value: function saveManualColumnWidths() {
      this.hot.runHooks("persistentStateSave", "manualColumnWidths", this.manualColumnWidths);
    }
    /**
     * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
     *
     * @returns {Array}
     *
     * @fires Hooks#persistentStateLoad
     * @fires Hooks#manualColumnWidths
     */
  }, {
    key: "loadManualColumnWidths",
    value: function loadManualColumnWidths() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", "manualColumnWidths", storedState);
      return storedState.value;
    }
    /**
     * Set the resize handle position.
     *
     * @private
     * @param {HTMLCellElement} TH TH HTML element.
     */
  }, {
    key: "setupHandlePosition",
    value: function setupHandlePosition(TH) {
      var _this3 = this;
      if (!TH.parentNode) {
        return false;
      }
      this.currentTH = TH;
      var col = this.hot.view.wt.wtTable.getCoords(TH).col;
      var headerHeight = outerHeight(this.currentTH);
      if (col >= 0) {
        var box = this.currentTH.getBoundingClientRect();
        this.currentCol = col;
        this.selectedCols = [];
        if (this.hot.selection.isSelected() && this.hot.selection.isSelectedByColumnHeader()) {
          var _this$hot$getSelected = this.hot.getSelectedRangeLast(), from3 = _this$hot$getSelected.from, to3 = _this$hot$getSelected.to;
          var start = from3.col;
          var end = to3.col;
          if (start >= end) {
            start = to3.col;
            end = from3.col;
          }
          if (this.currentCol >= start && this.currentCol <= end) {
            rangeEach(start, end, function(i) {
              return _this3.selectedCols.push(i);
            });
          } else {
            this.selectedCols.push(this.currentCol);
          }
        } else {
          this.selectedCols.push(this.currentCol);
        }
        this.startOffset = box.left - 6;
        this.startWidth = parseInt(box.width, 10);
        this.handle.style.top = "".concat(box.top, "px");
        this.handle.style.left = "".concat(this.startOffset + this.startWidth, "px");
        this.handle.style.height = "".concat(headerHeight, "px");
        this.hot.rootElement.appendChild(this.handle);
      }
    }
    /**
     * Refresh the resize handle position.
     *
     * @private
     */
  }, {
    key: "refreshHandlePosition",
    value: function refreshHandlePosition() {
      this.handle.style.left = "".concat(this.startOffset + this.currentWidth, "px");
    }
    /**
     * Sets the resize guide position.
     *
     * @private
     */
  }, {
    key: "setupGuidePosition",
    value: function setupGuidePosition() {
      var handleHeight = parseInt(outerHeight(this.handle), 10);
      var handleBottomPosition = parseInt(this.handle.style.top, 10) + handleHeight;
      var maximumVisibleElementHeight = parseInt(this.hot.view.maximumVisibleElementHeight(0), 10);
      addClass(this.handle, "active");
      addClass(this.guide, "active");
      this.guide.style.top = "".concat(handleBottomPosition, "px");
      this.guide.style.left = this.handle.style.left;
      this.guide.style.height = "".concat(maximumVisibleElementHeight - handleHeight, "px");
      this.hot.rootElement.appendChild(this.guide);
    }
    /**
     * Refresh the resize guide position.
     *
     * @private
     */
  }, {
    key: "refreshGuidePosition",
    value: function refreshGuidePosition() {
      this.guide.style.left = this.handle.style.left;
    }
    /**
     * Hides both the resize handle and resize guide.
     *
     * @private
     */
  }, {
    key: "hideHandleAndGuide",
    value: function hideHandleAndGuide() {
      removeClass(this.handle, "active");
      removeClass(this.guide, "active");
    }
    /**
     * Checks if provided element is considered a column header.
     *
     * @private
     * @param {HTMLElement} element HTML element.
     * @returns {Boolean}
     */
  }, {
    key: "checkIfColumnHeader",
    value: function checkIfColumnHeader(element) {
      if (element !== this.hot.rootElement) {
        var parent = element.parentNode;
        if (parent.tagName === "THEAD") {
          return true;
        }
        return this.checkIfColumnHeader(parent);
      }
      return false;
    }
    /**
     * Gets the TH element from the provided element.
     *
     * @private
     * @param {HTMLElement} element HTML element.
     * @returns {HTMLElement}
     */
  }, {
    key: "getTHFromTargetElement",
    value: function getTHFromTargetElement(element) {
      if (element.tagName !== "TABLE") {
        if (element.tagName === "TH") {
          return element;
        }
        return this.getTHFromTargetElement(element.parentNode);
      }
      return null;
    }
    /**
     * 'mouseover' event callback - set the handle position.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event2) {
      if (this.checkIfColumnHeader(event2.target)) {
        var th = this.getTHFromTargetElement(event2.target);
        if (!th) {
          return;
        }
        var colspan = th.getAttribute("colspan");
        if (th && (colspan === null || colspan === 1)) {
          if (!this.pressed) {
            this.setupHandlePosition(th);
          }
        }
      }
    }
    /**
     * Auto-size row after doubleclick - callback.
     *
     * @private
     *
     * @fires Hooks#beforeColumnResize
     * @fires Hooks#afterColumnResize
     */
  }, {
    key: "afterMouseDownTimeout",
    value: function afterMouseDownTimeout() {
      var _this4 = this;
      var render = function render2() {
        _this4.hot.forceFullRender = true;
        _this4.hot.view.render();
        _this4.hot.view.wt.wtOverlays.adjustElementsSize(true);
      };
      var resize = function resize2(selectedCol, forceRender) {
        var hookNewSize = _this4.hot.runHooks("beforeColumnResize", selectedCol, _this4.newSize, true);
        if (hookNewSize !== void 0) {
          _this4.newSize = hookNewSize;
        }
        if (_this4.hot.getSettings().stretchH === "all") {
          _this4.clearManualSize(selectedCol);
        } else {
          _this4.setManualSize(selectedCol, _this4.newSize);
        }
        if (forceRender) {
          render();
        }
        _this4.saveManualColumnWidths();
        _this4.hot.runHooks("afterColumnResize", selectedCol, _this4.newSize, true);
      };
      if (this.dblclick >= 2) {
        var selectedColsLength = this.selectedCols.length;
        if (selectedColsLength > 1) {
          arrayEach(this.selectedCols, function(selectedCol) {
            resize(selectedCol);
          });
          render();
        } else {
          arrayEach(this.selectedCols, function(selectedCol) {
            resize(selectedCol, true);
          });
        }
      }
      this.dblclick = 0;
      this.autoresizeTimeout = null;
    }
    /**
     * 'mousedown' event callback.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event2) {
      var _this5 = this;
      if (hasClass(event2.target, "manualColumnResizer")) {
        this.setupGuidePosition();
        this.pressed = this.hot;
        if (this.autoresizeTimeout === null) {
          this.autoresizeTimeout = setTimeout(function() {
            return _this5.afterMouseDownTimeout();
          }, 500);
          this.hot._registerTimeout(this.autoresizeTimeout);
        }
        this.dblclick += 1;
        this.startX = pageX(event2);
        this.newSize = this.startWidth;
      }
    }
    /**
     * 'mousemove' event callback - refresh the handle and guide positions, cache the new column width.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var _this6 = this;
      if (this.pressed) {
        this.currentWidth = this.startWidth + (pageX(event2) - this.startX);
        arrayEach(this.selectedCols, function(selectedCol) {
          _this6.newSize = _this6.setManualSize(selectedCol, _this6.currentWidth);
        });
        this.refreshHandlePosition();
        this.refreshGuidePosition();
      }
    }
    /**
     * 'mouseup' event callback - apply the column resizing.
     *
     * @private
     *
     * @fires Hooks#beforeColumnResize
     * @fires Hooks#afterColumnResize
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      var _this7 = this;
      var render = function render2() {
        _this7.hot.forceFullRender = true;
        _this7.hot.view.render();
        _this7.hot.view.wt.wtOverlays.adjustElementsSize(true);
      };
      var resize = function resize2(selectedCol, forceRender) {
        _this7.hot.runHooks("beforeColumnResize", selectedCol, _this7.newSize, false);
        if (forceRender) {
          render();
        }
        _this7.saveManualColumnWidths();
        _this7.hot.runHooks("afterColumnResize", selectedCol, _this7.newSize);
      };
      if (this.pressed) {
        this.hideHandleAndGuide();
        this.pressed = false;
        if (this.newSize !== this.startWidth) {
          var selectedColsLength = this.selectedCols.length;
          if (selectedColsLength > 1) {
            arrayEach(this.selectedCols, function(selectedCol) {
              resize(selectedCol);
            });
            render();
          } else {
            arrayEach(this.selectedCols, function(selectedCol) {
              resize(selectedCol, true);
            });
          }
        }
        this.setupHandlePosition(this.currentTH);
      }
    }
    /**
     * Binds the mouse events.
     *
     * @private
     */
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      var _this8 = this;
      this.eventManager.addEventListener(this.hot.rootElement, "mouseover", function(e) {
        return _this8.onMouseOver(e);
      });
      this.eventManager.addEventListener(this.hot.rootElement, "mousedown", function(e) {
        return _this8.onMouseDown(e);
      });
      this.eventManager.addEventListener(window, "mousemove", function(e) {
        return _this8.onMouseMove(e);
      });
      this.eventManager.addEventListener(window, "mouseup", function() {
        return _this8.onMouseUp();
      });
    }
    /**
     * Sets the new width for specified column index.
     *
     * @param {Number} column Visual column index.
     * @param {Number} width Column width (no less than 20px).
     * @returns {Number} Returns new width.
     */
  }, {
    key: "setManualSize",
    value: function setManualSize(column, width) {
      var newWidth = Math.max(width, 20);
      var physicalColumn = this.hot.runHooks("modifyCol", column);
      this.manualColumnWidths[physicalColumn] = newWidth;
      return newWidth;
    }
    /**
     * Clears the cache for the specified column index.
     *
     * @param {Number} column Visual column index.
     */
  }, {
    key: "clearManualSize",
    value: function clearManualSize(column) {
      var physicalColumn = this.hot.runHooks("modifyCol", column);
      this.manualColumnWidths[physicalColumn] = void 0;
    }
    /**
     * Modifies the provided column width, based on the plugin settings
     *
     * @private
     * @param {Number} width Column width.
     * @param {Number} column Visual column index.
     * @returns {Number}
     */
  }, {
    key: "onModifyColWidth",
    value: function onModifyColWidth(width, column) {
      var newWidth = width;
      if (this.enabled) {
        var physicalColumn = this.hot.runHooks("modifyCol", column);
        var columnWidth = this.manualColumnWidths[physicalColumn];
        if (this.hot.getSettings().manualColumnResize && columnWidth) {
          newWidth = columnWidth;
        }
      }
      return newWidth;
    }
    /**
     * Modifies the provided column stretched width. This hook decides if specified column should be stretched or not.
     *
     * @private
     * @param {Number} stretchedWidth Stretched width.
     * @param {Number} column Physical column index.
     * @returns {Number}
     */
  }, {
    key: "onBeforeStretchingColumnWidth",
    value: function onBeforeStretchingColumnWidth(stretchedWidth, column) {
      var width = this.manualColumnWidths[column];
      if (width === void 0) {
        width = stretchedWidth;
      }
      return width;
    }
    /**
     * `beforeColumnResize` hook callback.
     *
     * @private
     */
  }, {
    key: "onBeforeColumnResize",
    value: function onBeforeColumnResize() {
      this.hot.view.wt.wtViewport.hasOversizedColumnHeadersMarked = {};
    }
  }]);
  return ManualColumnResize2;
}(base_default2);
registerPlugin("manualColumnResize", ManualColumnResize);
var manualColumnResize_default = ManualColumnResize;

// node_modules/handsontable/es/plugins/manualRowMove/rowsMapper.js
function _classCallCheck71(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties68(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass68(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties68(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties68(Constructor, staticProps);
  return Constructor;
}
var RowsMapper2 = function() {
  function RowsMapper3(manualRowMove) {
    _classCallCheck71(this, RowsMapper3);
    this.manualRowMove = manualRowMove;
  }
  _createClass68(RowsMapper3, [{
    key: "createMap",
    value: function createMap(length) {
      var _this = this;
      var originLength = length === void 0 ? this._arrayMap.length : length;
      this._arrayMap.length = 0;
      rangeEach(originLength - 1, function(itemIndex) {
        _this._arrayMap[itemIndex] = itemIndex;
      });
    }
    /**
     * Destroy class.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this._arrayMap = null;
    }
    /**
     *
     * Moving elements in rowsMapper.
     * @param {Number} from Row index to move.
     * @param {Number} to Target index.
     */
  }, {
    key: "moveRow",
    value: function moveRow(from3, to3) {
      var indexToMove = this._arrayMap[from3];
      this._arrayMap[from3] = null;
      this._arrayMap.splice(to3, 0, indexToMove);
    }
    /**
     * Clearing arrayMap from `null` entries.
     */
  }, {
    key: "clearNull",
    value: function clearNull() {
      this._arrayMap = arrayFilter(this._arrayMap, function(i) {
        return i !== null;
      });
    }
  }]);
  return RowsMapper3;
}();
mixin(RowsMapper2, arrayMapper_default);
var rowsMapper_default2 = RowsMapper2;

// node_modules/handsontable/es/plugins/manualRowMove/ui/_base.js
function _classCallCheck72(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties69(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass69(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties69(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties69(Constructor, staticProps);
  return Constructor;
}
var STATE_INITIALIZED2 = 0;
var STATE_BUILT2 = 1;
var STATE_APPENDED2 = 2;
var UNIT2 = "px";
var BaseUI2 = function() {
  function BaseUI3(hotInstance) {
    _classCallCheck72(this, BaseUI3);
    this.hot = hotInstance;
    this._element = null;
    this.state = STATE_INITIALIZED2;
  }
  _createClass69(BaseUI3, [{
    key: "appendTo",
    value: function appendTo(wrapper) {
      wrapper.appendChild(this._element);
      this.state = STATE_APPENDED2;
    }
    /**
     * Method for create UI element. Only create, without append to table.
     */
  }, {
    key: "build",
    value: function build() {
      this._element = document.createElement("div");
      this.state = STATE_BUILT2;
    }
    /**
     * Method for remove UI element.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.isAppended()) {
        this._element.parentElement.removeChild(this._element);
      }
      this._element = null;
      this.state = STATE_INITIALIZED2;
    }
    /**
     * Check if UI element are appended.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isAppended",
    value: function isAppended() {
      return this.state === STATE_APPENDED2;
    }
    /**
     * Check if UI element are built.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isBuilt",
    value: function isBuilt() {
      return this.state >= STATE_BUILT2;
    }
    /**
     * Setter for position.
     *
     * @param {Number} top New top position of the element.
     * @param {Number} left New left position of the element.
     */
  }, {
    key: "setPosition",
    value: function setPosition(top2, left2) {
      if (top2 !== void 0) {
        this._element.style.top = top2 + UNIT2;
      }
      if (left2 !== void 0) {
        this._element.style.left = left2 + UNIT2;
      }
    }
    /**
     * Getter for the element position.
     *
     * @returns {Object} Object contains left and top position of the element.
     */
  }, {
    key: "getPosition",
    value: function getPosition() {
      return {
        top: this._element.style.top ? parseInt(this._element.style.top, 10) : 0,
        left: this._element.style.left ? parseInt(this._element.style.left, 10) : 0
      };
    }
    /**
     * Setter for the element size.
     *
     * @param {Number} width New width of the element.
     * @param {Number} height New height of the element.
     */
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      if (width) {
        this._element.style.width = width + UNIT2;
      }
      if (height) {
        this._element.style.height = height + UNIT2;
      }
    }
    /**
     * Getter for the element position.
     *
     * @returns {Object} Object contains height and width of the element.
     */
  }, {
    key: "getSize",
    value: function getSize() {
      return {
        width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
        height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
      };
    }
    /**
     * Setter for the element offset. Offset means marginTop and marginLeft of the element.
     *
     * @param {Number} top New margin top of the element.
     * @param {Number} left New margin left of the element.
     */
  }, {
    key: "setOffset",
    value: function setOffset(top2, left2) {
      if (top2) {
        this._element.style.marginTop = top2 + UNIT2;
      }
      if (left2) {
        this._element.style.marginLeft = left2 + UNIT2;
      }
    }
    /**
     * Getter for the element offset.
     *
     * @returns {Object} Object contains top and left offset of the element.
     */
  }, {
    key: "getOffset",
    value: function getOffset() {
      return {
        top: this._element.style.marginTop ? parseInt(this._element.style.marginTop, 10) : 0,
        left: this._element.style.marginLeft ? parseInt(this._element.style.marginLeft, 10) : 0
      };
    }
  }]);
  return BaseUI3;
}();
var base_default4 = BaseUI2;

// node_modules/handsontable/es/plugins/manualRowMove/ui/backlight.js
function _typeof39(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof39 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof39 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof39(obj);
}
function _classCallCheck73(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties70(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass70(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties70(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties70(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn27(self2, call) {
  if (call && (_typeof39(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized27(self2);
}
function _assertThisInitialized27(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get19(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get19 = Reflect.get;
  } else {
    _get19 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase19(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get19(target, property, receiver || target);
}
function _superPropBase19(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf27(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf27(o) {
  _getPrototypeOf27 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf27(o);
}
function _inherits27(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf27(subClass, superClass);
}
function _setPrototypeOf27(o, p) {
  _setPrototypeOf27 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf27(o, p);
}
var CSS_CLASSNAME3 = "ht__manualRowMove--backlight";
var BacklightUI2 = function(_BaseUI) {
  _inherits27(BacklightUI3, _BaseUI);
  function BacklightUI3() {
    _classCallCheck73(this, BacklightUI3);
    return _possibleConstructorReturn27(this, _getPrototypeOf27(BacklightUI3).apply(this, arguments));
  }
  _createClass70(BacklightUI3, [{
    key: "build",
    /**
     * Custom className on build process.
     */
    value: function build() {
      _get19(_getPrototypeOf27(BacklightUI3.prototype), "build", this).call(this);
      addClass(this._element, CSS_CLASSNAME3);
    }
  }]);
  return BacklightUI3;
}(base_default4);
var backlight_default2 = BacklightUI2;

// node_modules/handsontable/es/plugins/manualRowMove/ui/guideline.js
function _typeof40(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof40 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof40 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof40(obj);
}
function _classCallCheck74(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties71(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass71(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties71(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties71(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn28(self2, call) {
  if (call && (_typeof40(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized28(self2);
}
function _assertThisInitialized28(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get20(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get20 = Reflect.get;
  } else {
    _get20 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase20(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get20(target, property, receiver || target);
}
function _superPropBase20(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf28(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf28(o) {
  _getPrototypeOf28 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf28(o);
}
function _inherits28(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf28(subClass, superClass);
}
function _setPrototypeOf28(o, p) {
  _setPrototypeOf28 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf28(o, p);
}
var CSS_CLASSNAME4 = "ht__manualRowMove--guideline";
var GuidelineUI2 = function(_BaseUI) {
  _inherits28(GuidelineUI3, _BaseUI);
  function GuidelineUI3() {
    _classCallCheck74(this, GuidelineUI3);
    return _possibleConstructorReturn28(this, _getPrototypeOf28(GuidelineUI3).apply(this, arguments));
  }
  _createClass71(GuidelineUI3, [{
    key: "build",
    /**
     * Custom className on build process.
     */
    value: function build() {
      _get20(_getPrototypeOf28(GuidelineUI3.prototype), "build", this).call(this);
      addClass(this._element, CSS_CLASSNAME4);
    }
  }]);
  return GuidelineUI3;
}(base_default4);
var guideline_default2 = GuidelineUI2;

// node_modules/handsontable/es/plugins/manualRowMove/manualRowMove.js
function _typeof41(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof41 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof41 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof41(obj);
}
function _toConsumableArray10(arr) {
  return _arrayWithoutHoles10(arr) || _iterableToArray11(arr) || _nonIterableSpread10();
}
function _nonIterableSpread10() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray11(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles10(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function _classCallCheck75(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties72(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass72(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties72(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties72(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn29(self2, call) {
  if (call && (_typeof41(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized29(self2);
}
function _get21(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get21 = Reflect.get;
  } else {
    _get21 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase21(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get21(target, property, receiver || target);
}
function _superPropBase21(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf29(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf29(o) {
  _getPrototypeOf29 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf29(o);
}
function _inherits29(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf29(subClass, superClass);
}
function _setPrototypeOf29(o, p) {
  _setPrototypeOf29 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf29(o, p);
}
function _assertThisInitialized29(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
pluginHooks_default.getSingleton().register("beforeRowMove");
pluginHooks_default.getSingleton().register("afterRowMove");
pluginHooks_default.getSingleton().register("unmodifyRow");
var privatePool10 = /* @__PURE__ */ new WeakMap();
var CSS_PLUGIN2 = "ht__manualRowMove";
var CSS_SHOW_UI2 = "show-ui";
var CSS_ON_MOVING2 = "on-moving--rows";
var CSS_AFTER_SELECTION2 = "after-selection--rows";
var ManualRowMove = function(_BasePlugin) {
  _inherits29(ManualRowMove2, _BasePlugin);
  function ManualRowMove2(hotInstance) {
    var _this;
    _classCallCheck75(this, ManualRowMove2);
    _this = _possibleConstructorReturn29(this, _getPrototypeOf29(ManualRowMove2).call(this, hotInstance));
    privatePool10.set(_assertThisInitialized29(_assertThisInitialized29(_this)), {
      rowsToMove: [],
      pressed: void 0,
      disallowMoving: void 0,
      target: {
        eventPageY: void 0,
        coords: void 0,
        TD: void 0,
        row: void 0
      }
    });
    _this.removedRows = [];
    _this.rowsMapper = new rowsMapper_default2(_assertThisInitialized29(_assertThisInitialized29(_this)));
    _this.eventManager = new eventManager_default(_assertThisInitialized29(_assertThisInitialized29(_this)));
    _this.backlight = new backlight_default2(hotInstance);
    _this.guideline = new guideline_default2(hotInstance);
    return _this;
  }
  _createClass72(ManualRowMove2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings().manualRowMove;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("beforeOnCellMouseDown", function(event2, coords, TD, blockCalculations) {
        return _this2.onBeforeOnCellMouseDown(event2, coords, TD, blockCalculations);
      });
      this.addHook("beforeOnCellMouseOver", function(event2, coords, TD, blockCalculations) {
        return _this2.onBeforeOnCellMouseOver(event2, coords, TD, blockCalculations);
      });
      this.addHook("afterScrollHorizontally", function() {
        return _this2.onAfterScrollHorizontally();
      });
      this.addHook("modifyRow", function(row, source) {
        return _this2.onModifyRow(row, source);
      });
      this.addHook("beforeRemoveRow", function(index2, amount) {
        return _this2.onBeforeRemoveRow(index2, amount);
      });
      this.addHook("afterRemoveRow", function() {
        return _this2.onAfterRemoveRow();
      });
      this.addHook("afterCreateRow", function(index2, amount) {
        return _this2.onAfterCreateRow(index2, amount);
      });
      this.addHook("afterLoadData", function() {
        return _this2.onAfterLoadData();
      });
      this.addHook("beforeColumnSort", function(column, order) {
        return _this2.onBeforeColumnSort(column, order);
      });
      this.addHook("unmodifyRow", function(row) {
        return _this2.onUnmodifyRow(row);
      });
      this.registerEvents();
      addClass(this.hot.rootElement, CSS_PLUGIN2);
      _get21(_getPrototypeOf29(ManualRowMove2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      this.onAfterPluginsInitialized();
      _get21(_getPrototypeOf29(ManualRowMove2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var pluginSettings = this.hot.getSettings().manualRowMove;
      if (Array.isArray(pluginSettings)) {
        this.rowsMapper.clearMap();
      }
      removeClass(this.hot.rootElement, CSS_PLUGIN2);
      this.unregisterEvents();
      this.backlight.destroy();
      this.guideline.destroy();
      _get21(_getPrototypeOf29(ManualRowMove2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Moves a single row.
     *
     * @param {Number} row Visual row index to be moved.
     * @param {Number} target Visual row index being a target for the moved row.
     * @fires Hooks#beforeRowMove
     * @fires Hooks#afterRowMove
     */
  }, {
    key: "moveRow",
    value: function moveRow(row, target) {
      this.moveRows([row], target);
    }
    /**
     * Moves a multiple rows.
     *
     * @param {Array} rows Array of visual row indexes to be moved.
     * @param {Number} target Visual row index being a target for the moved rows.
     * @fires Hooks#beforeRowMove
     * @fires Hooks#afterRowMove
     */
  }, {
    key: "moveRows",
    value: function moveRows(rows, target) {
      var _this3 = this;
      var visualRows = _toConsumableArray10(rows);
      var priv = privatePool10.get(this);
      var beforeMoveHook = this.hot.runHooks("beforeRowMove", visualRows, target);
      priv.disallowMoving = beforeMoveHook === false;
      if (!priv.disallowMoving) {
        arrayEach(rows, function(row, index2, array) {
          array[index2] = _this3.rowsMapper.getValueByIndex(row);
        });
        arrayEach(rows, function(row, index2) {
          var actualPosition = _this3.rowsMapper.getIndexByValue(row);
          if (actualPosition !== target) {
            _this3.rowsMapper.moveRow(actualPosition, target + index2);
          }
        });
        this.rowsMapper.clearNull();
      }
      this.hot.runHooks("afterRowMove", visualRows, target);
    }
    /**
     * Correct the cell selection after the move action. Fired only when action was made with a mouse.
     * That means that changing the row order using the API won't correct the selection.
     *
     * @private
     * @param {Number} startRow Visual row index for the start of the selection.
     * @param {Number} endRow Visual row index for the end of the selection.
     */
  }, {
    key: "changeSelection",
    value: function changeSelection(startRow, endRow) {
      this.hot.selectRows(startRow, endRow);
    }
    /**
     * Gets the sum of the heights of rows in the provided range.
     *
     * @private
     * @param {Number} from Visual row index.
     * @param {Number} to Visual row index.
     * @returns {Number}
     */
  }, {
    key: "getRowsHeight",
    value: function getRowsHeight(from3, to3) {
      var height = 0;
      for (var i = from3; i < to3; i++) {
        var rowHeight = this.hot.view.wt.wtTable.getRowHeight(i) || 23;
        height += rowHeight;
      }
      return height;
    }
    /**
     * Loads initial settings when persistent state is saved or when plugin was initialized as an array.
     *
     * @private
     */
  }, {
    key: "initialSettings",
    value: function initialSettings() {
      var pluginSettings = this.hot.getSettings().manualRowMove;
      if (Array.isArray(pluginSettings)) {
        this.moveRows(pluginSettings, 0);
      } else if (pluginSettings !== void 0) {
        var persistentState = this.persistentStateLoad();
        if (persistentState.length) {
          this.moveRows(persistentState, 0);
        }
      }
    }
    /**
     * Checks if the provided row is in the fixedRowsTop section.
     *
     * @private
     * @param {Number} row Visual row index to check.
     * @returns {Boolean}
     */
  }, {
    key: "isFixedRowTop",
    value: function isFixedRowTop(row) {
      return row < this.hot.getSettings().fixedRowsTop;
    }
    /**
     * Checks if the provided row is in the fixedRowsBottom section.
     *
     * @private
     * @param {Number} row Visual row index to check.
     * @returns {Boolean}
     */
  }, {
    key: "isFixedRowBottom",
    value: function isFixedRowBottom(row) {
      return row > this.hot.getSettings().fixedRowsBottom;
    }
    /**
     * Saves the manual row positions to the persistent state (the {@link Options#persistentState} option has to be enabled).
     *
     * @fires Hooks#persistentStateSave
     * @fires Hooks#manualRowMove
     */
  }, {
    key: "persistentStateSave",
    value: function persistentStateSave() {
      this.hot.runHooks("persistentStateSave", "manualRowMove", this.rowsMapper._arrayMap);
    }
    /**
     * Loads the manual row positions from the persistent state (the {@link Options#persistentState} option has to be enabled).
     *
     * @returns {Array} Stored state.
     *
     * @fires Hooks#persistentStateLoad
     * @fires Hooks#manualRowMove
     */
  }, {
    key: "persistentStateLoad",
    value: function persistentStateLoad() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", "manualRowMove", storedState);
      return storedState.value ? storedState.value : [];
    }
    /**
     * Prepare array of indexes based on actual selection.
     *
     * @private
     * @returns {Array}
     */
  }, {
    key: "prepareRowsToMoving",
    value: function prepareRowsToMoving() {
      var selection = this.hot.getSelectedRangeLast();
      var selectedRows = [];
      if (!selection) {
        return selectedRows;
      }
      var from3 = selection.from, to3 = selection.to;
      var start = Math.min(from3.row, to3.row);
      var end = Math.max(from3.row, to3.row);
      rangeEach(start, end, function(i) {
        selectedRows.push(i);
      });
      return selectedRows;
    }
    /**
     * Update the UI visual position.
     *
     * @private
     */
  }, {
    key: "refreshPositions",
    value: function refreshPositions() {
      var priv = privatePool10.get(this);
      var coords = priv.target.coords;
      var firstVisible = this.hot.view.wt.wtTable.getFirstVisibleRow();
      var lastVisible = this.hot.view.wt.wtTable.getLastVisibleRow();
      var fixedRows = this.hot.getSettings().fixedRowsTop;
      var countRows = this.hot.countRows();
      if (coords.row < fixedRows && firstVisible > 0) {
        this.hot.scrollViewportTo(firstVisible - 1);
      }
      if (coords.row >= lastVisible && lastVisible < countRows) {
        this.hot.scrollViewportTo(lastVisible + 1, void 0, true);
      }
      var wtTable = this.hot.view.wt.wtTable;
      var TD = priv.target.TD;
      var rootElementOffset = offset(this.hot.rootElement);
      var tdOffsetTop = this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row);
      var mouseOffsetTop = priv.target.eventPageY - rootElementOffset.top + wtTable.holder.scrollTop;
      var hiderHeight = wtTable.hider.offsetHeight;
      var tbodyOffsetTop = wtTable.TBODY.offsetTop;
      var backlightElemMarginTop = this.backlight.getOffset().top;
      var backlightElemHeight = this.backlight.getSize().height;
      if (this.isFixedRowTop(coords.row)) {
        tdOffsetTop += wtTable.holder.scrollTop;
      }
      if (coords.row < 0) {
        priv.target.row = firstVisible > 0 ? firstVisible - 1 : firstVisible;
      } else if (TD.offsetHeight / 2 + tdOffsetTop <= mouseOffsetTop) {
        priv.target.row = coords.row + 1;
        tdOffsetTop += coords.row === 0 ? TD.offsetHeight - 1 : TD.offsetHeight;
      } else {
        priv.target.row = coords.row;
      }
      var backlightTop = mouseOffsetTop;
      var guidelineTop = tdOffsetTop;
      if (mouseOffsetTop + backlightElemHeight + backlightElemMarginTop >= hiderHeight) {
        backlightTop = hiderHeight - backlightElemHeight - backlightElemMarginTop;
      } else if (mouseOffsetTop + backlightElemMarginTop < tbodyOffsetTop) {
        backlightTop = tbodyOffsetTop + Math.abs(backlightElemMarginTop);
      }
      if (tdOffsetTop >= hiderHeight - 1) {
        guidelineTop = hiderHeight - 1;
      }
      var topOverlayHeight = 0;
      if (this.hot.view.wt.wtOverlays.topOverlay) {
        topOverlayHeight = this.hot.view.wt.wtOverlays.topOverlay.clone.wtTable.TABLE.offsetHeight;
      }
      if (coords.row >= fixedRows && guidelineTop - wtTable.holder.scrollTop < topOverlayHeight) {
        this.hot.scrollViewportTo(coords.row);
      }
      this.backlight.setPosition(backlightTop);
      this.guideline.setPosition(guidelineTop);
    }
    /**
     * This method checks arrayMap from rowsMapper and updates the rowsMapper if it's necessary.
     *
     * @private
     */
  }, {
    key: "updateRowsMapper",
    value: function updateRowsMapper() {
      var countRows = this.hot.countSourceRows();
      var rowsMapperLen = this.rowsMapper._arrayMap.length;
      if (rowsMapperLen === 0) {
        this.rowsMapper.createMap(countRows || this.hot.getSettings().startRows);
      } else if (rowsMapperLen < countRows) {
        var diff3 = countRows - rowsMapperLen;
        this.rowsMapper.insertItems(rowsMapperLen, diff3);
      } else if (rowsMapperLen > countRows) {
        var maxIndex = countRows - 1;
        var rowsToRemove = [];
        arrayEach(this.rowsMapper._arrayMap, function(value, index2) {
          if (value > maxIndex) {
            rowsToRemove.push(index2);
          }
        });
        this.rowsMapper.removeItems(rowsToRemove);
      }
    }
    /**
     * Binds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this4 = this;
      this.eventManager.addEventListener(document.documentElement, "mousemove", function(event2) {
        return _this4.onMouseMove(event2);
      });
      this.eventManager.addEventListener(document.documentElement, "mouseup", function() {
        return _this4.onMouseUp();
      });
    }
    /**
     * Unbinds the events used by the plugin.
     *
     * @private
     */
  }, {
    key: "unregisterEvents",
    value: function unregisterEvents() {
      this.eventManager.clear();
    }
    /**
     * `beforeColumnSort` hook callback. If user uses the sorting, manual row moving is disabled.
     *
     * @private
     * @param {Number} column Column index where soring is present
     * @param {*} order State of sorting. ASC/DESC/None
     */
  }, {
    key: "onBeforeColumnSort",
    value: function onBeforeColumnSort(column, order) {
      var priv = privatePool10.get(this);
      priv.disallowMoving = order !== void 0;
    }
    /**
     * Changes the behavior of selection / dragging.
     *
     * @private
     * @param {MouseEvent} event
     * @param {CellCoords} coords Visual coordinates.
     * @param {HTMLElement} TD
     * @param {Object} blockCalculations
     */
  }, {
    key: "onBeforeOnCellMouseDown",
    value: function onBeforeOnCellMouseDown(event2, coords, TD, blockCalculations) {
      var wtTable = this.hot.view.wt.wtTable;
      var isHeaderSelection = this.hot.selection.isSelectedByRowHeader();
      var selection = this.hot.getSelectedRangeLast();
      var priv = privatePool10.get(this);
      if (!selection || !isHeaderSelection || priv.pressed || event2.button !== 0) {
        priv.pressed = false;
        priv.rowsToMove.length = 0;
        removeClass(this.hot.rootElement, [CSS_ON_MOVING2, CSS_SHOW_UI2]);
        return;
      }
      var guidelineIsNotReady = this.guideline.isBuilt() && !this.guideline.isAppended();
      var backlightIsNotReady = this.backlight.isBuilt() && !this.backlight.isAppended();
      if (guidelineIsNotReady && backlightIsNotReady) {
        this.guideline.appendTo(wtTable.hider);
        this.backlight.appendTo(wtTable.hider);
      }
      var from3 = selection.from, to3 = selection.to;
      var start = Math.min(from3.row, to3.row);
      var end = Math.max(from3.row, to3.row);
      if (coords.col < 0 && coords.row >= start && coords.row <= end) {
        blockCalculations.row = true;
        priv.pressed = true;
        priv.target.eventPageY = event2.pageY;
        priv.target.coords = coords;
        priv.target.TD = TD;
        priv.rowsToMove = this.prepareRowsToMoving();
        var leftPos = wtTable.holder.scrollLeft + this.hot.view.wt.wtViewport.getRowHeaderWidth();
        this.backlight.setPosition(null, leftPos);
        this.backlight.setSize(wtTable.hider.offsetWidth - leftPos, this.getRowsHeight(start, end + 1));
        this.backlight.setOffset((this.getRowsHeight(start, coords.row) + event2.layerY) * -1, null);
        addClass(this.hot.rootElement, CSS_ON_MOVING2);
        this.refreshPositions();
      } else {
        removeClass(this.hot.rootElement, CSS_AFTER_SELECTION2);
        priv.pressed = false;
        priv.rowsToMove.length = 0;
      }
    }
    /**
     * 'mouseMove' event callback. Fired when pointer move on document.documentElement.
     *
     * @private
     * @param {MouseEvent} event `mousemove` event properties.
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var priv = privatePool10.get(this);
      if (!priv.pressed) {
        return;
      }
      if (event2.realTarget === this.backlight.element) {
        var height = this.backlight.getSize().height;
        this.backlight.setSize(null, 0);
        setTimeout(function() {
          this.backlight.setPosition(null, height);
        });
      }
      priv.target.eventPageY = event2.pageY;
      this.refreshPositions();
    }
    /**
     * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.
     *
     * @private
     * @param {MouseEvent} event `mouseover` event properties.
     * @param {CellCoords} coords Visual cell coordinates where was fired event.
     * @param {HTMLElement} TD Cell represented as HTMLElement.
     * @param {Object} blockCalculations Object which contains information about blockCalculation for row, column or cells.
     */
  }, {
    key: "onBeforeOnCellMouseOver",
    value: function onBeforeOnCellMouseOver(event2, coords, TD, blockCalculations) {
      var selectedRange = this.hot.getSelectedRangeLast();
      var priv = privatePool10.get(this);
      if (!selectedRange || !priv.pressed) {
        return;
      }
      if (priv.rowsToMove.indexOf(coords.row) > -1) {
        removeClass(this.hot.rootElement, CSS_SHOW_UI2);
      } else {
        addClass(this.hot.rootElement, CSS_SHOW_UI2);
      }
      blockCalculations.row = true;
      blockCalculations.column = true;
      blockCalculations.cell = true;
      priv.target.coords = coords;
      priv.target.TD = TD;
    }
    /**
     * `onMouseUp` hook callback.
     *
     * @private
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      var priv = privatePool10.get(this);
      var target = priv.target.row;
      var rowsLen = priv.rowsToMove.length;
      priv.pressed = false;
      priv.backlightHeight = 0;
      removeClass(this.hot.rootElement, [CSS_ON_MOVING2, CSS_SHOW_UI2, CSS_AFTER_SELECTION2]);
      if (this.hot.selection.isSelectedByRowHeader()) {
        addClass(this.hot.rootElement, CSS_AFTER_SELECTION2);
      }
      if (rowsLen < 1 || target === void 0 || priv.rowsToMove.indexOf(target) > -1 || priv.rowsToMove[rowsLen - 1] === target - 1) {
        return;
      }
      this.moveRows(priv.rowsToMove, target);
      this.persistentStateSave();
      this.hot.render();
      if (!priv.disallowMoving) {
        var selectionStart = this.rowsMapper.getIndexByValue(priv.rowsToMove[0]);
        var selectionEnd = this.rowsMapper.getIndexByValue(priv.rowsToMove[rowsLen - 1]);
        this.changeSelection(selectionStart, selectionEnd);
      }
      priv.rowsToMove.length = 0;
    }
    /**
     * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.
     *
     * @private
     */
  }, {
    key: "onAfterScrollHorizontally",
    value: function onAfterScrollHorizontally() {
      var wtTable = this.hot.view.wt.wtTable;
      var headerWidth = this.hot.view.wt.wtViewport.getRowHeaderWidth();
      var scrollLeft = wtTable.holder.scrollLeft;
      var posLeft = headerWidth + scrollLeft;
      this.backlight.setPosition(null, posLeft);
      this.backlight.setSize(wtTable.hider.offsetWidth - posLeft);
    }
    /**
     * `afterCreateRow` hook callback.
     *
     * @private
     * @param {Number} index Visual index of the created row.
     * @param {Number} amount Amount of created rows.
     */
  }, {
    key: "onAfterCreateRow",
    value: function onAfterCreateRow(index2, amount) {
      this.rowsMapper.shiftItems(index2, amount);
    }
    /**
     * On before remove row listener.
     *
     * @private
     * @param {Number} index Visual row index.
     * @param {Number} amount Defines how many rows removed.
     */
  }, {
    key: "onBeforeRemoveRow",
    value: function onBeforeRemoveRow(index2, amount) {
      var _this5 = this;
      this.removedRows.length = 0;
      if (index2 !== false) {
        rangeEach(index2, index2 + amount - 1, function(removedIndex) {
          _this5.removedRows.push(_this5.hot.runHooks("modifyRow", removedIndex, _this5.pluginName));
        });
      }
    }
    /**
     * `afterRemoveRow` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterRemoveRow",
    value: function onAfterRemoveRow() {
      this.rowsMapper.unshiftItems(this.removedRows);
    }
    /**
     * `afterLoadData` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData() {
      this.updateRowsMapper();
    }
    /**
     * 'modifyRow' hook callback.
     *
     * @private
     * @param {Number} row Visual Row index.
     * @returns {Number} Physical row index.
     */
  }, {
    key: "onModifyRow",
    value: function onModifyRow(row, source) {
      var physicalRow = row;
      if (source !== this.pluginName) {
        var rowInMapper = this.rowsMapper.getValueByIndex(physicalRow);
        physicalRow = rowInMapper === null ? physicalRow : rowInMapper;
      }
      return physicalRow;
    }
    /**
     * 'unmodifyRow' hook callback.
     *
     * @private
     * @param {Number} row Physical row index.
     * @returns {Number} Visual row index.
     */
  }, {
    key: "onUnmodifyRow",
    value: function onUnmodifyRow(row) {
      var indexInMapper = this.rowsMapper.getIndexByValue(row);
      return indexInMapper === null ? row : indexInMapper;
    }
    /**
     * `afterPluginsInitialized` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterPluginsInitialized",
    value: function onAfterPluginsInitialized() {
      this.updateRowsMapper();
      this.initialSettings();
      this.backlight.build();
      this.guideline.build();
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.backlight.destroy();
      this.guideline.destroy();
      this.rowsMapper.destroy();
      _get21(_getPrototypeOf29(ManualRowMove2.prototype), "destroy", this).call(this);
    }
  }]);
  return ManualRowMove2;
}(base_default2);
registerPlugin("ManualRowMove", ManualRowMove);
var manualRowMove_default = ManualRowMove;

// node_modules/handsontable/es/plugins/manualRowResize/manualRowResize.js
function _typeof42(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof42 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof42 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof42(obj);
}
function _classCallCheck76(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties73(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass73(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties73(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties73(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn30(self2, call) {
  if (call && (_typeof42(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized30(self2);
}
function _get22(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get22 = Reflect.get;
  } else {
    _get22 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase22(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get22(target, property, receiver || target);
}
function _superPropBase22(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf30(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf30(o) {
  _getPrototypeOf30 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf30(o);
}
function _inherits30(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf30(subClass, superClass);
}
function _setPrototypeOf30(o, p) {
  _setPrototypeOf30 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf30(o, p);
}
function _assertThisInitialized30(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var ManualRowResize = function(_BasePlugin) {
  _inherits30(ManualRowResize2, _BasePlugin);
  function ManualRowResize2(hotInstance) {
    var _this;
    _classCallCheck76(this, ManualRowResize2);
    _this = _possibleConstructorReturn30(this, _getPrototypeOf30(ManualRowResize2).call(this, hotInstance));
    _this.currentTH = null;
    _this.currentRow = null;
    _this.selectedRows = [];
    _this.currentHeight = null;
    _this.newSize = null;
    _this.startY = null;
    _this.startHeight = null;
    _this.startOffset = null;
    _this.handle = document.createElement("DIV");
    _this.guide = document.createElement("DIV");
    _this.eventManager = new eventManager_default(_assertThisInitialized30(_assertThisInitialized30(_this)));
    _this.pressed = null;
    _this.dblclick = 0;
    _this.autoresizeTimeout = null;
    _this.manualRowHeights = [];
    addClass(_this.handle, "manualRowResizer");
    addClass(_this.guide, "manualRowResizerGuide");
    return _this;
  }
  _createClass73(ManualRowResize2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().manualRowResize;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.manualRowHeights = [];
      var initialRowHeights = this.hot.getSettings().manualRowResize;
      var loadedManualRowHeights = this.loadManualRowHeights();
      if (typeof loadedManualRowHeights !== "undefined") {
        this.manualRowHeights = loadedManualRowHeights;
      } else if (Array.isArray(initialRowHeights)) {
        this.manualRowHeights = initialRowHeights;
      } else {
        this.manualRowHeights = [];
      }
      this.addHook("modifyRowHeight", function(height, row) {
        return _this2.onModifyRowHeight(height, row);
      });
      this.bindEvents();
      _get22(_getPrototypeOf30(ManualRowResize2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var initialRowHeights = this.hot.getSettings().manualRowResize;
      if (Array.isArray(initialRowHeights)) {
        this.manualRowHeights = initialRowHeights;
      } else if (!initialRowHeights) {
        this.manualRowHeights = [];
      }
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get22(_getPrototypeOf30(ManualRowResize2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
     * @fires Hooks#persistentStateSave
     * @fires Hooks#manualRowHeights
     */
  }, {
    key: "saveManualRowHeights",
    value: function saveManualRowHeights() {
      this.hot.runHooks("persistentStateSave", "manualRowHeights", this.manualRowHeights);
    }
    /**
     * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
     *
     * @returns {Array}
     * @fires Hooks#persistentStateLoad
     * @fires Hooks#manualRowHeights
     */
  }, {
    key: "loadManualRowHeights",
    value: function loadManualRowHeights() {
      var storedState = {};
      this.hot.runHooks("persistentStateLoad", "manualRowHeights", storedState);
      return storedState.value;
    }
    /**
     * Sets the resize handle position.
     *
     * @private
     * @param {HTMLCellElement} TH TH HTML element.
     */
  }, {
    key: "setupHandlePosition",
    value: function setupHandlePosition(TH) {
      var _this3 = this;
      this.currentTH = TH;
      var row = this.hot.view.wt.wtTable.getCoords(TH).row;
      var headerWidth = outerWidth(this.currentTH);
      if (row >= 0) {
        var box = this.currentTH.getBoundingClientRect();
        this.currentRow = row;
        this.selectedRows = [];
        if (this.hot.selection.isSelected() && this.hot.selection.isSelectedByRowHeader()) {
          var _this$hot$getSelected = this.hot.getSelectedRangeLast(), from3 = _this$hot$getSelected.from, to3 = _this$hot$getSelected.to;
          var start = from3.row;
          var end = to3.row;
          if (start >= end) {
            start = to3.row;
            end = from3.row;
          }
          if (this.currentRow >= start && this.currentRow <= end) {
            rangeEach(start, end, function(i) {
              return _this3.selectedRows.push(i);
            });
          } else {
            this.selectedRows.push(this.currentRow);
          }
        } else {
          this.selectedRows.push(this.currentRow);
        }
        this.startOffset = box.top - 6;
        this.startHeight = parseInt(box.height, 10);
        this.handle.style.left = "".concat(box.left, "px");
        this.handle.style.top = "".concat(this.startOffset + this.startHeight, "px");
        this.handle.style.width = "".concat(headerWidth, "px");
        this.hot.rootElement.appendChild(this.handle);
      }
    }
    /**
     * Refresh the resize handle position.
     *
     * @private
     */
  }, {
    key: "refreshHandlePosition",
    value: function refreshHandlePosition() {
      this.handle.style.top = "".concat(this.startOffset + this.currentHeight, "px");
    }
    /**
     * Sets the resize guide position.
     *
     * @private
     */
  }, {
    key: "setupGuidePosition",
    value: function setupGuidePosition() {
      var handleWidth = parseInt(outerWidth(this.handle), 10);
      var handleRightPosition = parseInt(this.handle.style.left, 10) + handleWidth;
      var maximumVisibleElementWidth = parseInt(this.hot.view.maximumVisibleElementWidth(0), 10);
      addClass(this.handle, "active");
      addClass(this.guide, "active");
      this.guide.style.top = this.handle.style.top;
      this.guide.style.left = "".concat(handleRightPosition, "px");
      this.guide.style.width = "".concat(maximumVisibleElementWidth - handleWidth, "px");
      this.hot.rootElement.appendChild(this.guide);
    }
    /**
     * Refresh the resize guide position.
     *
     * @private
     */
  }, {
    key: "refreshGuidePosition",
    value: function refreshGuidePosition() {
      this.guide.style.top = this.handle.style.top;
    }
    /**
     * Hides both the resize handle and resize guide.
     *
     * @private
     */
  }, {
    key: "hideHandleAndGuide",
    value: function hideHandleAndGuide() {
      removeClass(this.handle, "active");
      removeClass(this.guide, "active");
    }
    /**
     * Checks if provided element is considered as a row header.
     *
     * @private
     * @param {HTMLElement} element HTML element.
     * @returns {Boolean}
     */
  }, {
    key: "checkIfRowHeader",
    value: function checkIfRowHeader(element) {
      if (element !== this.hot.rootElement) {
        var parent = element.parentNode;
        if (parent.tagName === "TBODY") {
          return true;
        }
        return this.checkIfRowHeader(parent);
      }
      return false;
    }
    /**
     * Gets the TH element from the provided element.
     *
     * @private
     * @param {HTMLElement} element HTML element.
     * @returns {HTMLElement}
     */
  }, {
    key: "getTHFromTargetElement",
    value: function getTHFromTargetElement(element) {
      if (element.tagName !== "TABLE") {
        if (element.tagName === "TH") {
          return element;
        }
        return this.getTHFromTargetElement(element.parentNode);
      }
      return null;
    }
    /**
     * 'mouseover' event callback - set the handle position.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseOver",
    value: function onMouseOver(event2) {
      if (this.checkIfRowHeader(event2.target)) {
        var th = this.getTHFromTargetElement(event2.target);
        if (th) {
          if (!this.pressed) {
            this.setupHandlePosition(th);
          }
        }
      }
    }
    /**
     * Auto-size row after doubleclick - callback.
     *
     * @private
     * @fires Hooks#beforeRowResize
     * @fires Hooks#afterRowResize
     */
  }, {
    key: "afterMouseDownTimeout",
    value: function afterMouseDownTimeout() {
      var _this4 = this;
      var render = function render2() {
        _this4.hot.forceFullRender = true;
        _this4.hot.view.render();
        _this4.hot.view.wt.wtOverlays.adjustElementsSize(true);
      };
      var resize = function resize2(selectedRow, forceRender) {
        var hookNewSize = _this4.hot.runHooks("beforeRowResize", selectedRow, _this4.newSize, true);
        if (hookNewSize !== void 0) {
          _this4.newSize = hookNewSize;
        }
        _this4.setManualSize(selectedRow, _this4.newSize);
        if (forceRender) {
          render();
        }
        _this4.hot.runHooks("afterRowResize", selectedRow, _this4.newSize, true);
      };
      if (this.dblclick >= 2) {
        var selectedRowsLength = this.selectedRows.length;
        if (selectedRowsLength > 1) {
          arrayEach(this.selectedRows, function(selectedRow) {
            resize(selectedRow);
          });
          render();
        } else {
          arrayEach(this.selectedRows, function(selectedRow) {
            resize(selectedRow, true);
          });
        }
      }
      this.dblclick = 0;
      this.autoresizeTimeout = null;
    }
    /**
     * 'mousedown' event callback.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseDown",
    value: function onMouseDown(event2) {
      var _this5 = this;
      if (hasClass(event2.target, "manualRowResizer")) {
        this.setupGuidePosition();
        this.pressed = this.hot;
        if (this.autoresizeTimeout === null) {
          this.autoresizeTimeout = setTimeout(function() {
            return _this5.afterMouseDownTimeout();
          }, 500);
          this.hot._registerTimeout(this.autoresizeTimeout);
        }
        this.dblclick += 1;
        this.startY = pageY(event2);
        this.newSize = this.startHeight;
      }
    }
    /**
     * 'mousemove' event callback - refresh the handle and guide positions, cache the new row height.
     *
     * @private
     * @param {MouseEvent} event
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event2) {
      var _this6 = this;
      if (this.pressed) {
        this.currentHeight = this.startHeight + (pageY(event2) - this.startY);
        arrayEach(this.selectedRows, function(selectedRow) {
          _this6.newSize = _this6.setManualSize(selectedRow, _this6.currentHeight);
        });
        this.refreshHandlePosition();
        this.refreshGuidePosition();
      }
    }
    /**
     * 'mouseup' event callback - apply the row resizing.
     *
     * @private
     *
     * @fires Hooks#beforeRowResize
     * @fires Hooks#afterRowResize
     */
  }, {
    key: "onMouseUp",
    value: function onMouseUp2() {
      var _this7 = this;
      var render = function render2() {
        _this7.hot.forceFullRender = true;
        _this7.hot.view.render();
        _this7.hot.view.wt.wtOverlays.adjustElementsSize(true);
      };
      var runHooks = function runHooks2(selectedRow, forceRender) {
        _this7.hot.runHooks("beforeRowResize", selectedRow, _this7.newSize);
        if (forceRender) {
          render();
        }
        _this7.saveManualRowHeights();
        _this7.hot.runHooks("afterRowResize", selectedRow, _this7.newSize, false);
      };
      if (this.pressed) {
        this.hideHandleAndGuide();
        this.pressed = false;
        if (this.newSize !== this.startHeight) {
          var selectedRowsLength = this.selectedRows.length;
          if (selectedRowsLength > 1) {
            arrayEach(this.selectedRows, function(selectedRow) {
              runHooks(selectedRow);
            });
            render();
          } else {
            arrayEach(this.selectedRows, function(selectedRow) {
              runHooks(selectedRow, true);
            });
          }
        }
        this.setupHandlePosition(this.currentTH);
      }
    }
    /**
     * Binds the mouse events.
     *
     * @private
     */
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      var _this8 = this;
      this.eventManager.addEventListener(this.hot.rootElement, "mouseover", function(e) {
        return _this8.onMouseOver(e);
      });
      this.eventManager.addEventListener(this.hot.rootElement, "mousedown", function(e) {
        return _this8.onMouseDown(e);
      });
      this.eventManager.addEventListener(window, "mousemove", function(e) {
        return _this8.onMouseMove(e);
      });
      this.eventManager.addEventListener(window, "mouseup", function() {
        return _this8.onMouseUp();
      });
    }
    /**
     * Sets the new height for specified row index.
     *
     * @param {Number} row Visual row index.
     * @param {Number} height Row height.
     * @returns {Number} Returns new height.
     *
     * @fires Hooks#modifyRow
     */
  }, {
    key: "setManualSize",
    value: function setManualSize(row, height) {
      var physicalRow = this.hot.runHooks("modifyRow", row);
      this.manualRowHeights[physicalRow] = height;
      return height;
    }
    /**
     * Modifies the provided row height, based on the plugin settings.
     *
     * @private
     * @param {Number} height Row height.
     * @param {Number} row Visual row index.
     * @returns {Number}
     *
     * @fires Hooks#modifyRow
     */
  }, {
    key: "onModifyRowHeight",
    value: function onModifyRowHeight(height, row) {
      if (this.enabled) {
        var autoRowSizePlugin = this.hot.getPlugin("autoRowSize");
        var autoRowHeightResult = autoRowSizePlugin ? autoRowSizePlugin.heights[row] : null;
        var physicalRow = this.hot.runHooks("modifyRow", row);
        var manualRowHeight = this.manualRowHeights[physicalRow];
        if (manualRowHeight !== void 0 && (manualRowHeight === autoRowHeightResult || manualRowHeight > (height || 0))) {
          return manualRowHeight;
        }
      }
      return height;
    }
  }]);
  return ManualRowResize2;
}(base_default2);
registerPlugin("manualRowResize", ManualRowResize);
var manualRowResize_default = ManualRowResize;

// node_modules/handsontable/es/plugins/mergeCells/cellCoords.js
function _templateObject42() {
  var data = _taggedTemplateLiteral6(["The merged cell declared at [", ", ", '] has "rowspan" or "colspan" declared as \n      "0", which is not supported. It cannot be added to the collection.']);
  _templateObject42 = function _templateObject43() {
    return data;
  };
  return data;
}
function _templateObject32() {
  var data = _taggedTemplateLiteral6(["The merged cell declared at [", ", ", '] has both "rowspan" \n     and "colspan" declared as "1", which makes it a single cell. It cannot be added to the collection.']);
  _templateObject32 = function _templateObject33() {
    return data;
  };
  return data;
}
function _templateObject22() {
  var data = _taggedTemplateLiteral6(["The merged cell declared at [", ", ", "] is positioned (or positioned partially) \n       outside of the table range. It was not added to the table, please fix your setup."]);
  _templateObject22 = function _templateObject23() {
    return data;
  };
  return data;
}
function _templateObject6() {
  var data = _taggedTemplateLiteral6(["The merged cell declared with {row: ", ", col: ", ", rowspan: \n    ", ", colspan: ", "} contains negative values, which is not supported. It \n    will not be added to the collection."]);
  _templateObject6 = function _templateObject8() {
    return data;
  };
  return data;
}
function _taggedTemplateLiteral6(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck77(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties74(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass74(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties74(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties74(Constructor, staticProps);
  return Constructor;
}
var MergedCellCoords = function() {
  function MergedCellCoords2(row, column, rowspan, colspan) {
    _classCallCheck77(this, MergedCellCoords2);
    this.row = row;
    this.col = column;
    this.rowspan = rowspan;
    this.colspan = colspan;
    this.removed = false;
  }
  _createClass74(MergedCellCoords2, [{
    key: "normalize",
    /**
     * Sanitize (prevent from going outside the boundaries) the merged cell.
     *
     * @param hotInstance
     */
    value: function normalize(hotInstance) {
      var totalRows = hotInstance.countRows();
      var totalColumns = hotInstance.countCols();
      if (this.row < 0) {
        this.row = 0;
      } else if (this.row > totalRows - 1) {
        this.row = totalRows - 1;
      }
      if (this.col < 0) {
        this.col = 0;
      } else if (this.col > totalColumns - 1) {
        this.col = totalColumns - 1;
      }
      if (this.row + this.rowspan > totalRows - 1) {
        this.rowspan = totalRows - this.row;
      }
      if (this.col + this.colspan > totalColumns - 1) {
        this.colspan = totalColumns - this.col;
      }
    }
    /**
     * Returns `true` if the provided coordinates are inside the merged cell.
     *
     * @param {Number} row The row index.
     * @param {Number} column The column index.
     * @return {Boolean}
     */
  }, {
    key: "includes",
    value: function includes(row, column) {
      return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;
    }
    /**
     * Returns `true` if the provided `column` property is within the column span of the merged cell.
     *
     * @param {Number} column The column index.
     * @return {Boolean}
     */
  }, {
    key: "includesHorizontally",
    value: function includesHorizontally(column) {
      return this.col <= column && this.col + this.colspan - 1 >= column;
    }
    /**
     * Returns `true` if the provided `row` property is within the row span of the merged cell.
     *
     * @param {Number} row Row index.
     * @return {Boolean}
     */
  }, {
    key: "includesVertically",
    value: function includesVertically(row) {
      return this.row <= row && this.row + this.rowspan - 1 >= row;
    }
    /**
     * Shift (and possibly resize, if needed) the merged cell.
     *
     * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.
     * @param {Number} indexOfChange Index of the preceding change.
     * @returns {Boolean} Returns `false` if the whole merged cell was removed.
     */
  }, {
    key: "shift",
    value: function shift(shiftVector, indexOfChange) {
      var shiftValue = shiftVector[0] || shiftVector[1];
      var shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;
      var span = shiftVector[0] ? "colspan" : "rowspan";
      var index2 = shiftVector[0] ? "col" : "row";
      var changeStart = Math.min(indexOfChange, shiftedIndex);
      var changeEnd = Math.max(indexOfChange, shiftedIndex);
      var mergeStart = this[index2];
      var mergeEnd = this[index2] + this[span] - 1;
      if (mergeStart >= indexOfChange) {
        this[index2] += shiftValue;
      }
      if (shiftValue > 0) {
        if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {
          this[span] += shiftValue;
        }
      } else if (shiftValue < 0) {
        if (changeStart <= mergeStart && changeEnd >= mergeEnd) {
          this.removed = true;
          return false;
        } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {
          var removedOffset = changeEnd - mergeStart + 1;
          var preRemovedOffset = Math.abs(shiftValue) - removedOffset;
          this[index2] -= preRemovedOffset + shiftValue;
          this[span] -= removedOffset;
        } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {
          this[span] += shiftValue;
        } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {
          var removedPart = mergeEnd - changeStart + 1;
          this[span] -= removedPart;
        }
      }
      return true;
    }
    /**
     * Check if the second provided merged cell is "farther" in the provided direction.
     *
     * @param {MergedCellCoords} mergedCell The merged cell to check.
     * @param {String} direction Drag direction.
     * @return {Boolean|null} `true` if the second provided merged cell is "farther".
     */
  }, {
    key: "isFarther",
    value: function isFarther(mergedCell, direction) {
      if (!mergedCell) {
        return true;
      }
      if (direction === "down") {
        return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;
      } else if (direction === "up") {
        return mergedCell.row > this.row;
      } else if (direction === "right") {
        return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;
      } else if (direction === "left") {
        return mergedCell.col > this.col;
      }
      return null;
    }
    /**
     * Get the bottom row index of the merged cell.
     *
     * @returns {Number}
     */
  }, {
    key: "getLastRow",
    value: function getLastRow() {
      return this.row + this.rowspan - 1;
    }
    /**
     * Get the rightmost column index of the merged cell.
     *
     * @returns {Number}
     */
  }, {
    key: "getLastColumn",
    value: function getLastColumn() {
      return this.col + this.colspan - 1;
    }
    /**
     * Get the range coordinates of the merged cell.
     *
     * @return {CellRange}
     */
  }, {
    key: "getRange",
    value: function getRange() {
      return new range_default(new coords_default(this.row, this.col), new coords_default(this.row, this.col), new coords_default(this.getLastRow(), this.getLastColumn()));
    }
  }], [{
    key: "NEGATIVE_VALUES_WARNING",
    value: function NEGATIVE_VALUES_WARNING(newMergedCell) {
      return toSingleLine(_templateObject6(), newMergedCell.row, newMergedCell.col, newMergedCell.rowspan, newMergedCell.colspan);
    }
    /**
     * Get a warning message for when the declared merged cell data contains values exceeding the table limits.
     *
     * @param {Object} newMergedCell Object containg information about the merged cells that was about to be added.
     * @return {String}
     */
  }, {
    key: "IS_OUT_OF_BOUNDS_WARNING",
    value: function IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {
      return toSingleLine(_templateObject22(), newMergedCell.row, newMergedCell.col);
    }
    /**
     * Get a warning message for when the declared merged cell data represents a single cell.
     *
     * @param {Object} newMergedCell Object containg information about the merged cells that was about to be added.
     * @return {String}
     */
  }, {
    key: "IS_SINGLE_CELL",
    value: function IS_SINGLE_CELL(newMergedCell) {
      return toSingleLine(_templateObject32(), newMergedCell.row, newMergedCell.col);
    }
    /**
     * Get a warning message for when the declared merged cell data contains "colspan" or "rowspan", that equals 0.
     *
     * @param {Object} newMergedCell Object containg information about the merged cells that was about to be added.
     * @return {String}
     */
  }, {
    key: "ZERO_SPAN_WARNING",
    value: function ZERO_SPAN_WARNING(newMergedCell) {
      return toSingleLine(_templateObject42(), newMergedCell.row, newMergedCell.col);
    }
    /**
     * Check whether the values provided for a merged cell contain any negative values.
     *
     * @param {Object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.
     * @return {Boolean}
     */
  }, {
    key: "containsNegativeValues",
    value: function containsNegativeValues(mergedCellInfo) {
      return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;
    }
    /**
     * Check whether the provided merged cell information object represents a single cell.
     *
     * @private
     * @param {Object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.
     * @return {Boolean}
     */
  }, {
    key: "isSingleCell",
    value: function isSingleCell(mergedCellInfo) {
      return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;
    }
    /**
     * Check whether the provided merged cell information object contains a rowspan or colspan of 0.
     *
     * @private
     * @param {Object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.
     * @return {Boolean}
     */
  }, {
    key: "containsZeroSpan",
    value: function containsZeroSpan(mergedCellInfo) {
      return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;
    }
    /**
     * Check whether the provided merged cell object is to be declared out of bounds of the table.
     *
     * @param {Object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.
     * @param {Number} rowCount Number of rows in the table.
     * @param {Number} columnCount Number of rows in the table.
     * @return {Boolean}
     */
  }, {
    key: "isOutOfBounds",
    value: function isOutOfBounds(mergeCell, rowCount, columnCount) {
      return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;
    }
  }]);
  return MergedCellCoords2;
}();
var cellCoords_default = MergedCellCoords;

// node_modules/handsontable/es/plugins/mergeCells/utils.js
function applySpanProperties(TD, mergedCellInfo, row, col) {
  if (mergedCellInfo) {
    if (mergedCellInfo.row === row && mergedCellInfo.col === col) {
      TD.setAttribute("rowspan", mergedCellInfo.rowspan.toString());
      TD.setAttribute("colspan", mergedCellInfo.colspan.toString());
    } else {
      TD.removeAttribute("rowspan");
      TD.removeAttribute("colspan");
      TD.style.display = "none";
    }
  } else {
    TD.removeAttribute("rowspan");
    TD.removeAttribute("colspan");
    TD.style.display = "";
  }
}

// node_modules/handsontable/es/plugins/mergeCells/cellsCollection.js
function _templateObject7() {
  var data = _taggedTemplateLiteral7(["The merged cell declared at [", ", ", "], overlaps with the other declared merged \n    cell. The overlapping merged cell was not added to the table, please fix your setup."]);
  _templateObject7 = function _templateObject8() {
    return data;
  };
  return data;
}
function _taggedTemplateLiteral7(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _toConsumableArray11(arr) {
  return _arrayWithoutHoles11(arr) || _iterableToArray12(arr) || _nonIterableSpread11();
}
function _nonIterableSpread11() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray12(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles11(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function _classCallCheck78(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties75(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass75(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties75(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties75(Constructor, staticProps);
  return Constructor;
}
var MergedCellsCollection = function() {
  function MergedCellsCollection2(plugin) {
    _classCallCheck78(this, MergedCellsCollection2);
    this.plugin = plugin;
    this.mergedCells = [];
    this.hot = plugin.hot;
  }
  _createClass75(MergedCellsCollection2, [{
    key: "get",
    /**
     * Get a merged cell from the container, based on the provided arguments. You can provide either the "starting coordinates"
     * of a merged cell, or any coordinates from the body of the merged cell.
     *
     * @param {Number} row Row index.
     * @param {Number} column Column index.
     * @returns {MergedCellCoords|Boolean} Returns a wanted merged cell on success and `false` on failure.
     */
    value: function get5(row, column) {
      var mergedCells = this.mergedCells;
      var result = false;
      arrayEach(mergedCells, function(mergedCell) {
        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {
          result = mergedCell;
          return false;
        }
        return true;
      });
      return result;
    }
    /**
     * Get a merged cell containing the provided range.
     *
     * @param {CellRange|Object} range The range to search merged cells for.
     * @return {MergedCellCoords|Boolean}
     */
  }, {
    key: "getByRange",
    value: function getByRange(range) {
      var mergedCells = this.mergedCells;
      var result = false;
      arrayEach(mergedCells, function(mergedCell) {
        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {
          result = mergedCell;
          return result;
        }
        return true;
      });
      return result;
    }
    /**
     * Get a merged cell contained in the provided range.
     *
     * @param {CellRange|Object} range The range to search merged cells in.
     * @param [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.
     * @return {Array|Boolean} Array of found merged cells of `false` if none were found.
     */
  }, {
    key: "getWithinRange",
    value: function getWithinRange(range) {
      var countPartials = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var mergedCells = this.mergedCells;
      var foundMergedCells = [];
      var testedRange = range;
      if (!testedRange.includesRange) {
        var from3 = new coords_default(testedRange.from.row, testedRange.from.col);
        var to3 = new coords_default(testedRange.to.row, testedRange.to.col);
        testedRange = new range_default(from3, from3, to3);
      }
      arrayEach(mergedCells, function(mergedCell) {
        var mergedCellTopLeft = new coords_default(mergedCell.row, mergedCell.col);
        var mergedCellBottomRight = new coords_default(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);
        var mergedCellRange = new range_default(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
        if (countPartials) {
          if (testedRange.overlaps(mergedCellRange)) {
            foundMergedCells.push(mergedCell);
          }
        } else if (testedRange.includesRange(mergedCellRange)) {
          foundMergedCells.push(mergedCell);
        }
      });
      return foundMergedCells.length ? foundMergedCells : false;
    }
    /**
     * Add a merged cell to the container.
     *
     * @param {Object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.
     * @return {MergedCellCoords|Boolean} Returns the new merged cell on success and `false` on failure.
     */
  }, {
    key: "add",
    value: function add5(mergedCellInfo) {
      var mergedCells = this.mergedCells;
      var row = mergedCellInfo.row;
      var column = mergedCellInfo.col;
      var rowspan = mergedCellInfo.rowspan;
      var colspan = mergedCellInfo.colspan;
      var newMergedCell = new cellCoords_default(row, column, rowspan, colspan);
      var alreadyExists = this.get(row, column);
      var isOverlapping = this.isOverlapping(newMergedCell);
      if (!alreadyExists && !isOverlapping) {
        if (this.hot) {
          newMergedCell.normalize(this.hot);
        }
        mergedCells.push(newMergedCell);
        return newMergedCell;
      }
      warn2(MergedCellsCollection2.IS_OVERLAPPING_WARNING(newMergedCell));
      return false;
    }
    /**
     * Remove a merged cell from the container. You can provide either the "starting coordinates"
     * of a merged cell, or any coordinates from the body of the merged cell.
     *
     * @param {Number} row Row index.
     * @param {Number} column Column index.
     * @return {MergedCellCoords|Boolean} Returns the removed merged cell on success and `false` on failure.
     */
  }, {
    key: "remove",
    value: function remove(row, column) {
      var mergedCells = this.mergedCells;
      var wantedCollection = this.get(row, column);
      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : null;
      if (wantedCollection && wantedCollectionIndex !== false) {
        mergedCells.splice(wantedCollectionIndex, 1);
        return wantedCollection;
      }
      return false;
    }
    /**
     * Clear all the merged cells.
     */
  }, {
    key: "clear",
    value: function clear() {
      var _this = this;
      var mergedCells = this.mergedCells;
      var mergedCellParentsToClear = [];
      var hiddenCollectionElements = [];
      arrayEach(mergedCells, function(mergedCell) {
        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);
        if (TD) {
          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);
        }
      });
      this.mergedCells.length = 0;
      arrayEach(mergedCellParentsToClear, function(mergedCell, i) {
        rangeEach(0, mergedCell.rowspan - 1, function(j) {
          rangeEach(0, mergedCell.colspan - 1, function(k) {
            if (k !== 0 || j !== 0) {
              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);
              if (TD) {
                hiddenCollectionElements.push([TD, null, null, null]);
              }
            }
          });
        });
        mergedCellParentsToClear[i][1] = null;
      });
      arrayEach(mergedCellParentsToClear, function(mergedCellParents) {
        applySpanProperties.apply(void 0, _toConsumableArray11(mergedCellParents));
      });
      arrayEach(hiddenCollectionElements, function(hiddenCollectionElement) {
        applySpanProperties.apply(void 0, _toConsumableArray11(hiddenCollectionElement));
      });
    }
    /**
     * Check if the provided merged cell overlaps with the others in the container.
     *
     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.
     * @return {Boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.
     */
  }, {
    key: "isOverlapping",
    value: function isOverlapping(mergedCell) {
      var mergedCellRange = new range_default(null, new coords_default(mergedCell.row, mergedCell.col), new coords_default(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));
      var result = false;
      arrayEach(this.mergedCells, function(col) {
        var currentRange = new range_default(null, new coords_default(col.row, col.col), new coords_default(col.row + col.rowspan - 1, col.col + col.colspan - 1));
        if (currentRange.overlaps(mergedCellRange)) {
          result = true;
          return false;
        }
        return true;
      });
      return result;
    }
    /**
     * Check whether the provided row/col coordinates direct to a merged parent.
     *
     * @param {Number} row Row index.
     * @param {Number} column Column index.
     * @return {Boolean}
     */
  }, {
    key: "isMergedParent",
    value: function isMergedParent(row, column) {
      var mergedCells = this.mergedCells;
      var result = false;
      arrayEach(mergedCells, function(mergedCell) {
        if (mergedCell.row === row && mergedCell.col === column) {
          result = true;
          return false;
        }
        return true;
      });
      return result;
    }
    /**
     * Shift the merged cell in the direction and by an offset defined in the arguments.
     *
     * @param {String} direction `right`, `left`, `up` or `down`.
     * @param {Number} index Index where the change, which caused the shifting took place.
     * @param {Number} count Number of rows/columns added/removed in the preceding action.
     */
  }, {
    key: "shiftCollections",
    value: function shiftCollections(direction, index2, count) {
      var _this2 = this;
      var shiftVector = [0, 0];
      switch (direction) {
        case "right":
          shiftVector[0] += count;
          break;
        case "left":
          shiftVector[0] -= count;
          break;
        case "down":
          shiftVector[1] += count;
          break;
        case "up":
          shiftVector[1] -= count;
          break;
        default:
      }
      arrayEach(this.mergedCells, function(currentMerge) {
        currentMerge.shift(shiftVector, index2);
      });
      rangeEachReverse(this.mergedCells.length - 1, 0, function(i) {
        var currentMerge = _this2.mergedCells[i];
        if (currentMerge && currentMerge.removed) {
          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);
        }
      });
    }
  }], [{
    key: "IS_OVERLAPPING_WARNING",
    value: function IS_OVERLAPPING_WARNING(newMergedCell) {
      return toSingleLine(_templateObject7(), newMergedCell.row, newMergedCell.col);
    }
  }]);
  return MergedCellsCollection2;
}();
var cellsCollection_default = MergedCellsCollection;

// node_modules/handsontable/es/plugins/mergeCells/calculations/autofill.js
function _slicedToArray19(arr, i) {
  return _arrayWithHoles20(arr) || _iterableToArrayLimit19(arr, i) || _nonIterableRest20();
}
function _nonIterableRest20() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit19(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles20(arr) {
  if (Array.isArray(arr)) return arr;
}
function _classCallCheck79(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties76(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass76(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties76(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties76(Constructor, staticProps);
  return Constructor;
}
var AutofillCalculations = function() {
  function AutofillCalculations2(plugin) {
    _classCallCheck79(this, AutofillCalculations2);
    this.plugin = plugin;
    this.mergedCellsCollection = this.plugin.mergedCellsCollection;
    this.currentFillData = null;
  }
  _createClass76(AutofillCalculations2, [{
    key: "correctSelectionAreaSize",
    value: function correctSelectionAreaSize(selectionArea) {
      if (selectionArea[0] === selectionArea[2] && selectionArea[1] === selectionArea[3]) {
        var mergedCell = this.mergedCellsCollection.get(selectionArea[0], selectionArea[1]);
        if (mergedCell) {
          selectionArea[2] = selectionArea[0] + mergedCell.rowspan - 1;
          selectionArea[3] = selectionArea[1] + mergedCell.colspan - 1;
        }
      }
    }
    /**
     * Get the direction of the autofill process.
     *
     * @param {Array} selectionArea The selection area.
     * @param {Array} finalArea The final area (base + drag).
     * @return {String} `up`, `down`, `left` or `right`.
     */
  }, {
    key: "getDirection",
    value: function getDirection(selectionArea, finalArea) {
      var direction = null;
      if (finalArea[0] === selectionArea[0] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
        direction = "down";
      } else if (finalArea[2] === selectionArea[2] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
        direction = "up";
      } else if (finalArea[1] === selectionArea[1] && finalArea[2] === selectionArea[2]) {
        direction = "right";
      } else {
        direction = "left";
      }
      return direction;
    }
    /**
     * Snap the drag area to the farthest merged cell, so it won't clip any of the merged cells.
     *
     * @param {Array} baseArea The base selected area.
     * @param {Array} dragArea The drag area.
     * @param {String} dragDirection The autofill drag direction.
     * @param {Array} foundMergedCells MergeCellCoords found in the base selection area.
     * @return {Array} The new drag area
     */
  }, {
    key: "snapDragArea",
    value: function snapDragArea(baseArea, dragArea, dragDirection, foundMergedCells) {
      var newDragArea = dragArea.slice(0);
      var fillSize = this.getAutofillSize(baseArea, dragArea, dragDirection);
      var _baseArea = _slicedToArray19(baseArea, 4), baseAreaStartRow = _baseArea[0], baseAreaStartColumn = _baseArea[1], baseAreaEndRow = _baseArea[2], baseAreaEndColumn = _baseArea[3];
      var verticalDirection = ["up", "down"].indexOf(dragDirection) > -1;
      var fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
      var fulls = Math.floor(fillSize / fullCycle) * fullCycle;
      var partials = fillSize - fulls;
      var farthestCollection = this.getFarthestCollection(baseArea, dragArea, dragDirection, foundMergedCells);
      if (farthestCollection) {
        if (dragDirection === "down") {
          var fill = farthestCollection.row + farthestCollection.rowspan - baseAreaStartRow - partials;
          var newLimit = newDragArea[2] + fill;
          if (newLimit >= this.plugin.hot.countRows()) {
            newDragArea[2] -= partials;
          } else {
            newDragArea[2] += partials ? fill : 0;
          }
        } else if (dragDirection === "right") {
          var _fill = farthestCollection.col + farthestCollection.colspan - baseAreaStartColumn - partials;
          var _newLimit = newDragArea[3] + _fill;
          if (_newLimit >= this.plugin.hot.countCols()) {
            newDragArea[3] -= partials;
          } else {
            newDragArea[3] += partials ? _fill : 0;
          }
        } else if (dragDirection === "up") {
          var _fill2 = baseAreaEndRow - partials - farthestCollection.row + 1;
          var _newLimit2 = newDragArea[0] + _fill2;
          if (_newLimit2 < 0) {
            newDragArea[0] += partials;
          } else {
            newDragArea[0] -= partials ? _fill2 : 0;
          }
        } else if (dragDirection === "left") {
          var _fill3 = baseAreaEndColumn - partials - farthestCollection.col + 1;
          var _newLimit3 = newDragArea[1] + _fill3;
          if (_newLimit3 < 0) {
            newDragArea[1] += partials;
          } else {
            newDragArea[1] -= partials ? _fill3 : 0;
          }
        }
      }
      this.updateCurrentFillCache({
        baseArea,
        dragDirection,
        foundMergedCells,
        fillSize,
        dragArea: newDragArea,
        cycleLength: fullCycle
      });
      return newDragArea;
    }
    /**
     * Update the current fill cache with the provided object.
     *
     * @private
     * @param {Object} updateObject
     */
  }, {
    key: "updateCurrentFillCache",
    value: function updateCurrentFillCache(updateObject) {
      if (!this.currentFillData) {
        this.currentFillData = {};
      }
      extend(this.currentFillData, updateObject);
    }
    /**
     * Get the "length" of the drag area.
     *
     * @private
     * @param {Array} baseArea The base selection area.
     * @param {Array} dragArea The drag area (containing the base area).
     * @param {String} direction The drag direction.
     * @return {Number|null} The "length" (height or width, depending on the direction) of the drag.
     */
  }, {
    key: "getAutofillSize",
    value: function getAutofillSize(baseArea, dragArea, direction) {
      var _baseArea2 = _slicedToArray19(baseArea, 4), baseAreaStartRow = _baseArea2[0], baseAreaStartColumn = _baseArea2[1], baseAreaEndRow = _baseArea2[2], baseAreaEndColumn = _baseArea2[3];
      var _dragArea = _slicedToArray19(dragArea, 4), dragAreaStartRow = _dragArea[0], dragAreaStartColumn = _dragArea[1], dragAreaEndRow = _dragArea[2], dragAreaEndColumn = _dragArea[3];
      switch (direction) {
        case "up":
          return baseAreaStartRow - dragAreaStartRow;
        case "down":
          return dragAreaEndRow - baseAreaEndRow;
        case "left":
          return baseAreaStartColumn - dragAreaStartColumn;
        case "right":
          return dragAreaEndColumn - baseAreaEndColumn;
        default:
          return null;
      }
    }
    /**
     * Trim the default drag area (containing the selection area) to the drag-only area.
     *
     * @private
     * @param {Array} baseArea The base selection area.
     * @param {Array} dragArea The base selection area extended by the drag area.
     * @param {String} direction Drag direction.
     * @return {Array|null} Array representing the drag area coordinates.
     */
  }, {
    key: "getDragArea",
    value: function getDragArea(baseArea, dragArea, direction) {
      var _baseArea3 = _slicedToArray19(baseArea, 4), baseAreaStartRow = _baseArea3[0], baseAreaStartColumn = _baseArea3[1], baseAreaEndRow = _baseArea3[2], baseAreaEndColumn = _baseArea3[3];
      var _dragArea2 = _slicedToArray19(dragArea, 4), dragAreaStartRow = _dragArea2[0], dragAreaStartColumn = _dragArea2[1], dragAreaEndRow = _dragArea2[2], dragAreaEndColumn = _dragArea2[3];
      switch (direction) {
        case "up":
          return [dragAreaStartRow, dragAreaStartColumn, baseAreaStartRow - 1, baseAreaEndColumn];
        case "down":
          return [baseAreaEndRow + 1, baseAreaStartColumn, dragAreaEndRow, baseAreaEndColumn];
        case "left":
          return [dragAreaStartRow, dragAreaStartColumn, baseAreaEndRow, baseAreaStartColumn - 1];
        case "right":
          return [baseAreaStartRow, baseAreaEndColumn + 1, dragAreaEndRow, dragAreaEndColumn];
        default:
          return null;
      }
    }
    /**
     * Get the to-be-farthest merged cell in the newly filled area.
     *
     * @private
     * @param {Array} baseArea The base selection area.
     * @param {Array} dragArea The drag area (containing the base area).
     * @param {String} direction The drag direction.
     * @param {Array} mergedCellArray Array of the merged cells found in the base area.
     * @return {MergedCellCoords|null}
     */
  }, {
    key: "getFarthestCollection",
    value: function getFarthestCollection(baseArea, dragArea, direction, mergedCellArray) {
      var _baseArea4 = _slicedToArray19(baseArea, 4), baseAreaStartRow = _baseArea4[0], baseAreaStartColumn = _baseArea4[1], baseAreaEndRow = _baseArea4[2], baseAreaEndColumn = _baseArea4[3];
      var verticalDirection = ["up", "down"].indexOf(direction) > -1;
      var baseEnd = verticalDirection ? baseAreaEndRow : baseAreaEndColumn;
      var baseStart = verticalDirection ? baseAreaStartRow : baseAreaStartColumn;
      var fillSize = this.getAutofillSize(baseArea, dragArea, direction);
      var fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
      var fulls = Math.floor(fillSize / fullCycle) * fullCycle;
      var partials = fillSize - fulls;
      var inclusionFunctionName = null;
      var farthestCollection = null;
      var endOfDragRecreationIndex = null;
      switch (direction) {
        case "up":
          inclusionFunctionName = "includesVertically";
          endOfDragRecreationIndex = baseEnd - partials + 1;
          break;
        case "left":
          inclusionFunctionName = "includesHorizontally";
          endOfDragRecreationIndex = baseEnd - partials + 1;
          break;
        case "down":
          inclusionFunctionName = "includesVertically";
          endOfDragRecreationIndex = baseStart + partials - 1;
          break;
        case "right":
          inclusionFunctionName = "includesHorizontally";
          endOfDragRecreationIndex = baseStart + partials - 1;
          break;
        default:
      }
      arrayEach(mergedCellArray, function(currentCollection) {
        if (currentCollection[inclusionFunctionName](endOfDragRecreationIndex) && currentCollection.isFarther(farthestCollection, direction)) {
          farthestCollection = currentCollection;
        }
      });
      return farthestCollection;
    }
    /**
     * Recreate the merged cells after the autofill process.
     *
     * @param {Array} changes Changes made.
     */
  }, {
    key: "recreateAfterDataPopulation",
    value: function recreateAfterDataPopulation(changes) {
      if (!this.currentFillData) {
        return;
      }
      var fillRange = this.getRangeFromChanges(changes);
      var foundMergedCells = this.currentFillData.foundMergedCells;
      var dragDirection = this.currentFillData.dragDirection;
      var inBounds = function inBounds2(current2, offset4) {
        switch (dragDirection) {
          case "up":
            return current2.row - offset4 >= fillRange.from.row;
          case "down":
            return current2.row + current2.rowspan - 1 + offset4 <= fillRange.to.row;
          case "left":
            return current2.col - offset4 >= fillRange.from.column;
          case "right":
            return current2.col + current2.colspan - 1 + offset4 <= fillRange.to.column;
          default:
            return null;
        }
      };
      var fillOffset = 0;
      var current = null;
      var multiplier = 1;
      do {
        for (var j = 0; j < foundMergedCells.length; j += 1) {
          current = foundMergedCells[j];
          fillOffset = multiplier * this.currentFillData.cycleLength;
          if (inBounds(current, fillOffset)) {
            switch (dragDirection) {
              case "up":
                this.plugin.mergedCellsCollection.add({
                  row: current.row - fillOffset,
                  rowspan: current.rowspan,
                  col: current.col,
                  colspan: current.colspan
                });
                break;
              case "down":
                this.plugin.mergedCellsCollection.add({
                  row: current.row + fillOffset,
                  rowspan: current.rowspan,
                  col: current.col,
                  colspan: current.colspan
                });
                break;
              case "left":
                this.plugin.mergedCellsCollection.add({
                  row: current.row,
                  rowspan: current.rowspan,
                  col: current.col - fillOffset,
                  colspan: current.colspan
                });
                break;
              case "right":
                this.plugin.mergedCellsCollection.add({
                  row: current.row,
                  rowspan: current.rowspan,
                  col: current.col + fillOffset,
                  colspan: current.colspan
                });
                break;
              default:
            }
          }
          if (j === foundMergedCells.length - 1) {
            multiplier += 1;
          }
        }
      } while (inBounds(current, fillOffset));
      this.currentFillData = null;
      this.plugin.hot.render();
    }
    /**
     * Get the drag range from the changes made.
     *
     * @private
     * @param {Array} changes The changes made.
     * @returns {Object} Object with `from` and `to` properties, both containing `row` and `column` keys.
     */
  }, {
    key: "getRangeFromChanges",
    value: function getRangeFromChanges(changes) {
      var _this = this;
      var rows = {
        min: null,
        max: null
      };
      var columns = {
        min: null,
        max: null
      };
      arrayEach(changes, function(change) {
        var rowIndex = change[0];
        var columnIndex = _this.plugin.hot.propToCol(change[1]);
        if (rows.min === null || rowIndex < rows.min) {
          rows.min = rowIndex;
        }
        if (rows.max === null || rowIndex > rows.max) {
          rows.max = rowIndex;
        }
        if (columns.min === null || columnIndex < columns.min) {
          columns.min = columnIndex;
        }
        if (columns.max === null || columnIndex > columns.max) {
          columns.max = columnIndex;
        }
      });
      return {
        from: {
          row: rows.min,
          column: columns.min
        },
        to: {
          row: rows.max,
          column: columns.max
        }
      };
    }
    /**
     * Check if the drag area contains any merged cells.
     *
     * @param {Array} baseArea The base selection area.
     * @param {Array} fullArea The base area extended by the drag area.
     * @param {String} direction Drag direction.
     * @returns {Boolean}
     */
  }, {
    key: "dragAreaOverlapsCollections",
    value: function dragAreaOverlapsCollections(baseArea, fullArea, direction) {
      var dragArea = this.getDragArea(baseArea, fullArea, direction);
      var _dragArea3 = _slicedToArray19(dragArea, 4), dragAreaStartRow = _dragArea3[0], dragAreaStartColumn = _dragArea3[1], dragAreaEndRow = _dragArea3[2], dragAreaEndColumn = _dragArea3[3];
      var topLeft = new coords_default(dragAreaStartRow, dragAreaStartColumn);
      var bottomRight = new coords_default(dragAreaEndRow, dragAreaEndColumn);
      var dragRange = new range_default(topLeft, topLeft, bottomRight);
      return !!this.mergedCellsCollection.getWithinRange(dragRange, true);
    }
  }]);
  return AutofillCalculations2;
}();
var autofill_default2 = AutofillCalculations;

// node_modules/handsontable/es/plugins/mergeCells/calculations/selection.js
function _slicedToArray20(arr, i) {
  return _arrayWithHoles21(arr) || _iterableToArrayLimit20(arr, i) || _nonIterableRest21();
}
function _nonIterableRest21() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit20(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles21(arr) {
  if (Array.isArray(arr)) return arr;
}
function _classCallCheck80(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties77(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass77(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties77(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties77(Constructor, staticProps);
  return Constructor;
}
var SelectionCalculations = function() {
  function SelectionCalculations2(plugin) {
    _classCallCheck80(this, SelectionCalculations2);
    this.plugin = plugin;
    this.fullySelectedMergedCellClassName = "fullySelectedMergedCell";
  }
  _createClass77(SelectionCalculations2, [{
    key: "snapDelta",
    value: function snapDelta(delta, selectionRange, mergedCell) {
      var cellCoords = selectionRange.to;
      var newRow = cellCoords.row + delta.row;
      var newColumn = cellCoords.col + delta.col;
      if (delta.row) {
        this.jumpOverMergedCell(delta, mergedCell, newRow);
      } else if (delta.col) {
        this.jumpOverMergedCell(delta, mergedCell, newColumn);
      }
    }
    /**
     * "Jump" over the merged cell (compensate for the indexes within the merged cell to get past it)
     *
     * @private
     * @param {Object} delta The delta object.
     * @param {MergedCellCoords} mergedCell The merge cell object.
     * @param {Number} newIndex New row/column index, created with the delta.
     */
  }, {
    key: "jumpOverMergedCell",
    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {
      var flatDelta = delta.row || delta.col;
      var includesIndex = null;
      var firstIndex = null;
      var lastIndex = null;
      if (delta.row) {
        includesIndex = mergedCell.includesVertically(newIndex);
        firstIndex = mergedCell.row;
        lastIndex = mergedCell.getLastRow();
      } else if (delta.col) {
        includesIndex = mergedCell.includesHorizontally(newIndex);
        firstIndex = mergedCell.col;
        lastIndex = mergedCell.getLastColumn();
      }
      if (flatDelta === 0) {
        return;
      } else if (flatDelta > 0) {
        if (includesIndex && newIndex !== firstIndex) {
          flatDelta += lastIndex - newIndex + 1;
        }
      } else if (includesIndex && newIndex !== lastIndex) {
        flatDelta -= newIndex - firstIndex + 1;
      }
      if (delta.row) {
        delta.row = flatDelta;
      } else if (delta.col) {
        delta.col = flatDelta;
      }
    }
    /**
     * Get a selection range with `to` property incremented by the provided delta.
     *
     * @param {CellRange} oldSelectionRange The base selection range.
     * @param {Object} delta The delta object with `row` and `col` properties.
     * @returns {CellRange} A new `CellRange` object.
     */
  }, {
    key: "getUpdatedSelectionRange",
    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {
      return new range_default(oldSelectionRange.highlight, oldSelectionRange.from, new coords_default(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));
    }
    /**
     * Generate an additional class name for the entirely-selected merged cells.
     *
     * @param {Number} currentRow Row index of the currently processed cell.
     * @param {Number} currentColumn Column index of the currently cell.
     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.
     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.
     */
  }, {
    key: "getSelectedMergedCellClassName",
    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {
      var _cornersOfSelection = _slicedToArray20(cornersOfSelection, 4), startRow = _cornersOfSelection[0], startColumn = _cornersOfSelection[1], endRow = _cornersOfSelection[2], endColumn = _cornersOfSelection[3];
      if (layerLevel === void 0) {
        return;
      }
      if (currentRow >= startRow && currentRow <= endRow && currentColumn >= startColumn && currentColumn <= endColumn) {
        var isMergedCellParent = this.plugin.mergedCellsCollection.isMergedParent(currentRow, currentColumn);
        if (!isMergedCellParent) {
          return;
        }
        var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);
        if (!mergedCell) {
          return;
        }
        if (mergedCell.row + mergedCell.rowspan - 1 <= endRow && mergedCell.col + mergedCell.colspan - 1 <= endColumn) {
          return "".concat(this.fullySelectedMergedCellClassName, "-").concat(layerLevel);
        } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {
          return "".concat(this.fullySelectedMergedCellClassName, "-multiple");
        }
      }
    }
    /**
     * Check if the provided merged cell is fully selected (by one or many layers of selection)
     *
     * @param {MergedCellCoords} mergedCell The merged cell to be processed.
     * @param {CellRange[]} selectionRangesArray Array of selection ranges.
     * @returns {Boolean}
     */
  }, {
    key: "isMergeCellFullySelected",
    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {
      var mergedCellIndividualCoords = [];
      if (!selectionRangesArray || !mergedCell) {
        return false;
      }
      for (var r = 0; r < mergedCell.rowspan; r += 1) {
        for (var c = 0; c < mergedCell.colspan; c += 1) {
          mergedCellIndividualCoords.push(new coords_default(mergedCell.row + r, mergedCell.col + c));
        }
      }
      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {
        var insideSelections = [];
        for (var s = 0; s < selectionRangesArray.length; s += 1) {
          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);
        }
        if (!insideSelections.includes(true)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Generate an array of the entirely-selected merged cells' class names.
     *
     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
     */
  }, {
    key: "getSelectedMergedCellClassNameToRemove",
    value: function getSelectedMergedCellClassNameToRemove() {
      var classNames = [];
      for (var i = 0; i <= 7; i += 1) {
        classNames.push("".concat(this.fullySelectedMergedCellClassName, "-").concat(i));
      }
      classNames.push("".concat(this.fullySelectedMergedCellClassName, "-multiple"));
      return classNames;
    }
  }]);
  return SelectionCalculations2;
}();
var selection_default3 = SelectionCalculations;

// node_modules/handsontable/es/plugins/mergeCells/contextMenuItem/toggleMerge.js
function toggleMergeItem(plugin) {
  return {
    key: "mergeCells",
    name: function name() {
      var sel = this.getSelectedLast();
      if (sel) {
        var info = plugin.mergedCellsCollection.get(sel[0], sel[1]);
        if (info.row === sel[0] && info.col === sel[1] && info.row + info.rowspan - 1 === sel[2] && info.col + info.colspan - 1 === sel[3]) {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNMERGE_CELLS);
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_MERGE_CELLS);
    },
    callback: function callback() {
      plugin.toggleMergeOnSelection();
    },
    disabled: function disabled() {
      var sel = this.getSelectedLast();
      if (!sel) {
        return true;
      }
      var isSingleCell = cellCoords_default.isSingleCell({
        row: sel[0],
        col: sel[1],
        rowspan: sel[2] - sel[0] + 1,
        colspan: sel[3] - sel[1] + 1
      });
      return isSingleCell || this.selection.isSelectedByCorner();
    },
    hidden: false
  };
}

// node_modules/handsontable/es/plugins/mergeCells/mergeCells.js
function _typeof43(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof43 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof43 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof43(obj);
}
function _slicedToArray21(arr, i) {
  return _arrayWithHoles22(arr) || _iterableToArrayLimit21(arr, i) || _nonIterableRest22();
}
function _nonIterableRest22() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit21(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles22(arr) {
  if (Array.isArray(arr)) return arr;
}
function _toConsumableArray12(arr) {
  return _arrayWithoutHoles12(arr) || _iterableToArray13(arr) || _nonIterableSpread12();
}
function _nonIterableSpread12() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray13(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles12(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function _classCallCheck81(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties78(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass78(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties78(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties78(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn31(self2, call) {
  if (call && (_typeof43(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized31(self2);
}
function _get23(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get23 = Reflect.get;
  } else {
    _get23 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase23(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get23(target, property, receiver || target);
}
function _superPropBase23(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf31(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf31(o) {
  _getPrototypeOf31 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf31(o);
}
function _inherits31(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf31(subClass, superClass);
}
function _setPrototypeOf31(o, p) {
  _setPrototypeOf31 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf31(o, p);
}
function _assertThisInitialized31(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
pluginHooks_default.getSingleton().register("beforeMergeCells");
pluginHooks_default.getSingleton().register("afterMergeCells");
pluginHooks_default.getSingleton().register("beforeUnmergeCells");
pluginHooks_default.getSingleton().register("afterUnmergeCells");
var privatePool11 = /* @__PURE__ */ new WeakMap();
var MergeCells = function(_BasePlugin) {
  _inherits31(MergeCells2, _BasePlugin);
  function MergeCells2(hotInstance) {
    var _this;
    _classCallCheck81(this, MergeCells2);
    _this = _possibleConstructorReturn31(this, _getPrototypeOf31(MergeCells2).call(this, hotInstance));
    privatePool11.set(_assertThisInitialized31(_assertThisInitialized31(_this)), {
      lastDesiredCoords: null
    });
    _this.mergedCellsCollection = null;
    _this.autofillCalculations = null;
    _this.selectionCalculations = null;
    return _this;
  }
  _createClass78(MergeCells2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return !!this.hot.getSettings().mergeCells;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.mergedCellsCollection = new cellsCollection_default(this);
      this.autofillCalculations = new autofill_default2(this);
      this.selectionCalculations = new selection_default3(this);
      this.addHook("afterInit", function() {
        return _this2.onAfterInit.apply(_this2, arguments);
      });
      this.addHook("beforeKeyDown", function() {
        return _this2.onBeforeKeyDown.apply(_this2, arguments);
      });
      this.addHook("modifyTransformStart", function() {
        return _this2.onModifyTransformStart.apply(_this2, arguments);
      });
      this.addHook("afterModifyTransformStart", function() {
        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);
      });
      this.addHook("modifyTransformEnd", function() {
        return _this2.onModifyTransformEnd.apply(_this2, arguments);
      });
      this.addHook("modifyGetCellCoords", function() {
        return _this2.onModifyGetCellCoords.apply(_this2, arguments);
      });
      this.addHook("beforeSetRangeEnd", function() {
        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);
      });
      this.addHook("afterIsMultipleSelection", function() {
        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);
      });
      this.addHook("afterRenderer", function() {
        return _this2.onAfterRenderer.apply(_this2, arguments);
      });
      this.addHook("afterContextMenuDefaultOptions", function() {
        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);
      });
      this.addHook("afterGetCellMeta", function() {
        return _this2.onAfterGetCellMeta.apply(_this2, arguments);
      });
      this.addHook("afterViewportRowCalculatorOverride", function() {
        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);
      });
      this.addHook("afterViewportColumnCalculatorOverride", function() {
        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);
      });
      this.addHook("modifyAutofillRange", function() {
        return _this2.onModifyAutofillRange.apply(_this2, arguments);
      });
      this.addHook("afterCreateCol", function() {
        return _this2.onAfterCreateCol.apply(_this2, arguments);
      });
      this.addHook("afterRemoveCol", function() {
        return _this2.onAfterRemoveCol.apply(_this2, arguments);
      });
      this.addHook("afterCreateRow", function() {
        return _this2.onAfterCreateRow.apply(_this2, arguments);
      });
      this.addHook("afterRemoveRow", function() {
        return _this2.onAfterRemoveRow.apply(_this2, arguments);
      });
      this.addHook("afterChange", function() {
        return _this2.onAfterChange.apply(_this2, arguments);
      });
      this.addHook("beforeDrawBorders", function() {
        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);
      });
      this.addHook("afterDrawSelection", function() {
        return _this2.onAfterDrawSelection.apply(_this2, arguments);
      });
      this.addHook("beforeRemoveCellClassNames", function() {
        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);
      });
      _get23(_getPrototypeOf31(MergeCells2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      this.clearCollections();
      this.hot.render();
      _get23(_getPrototypeOf31(MergeCells2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      var settings = this.hot.getSettings().mergeCells;
      this.disablePlugin();
      this.enablePlugin();
      this.generateFromSettings(settings);
      _get23(_getPrototypeOf31(MergeCells2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Validates a single setting object, represented by a single merged cell information object.
     *
     * @private
     * @param {Object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.
     * @return {Boolean}
     */
  }, {
    key: "validateSetting",
    value: function validateSetting(setting) {
      var valid = true;
      if (!setting) {
        return false;
      }
      if (cellCoords_default.containsNegativeValues(setting)) {
        warn2(cellCoords_default.NEGATIVE_VALUES_WARNING(setting));
        valid = false;
      } else if (cellCoords_default.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {
        warn2(cellCoords_default.IS_OUT_OF_BOUNDS_WARNING(setting));
        valid = false;
      } else if (cellCoords_default.isSingleCell(setting)) {
        warn2(cellCoords_default.IS_SINGLE_CELL(setting));
        valid = false;
      } else if (cellCoords_default.containsZeroSpan(setting)) {
        warn2(cellCoords_default.ZERO_SPAN_WARNING(setting));
        valid = false;
      }
      return valid;
    }
    /**
     * Generates the merged cells from the settings provided to the plugin.
     *
     * @private
     * @param {Array|Boolean} settings The settings provided to the plugin.
     */
  }, {
    key: "generateFromSettings",
    value: function generateFromSettings(settings) {
      var _this3 = this;
      if (Array.isArray(settings)) {
        var _this$hot;
        var populationArgumentsList = [];
        arrayEach(settings, function(setting) {
          if (!_this3.validateSetting(setting)) {
            return;
          }
          var highlight = new coords_default(setting.row, setting.col);
          var rangeEnd = new coords_default(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);
          var mergeRange = new range_default(highlight, highlight, rangeEnd);
          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));
        });
        populationArgumentsList = populationArgumentsList.filter(function(value) {
          return value !== true;
        });
        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);
        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray12(bulkPopulationData));
      }
    }
    /**
     * Generates a bulk set of all the data to be populated to fill the data "under" the added merged cells.
     *
     * @private
     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.
     * @return {Array} Array in a form of `[row, column, dataOfAllCollections]`.
     */
  }, {
    key: "getBulkCollectionData",
    value: function getBulkCollectionData(populationArgumentsList) {
      var _this$hot2;
      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);
      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray12(populationDataRange));
      var newDataAtRange = dataAtRange.splice(0);
      arrayEach(populationArgumentsList, function(mergedCellArguments) {
        var _mergedCellArguments = _slicedToArray21(mergedCellArguments, 3), mergedCellRowIndex = _mergedCellArguments[0], mergedCellColumnIndex = _mergedCellArguments[1], mergedCellData = _mergedCellArguments[2];
        arrayEach(mergedCellData, function(mergedCellRow, rowIndex) {
          arrayEach(mergedCellRow, function(mergedCellElement, columnIndex) {
            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement;
          });
        });
      });
      return [populationDataRange[0], populationDataRange[1], newDataAtRange];
    }
    /**
     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection])
     *
     * @private
     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.
     * @return {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex])
     */
  }, {
    key: "getBulkCollectionDataRange",
    value: function getBulkCollectionDataRange(populationArgumentsList) {
      var start = [0, 0];
      var end = [0, 0];
      var mergedCellRow = null;
      var mergedCellColumn = null;
      var mergedCellData = null;
      arrayEach(populationArgumentsList, function(mergedCellArguments) {
        mergedCellRow = mergedCellArguments[0];
        mergedCellColumn = mergedCellArguments[1];
        mergedCellData = mergedCellArguments[2];
        start[0] = Math.min(mergedCellRow, start[0]);
        start[1] = Math.min(mergedCellColumn, start[1]);
        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);
        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);
      });
      return [].concat(start, end);
    }
    /**
     * Clears the merged cells from the merged cell container.
     */
  }, {
    key: "clearCollections",
    value: function clearCollections() {
      this.mergedCellsCollection.clear();
    }
    /**
     * Returns `true` if a range is mergeable.
     *
     * @private
     * @param {Object} newMergedCellInfo Merged cell information object to test.
     * @param {Boolean} [auto=false] `true` if triggered at initialization.
     * @returns {Boolean}
     */
  }, {
    key: "canMergeRange",
    value: function canMergeRange(newMergedCellInfo) {
      var auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return auto ? true : this.validateSetting(newMergedCellInfo);
    }
    /**
     * Merge or unmerge, based on last selected range.
     *
     * @private
     */
  }, {
    key: "toggleMergeOnSelection",
    value: function toggleMergeOnSelection() {
      var currentRange = this.hot.getSelectedRangeLast();
      if (!currentRange) {
        return;
      }
      currentRange.setDirection("NW-SE");
      var from3 = currentRange.from, to3 = currentRange.to;
      this.toggleMerge(currentRange);
      this.hot.selectCell(from3.row, from3.col, to3.row, to3.col, false);
    }
    /**
     * Merges the selection provided as a cell range.
     *
     * @param {CellRange} [cellRange] Selection cell range.
     */
  }, {
    key: "mergeSelection",
    value: function mergeSelection() {
      var cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
      if (!cellRange) {
        return;
      }
      cellRange.setDirection("NW-SE");
      var from3 = cellRange.from, to3 = cellRange.to;
      this.unmergeRange(cellRange, true);
      this.mergeRange(cellRange);
      this.hot.selectCell(from3.row, from3.col, to3.row, to3.col, false);
    }
    /**
     * Unmerges the selection provided as a cell range.
     *
     * @param {CellRange} [cellRange] Selection cell range.
     */
  }, {
    key: "unmergeSelection",
    value: function unmergeSelection() {
      var cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
      if (!cellRange) {
        return;
      }
      var from3 = cellRange.from, to3 = cellRange.to;
      this.unmergeRange(cellRange, true);
      this.hot.selectCell(from3.row, from3.col, to3.row, to3.col, false);
    }
    /**
     * Merges cells in the provided cell range.
     *
     * @private
     * @param {CellRange} cellRange Cell range to merge.
     * @param {Boolean} [auto=false] `true` if is called automatically, e.g. at initialization.
     * @param {Boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.
     * @returns {Array|Boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.
     * @fires Hooks#beforeMergeCells
     * @fires Hooks#afterMergeCells
     */
  }, {
    key: "mergeRange",
    value: function mergeRange(cellRange) {
      var _this4 = this;
      var auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var preventPopulation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var topLeft = cellRange.getTopLeftCorner();
      var bottomRight = cellRange.getBottomRightCorner();
      var mergeParent = {
        row: topLeft.row,
        col: topLeft.col,
        rowspan: bottomRight.row - topLeft.row + 1,
        colspan: bottomRight.col - topLeft.col + 1
      };
      var clearedData = [];
      var populationInfo = null;
      if (!this.canMergeRange(mergeParent, auto)) {
        return false;
      }
      this.hot.runHooks("beforeMergeCells", cellRange, auto);
      rangeEach(0, mergeParent.rowspan - 1, function(i) {
        rangeEach(0, mergeParent.colspan - 1, function(j) {
          var clearedValue = null;
          if (!clearedData[i]) {
            clearedData[i] = [];
          }
          if (i === 0 && j === 0) {
            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);
          } else {
            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, "hidden", true);
          }
          clearedData[i][j] = clearedValue;
        });
      });
      this.hot.setCellMeta(mergeParent.row, mergeParent.col, "spanned", true);
      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);
      if (mergedCellAdded) {
        if (preventPopulation) {
          populationInfo = [mergeParent.row, mergeParent.col, clearedData];
        } else {
          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);
        }
        this.hot.runHooks("afterMergeCells", cellRange, mergeParent, auto);
        return populationInfo;
      }
      return true;
    }
    /**
     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.
     *
     * @private
     * @param {CellRange} cellRange Selection cell range.
     * @param {Boolean} [auto=false] `true` if called automatically by the plugin.
     *
     * @fires Hooks#beforeUnmergeCells
     * @fires Hooks#afterUnmergeCells
     */
  }, {
    key: "unmergeRange",
    value: function unmergeRange(cellRange) {
      var _this5 = this;
      var auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);
      if (!mergedCells) {
        return;
      }
      this.hot.runHooks("beforeUnmergeCells", cellRange, auto);
      arrayEach(mergedCells, function(currentCollection) {
        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);
        rangeEach(0, currentCollection.rowspan - 1, function(i) {
          rangeEach(0, currentCollection.colspan - 1, function(j) {
            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, "hidden");
          });
        });
        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, "spanned");
      });
      this.hot.render();
      this.hot.runHooks("afterUnmergeCells", cellRange, auto);
    }
    /**
     * Merges or unmerges, based on the cell range provided as `cellRange`.
     *
     * @private
     * @param {CellRange} cellRange The cell range to merge or unmerged.
     */
  }, {
    key: "toggleMerge",
    value: function toggleMerge(cellRange) {
      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);
      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;
      if (mergedCellCoversWholeRange) {
        this.unmergeRange(cellRange);
      } else {
        this.mergeSelection(cellRange);
      }
    }
    /**
     * Merges the specified range.
     *
     * @param {Number} startRow Start row of the merged cell.
     * @param {Number} startColumn Start column of the merged cell.
     * @param {Number} endRow End row of the merged cell.
     * @param {Number} endColumn End column of the merged cell.
     * @fires Hooks#beforeMergeCells
     * @fires Hooks#afterMergeCells
     */
  }, {
    key: "merge",
    value: function merge2(startRow, startColumn, endRow, endColumn) {
      var start = new coords_default(startRow, startColumn);
      var end = new coords_default(endRow, endColumn);
      this.mergeRange(new range_default(start, start, end));
    }
    /**
     * Unmerges the merged cell in the provided range.
     *
     * @param {Number} startRow Start row of the merged cell.
     * @param {Number} startColumn Start column of the merged cell.
     * @param {Number} endRow End row of the merged cell.
     * @param {Number} endColumn End column of the merged cell.
     * @fires Hooks#beforeUnmergeCells
     * @fires Hooks#afterUnmergeCells
     */
  }, {
    key: "unmerge",
    value: function unmerge(startRow, startColumn, endRow, endColumn) {
      var start = new coords_default(startRow, startColumn);
      var end = new coords_default(endRow, endColumn);
      this.unmergeRange(new range_default(start, start, end));
    }
    /**
     * `afterInit` hook callback.
     *
     * @private
     */
  }, {
    key: "onAfterInit",
    value: function onAfterInit() {
      this.generateFromSettings(this.hot.getSettings().mergeCells);
      this.hot.render();
    }
    /**
     * `beforeKeyDown` hook callback.
     *
     * @private
     * @param {KeyboardEvent} event The `keydown` event object.
     */
  }, {
    key: "onBeforeKeyDown",
    value: function onBeforeKeyDown9(event2) {
      var ctrlDown = (event2.ctrlKey || event2.metaKey) && !event2.altKey;
      if (ctrlDown && event2.keyCode === 77) {
        this.toggleMerge(this.hot.getSelectedRangeLast());
        this.hot.render();
        stopImmediatePropagation(event2);
      }
    }
    /**
     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.
     *
     * @private
     * @param {Boolean} isMultiple
     * @returns {Boolean}
     */
  }, {
    key: "onAfterIsMultipleSelection",
    value: function onAfterIsMultipleSelection(isMultiple) {
      if (isMultiple) {
        var mergedCells = this.mergedCellsCollection.mergedCells;
        var selectionRange = this.hot.getSelectedRangeLast();
        for (var group = 0; group < mergedCells.length; group += 1) {
          if (selectionRange.highlight.row === mergedCells[group].row && selectionRange.highlight.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {
            return false;
          }
        }
      }
      return isMultiple;
    }
    /**
     * `modifyTransformStart` hook callback.
     *
     * @private
     * @param {Object} delta The transformation delta.
     */
  }, {
    key: "onModifyTransformStart",
    value: function onModifyTransformStart(delta) {
      var priv = privatePool11.get(this);
      var currentlySelectedRange = this.hot.getSelectedRangeLast();
      var newDelta = {
        row: delta.row,
        col: delta.col
      };
      var nextPosition = null;
      var currentPosition = new coords_default(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);
      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);
      if (!priv.lastDesiredCoords) {
        priv.lastDesiredCoords = new coords_default(null, null);
      }
      if (mergedParent) {
        var mergeTopLeft = new coords_default(mergedParent.row, mergedParent.col);
        var mergeBottomRight = new coords_default(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);
        var mergeRange = new range_default(mergeTopLeft, mergeTopLeft, mergeBottomRight);
        if (!mergeRange.includes(priv.lastDesiredCoords)) {
          priv.lastDesiredCoords = new coords_default(null, null);
        }
        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;
        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;
        if (delta.row > 0) {
          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;
        } else if (delta.row < 0) {
          newDelta.row = currentPosition.row - mergedParent.row + delta.row;
        }
        if (delta.col > 0) {
          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;
        } else if (delta.col < 0) {
          newDelta.col = currentPosition.col - mergedParent.col + delta.col;
        }
      }
      nextPosition = new coords_default(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);
      var nextParentIsMerged = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);
      if (nextParentIsMerged) {
        priv.lastDesiredCoords = nextPosition;
        newDelta = {
          row: nextParentIsMerged.row - currentPosition.row,
          col: nextParentIsMerged.col - currentPosition.col
        };
      }
      if (newDelta.row !== 0) {
        delta.row = newDelta.row;
      }
      if (newDelta.col !== 0) {
        delta.col = newDelta.col;
      }
    }
    /**
     * `modifyTransformEnd` hook callback. Needed to handle "jumping over" merged merged cells, while selecting.
     *
     * @private
     * @param {Object} delta The transformation delta.
     */
  }, {
    key: "onModifyTransformEnd",
    value: function onModifyTransformEnd(delta) {
      var _this6 = this;
      var currentSelectionRange = this.hot.getSelectedRangeLast();
      var newDelta = clone(delta);
      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);
      var tempDelta = clone(newDelta);
      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);
      do {
        tempDelta = clone(newDelta);
        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);
        arrayEach(mergedCellsWithinRange, function(mergedCell) {
          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);
        });
      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);
      delta.row = newDelta.row;
      delta.col = newDelta.col;
    }
    /**
     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.
     *
     * @private
     * @param {Number} row Row index.
     * @param {Number} column Column index.
     * @returns {Array}
     */
  }, {
    key: "onModifyGetCellCoords",
    value: function onModifyGetCellCoords(row, column) {
      var mergeParent = this.mergedCellsCollection.get(row, column);
      return mergeParent ? [mergeParent.row, mergeParent.col, mergeParent.row + mergeParent.rowspan - 1, mergeParent.col + mergeParent.colspan - 1] : void 0;
    }
    /**
     * `afterContextMenuDefaultOptions` hook callback.
     *
     * @private
     * @param {Object} defaultOptions The default context menu options.
     */
  }, {
    key: "addMergeActionsToContextMenu",
    value: function addMergeActionsToContextMenu(defaultOptions2) {
      defaultOptions2.items.push({
        name: "---------"
      }, toggleMergeItem(this));
    }
    /**
     * `afterRenderer` hook callback.
     *
     * @private
     * @param {HTMLElement} TD The cell to be modified.
     * @param {Number} row Row index.
     * @param {Number} col Column index.
     */
  }, {
    key: "onAfterRenderer",
    value: function onAfterRenderer(TD, row, col) {
      var mergedCell = this.mergedCellsCollection.get(row, col);
      applySpanProperties(TD, mergedCell, row, col);
    }
    /**
     * `beforeSetRangeEnd` hook callback.
     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell
     *
     * @private
     * @param {Object} coords Cell coords.
     */
  }, {
    key: "onBeforeSetRangeEnd",
    value: function onBeforeSetRangeEnd(coords) {
      var selRange = this.hot.getSelectedRangeLast();
      selRange.highlight = new coords_default(selRange.highlight.row, selRange.highlight.col);
      selRange.to = coords;
      var rangeExpanded = false;
      if (selRange.from.row === 0 && selRange.to.row === this.hot.countRows() - 1 || selRange.from.col === 0 && selRange.to.col === this.hot.countCols() - 1) {
        return;
      }
      do {
        rangeExpanded = false;
        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {
          var cellInfo = this.mergedCellsCollection.mergedCells[i];
          var mergedCellRange = cellInfo.getRange();
          if (selRange.expandByRange(mergedCellRange)) {
            coords.row = selRange.to.row;
            coords.col = selRange.to.col;
            rangeExpanded = true;
          }
        }
      } while (rangeExpanded);
    }
    /**
     * The `afterGetCellMeta` hook callback.
     *
     * @private
     * @param {Number} row Row index.
     * @param {Number} col Column index.
     * @param {Object} cellProperties The cell properties object.
     */
  }, {
    key: "onAfterGetCellMeta",
    value: function onAfterGetCellMeta(row, col, cellProperties) {
      var mergeParent = this.mergedCellsCollection.get(row, col);
      if (mergeParent && (mergeParent.row !== row || mergeParent.col !== col)) {
        cellProperties.copyable = false;
      }
    }
    /**
     * `afterViewportRowCalculatorOverride` hook callback.
     *
     * @private
     * @param {Object} calc The row calculator object.
     */
  }, {
    key: "onAfterViewportRowCalculatorOverride",
    value: function onAfterViewportRowCalculatorOverride(calc) {
      var _this7 = this;
      var colCount = this.hot.countCols();
      var mergeParent;
      rangeEach(0, colCount - 1, function(c) {
        mergeParent = _this7.mergedCellsCollection.get(calc.startRow, c);
        if (mergeParent) {
          if (mergeParent.row < calc.startRow) {
            calc.startRow = mergeParent.row;
            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc);
          }
        }
        mergeParent = _this7.mergedCellsCollection.get(calc.endRow, c);
        if (mergeParent) {
          var mergeEnd = mergeParent.row + mergeParent.rowspan - 1;
          if (mergeEnd > calc.endRow) {
            calc.endRow = mergeEnd;
            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc);
          }
        }
        return true;
      });
    }
    /**
     * `afterViewportColumnCalculatorOverride` hook callback.
     *
     * @private
     * @param {Object} calc The column calculator object.
     */
  }, {
    key: "onAfterViewportColumnCalculatorOverride",
    value: function onAfterViewportColumnCalculatorOverride(calc) {
      var _this8 = this;
      var rowCount = this.hot.countRows();
      var mergeParent;
      rangeEach(0, rowCount - 1, function(r) {
        mergeParent = _this8.mergedCellsCollection.get(r, calc.startColumn);
        if (mergeParent && mergeParent.col < calc.startColumn) {
          calc.startColumn = mergeParent.col;
          return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc);
        }
        mergeParent = _this8.mergedCellsCollection.get(r, calc.endColumn);
        if (mergeParent) {
          var mergeEnd = mergeParent.col + mergeParent.colspan - 1;
          if (mergeEnd > calc.endColumn) {
            calc.endColumn = mergeEnd;
            return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc);
          }
        }
        return true;
      });
    }
    /**
     * The `modifyAutofillRange` hook callback.
     *
     * @private
     * @param {Array} drag The drag area coordinates.
     * @param {Array} select The selection information.
     * @return {Array} The new drag area.
     */
  }, {
    key: "onModifyAutofillRange",
    value: function onModifyAutofillRange(drag, select) {
      this.autofillCalculations.correctSelectionAreaSize(select);
      var dragDirection = this.autofillCalculations.getDirection(select, drag);
      var dragArea = drag;
      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {
        dragArea = select;
        return dragArea;
      }
      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({
        from: {
          row: select[0],
          col: select[1]
        },
        to: {
          row: select[2],
          col: select[3]
        }
      });
      if (!mergedCellsWithinSelectionArea) {
        return dragArea;
      }
      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);
      return dragArea;
    }
    /**
     * `afterCreateCol` hook callback.
     *
     * @private
     * @param {Number} column Column index.
     * @param {Number} count Number of created columns.
     */
  }, {
    key: "onAfterCreateCol",
    value: function onAfterCreateCol(column, count) {
      this.mergedCellsCollection.shiftCollections("right", column, count);
    }
    /**
     * `afterRemoveCol` hook callback.
     *
     * @private
     * @param {Number} column Column index.
     * @param {Number} count Number of removed columns.
     */
  }, {
    key: "onAfterRemoveCol",
    value: function onAfterRemoveCol(column, count) {
      this.mergedCellsCollection.shiftCollections("left", column, count);
    }
    /**
     * `afterCreateRow` hook callback.
     *
     * @private
     * @param {Number} row Row index.
     * @param {Number} count Number of created rows.
     * @param {String} source Source of change.
     */
  }, {
    key: "onAfterCreateRow",
    value: function onAfterCreateRow(row, count, source) {
      if (source === "auto") {
        return;
      }
      this.mergedCellsCollection.shiftCollections("down", row, count);
    }
    /**
     * `afterRemoveRow` hook callback.
     *
     * @private
     * @param {Number} row Row index.
     * @param {Number} count Number of removed rows.
     */
  }, {
    key: "onAfterRemoveRow",
    value: function onAfterRemoveRow(row, count) {
      this.mergedCellsCollection.shiftCollections("up", row, count);
    }
    /**
     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.
     *
     * @private
     * @param {Array} changes The changes array.
     * @param {String} source Determines the source of the change.
     */
  }, {
    key: "onAfterChange",
    value: function onAfterChange2(changes, source) {
      if (source !== "Autofill.fill") {
        return;
      }
      this.autofillCalculations.recreateAfterDataPopulation(changes);
    }
    /**
     * `beforeDrawAreaBorders` hook callback.
     *
     * @private
     * @param {Array} corners Coordinates of the area corners.
     * @param {String} className Class name for the area.
     */
  }, {
    key: "onBeforeDrawAreaBorders",
    value: function onBeforeDrawAreaBorders(corners, className) {
      if (className && className === "area") {
        var selectedRange = this.hot.getSelectedRangeLast();
        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);
        arrayEach(mergedCellsWithinRange, function(mergedCell) {
          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {
            corners[2] = mergedCell.row;
            corners[3] = mergedCell.col;
          }
        });
      }
    }
    /**
     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table
     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.
     *
     * @private
     * @param {CellCoords} coords Coordinates of the to-be-selected cell.
     * @param {Number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down)
     * @param {Number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down)
     */
  }, {
    key: "onAfterModifyTransformStart",
    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {
      if (!this.enabled) {
        return;
      }
      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);
      if (!mergedCellAtCoords) {
        return;
      }
      var goingDown = rowTransformDir > 0;
      var goingUp = rowTransformDir < 0;
      var goingLeft = colTransformDir < 0;
      var goingRight = colTransformDir > 0;
      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;
      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;
      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;
      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;
      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {
        coords.row = mergedCellAtCoords.row;
        coords.col = mergedCellAtCoords.col;
      }
    }
    /**
     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.
     *
     * @private
     * @param {Number} currentRow Row index of the currently processed cell.
     * @param {Number} currentColumn Column index of the currently cell.
     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.
     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.
     */
  }, {
    key: "onAfterDrawSelection",
    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {
      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);
    }
    /**
     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.
     *
     * @private
     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
     */
  }, {
    key: "onBeforeRemoveCellClassNames",
    value: function onBeforeRemoveCellClassNames() {
      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();
    }
  }]);
  return MergeCells2;
}(base_default2);
registerPlugin("mergeCells", MergeCells);
var mergeCells_default = MergeCells;

// node_modules/handsontable/es/plugins/multipleSelectionHandles/multipleSelectionHandles.js
function _typeof44(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof44 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof44 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof44(obj);
}
function _classCallCheck82(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties79(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass79(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties79(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties79(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn32(self2, call) {
  if (call && (_typeof44(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized32(self2);
}
function _assertThisInitialized32(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get24(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get24 = Reflect.get;
  } else {
    _get24 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase24(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get24(target, property, receiver || target);
}
function _superPropBase24(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf32(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf32(o) {
  _getPrototypeOf32 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf32(o);
}
function _inherits32(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf32(subClass, superClass);
}
function _setPrototypeOf32(o, p) {
  _setPrototypeOf32 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf32(o, p);
}
var MultipleSelectionHandles = function(_BasePlugin) {
  _inherits32(MultipleSelectionHandles2, _BasePlugin);
  function MultipleSelectionHandles2(hotInstance) {
    var _this2;
    _classCallCheck82(this, MultipleSelectionHandles2);
    _this2 = _possibleConstructorReturn32(this, _getPrototypeOf32(MultipleSelectionHandles2).call(this, hotInstance));
    _this2.dragged = [];
    _this2.eventManager = null;
    _this2.lastSetCell = null;
    return _this2;
  }
  _createClass79(MultipleSelectionHandles2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return isMobileBrowser();
    }
    /**
     * Enable plugin for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      if (this.enabled) {
        return;
      }
      if (!this.eventManager) {
        this.eventManager = new eventManager_default(this);
      }
      this.registerListeners();
      _get24(_getPrototypeOf32(MultipleSelectionHandles2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Bind the touch events
     * @private
     */
  }, {
    key: "registerListeners",
    value: function registerListeners() {
      var _this = this;
      function removeFromDragged(query) {
        if (_this.dragged.length === 1) {
          _this.dragged.splice(0, _this.dragged.length);
          return true;
        }
        var entryPosition = _this.dragged.indexOf(query);
        if (entryPosition === -1) {
          return false;
        } else if (entryPosition === 0) {
          _this.dragged = _this.dragged.slice(0, 1);
        } else if (entryPosition === 1) {
          _this.dragged = _this.dragged.slice(-1);
        }
      }
      this.eventManager.addEventListener(this.hot.rootElement, "touchstart", function(event2) {
        var selectedRange;
        if (hasClass(event2.target, "topLeftSelectionHandle-HitArea")) {
          selectedRange = _this.hot.getSelectedRangeLast();
          _this.dragged.push("topLeft");
          _this.touchStartRange = {
            width: selectedRange.getWidth(),
            height: selectedRange.getHeight(),
            direction: selectedRange.getDirection()
          };
          event2.preventDefault();
          return false;
        } else if (hasClass(event2.target, "bottomRightSelectionHandle-HitArea")) {
          selectedRange = _this.hot.getSelectedRangeLast();
          _this.dragged.push("bottomRight");
          _this.touchStartRange = {
            width: selectedRange.getWidth(),
            height: selectedRange.getHeight(),
            direction: selectedRange.getDirection()
          };
          event2.preventDefault();
          return false;
        }
      });
      this.eventManager.addEventListener(this.hot.rootElement, "touchend", function(event2) {
        if (hasClass(event2.target, "topLeftSelectionHandle-HitArea")) {
          removeFromDragged.call(_this, "topLeft");
          _this.touchStartRange = void 0;
          event2.preventDefault();
          return false;
        } else if (hasClass(event2.target, "bottomRightSelectionHandle-HitArea")) {
          removeFromDragged.call(_this, "bottomRight");
          _this.touchStartRange = void 0;
          event2.preventDefault();
          return false;
        }
      });
      this.eventManager.addEventListener(this.hot.rootElement, "touchmove", function(event2) {
        var scrollTop = getWindowScrollTop();
        var scrollLeft = getWindowScrollLeft();
        var targetCoords;
        var selectedRange;
        var rangeWidth;
        var rangeHeight;
        var rangeDirection;
        var newRangeCoords;
        if (_this.dragged.length === 0) {
          return;
        }
        var endTarget = document.elementFromPoint(event2.touches[0].screenX - scrollLeft, event2.touches[0].screenY - scrollTop);
        if (!endTarget || endTarget === _this.lastSetCell) {
          return;
        }
        if (endTarget.nodeName === "TD" || endTarget.nodeName === "TH") {
          targetCoords = _this.hot.getCoords(endTarget);
          if (targetCoords.col === -1) {
            targetCoords.col = 0;
          }
          selectedRange = _this.hot.getSelectedRangeLast();
          rangeWidth = selectedRange.getWidth();
          rangeHeight = selectedRange.getHeight();
          rangeDirection = selectedRange.getDirection();
          if (rangeWidth === 1 && rangeHeight === 1) {
            _this.hot.selection.setRangeEnd(targetCoords);
          }
          newRangeCoords = _this.getCurrentRangeCoords(selectedRange, targetCoords, _this.touchStartRange.direction, rangeDirection, _this.dragged[0]);
          if (newRangeCoords.start !== null) {
            _this.hot.selection.setRangeStart(newRangeCoords.start);
          }
          _this.hot.selection.setRangeEnd(newRangeCoords.end);
          _this.lastSetCell = endTarget;
        }
        event2.preventDefault();
      });
    }
  }, {
    key: "getCurrentRangeCoords",
    value: function getCurrentRangeCoords(selectedRange, currentTouch, touchStartDirection, currentDirection, draggedHandle) {
      var topLeftCorner = selectedRange.getTopLeftCorner();
      var bottomRightCorner = selectedRange.getBottomRightCorner();
      var bottomLeftCorner = selectedRange.getBottomLeftCorner();
      var topRightCorner = selectedRange.getTopRightCorner();
      var newCoords = {
        start: null,
        end: null
      };
      switch (touchStartDirection) {
        case "NE-SW":
          switch (currentDirection) {
            case "NE-SW":
            case "NW-SE":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: new coords_default(currentTouch.row, selectedRange.highlight.col),
                  end: new coords_default(bottomLeftCorner.row, currentTouch.col)
                };
              } else {
                newCoords = {
                  start: new coords_default(selectedRange.highlight.row, currentTouch.col),
                  end: new coords_default(currentTouch.row, topLeftCorner.col)
                };
              }
              break;
            case "SE-NW":
              if (draggedHandle === "bottomRight") {
                newCoords = {
                  start: new coords_default(bottomRightCorner.row, currentTouch.col),
                  end: new coords_default(currentTouch.row, topLeftCorner.col)
                };
              }
              break;
            default:
              break;
          }
          break;
        case "NW-SE":
          switch (currentDirection) {
            case "NE-SW":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: currentTouch,
                  end: bottomLeftCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            case "NW-SE":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: currentTouch,
                  end: bottomRightCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            case "SE-NW":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: currentTouch,
                  end: topLeftCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            case "SW-NE":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: currentTouch,
                  end: topRightCorner
                };
              } else {
                newCoords.end = currentTouch;
              }
              break;
            default:
              break;
          }
          break;
        case "SW-NE":
          switch (currentDirection) {
            case "NW-SE":
              if (draggedHandle === "bottomRight") {
                newCoords = {
                  start: new coords_default(currentTouch.row, topLeftCorner.col),
                  end: new coords_default(bottomLeftCorner.row, currentTouch.col)
                };
              } else {
                newCoords = {
                  start: new coords_default(topLeftCorner.row, currentTouch.col),
                  end: new coords_default(currentTouch.row, bottomRightCorner.col)
                };
              }
              break;
            case "SW-NE":
              if (draggedHandle === "topLeft") {
                newCoords = {
                  start: new coords_default(selectedRange.highlight.row, currentTouch.col),
                  end: new coords_default(currentTouch.row, bottomRightCorner.col)
                };
              } else {
                newCoords = {
                  start: new coords_default(currentTouch.row, topLeftCorner.col),
                  end: new coords_default(topLeftCorner.row, currentTouch.col)
                };
              }
              break;
            case "SE-NW":
              if (draggedHandle === "bottomRight") {
                newCoords = {
                  start: new coords_default(currentTouch.row, topRightCorner.col),
                  end: new coords_default(topLeftCorner.row, currentTouch.col)
                };
              } else if (draggedHandle === "topLeft") {
                newCoords = {
                  start: bottomLeftCorner,
                  end: currentTouch
                };
              }
              break;
            default:
              break;
          }
          break;
        case "SE-NW":
          switch (currentDirection) {
            case "NW-SE":
            case "NE-SW":
            case "SW-NE":
              if (draggedHandle === "topLeft") {
                newCoords.end = currentTouch;
              }
              break;
            case "SE-NW":
              if (draggedHandle === "topLeft") {
                newCoords.end = currentTouch;
              } else {
                newCoords = {
                  start: currentTouch,
                  end: topLeftCorner
                };
              }
              break;
            default:
              break;
          }
          break;
        default:
          break;
      }
      return newCoords;
    }
    /**
     * Check if user is currently dragging the handle.
     *
     * @returns {boolean} Dragging state
     */
  }, {
    key: "isDragged",
    value: function isDragged() {
      return this.dragged.length > 0;
    }
  }]);
  return MultipleSelectionHandles2;
}(base_default2);
registerPlugin("multipleSelectionHandles", MultipleSelectionHandles);
var multipleSelectionHandles_default = MultipleSelectionHandles;

// node_modules/handsontable/es/plugins/observeChanges/dataObserver.js
var import_json_patch_duplex = __toESM(require_json_patch_duplex());

// node_modules/handsontable/es/plugins/observeChanges/utils.js
function _slicedToArray22(arr, i) {
  return _arrayWithHoles23(arr) || _iterableToArrayLimit22(arr, i) || _nonIterableRest23();
}
function _nonIterableRest23() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit22(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles23(arr) {
  if (Array.isArray(arr)) return arr;
}
function cleanPatches(patches) {
  var newOrRemovedColumns = [];
  var cleanedPatches = arrayFilter(patches, function(patch) {
    if (/[/]length/ig.test(patch.path)) {
      return false;
    }
    if (!parsePath(patch.path)) {
      return false;
    }
    return true;
  });
  cleanedPatches = arrayMap(cleanedPatches, function(patch) {
    var coords = parsePath(patch.path);
    patch.row = coords.row;
    patch.col = coords.col;
    return patch;
  });
  cleanedPatches = arrayFilter(cleanedPatches, function(patch) {
    if (["add", "remove"].indexOf(patch.op) !== -1 && !isNaN(patch.col)) {
      if (newOrRemovedColumns.indexOf(patch.col) !== -1) {
        return false;
      }
      newOrRemovedColumns.push(patch.col);
    }
    return true;
  });
  newOrRemovedColumns.length = 0;
  return cleanedPatches;
}
function parsePath(path) {
  var match = path.match(/^\/(\d+)\/?(.*)?$/);
  if (!match) {
    return null;
  }
  var _match = _slicedToArray22(match, 3), row = _match[1], column = _match[2];
  return {
    row: parseInt(row, 10),
    col: /^\d*$/.test(column) ? parseInt(column, 10) : column
  };
}

// node_modules/handsontable/es/plugins/observeChanges/dataObserver.js
function _classCallCheck83(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties80(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass80(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties80(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties80(Constructor, staticProps);
  return Constructor;
}
var DataObserver = function() {
  function DataObserver2(observedData) {
    _classCallCheck83(this, DataObserver2);
    this.observedData = null;
    this.observer = null;
    this.paused = false;
    this.setObservedData(observedData);
  }
  _createClass80(DataObserver2, [{
    key: "setObservedData",
    value: function setObservedData(observedData) {
      var _this = this;
      if (this.observer) {
        import_json_patch_duplex.default.unobserve(this.observedData, this.observer);
      }
      this.observedData = observedData;
      this.observer = import_json_patch_duplex.default.observe(this.observedData, function(patches) {
        return _this.onChange(patches);
      });
    }
    /**
     * Check if observer was paused.
     *
     * @returns {Boolean}
     */
  }, {
    key: "isPaused",
    value: function isPaused() {
      return this.paused;
    }
    /**
     * Pause observer (stop emitting all detected changes).
     */
  }, {
    key: "pause",
    value: function pause() {
      this.paused = true;
    }
    /**
     * Resume observer (emit all detected changes).
     */
  }, {
    key: "resume",
    value: function resume() {
      this.paused = false;
    }
    /**
     * JsonPatch on change listener.
     *
     * @private
     * @param {Array} patches An array of object passed from jsonpatch.
     */
  }, {
    key: "onChange",
    value: function onChange2(patches) {
      this.runLocalHooks("change", cleanPatches(patches));
    }
    /**
     * Destroy observer instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      import_json_patch_duplex.default.unobserve(this.observedData, this.observer);
      this.observedData = null;
      this.observer = null;
    }
  }]);
  return DataObserver2;
}();
mixin(DataObserver, localHooks_default);
var dataObserver_default = DataObserver;

// node_modules/handsontable/es/plugins/observeChanges/observeChanges.js
function _typeof45(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof45 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof45 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof45(obj);
}
function _classCallCheck84(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties81(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass81(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties81(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties81(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn33(self2, call) {
  if (call && (_typeof45(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized33(self2);
}
function _assertThisInitialized33(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get25(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get25 = Reflect.get;
  } else {
    _get25 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase25(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get25(target, property, receiver || target);
}
function _superPropBase25(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf33(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf33(o) {
  _getPrototypeOf33 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf33(o);
}
function _inherits33(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf33(subClass, superClass);
}
function _setPrototypeOf33(o, p) {
  _setPrototypeOf33 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf33(o, p);
}
var ObserveChanges = function(_BasePlugin) {
  _inherits33(ObserveChanges2, _BasePlugin);
  function ObserveChanges2(hotInstance) {
    var _this;
    _classCallCheck84(this, ObserveChanges2);
    _this = _possibleConstructorReturn33(this, _getPrototypeOf33(ObserveChanges2).call(this, hotInstance));
    _this.observer = null;
    return _this;
  }
  _createClass81(ObserveChanges2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().observeChanges;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      if (!this.observer) {
        this.observer = new dataObserver_default(this.hot.getSourceData());
        this._exposePublicApi();
      }
      this.observer.addLocalHook("change", function(patches) {
        return _this2.onDataChange(patches);
      });
      this.addHook("afterCreateRow", function() {
        return _this2.onAfterTableAlter();
      });
      this.addHook("afterRemoveRow", function() {
        return _this2.onAfterTableAlter();
      });
      this.addHook("afterCreateCol", function() {
        return _this2.onAfterTableAlter();
      });
      this.addHook("afterRemoveCol", function() {
        return _this2.onAfterTableAlter();
      });
      this.addHook("afterChange", function(changes, source) {
        return _this2.onAfterTableAlter(source);
      });
      this.addHook("afterLoadData", function(firstRun) {
        return _this2.onAfterLoadData(firstRun);
      });
      _get25(_getPrototypeOf33(ObserveChanges2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      if (this.observer) {
        this.observer.destroy();
        this.observer = null;
        this._deletePublicApi();
      }
      _get25(_getPrototypeOf33(ObserveChanges2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Data change observer.
     *
     * @private
     * @param {Array} patches An array of objects which every item defines coordinates where data was changed.
     */
  }, {
    key: "onDataChange",
    value: function onDataChange(patches) {
      var _this3 = this;
      if (!this.observer.isPaused()) {
        var sourceName = "".concat(this.pluginName, ".change");
        var actions = {
          add: function add5(patch) {
            if (isNaN(patch.col)) {
              _this3.hot.runHooks("afterCreateRow", patch.row, 1, sourceName);
            } else {
              _this3.hot.runHooks("afterCreateCol", patch.col, 1, sourceName);
            }
          },
          remove: function remove(patch) {
            if (isNaN(patch.col)) {
              _this3.hot.runHooks("afterRemoveRow", patch.row, 1, sourceName);
            } else {
              _this3.hot.runHooks("afterRemoveCol", patch.col, 1, sourceName);
            }
          },
          replace: function replace(patch) {
            _this3.hot.runHooks("afterChange", [[patch.row, patch.col, null, patch.value]], sourceName);
          }
        };
        arrayEach(patches, function(patch) {
          if (actions[patch.op]) {
            actions[patch.op](patch);
          }
        });
        this.hot.render();
      }
      this.hot.runHooks("afterChangesObserved");
    }
    /**
     * On after table alter listener. Prevents infinity loop between internal and external data changing.
     *
     * @private
     * @param source
     */
  }, {
    key: "onAfterTableAlter",
    value: function onAfterTableAlter(source) {
      var _this4 = this;
      if (source !== "loadData") {
        this.observer.pause();
        this.hot.addHookOnce("afterChangesObserved", function() {
          return _this4.observer.resume();
        });
      }
    }
    /**
     * On after load data listener.
     *
     * @private
     * @param {Boolean} firstRun `true` if event was fired first time.
     */
  }, {
    key: "onAfterLoadData",
    value: function onAfterLoadData(firstRun) {
      if (!firstRun) {
        this.observer.setObservedData(this.hot.getSourceData());
      }
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.observer) {
        this.observer.destroy();
        this._deletePublicApi();
      }
      _get25(_getPrototypeOf33(ObserveChanges2.prototype), "destroy", this).call(this);
    }
    /**
     * Expose plugins methods to the core.
     *
     * @private
     */
  }, {
    key: "_exposePublicApi",
    value: function _exposePublicApi() {
      var _this5 = this;
      var hot = this.hot;
      hot.pauseObservingChanges = function() {
        return _this5.observer.pause();
      };
      hot.resumeObservingChanges = function() {
        return _this5.observer.resume();
      };
      hot.isPausedObservingChanges = function() {
        return _this5.observer.isPaused();
      };
    }
    /**
     * Deletes all previously exposed methods.
     *
     * @private
     */
  }, {
    key: "_deletePublicApi",
    value: function _deletePublicApi() {
      var hot = this.hot;
      delete hot.pauseObservingChanges;
      delete hot.resumeObservingChanges;
      delete hot.isPausedObservingChanges;
    }
  }]);
  return ObserveChanges2;
}(base_default2);
var observeChanges_default = ObserveChanges;
registerPlugin("observeChanges", ObserveChanges);

// node_modules/handsontable/es/plugins/search/search.js
function _typeof46(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof46 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof46 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof46(obj);
}
function _toConsumableArray13(arr) {
  return _arrayWithoutHoles13(arr) || _iterableToArray14(arr) || _nonIterableSpread13();
}
function _nonIterableSpread13() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray14(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles13(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function _classCallCheck85(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties82(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass82(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties82(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties82(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn34(self2, call) {
  if (call && (_typeof46(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized34(self2);
}
function _assertThisInitialized34(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get26(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get26 = Reflect.get;
  } else {
    _get26 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase26(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get26(target, property, receiver || target);
}
function _superPropBase26(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf34(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf34(o) {
  _getPrototypeOf34 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf34(o);
}
function _inherits34(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf34(subClass, superClass);
}
function _setPrototypeOf34(o, p) {
  _setPrototypeOf34 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf34(o, p);
}
var DEFAULT_SEARCH_RESULT_CLASS = "htSearchResult";
var DEFAULT_CALLBACK = function DEFAULT_CALLBACK2(instance, row, col, data, testResult) {
  instance.getCellMeta(row, col).isSearchResult = testResult;
};
var DEFAULT_QUERY_METHOD = function DEFAULT_QUERY_METHOD2(query, value) {
  if (isUndefined2(query) || query === null || !query.toLowerCase || query.length === 0) {
    return false;
  }
  if (isUndefined2(value) || value === null) {
    return false;
  }
  return value.toString().toLowerCase().indexOf(query.toLowerCase()) !== -1;
};
var Search = function(_BasePlugin) {
  _inherits34(Search2, _BasePlugin);
  function Search2(hotInstance) {
    var _this;
    _classCallCheck85(this, Search2);
    _this = _possibleConstructorReturn34(this, _getPrototypeOf34(Search2).call(this, hotInstance));
    _this.callback = DEFAULT_CALLBACK;
    _this.queryMethod = DEFAULT_QUERY_METHOD;
    _this.searchResultClass = DEFAULT_SEARCH_RESULT_CLASS;
    return _this;
  }
  _createClass82(Search2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this.hot.getSettings().search;
    }
    /**
     * Enables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      var searchSettings = this.hot.getSettings().search;
      this.updatePluginSettings(searchSettings);
      this.addHook("beforeRenderer", function() {
        return _this2.onBeforeRenderer.apply(_this2, arguments);
      });
      _get26(_getPrototypeOf34(Search2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Disables the plugin functionality for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      var _this3 = this;
      var beforeRendererCallback = function beforeRendererCallback2() {
        return _this3.onBeforeRenderer.apply(_this3, arguments);
      };
      this.hot.addHook("beforeRenderer", beforeRendererCallback);
      this.hot.addHookOnce("afterRender", function() {
        _this3.hot.removeHook("beforeRenderer", beforeRendererCallback);
      });
      _get26(_getPrototypeOf34(Search2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.disablePlugin();
      this.enablePlugin();
      _get26(_getPrototypeOf34(Search2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Makes the query.
     *
     * @param {String} queryStr Value to be search.
     * @param {Function} [callback] Callback function performed on cells with values which matches to the searched query.
     * @param {Function} [queryMethod] Query function responsible for determining whether a query matches the value stored in a cell.
     * @returns {Object[]} Return an array of objects with `row`, `col`, `data` properties or empty array.
     */
  }, {
    key: "query",
    value: function query(queryStr) {
      var _this4 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getCallback();
      var queryMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getQueryMethod();
      var rowCount = this.hot.countRows();
      var colCount = this.hot.countCols();
      var queryResult = [];
      var instance = this.hot;
      rangeEach(0, rowCount - 1, function(rowIndex) {
        rangeEach(0, colCount - 1, function(colIndex) {
          var cellData = _this4.hot.getDataAtCell(rowIndex, colIndex);
          var cellProperties = _this4.hot.getCellMeta(rowIndex, colIndex);
          var cellCallback = cellProperties.search.callback || callback;
          var cellQueryMethod = cellProperties.search.queryMethod || queryMethod;
          var testResult = cellQueryMethod(queryStr, cellData);
          if (testResult) {
            var singleResult = {
              row: rowIndex,
              col: colIndex,
              data: cellData
            };
            queryResult.push(singleResult);
          }
          if (cellCallback) {
            cellCallback(instance, rowIndex, colIndex, cellData, testResult);
          }
        });
      });
      return queryResult;
    }
    /**
     * Gets the callback function.
     *
     * @returns {Function} Return the callback function.
     */
  }, {
    key: "getCallback",
    value: function getCallback() {
      return this.callback;
    }
    /**
     * Sets the callback function. This function will be called during querying for each cell.
     *
     * @param {Function} newCallback
     */
  }, {
    key: "setCallback",
    value: function setCallback(newCallback) {
      this.callback = newCallback;
    }
    /**
     * Gets the query method function.
     *
     * @returns {Function} Return the query method.
     */
  }, {
    key: "getQueryMethod",
    value: function getQueryMethod() {
      return this.queryMethod;
    }
    /**
     * Sets the query method function. The function is responsible for determining whether a query matches the value stored in a cell.
     *
     * @param {Function} newQueryMethod
     */
  }, {
    key: "setQueryMethod",
    value: function setQueryMethod(newQueryMethod) {
      this.queryMethod = newQueryMethod;
    }
    /**
     * Gets search result cells class name.
     *
     * @returns {String} Return the cell class name.
     */
  }, {
    key: "getSearchResultClass",
    value: function getSearchResultClass() {
      return this.searchResultClass;
    }
    /**
     * Sets search result cells class name. This class name will be added to each cell that belongs to the searched query.
     *
     * @param {String} newElementClass
     */
  }, {
    key: "setSearchResultClass",
    value: function setSearchResultClass(newElementClass) {
      this.searchResultClass = newElementClass;
    }
    /**
     * Updates the settings of the plugin.
     *
     * @param {Object} searchSettings The plugin settings, taken from Handsontable configuration.
     * @private
     */
  }, {
    key: "updatePluginSettings",
    value: function updatePluginSettings(searchSettings) {
      if (isObject(searchSettings)) {
        if (searchSettings.searchResultClass) {
          this.setSearchResultClass(searchSettings.searchResultClass);
        }
        if (searchSettings.queryMethod) {
          this.setQueryMethod(searchSettings.queryMethod);
        }
        if (searchSettings.callback) {
          this.setCallback(searchSettings.callback);
        }
      }
    }
    /** *
     * The `beforeRenderer` hook callback.
     *
     * @private
     * @param {HTMLTableCellElement} TD The rendered `TD` element.
     * @param {Number} row Visual row index.
     * @param {Number} col Visual column index.
     * @param {String | Number} prop Column property name or a column index, if datasource is an array of arrays.
     * @param {String} value Value of the rendered cell.
     * @param {Object} cellProperties Object containing the cell's properties.
     */
  }, {
    key: "onBeforeRenderer",
    value: function onBeforeRenderer(TD, row, col, prop, value, cellProperties) {
      var className = cellProperties.className || [];
      var classArray = [];
      if (typeof className === "string") {
        classArray = className.split(" ");
      } else {
        var _classArray;
        (_classArray = classArray).push.apply(_classArray, _toConsumableArray13(className));
      }
      if (this.isEnabled() && cellProperties.isSearchResult) {
        if (!classArray.includes(this.searchResultClass)) {
          classArray.push("".concat(this.searchResultClass));
        }
      } else if (classArray.includes(this.searchResultClass)) {
        classArray.splice(classArray.indexOf(this.searchResultClass), 1);
      }
      cellProperties.className = classArray.join(" ");
    }
    /**
     * Destroys the plugin instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get26(_getPrototypeOf34(Search2.prototype), "destroy", this).call(this);
    }
  }]);
  return Search2;
}(base_default2);
registerPlugin("search", Search);
var search_default = Search;

// node_modules/handsontable/es/plugins/touchScroll/touchScroll.js
function _typeof47(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof47 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof47 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof47(obj);
}
function _classCallCheck86(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties83(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass83(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties83(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties83(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn35(self2, call) {
  if (call && (_typeof47(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized35(self2);
}
function _assertThisInitialized35(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _get27(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get27 = Reflect.get;
  } else {
    _get27 = function _get28(target2, property2, receiver2) {
      var base = _superPropBase27(target2, property2);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get27(target, property, receiver || target);
}
function _superPropBase27(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf35(object);
    if (object === null) break;
  }
  return object;
}
function _getPrototypeOf35(o) {
  _getPrototypeOf35 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf35(o);
}
function _inherits35(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf35(subClass, superClass);
}
function _setPrototypeOf35(o, p) {
  _setPrototypeOf35 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf35(o, p);
}
var TouchScroll = function(_BasePlugin) {
  _inherits35(TouchScroll2, _BasePlugin);
  function TouchScroll2(hotInstance) {
    var _this;
    _classCallCheck86(this, TouchScroll2);
    _this = _possibleConstructorReturn35(this, _getPrototypeOf35(TouchScroll2).call(this, hotInstance));
    _this.scrollbars = [];
    _this.clones = [];
    _this.lockedCollection = false;
    _this.freezeOverlays = false;
    return _this;
  }
  _createClass83(TouchScroll2, [{
    key: "isEnabled",
    value: function isEnabled() {
      return isTouchSupported();
    }
    /**
     * Enable the plugin.
     */
  }, {
    key: "enablePlugin",
    value: function enablePlugin() {
      var _this2 = this;
      if (this.enabled) {
        return;
      }
      this.addHook("afterRender", function() {
        return _this2.onAfterRender();
      });
      this.registerEvents();
      _get27(_getPrototypeOf35(TouchScroll2.prototype), "enablePlugin", this).call(this);
    }
    /**
     * Updates the plugin to use the latest options you have specified.
     */
  }, {
    key: "updatePlugin",
    value: function updatePlugin() {
      this.lockedCollection = false;
      _get27(_getPrototypeOf35(TouchScroll2.prototype), "updatePlugin", this).call(this);
    }
    /**
     * Disable plugin for this Handsontable instance.
     */
  }, {
    key: "disablePlugin",
    value: function disablePlugin() {
      _get27(_getPrototypeOf35(TouchScroll2.prototype), "disablePlugin", this).call(this);
    }
    /**
     * Register all necessary events.
     *
     * @private
     */
  }, {
    key: "registerEvents",
    value: function registerEvents2() {
      var _this3 = this;
      this.addHook("beforeTouchScroll", function() {
        return _this3.onBeforeTouchScroll();
      });
      this.addHook("afterMomentumScroll", function() {
        return _this3.onAfterMomentumScroll();
      });
    }
    /**
     * After render listener.
     *
     * @private
     */
  }, {
    key: "onAfterRender",
    value: function onAfterRender() {
      if (this.lockedCollection) {
        return;
      }
      var _this$hot$view$wt$wtO = this.hot.view.wt.wtOverlays, topOverlay = _this$hot$view$wt$wtO.topOverlay, bottomOverlay = _this$hot$view$wt$wtO.bottomOverlay, leftOverlay = _this$hot$view$wt$wtO.leftOverlay, topLeftCornerOverlay = _this$hot$view$wt$wtO.topLeftCornerOverlay, bottomLeftCornerOverlay = _this$hot$view$wt$wtO.bottomLeftCornerOverlay;
      this.lockedCollection = true;
      this.scrollbars.length = 0;
      this.scrollbars.push(topOverlay);
      if (bottomOverlay.clone) {
        this.scrollbars.push(bottomOverlay);
      }
      this.scrollbars.push(leftOverlay);
      if (topLeftCornerOverlay) {
        this.scrollbars.push(topLeftCornerOverlay);
      }
      if (bottomLeftCornerOverlay && bottomLeftCornerOverlay.clone) {
        this.scrollbars.push(bottomLeftCornerOverlay);
      }
      this.clones.length = 0;
      if (topOverlay.needFullRender) {
        this.clones.push(topOverlay.clone.wtTable.holder.parentNode);
      }
      if (bottomOverlay.needFullRender) {
        this.clones.push(bottomOverlay.clone.wtTable.holder.parentNode);
      }
      if (leftOverlay.needFullRender) {
        this.clones.push(leftOverlay.clone.wtTable.holder.parentNode);
      }
      if (topLeftCornerOverlay) {
        this.clones.push(topLeftCornerOverlay.clone.wtTable.holder.parentNode);
      }
      if (bottomLeftCornerOverlay && bottomLeftCornerOverlay.clone) {
        this.clones.push(bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
      }
    }
    /**
     * Touch scroll listener.
     *
     * @private
     */
  }, {
    key: "onBeforeTouchScroll",
    value: function onBeforeTouchScroll() {
      this.freezeOverlays = true;
      arrayEach(this.clones, function(clone5) {
        addClass(clone5, "hide-tween");
      });
    }
    /**
     * After momentum scroll listener.
     *
     * @private
     */
  }, {
    key: "onAfterMomentumScroll",
    value: function onAfterMomentumScroll() {
      var _this4 = this;
      this.freezeOverlays = false;
      arrayEach(this.clones, function(clone5) {
        removeClass(clone5, "hide-tween");
        addClass(clone5, "show-tween");
      });
      setTimeout(function() {
        arrayEach(_this4.clones, function(clone5) {
          removeClass(clone5, "show-tween");
        });
      }, 400);
      arrayEach(this.scrollbars, function(scrollbar) {
        scrollbar.refresh();
        scrollbar.resetFixedPosition();
      });
      this.hot.view.wt.wtOverlays.syncScrollWithMaster();
    }
  }]);
  return TouchScroll2;
}(base_default2);
registerPlugin("touchScroll", TouchScroll);
var touchScroll_default = TouchScroll;

// node_modules/handsontable/es/plugins/undoRedo/undoRedo.js
function _typeof48(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof48 = function _typeof49(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof48 = function _typeof49(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof48(obj);
}
function _classCallCheck87(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties84(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass84(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties84(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties84(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn36(self2, call) {
  if (call && (_typeof48(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized36(self2);
}
function _assertThisInitialized36(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf36(o) {
  _getPrototypeOf36 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf37(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf36(o);
}
function _inherits36(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf36(subClass, superClass);
}
function _setPrototypeOf36(o, p) {
  _setPrototypeOf36 = Object.setPrototypeOf || function _setPrototypeOf37(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf36(o, p);
}
function UndoRedo(instance) {
  var plugin = this;
  this.instance = instance;
  this.doneActions = [];
  this.undoneActions = [];
  this.ignoreNewActions = false;
  instance.addHook("afterChange", function(changes, source) {
    if (changes && source !== "UndoRedo.undo" && source !== "UndoRedo.redo" && source !== "MergeCells") {
      plugin.done(new UndoRedo.ChangeAction(changes));
    }
  });
  instance.addHook("afterCreateRow", function(index2, amount, source) {
    if (source === "UndoRedo.undo" || source === "UndoRedo.undo" || source === "auto") {
      return;
    }
    var action = new UndoRedo.CreateRowAction(index2, amount);
    plugin.done(action);
  });
  instance.addHook("beforeRemoveRow", function(index2, amount, logicRows, source) {
    if (source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto") {
      return;
    }
    var originalData = plugin.instance.getSourceDataArray();
    var rowIndex = (originalData.length + index2) % originalData.length;
    var physicalRowIndex = instance.toPhysicalRow(rowIndex);
    var removedData = deepClone(originalData.slice(physicalRowIndex, physicalRowIndex + amount));
    plugin.done(new UndoRedo.RemoveRowAction(rowIndex, removedData));
  });
  instance.addHook("afterCreateCol", function(index2, amount, source) {
    if (source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto") {
      return;
    }
    plugin.done(new UndoRedo.CreateColumnAction(index2, amount));
  });
  instance.addHook("beforeRemoveCol", function(index2, amount, logicColumns, source) {
    if (source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto") {
      return;
    }
    var originalData = plugin.instance.getSourceDataArray();
    var columnIndex = (plugin.instance.countCols() + index2) % plugin.instance.countCols();
    var removedData = [];
    var headers = [];
    var indexes = [];
    rangeEach(originalData.length - 1, function(i) {
      var column = [];
      var origRow = originalData[i];
      rangeEach(columnIndex, columnIndex + (amount - 1), function(j) {
        column.push(origRow[instance.runHooks("modifyCol", j)]);
      });
      removedData.push(column);
    });
    rangeEach(amount - 1, function(i) {
      indexes.push(instance.runHooks("modifyCol", columnIndex + i));
    });
    if (Array.isArray(instance.getSettings().colHeaders)) {
      rangeEach(amount - 1, function(i) {
        headers.push(instance.getSettings().colHeaders[instance.runHooks("modifyCol", columnIndex + i)] || null);
      });
    }
    var manualColumnMovePlugin = plugin.instance.getPlugin("manualColumnMove");
    var columnsMap = manualColumnMovePlugin.isEnabled() ? manualColumnMovePlugin.columnsMapper.__arrayMap : [];
    var action = new UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, columnsMap);
    plugin.done(action);
  });
  instance.addHook("beforeCellAlignment", function(stateBefore, range, type, alignment) {
    var action = new UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment);
    plugin.done(action);
  });
  instance.addHook("beforeFilter", function(conditionsStack) {
    plugin.done(new UndoRedo.FiltersAction(conditionsStack));
  });
  instance.addHook("beforeRowMove", function(movedRows, target) {
    if (movedRows === false) {
      return;
    }
    plugin.done(new UndoRedo.RowMoveAction(movedRows, target));
  });
  instance.addHook("beforeMergeCells", function(cellRange, auto) {
    if (auto) {
      return;
    }
    plugin.done(new UndoRedo.MergeCellsAction(instance, cellRange));
  });
  instance.addHook("afterUnmergeCells", function(cellRange, auto) {
    if (auto) {
      return;
    }
    plugin.done(new UndoRedo.UnmergeCellsAction(instance, cellRange));
  });
}
UndoRedo.prototype.done = function(action) {
  if (!this.ignoreNewActions) {
    this.doneActions.push(action);
    this.undoneActions.length = 0;
  }
};
UndoRedo.prototype.undo = function() {
  if (this.isUndoAvailable()) {
    var action = this.doneActions.pop();
    var actionClone = deepClone(action);
    var instance = this.instance;
    var continueAction = instance.runHooks("beforeUndo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    var that = this;
    action.undo(this.instance, function() {
      that.ignoreNewActions = false;
      that.undoneActions.push(action);
    });
    instance.runHooks("afterUndo", actionClone);
  }
};
UndoRedo.prototype.redo = function() {
  if (this.isRedoAvailable()) {
    var action = this.undoneActions.pop();
    var actionClone = deepClone(action);
    var instance = this.instance;
    var continueAction = instance.runHooks("beforeRedo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    var that = this;
    action.redo(this.instance, function() {
      that.ignoreNewActions = false;
      that.doneActions.push(action);
    });
    instance.runHooks("afterRedo", actionClone);
  }
};
UndoRedo.prototype.isUndoAvailable = function() {
  return this.doneActions.length > 0;
};
UndoRedo.prototype.isRedoAvailable = function() {
  return this.undoneActions.length > 0;
};
UndoRedo.prototype.clear = function() {
  this.doneActions.length = 0;
  this.undoneActions.length = 0;
};
UndoRedo.Action = function() {
};
UndoRedo.Action.prototype.undo = function() {
};
UndoRedo.Action.prototype.redo = function() {
};
UndoRedo.ChangeAction = function(changes) {
  this.changes = changes;
  this.actionType = "change";
};
inherit(UndoRedo.ChangeAction, UndoRedo.Action);
UndoRedo.ChangeAction.prototype.undo = function(instance, undoneCallback) {
  var data = deepClone(this.changes);
  var emptyRowsAtTheEnd = instance.countEmptyRows(true);
  var emptyColsAtTheEnd = instance.countEmptyCols(true);
  for (var i = 0, len = data.length; i < len; i++) {
    data[i].splice(3, 1);
  }
  instance.addHookOnce("afterChange", undoneCallback);
  instance.setDataAtRowProp(data, null, null, "UndoRedo.undo");
  for (var _i = 0, _len = data.length; _i < _len; _i++) {
    if (instance.getSettings().minSpareRows && data[_i][0] + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {
      instance.alter("remove_row", parseInt(data[_i][0] + 1, 10), instance.getSettings().minSpareRows);
      instance.undoRedo.doneActions.pop();
    }
    if (instance.getSettings().minSpareCols && data[_i][1] + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd === instance.getSettings().minSpareCols) {
      instance.alter("remove_col", parseInt(data[_i][1] + 1, 10), instance.getSettings().minSpareCols);
      instance.undoRedo.doneActions.pop();
    }
  }
};
UndoRedo.ChangeAction.prototype.redo = function(instance, onFinishCallback) {
  var data = deepClone(this.changes);
  for (var i = 0, len = data.length; i < len; i++) {
    data[i].splice(2, 1);
  }
  instance.addHookOnce("afterChange", onFinishCallback);
  instance.setDataAtRowProp(data, null, null, "UndoRedo.redo");
};
UndoRedo.CreateRowAction = function(index2, amount) {
  this.index = index2;
  this.amount = amount;
  this.actionType = "insert_row";
};
inherit(UndoRedo.CreateRowAction, UndoRedo.Action);
UndoRedo.CreateRowAction.prototype.undo = function(instance, undoneCallback) {
  var rowCount = instance.countRows();
  var minSpareRows = instance.getSettings().minSpareRows;
  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {
    this.index -= minSpareRows;
  }
  instance.addHookOnce("afterRemoveRow", undoneCallback);
  instance.alter("remove_row", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateRow", redoneCallback);
  instance.alter("insert_row", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveRowAction = function(index2, data) {
  this.index = index2;
  this.data = data;
  this.actionType = "remove_row";
};
inherit(UndoRedo.RemoveRowAction, UndoRedo.Action);
UndoRedo.RemoveRowAction.prototype.undo = function(instance, undoneCallback) {
  instance.alter("insert_row", this.index, this.data.length, "UndoRedo.undo");
  instance.addHookOnce("afterRender", undoneCallback);
  instance.populateFromArray(this.index, 0, this.data, void 0, void 0, "UndoRedo.undo");
};
UndoRedo.RemoveRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveRow", redoneCallback);
  instance.alter("remove_row", this.index, this.data.length, "UndoRedo.redo");
};
UndoRedo.CreateColumnAction = function(index2, amount) {
  this.index = index2;
  this.amount = amount;
  this.actionType = "insert_col";
};
inherit(UndoRedo.CreateColumnAction, UndoRedo.Action);
UndoRedo.CreateColumnAction.prototype.undo = function(instance, undoneCallback) {
  instance.addHookOnce("afterRemoveCol", undoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateCol", redoneCallback);
  instance.alter("insert_col", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveColumnAction = function(index2, indexes, data, headers, columnPositions) {
  this.index = index2;
  this.indexes = indexes;
  this.data = data;
  this.amount = this.data[0].length;
  this.headers = headers;
  this.columnPositions = columnPositions.slice(0);
  this.actionType = "remove_col";
};
inherit(UndoRedo.RemoveColumnAction, UndoRedo.Action);
UndoRedo.RemoveColumnAction.prototype.undo = function(instance, undoneCallback) {
  var _this = this;
  var row;
  var ascendingIndexes = this.indexes.slice(0).sort();
  var sortByIndexes = function sortByIndexes2(elem, j, arr) {
    return arr[_this.indexes.indexOf(ascendingIndexes[j])];
  };
  var sortedData = [];
  rangeEach(this.data.length - 1, function(i) {
    sortedData[i] = arrayMap(_this.data[i], sortByIndexes);
  });
  var sortedHeaders = [];
  sortedHeaders = arrayMap(this.headers, sortByIndexes);
  var changes = [];
  instance.runHooks("beforeCreateCol", this.indexes[0], this.indexes.length, "UndoRedo.undo");
  rangeEach(this.data.length - 1, function(i) {
    row = instance.getSourceDataAtRow(i);
    rangeEach(ascendingIndexes.length - 1, function(j) {
      row.splice(ascendingIndexes[j], 0, sortedData[i][j]);
      changes.push([i, ascendingIndexes[j], null, sortedData[i][j]]);
    });
  });
  if (instance.getPlugin("formulas")) {
    instance.getPlugin("formulas").onAfterSetDataAtCell(changes);
  }
  if (typeof this.headers !== "undefined") {
    rangeEach(sortedHeaders.length - 1, function(j) {
      instance.getSettings().colHeaders.splice(ascendingIndexes[j], 0, sortedHeaders[j]);
    });
  }
  if (instance.getPlugin("manualColumnMove")) {
    instance.getPlugin("manualColumnMove").columnsMapper.__arrayMap = this.columnPositions;
  }
  instance.addHookOnce("afterRender", undoneCallback);
  instance.runHooks("afterCreateCol", this.indexes[0], this.indexes.length, "UndoRedo.undo");
  if (instance.getPlugin("formulas")) {
    instance.getPlugin("formulas").recalculateFull();
  }
  instance.render();
};
UndoRedo.RemoveColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveCol", redoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.CellAlignmentAction = function(stateBefore, range, type, alignment) {
  this.stateBefore = stateBefore;
  this.range = range;
  this.type = type;
  this.alignment = alignment;
};
UndoRedo.CellAlignmentAction.prototype.undo = function(instance, undoneCallback) {
  var _this2 = this;
  arrayEach(this.range, function(_ref) {
    var from3 = _ref.from, to3 = _ref.to;
    for (var row = from3.row; row <= to3.row; row += 1) {
      for (var col = from3.col; col <= to3.col; col += 1) {
        instance.setCellMeta(row, col, "className", _this2.stateBefore[row][col] || " htLeft");
      }
    }
  });
  instance.addHookOnce("afterRender", undoneCallback);
  instance.render();
};
UndoRedo.CellAlignmentAction.prototype.redo = function(instance, undoneCallback) {
  align(this.range, this.type, this.alignment, function(row, col) {
    return instance.getCellMeta(row, col);
  }, function(row, col, key, value) {
    return instance.setCellMeta(row, col, key, value);
  });
  instance.addHookOnce("afterRender", undoneCallback);
  instance.render();
};
UndoRedo.FiltersAction = function(conditionsStack) {
  this.conditionsStack = conditionsStack;
  this.actionType = "filter";
};
inherit(UndoRedo.FiltersAction, UndoRedo.Action);
UndoRedo.FiltersAction.prototype.undo = function(instance, undoneCallback) {
  var filters = instance.getPlugin("filters");
  instance.addHookOnce("afterRender", undoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, this.conditionsStack.length - 1));
  filters.filter();
};
UndoRedo.FiltersAction.prototype.redo = function(instance, redoneCallback) {
  var filters = instance.getPlugin("filters");
  instance.addHookOnce("afterRender", redoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack);
  filters.filter();
};
var MergeCellsAction = function(_UndoRedo$Action) {
  _inherits36(MergeCellsAction2, _UndoRedo$Action);
  function MergeCellsAction2(instance, cellRange) {
    var _this3;
    _classCallCheck87(this, MergeCellsAction2);
    _this3 = _possibleConstructorReturn36(this, _getPrototypeOf36(MergeCellsAction2).call(this));
    _this3.cellRange = cellRange;
    _this3.rangeData = instance.getData(cellRange.from.row, cellRange.from.col, cellRange.to.row, cellRange.to.col);
    return _this3;
  }
  _createClass84(MergeCellsAction2, [{
    key: "undo",
    value: function undo(instance, undoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterRender", undoneCallback);
      mergeCellsPlugin.unmergeRange(this.cellRange, true);
      instance.populateFromArray(this.cellRange.from.row, this.cellRange.from.col, this.rangeData, void 0, void 0, "MergeCells");
    }
  }, {
    key: "redo",
    value: function redo(instance, redoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterRender", redoneCallback);
      mergeCellsPlugin.mergeRange(this.cellRange);
    }
  }]);
  return MergeCellsAction2;
}(UndoRedo.Action);
UndoRedo.MergeCellsAction = MergeCellsAction;
var UnmergeCellsAction = function(_UndoRedo$Action2) {
  _inherits36(UnmergeCellsAction2, _UndoRedo$Action2);
  function UnmergeCellsAction2(instance, cellRange) {
    var _this4;
    _classCallCheck87(this, UnmergeCellsAction2);
    _this4 = _possibleConstructorReturn36(this, _getPrototypeOf36(UnmergeCellsAction2).call(this));
    _this4.cellRange = cellRange;
    return _this4;
  }
  _createClass84(UnmergeCellsAction2, [{
    key: "undo",
    value: function undo(instance, undoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterRender", undoneCallback);
      mergeCellsPlugin.mergeRange(this.cellRange, true);
    }
  }, {
    key: "redo",
    value: function redo(instance, redoneCallback) {
      var mergeCellsPlugin = instance.getPlugin("mergeCells");
      instance.addHookOnce("afterRender", redoneCallback);
      mergeCellsPlugin.unmergeRange(this.cellRange, true);
      instance.render();
    }
  }]);
  return UnmergeCellsAction2;
}(UndoRedo.Action);
UndoRedo.UnmergeCellsAction = UnmergeCellsAction;
UndoRedo.RowMoveAction = function(movedRows, target) {
  this.rows = movedRows.slice();
  this.target = target;
};
inherit(UndoRedo.RowMoveAction, UndoRedo.Action);
UndoRedo.RowMoveAction.prototype.undo = function(instance, undoneCallback) {
  var manualRowMove = instance.getPlugin("manualRowMove");
  instance.addHookOnce("afterRender", undoneCallback);
  var mod3 = this.rows[0] < this.target ? -1 * this.rows.length : 0;
  var newTarget = this.rows[0] > this.target ? this.rows[0] + this.rows.length : this.rows[0];
  var newRows = [];
  var rowsLen = this.rows.length + mod3;
  for (var i = mod3; i < rowsLen; i += 1) {
    newRows.push(this.target + i);
  }
  manualRowMove.moveRows(newRows.slice(), newTarget);
  instance.render();
  instance.selectCell(this.rows[0], 0, this.rows[this.rows.length - 1], instance.countCols() - 1, false, false);
};
UndoRedo.RowMoveAction.prototype.redo = function(instance, redoneCallback) {
  var manualRowMove = instance.getPlugin("manualRowMove");
  instance.addHookOnce("afterRender", redoneCallback);
  manualRowMove.moveRows(this.rows.slice(), this.target);
  instance.render();
  var startSelection = this.rows[0] < this.target ? this.target - this.rows.length : this.target;
  instance.selectCell(startSelection, 0, startSelection + this.rows.length - 1, instance.countCols() - 1, false, false);
};
function init() {
  var instance = this;
  var pluginEnabled = typeof instance.getSettings().undo === "undefined" || instance.getSettings().undo;
  if (pluginEnabled) {
    if (!instance.undoRedo) {
      instance.undoRedo = new UndoRedo(instance);
      exposeUndoRedoMethods(instance);
      instance.addHook("beforeKeyDown", onBeforeKeyDown8);
      instance.addHook("afterChange", onAfterChange);
    }
  } else if (instance.undoRedo) {
    delete instance.undoRedo;
    removeExposedUndoRedoMethods(instance);
    instance.removeHook("beforeKeyDown", onBeforeKeyDown8);
    instance.removeHook("afterChange", onAfterChange);
  }
}
function onBeforeKeyDown8(event2) {
  var instance = this;
  var ctrlDown = (event2.ctrlKey || event2.metaKey) && !event2.altKey;
  if (ctrlDown) {
    if (event2.keyCode === 89 || event2.shiftKey && event2.keyCode === 90) {
      instance.undoRedo.redo();
      stopImmediatePropagation(event2);
    } else if (event2.keyCode === 90) {
      instance.undoRedo.undo();
      stopImmediatePropagation(event2);
    }
  }
}
function onAfterChange(changes, source) {
  var instance = this;
  if (source === "loadData") {
    return instance.undoRedo.clear();
  }
}
function exposeUndoRedoMethods(instance) {
  instance.undo = function() {
    return instance.undoRedo.undo();
  };
  instance.redo = function() {
    return instance.undoRedo.redo();
  };
  instance.isUndoAvailable = function() {
    return instance.undoRedo.isUndoAvailable();
  };
  instance.isRedoAvailable = function() {
    return instance.undoRedo.isRedoAvailable();
  };
  instance.clearUndo = function() {
    return instance.undoRedo.clear();
  };
}
function removeExposedUndoRedoMethods(instance) {
  delete instance.undo;
  delete instance.redo;
  delete instance.isUndoAvailable;
  delete instance.isRedoAvailable;
  delete instance.clearUndo;
}
var hook = pluginHooks_default.getSingleton();
hook.add("afterInit", init);
hook.add("afterUpdateSettings", init);
hook.register("beforeUndo");
hook.register("afterUndo");
hook.register("beforeRedo");
hook.register("afterRedo");
var undoRedo_default = UndoRedo;

// node_modules/handsontable/es/index.js
function Handsontable(rootElement, userSettings) {
  var instance = new Core(rootElement, userSettings || {}, rootInstanceSymbol);
  instance.init();
  return instance;
}
jQueryWrapper(Handsontable);
Handsontable.Core = Core;
Handsontable.DefaultSettings = defaultSettings_default;
Handsontable.EventManager = eventManager_default;
Handsontable._getListenersCounter = getListenersCounter;
Handsontable.buildDate = "19/12/2018 13:16:54";
Handsontable.packageName = "handsontable";
Handsontable.version = "6.2.2";
var baseVersion = "";
if (baseVersion) {
  Handsontable.baseVersion = baseVersion;
}
Handsontable.hooks = pluginHooks_default.getSingleton();
Handsontable.__GhostTable = ghostTable_default;
var HELPERS = [array_exports, browser_exports, data_exports, date_exports, feature_exports, function_exports, mixed_exports, number_exports, object_exports, setting_exports, string_exports, unicode_exports];
var DOM = [element_exports, event_exports];
Handsontable.helper = {};
Handsontable.dom = {};
arrayEach(HELPERS, function(helper) {
  arrayEach(Object.getOwnPropertyNames(helper), function(key) {
    if (key.charAt(0) !== "_") {
      Handsontable.helper[key] = helper[key];
    }
  });
});
arrayEach(DOM, function(helper) {
  arrayEach(Object.getOwnPropertyNames(helper), function(key) {
    if (key.charAt(0) !== "_") {
      Handsontable.dom[key] = helper[key];
    }
  });
});
Handsontable.cellTypes = {};
arrayEach(getNames4(), function(cellTypeName) {
  Handsontable.cellTypes[cellTypeName] = _getItem4(cellTypeName);
});
Handsontable.cellTypes.registerCellType = _register2;
Handsontable.cellTypes.getCellType = _getItem4;
Handsontable.editors = {};
arrayEach(getNames(), function(editorName) {
  Handsontable.editors["".concat(toUpperCaseFirst(editorName), "Editor")] = _getItem(editorName);
});
Handsontable.editors.registerEditor = _register;
Handsontable.editors.getEditor = _getItem;
Handsontable.renderers = {};
arrayEach(getNames2(), function(rendererName) {
  var renderer = _getItem2(rendererName);
  if (rendererName === "base") {
    Handsontable.renderers.cellDecorator = renderer;
  }
  Handsontable.renderers["".concat(toUpperCaseFirst(rendererName), "Renderer")] = renderer;
});
Handsontable.renderers.registerRenderer = register2;
Handsontable.renderers.getRenderer = _getItem2;
Handsontable.validators = {};
arrayEach(getNames3(), function(validatorName) {
  Handsontable.validators["".concat(toUpperCaseFirst(validatorName), "Validator")] = _getItem3(validatorName);
});
Handsontable.validators.registerValidator = register3;
Handsontable.validators.getValidator = _getItem3;
Handsontable.plugins = {};
arrayEach(Object.getOwnPropertyNames(plugins_exports), function(pluginName) {
  var plugin = plugins_exports[pluginName];
  if (pluginName === "Base") {
    Handsontable.plugins["".concat(pluginName, "Plugin")] = plugin;
  } else {
    Handsontable.plugins[pluginName] = plugin;
  }
});
Handsontable.plugins.registerPlugin = registerPlugin;
Handsontable.languages = {};
Handsontable.languages.dictionaryKeys = constants_exports;
Handsontable.languages.getLanguageDictionary = getLanguage;
Handsontable.languages.getLanguagesDictionaries = getLanguages;
Handsontable.languages.registerLanguageDictionary = registerLanguage;
Handsontable.languages.getTranslatedPhrase = function() {
  return getTranslatedPhrase.apply(void 0, arguments);
};
var es_default = Handsontable;

export {
  es_default
};
/*! Bundled license information:

moment/dist/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

pikaday/pikaday.js:
  (*!
   * Pikaday
   *
   * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
   *)

handsontable/lib/jsonpatch/json-patch-duplex.js:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * json-patch-duplex.js version: 0.5.7
   * (c) 2013 Joachim Wester
   * MIT license
   *)

moment/src/moment.js:
  (*! moment.js *)
  (*! version : 2.20.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

numbro/dist/es/numbro.js:
  (*!
   * Copyright (c) 2017 Benjamin Van Ryseghem<benjamin@vanryseghem.com>
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)

handsontable/es/i18n/languages/en-US.js:
  (**
   * @preserve
   * Authors: Handsoncode
   * Last updated: Nov 15, 2017
   *
   * Description: Definition file for English - United States language-country.
   *)
*/
//# sourceMappingURL=chunk-PKLOVGDD.js.map
